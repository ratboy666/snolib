        -MODULE ALL
        -LINE 60 "ALL.lss"
        -INCLUDE 'AGT.INC'
        -MODULE AGT
        -LINE 13 "AGT.lss"
        -IN72
        -LINE 42 "AGT.lss"
        -STITL AGT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #      #####   #######                       *
        *                        # #    #     #     #                          *
        *                       #   #   #           #                          *
        *                      #     #  #  ####     #                          *
        *                      #######  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #   #####      #                          *
        *                                                                      *
        * AGT        ALPHABETIC COMPARISION WITH UPPER AND LOWER EQUAL         *
        *                                                                      *
        ************************************************************************
        *
        * AGT.lss
        *
        -LINE 16 "AGT.lss"
        -PUBLIC AGT()
        *
1                DEFINE('AGT(S1,S2)')
2                AGT_TT = REPLACE(&ALPHABET, &UCASE, &LCASE)          :(AGT_END)
        *
3       AGT      LGT(REPLACE(S1, &ALPHABET, AGT_TT),
3       +            REPLACE(S2, &ALPHABET, AGT_TT))        :S(RETURN)F(FRETURN)
        *
4       AGT_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'AI.INC'
        -MODULE AI
        -LINE 18 "AI.lss"
        -INCLUDE 'SEQ.INC'
        -MODULE SEQ
        -LINE 34 "SEQ.lss"
        -IN72
        -LINE 64 "SEQ.lss"
        -STITL SEQ
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       #####   #######   #####                        *
        *                      #     #  #        #     #                       *
        *                      #        #        #     #                       *
        *                       #####   #####    #     #                       *
        *                            #  #        #   # #                       *
        *                      #     #  #        #    #                        *
        *                       #####   #######   #### #                       *
        *                                                                      *
        * SEQ                SEQUENCE STATEMENT WITH COUNTER                   *
        *                                                                      *
        ************************************************************************
        *
        * SEQ.lss
        *
        -LINE 37 "SEQ.lss"
        -PUBLIC SEQ()
        *
5                DEFINE('SEQ(ARG_S,ARG_NAME,START,END)')              :(SEQ_END)
        *
6       SEQ      START = IDENT(START) 1
7                $ARG_NAME = START - 1
8                ARG_S = CODE(ARG_S  ' :S(SEQ_1)F(SEQ_2)')             :F(ERROR)
9       SEQ_1    DIFFER(END) GE($ARG_NAME, END)                       :S(RETURN)
10               $ARG_NAME = $ARG_NAME + 1                              :<ARG_S>
11      SEQ_2    EQ($ARG_NAME, START)                       :S(FRETURN)F(RETURN)
        *
12      SEQ_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 56 "AI.lss"
        -STITL AI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                #     ###                             *
        *                               # #     #                              *
        *                              #   #    #                              *
        *                             #     #   #                              *
        *                             #######   #                              *
        *                             #     #   #                              *
        *                             #     #  ###                             *
        *                                                                      *
        * AI                          APPLY INDEX                              *
        *                                                                      *
        ************************************************************************
        *
        * AI.lss
        *
        -LINE 22 "AI.lss"
        -PUBLIC AI()
        *
13               DEFINE('AI(A,I)J')                                    :(AI_END)
        *
14      AI       IDENT(DATATYPE(I), 'ARRAY')                            :F(AI_1)
15               AI = ARRAY(PROTOTYPE(I))
16               SEQ(' AI<J> = A<I<J>> ', .J)                          :(RETURN)
17      AI_1     AI = A<I>                                  :S(RETURN)F(FRETURN)
        *
18      AI_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'AOPA.INC'
        -MODULE AOPA
        -LINE 16 "AOPA.lss"
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 72 "AOPA.lss"
        -STITL AOPA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #     #######  ######      #                      *
        *                   # #    #     #  #     #    # #                     *
        *                  #   #   #     #  #     #   #   #                    *
        *                 #     #  #     #  ######   #     #                   *
        *                 #######  #     #  #        #######                   *
        *                 #     #  #     #  #        #     #                   *
        *                 #     #  #######  #        #     #                   *
        *                                                                      *
        * AOPA                 APPLY OPERATOR TO ARRAY                         *
        *                                                                      *
        ************************************************************************
        *
        * AOPA.lss
        *
        -LINE 20 "AOPA.lss"
        -PUBLIC AOPA()
        *
19               DEFINE('AOPA(A1,OP,A2)S1,I,S2,S')                   :(AOPA_END)
        *
20      AOPA     IDENT(DATATYPE(A1), 'ARRAY')                         :S(AOPA_1)
21               IDENT(DATATYPE(A2), 'ARRAY')                         :S(AOPA_2)
22               AOPA = EVAL('A1 ' OP ' A2')                           :(RETURN)
23      AOPA_1   S1 = '<I>'
24               S2 = IDENT(DATATYPE(A2), 'ARRAY')  '<I>'
25               AOPA = ARRAY(PROTOTYPE(A1))                      :(AOPA_COMMON)
26      AOPA_2   S2 = '<I>'
27               AOPA = ARRAY(PROTOTYPE(A2))
28      AOPA_COMMON
29               S = ' AOPA<I> = A1' S1 ' ' OP ' A2' S2
30               SEQ(S, .I)                                            :(RETURN)
        *
31      AOPA_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'APPENDA.INC'
        -MODULE APPENDA
        -LINE 12 "APPENDA.lss"
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'SIZEA.INC'
        -MODULE SIZEA
        -IN72
        -LINE 13 "SIZEA.lss"
        -INCLUDE 'ARRAY0.INC'
        -MODULE ARRAY0
        -LINE 11 "ARRAY0.lss"
        -INCLUDE 'SYSTEM.INC'
        -MODULE SYSTEM
        -IN72
        -LINE 49 "SYSTEM.lss"
        -LINE 129 "SYSTEM.lss"
        -STITL SYSTEM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *          #####   #     #   #####   #######  #######  #     #         *
        *         #     #   #   #   #     #     #     #        ##   ##         *
        *         #          # #    #           #     #        # # # #         *
        *          #####      #      #####      #     #####    #  #  #         *
        *               #     #           #     #     #        #     #         *
        *         #     #     #     #     #     #     #        #     #         *
        *          #####      #      #####      #     #######  #     #         *
        *                                                                      *
        * SYSTEM            DETERMINE KIND OF SNOBOL4                          *
        *                                                                      *
        ************************************************************************
        *
        * SYSTEM.lss
        *
        -LINE 52 "SYSTEM.lss"
        -PUBLIC SYSTEM(), ISSPITBOL(), ISSNOBOL4()
        -PUBLIC ISASCII(), ISEBCDIC(), ISCDC_DISPLAY_CODE()
        *
32               DEFINE('SYSTEM()K,E,T')
33               DEFINE('ISSPITBOL()')
34               DEFINE('ISSNOBOL4()')
35               DEFINE('ISASCII()A')
36               DEFINE('ISEBCDIC()A')
37               DEFINE('ISCDC_DISPLAY_CODE()A')                   :(SYSTEM_END)
        *
38      ISASCII  A = &ANCHOR
39               &ANCHOR = 0
40               &ALPHABET '()'                          :S(ISASCII1)F(ISASCII2)
41      ISASCII1 &ANCHOR = A                                           :(RETURN)
42      ISASCII2 &ANCHOR = A                                          :(FRETURN)
        *
        * OR, TRY LLT('A',1)
43      ISEBCDIC A = &ANCHOR
44               &ANCHOR = 0
45               &ALPHABET '(+'                          :S(ISASCII1)F(ISASCII2)
        *
46      ISCDC_DISPLAY_CODE
47               A = &ANCHOR
48               &ANCHOR = 0
49               &ALPHABET ')*'                          :S(ISASCII1)F(ISASCII2)
        *
50      ISSPITBOL
51               DIFFER(.NAME, 'NAME')                      :S(RETURN)F(FRETURN)
        *
52      ISSNOBOL4
53               IDENT(.NAME, 'NAME')                       :S(RETURN)F(FRETURN)
        *
54      SYSTEM   IDENT(DATATYPE(.X), 'STRING')                      :F(SYSTEM_2)
55               K = SIZE(&ALPHABET)
56               SYSTEM = EQ(K,512) 'HONEYWELL MAINBOL'               :S(RETURN)
57               SYSTEM = EQ(K,256) 'IBM MAINBOL'                   :S(SYSTEM_0)
58               SYSTEM = EQ(K,128) 'PDP-10 MAINBOL'                  :S(RETURN)
59               SYSTEM =           'CDC MAINBOL'
60               ISASCII()                                          :S(SYSTEM_1)
61               SYSTEM =           'UNIVAC MAINBOL'                   :(RETURN)
        *
        * DISTINGUISH IBM MAINBOL AND CSNOBOL, ASSUME ASCII FOR CSNOBOL4.
        * IBM MAINBOL RUNS ON SYSTEM/360, WHICH IS EBCDIC.
        *
        * AFTER 1.5 (VERSION 1.5+), CSNOBOL4 SUPPORTS BLOCKS WITH THE
        * -B COMMAND LINE SWITCH AND -BLOCKS/-NOBLOCKS
        *
62      SYSTEM_0 ISASCII()                                          :F(SYSTEM_1)
63               SYSTEM = 'CSNOBOL4 MAINBOL'
        *
64      SYSTEM_1 E = &ERRLIMIT
65               &ERRLIMIT = 1
66               T = DATATYPE(1 # 1)
67               &ERRLIMIT = E
68               DIFFER(T, 'BLOCK')                                   :S(RETURN)
69               SYSTEM = SYSTEM ' WITH BLOCKS'                        :(RETURN)
        *
70      SYSTEM_2 SYSTEM = DIFFER(SUBSTR('ABC', 2, 1), 'B') 'FASBOL'   :S(RETURN)
71               SYSTEM = EQ(SIZE(&ALPHABET), 128)         'SITBOL'   :S(RETURN)
72               SYSTEM =                                  'SPITBOL'   :(RETURN)
        *
73      SYSTEM_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 35 "ARRAY0.lss"
        -STITL ARRAY0
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *            #     ######   ######      #     #     #   ####           *
        *           # #    #     #  #     #    # #     #   #   #   ##          *
        *          #   #   #     #  #     #   #   #     # #    #  # #          *
        *         #     #  ######   ######   #     #     #     # #  #          *
        *         #######  #   #    #   #    #######     #     ##   #          *
        *         #     #  #    #   #    #   #     #     #     #    #          *
        *         #     #  #     #  #     #  #     #     #      ####           *
        *                                                                      *
        * ARRAY0                      ARRAY OF SIZE 0                          *
        *                                                                      *
        ************************************************************************
        *
        * ARRAY0.lss
        *
        -LINE 15 "ARRAY0.lss"
        -PUBLIC ARRAY0
        *
74               ARRAY0 = ARRAY('-10000:-10000')
75               ARRAY0 = ?(SYSTEM() ? 'CSNOBOL4') ARRAY('0:-1')
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'BRKREM.INC'
        -MODULE BRKREM
        -LINE 11 "BRKREM.lss"
        -INCLUDE 'SDIFF.INC'
        -MODULE SDIFF
        -LINE 10 "SDIFF.lss"
        -IN72
        -LINE 38 "SDIFF.lss"
        -STITL SDIFF
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                #####   ######   ###  #######  #######                *
        *               #     #  #     #   #   #        #                      *
        *               #        #     #   #   #        #                      *
        *                #####   #     #   #   #####    #####                  *
        *                     #  #     #   #   #        #                      *
        *               #     #  #     #   #   #        #                      *
        *                #####   ######   ###  #        #                      *
        *                                                                      *
        * SDIFF                     SET DIFFERENCE                             *
        *                                                                      *
        ************************************************************************
        *
        * SDIFF.lss
        *
        -LINE 13 "SDIFF.lss"
        -PUBLIC SDIFF()
        *
76               DEFINE('SDIFF(S1,S2)')                             :(SDIFF_END)
        *
77      SDIFF    SDIFF = S1
78               IDENT(S2, NULL)                                      :S(RETURN)
79               S2 = SPAN(S2)
80      SDIFF_1  SDIFF S2 =                                 :S(SDIFF_1)F(RETURN)
        *
81      SDIFF_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 41 "BRKREM.lss"
        -STITL BRKREM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *         ######   ######   #    #  ######   #######  #     #          *
        *         #     #  #     #  #   #   #     #  #        ##   ##          *
        *         #     #  #     #  #  #    #     #  #        # # # #          *
        *         ######   ######   ###     ######   #####    #  #  #          *
        *         #     #  #   #    #  #    #   #    #        #     #          *
        *         #     #  #    #   #   #   #    #   #        #     #          *
        *         ######   #     #  #    #  #     #  #######  #     #          *
        *                                                                      *
        * BRKREM                   BREAK(S) OR REM                             *
        *                                                                      *
        ************************************************************************
        *
        * BRKREM.lss
        *
        -LINE 15 "BRKREM.lss"
        -PUBLIC BRKREM()
        *
82               DEFINE('BRKREM(S)CS')                             :(BRKREM_END)
        *
83      BRKREM   BRKREM = IDENT(S) REM                                :S(RETURN)
84               CS = SDIFF(&ALPHABET, S)
85               IDENT(CS)                                            :S(RETURN)
86               BRKREM = RPOS(0) | SPAN(CS) RPOS(0) | BREAK(S)
87                                                                     :(RETURN)
        *
88      BRKREM_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'LOWA.INC'
        -MODULE LOWA
        -IN72
        -LINE 10 "LOWA.lss"
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'BRKREM.INC'
        -LINE 44 "LOWA.lss"
        -STITL LOWA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  #        #######  #     #     #                     *
        *                  #        #     #  #  #  #    # #                    *
        *                  #        #     #  #  #  #   #   #                   *
        *                  #        #     #  #  #  #  #     #                  *
        *                  #        #     #  #  #  #  #######                  *
        *                  #        #     #  #  #  #  #     #                  *
        *                  #######  #######   ## ##   #     #                  *
        *                                                                      *
        * LOWA                       LOW INDEX OF ARRAY                        *
        *                                                                      *
        ************************************************************************
        *
        * LOWA.lss
        *
        -LINE 15 "LOWA.lss"
        -PUBLIC LOWA()
        *
89               DEFINE('LOWA(A)L,U')                                :(LOWA_END)
        *
90      LOWA     LOWA = IDENT(A) 0                                    :S(RETURN)
91               LOWA = IDENT(A, ARRAY0) 0                            :S(RETURN)
92               IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
93               PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
94               IDENT(L)                                            :S(FRETURN)
95               LOWA = L
96               LOWA = IDENT(U) 1                                     :(RETURN)
        *
97      LOWA_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'SWAP.INC'
        -STITL SWAP
        -EJECT
        *
        -LINE 37 "SWAP.lss"
        ************************************************************************
        *                                                                      *
        *                   #####   #     #     #     ######                   *
        *                  #     #  #  #  #    # #    #     #                  *
        *                  #        #  #  #   #   #   #     #                  *
        *                   #####   #  #  #  #     #  ######                   *
        *                        #  #  #  #  #######  #                        *
        *                  #     #  #  #  #  #     #  #                        *
        *                   #####    ## ##   #     #  #                        *
        *                                                                      *
        * SWAP                    SWAP TWO VARIABLES                           *
        *                                                                      *
        ************************************************************************
        *
        * SWAP.lss
        *
        -LINE 12 "SWAP.lss"
        -MODULE SWAP
        -PUBLIC SWAP()
98               DEFINE('SWAP(SWAP_ARG1,SWAP_ARG2)')                 :(SWAP_END)
        *
99      SWAP     SWAP = $SWAP_ARG1
100              $SWAP_ARG1 = $SWAP_ARG2
101              $SWAP_ARG2 = SWAP
102              SWAP =                                                :(RETURN)
        *
103     SWAP_END
        *
        * CE: .MSNOBOL4;
        -LINE 65 "SIZEA.lss"
        -STITL SIZEA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #####   ###  #######  #######     #                  *
        *                #     #   #        #   #          # #                 *
        *                #         #       #    #         #   #                *
        *                 #####    #     #      #####    #     #               *
        *                      #   #    #       #        #######               *
        *                #     #   #   #        #        #     #               *
        *                 #####   ###  #######  #######  #     #               *
        *                                                                      *
        * SIZEA                       SIZE OF ARRAY                            *
        *                                                                      *
        ************************************************************************
        *
        * SIZEA.lss
        *
        -LINE 20 "SIZEA.lss"
        -PUBLIC SIZEA()
        *
104              DEFINE('SIZEA(A)L,U')                              :(SIZEA_END)
        *
105     SIZEA    SIZEA = IDENT(A) 0                                   :S(RETURN)
106              SIZEA = IDENT(A, ARRAY0) 0                           :S(RETURN)
107              IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
108              L =
109              U =
110              PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
111              IDENT(L)                                            :S(FRETURN)
112              U = IDENT(U) 1                                      :F(SIZEA_2)
113              SWAP(.L, .U)
114     SIZEA_2  SIZEA = LT(U, L) 0                                   :S(RETURN)
115              SIZEA = U - L + 1                                     :(RETURN)
        *
116     SIZEA_END
        *
        * CE: .F.MSNOBOL4;
        -IN72
        -LINE 41 "APPENDA.lss"
        -STITL AI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *       #     ######   ######   #######  #     #  ######      #        *
        *      # #    #     #  #     #  #        ##    #  #     #    # #       *
        *     #   #   #     #  #     #  #        # #   #  #     #   #   #      *
        *    #     #  ######   ######   #####    #  #  #  #     #  #     #     *
        *    #######  #        #        #        #   # #  #     #  #######     *
        *    #     #  #        #        #        #    ##  #     #  #     #     *
        *    #     #  #        #        #######  #     #  ######   #     #     *
        *                                                                      *
        * APPENDA              APPEND ELEMENT TO ARRRAY                        *
        *                                                                      *
        ************************************************************************
        *
        * APPENDA.lss
        *
        -LINE 17 "APPENDA.lss"
        -PUBLIC APPENDA()
        *
117              DEFINE('APPENDA(A,V)I')                          :(END_APPENDA)
        *
118     APPENDA  APPENDA = ARRAY(SIZEA(A) + 1)
119              SEQ(' APPENDA<I> = A<I>', .I)
120              APPENDA<I> = V                                        :(RETURN)
        *
121     END_APPENDA
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'ASM.INC'
        -MODULE ASM
        -INCLUDE 'JIT.INC'
        -MODULE JIT
        -LINE 15 "JIT.lss"
        -INCLUDE 'CRACK.INC'
        -MODULE CRACK
        -LINE 16 "CRACK.lss"
        -INCLUDE 'COUNT.INC'
        -MODULE COUNT
        -LINE 8 "COUNT.lss"
        -IN72
        -LINE 38 "COUNT.lss"
        -STITL COUNT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #####   #######  #     #  #     #  #######             *
        *              #     #  #     #  #     #  ##    #     #                *
        *              #        #     #  #     #  # #   #     #                *
        *              #        #     #  #     #  #  #  #     #                *
        *              #        #     #  #     #  #   # #     #                *
        *              #     #  #     #  #     #  #    ##     #                *
        *               #####   #######   #####   #     #     #                *
        *                                                                      *
        * COUNT              COUNT STRING OCCURRENCES                          *
        *                                                                      *
        * COUNT(S1,S2) COUNTS THE NUMBER OF OCCURRENCES OF STRING S2 IN STRING *
        * S1.                                                                  *
        *                                                                      *
        ************************************************************************
        *
        * COUNT.lss
        *
        -LINE 11 "COUNT.lss"
        -PUBLIC COUNT()
        *
122              DEFINE('COUNT(S1,S2)FIRST,REST,P')                 :(COUNT_END)
        *
123     COUNT    COUNT = 0
124              S2 LEN(1) . FIRST REM . REST                         :F(RETURN)
125              P = POS(0) BREAKX(FIRST) S2
126     COUNT_1  S1 P = REST                                          :F(RETURN)
127              COUNT = COUNT + 1                                    :(COUNT_1)
        *
128     COUNT_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 63 "CRACK.lss"
        -STITL CRACK
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #####   ######      #      #####   #    #              *
        *              #     #  #     #    # #    #     #  #   #               *
        *              #        #     #   #   #   #        #  #                *
        *              #        ######   #     #  #        ###                 *
        *              #        #   #    #######  #        #  #                *
        *              #     #  #    #   #     #  #     #  #   #               *
        *               #####   #     #  #     #   #####   #    #              *
        *                                                                      *
        * CRACK                    STRING TO ARRAY                             *
        *                                                                      *
        ************************************************************************
        *
        * CRACK.lss
        *
        -LINE 20 "CRACK.lss"
        -PUBLIC CRACK(), %1
        *
129              DEFINE('CRACK_1(S)P')
130              DEFINE('CRACK(S,B,F)I,PAT,N')
131              DEFINE('CRACK_4(S)')
132              OPSYN('%', 'CRACK_1', 1)                           :(CRACK_END)
        *
133     CRACK_1  P = IDENT(P) ','
134              CRACK_1 = CRACK(S, P)                                 :(RETURN)
        *
135     CRACK    F = IDENT(F) 'CRACK_4'
136              IDENT(B, NULL)                                      :S(CRACK_3)
137              S RTAB(1) B ABORT | REM . S = S B
138              N = COUNT(S, B)
139              EQ(N, 0)                                             :S(RETURN)
140              CRACK = ARRAY(N)
141              PAT = BREAK(B) . *CRACK<I> LEN(1)
142     CRACK_2  I = I + 1
143              S PAT =                                              :F(RETURN)
144              CRACK<I> = APPLY(F, CRACK<I>)             :S(CRACK_2)F(FRETURN)
145     CRACK_3  N = SIZE(S)
146              EQ(N, 0)                                             :S(RETURN)
147              CRACK = ARRAY(N)
148              PAT = LEN(1) . *CRACK<I>                             :(CRACK_2)
        *
149     CRACK_4  CRACK_4 = S                                           :(RETURN)
        *
150     CRACK_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SEQ.INC'
        -IN1024
        -LINE 1405 "JIT.lss"
        -STITL JIT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                              #  ###  #######                         *
        *                              #   #      #                            *
        *                              #   #      #                            *
        *                              #   #      #                            *
        *                        #     #   #      #                            *
        *                        #     #   #      #                            *
        *                         #####   ###     #                            *
        *                                                                      *
        * JIT                JUST-IN-TIME CODE GENERATION                      *
        *                                                                      *
        ************************************************************************
        *
        * QMUL/QDIV NOT YET SUPPORTED
        *
        * JIT.lss
        *
        -LINE 20 "JIT.lss"
        -CASE 1
        -PLUSOPS 1
        -LINE 23 "JIT.lss"
        -LINE 24 "JIT.lss"
        -LINE 25 "JIT.lss"
        -LINE 26 "JIT.lss"
        -LINE 27 "JIT.lss"
        -LINE 30 "JIT.lss"
151              JIT = 'jit.c'
        -LINE 577 "JIT.lss"
        -LINE 578 "JIT.lss"
        -LINE 579 "JIT.lss"
        -LINE 580 "JIT.lss"
        -LINE 581 "JIT.lss"
        -LINE 582 "JIT.lss"
        -LINE 585 "JIT.lss"
        *
        -PUBLIC INIT_JIT(), FINISH_JIT(), JIT_GET_STATE(), JIT_SET_STATE()
        *
152              LOAD('INIT_JIT(STRING)', 'jit.so')
153              LOAD('FINISH_JIT()', 'jit.so')
154              LOAD('JIT_GET_STATE()INTEGER', 'jit.so')
155              LOAD('JIT_SET_STATE(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_NEW_STATE(), JIT_DESTROY_STATE(), JIT_CLEAR_STATE()
        *
156              LOAD('JIT_NEW_STATE()INTEGER', 'jit.so')
157              LOAD('JIT_DESTROY_STATE()', 'jit.so')
158              LOAD('JIT_CLEAR_STATE()', 'jit.so')
        *
        -PUBLIC JIT_PROLOG(), JIT_EPILOG(), JIT_NOTE(), JIT_NAME()
        *
159              LOAD('JIT_PROLOG()', 'jit.so')
160              LOAD('JIT_EPILOG()', 'jit.so')
161              LOAD('JIT_NOTE(STRING,INTEGER)INTEGER', 'jit.so')
162              LOAD('JIT_NAME(STRING)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDRESS(), JIT_DISASSEMBLE(), JIT_EMIT(), JIT_LABEL()
        *
163              LOAD('JIT_ADDRESS(INTEGER)INTEGER', 'jit.so')
164              LOAD('JIT_DISASSEMBLE()', 'jit.so')
165              LOAD('JIT_EMIT()INTEGER', 'jit.so')
166              LOAD('JIT_PRINT()', 'jit.so')
167              LOAD('JIT_LABEL()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ELLIPSIS(), JIT_INTEGER_P(), JIT_CALLEE_SAVE_P()
        *
168              LOAD('JIT_ELLIPSIS()', 'jit.so')
169              LOAD('GET_NOTE_I()INTEGER', 'jit.so')
170              LOAD('GET_NOTE_S1()STRING', 'jit.so')
171              LOAD('GET_NOTE_S2()STRING', 'jit.so')
172              LOAD('GET_NOTE_JIT(INTEGER)PREDICATE', 'jit.so')
173              LOAD('JIT_INTEGER_P(INTEGER)PREDICATE', 'jit.so')
174              LOAD('JIT_CALLEE_SAVE_P(INTEGER)PREDICATE', 'jit.so')
        *
        -PUBLIC JIT_PATCH_AT(), JIT_PATCH_ABS(), JIT_PATCH(), JIT_PREPARE()
        *
175              LOAD('JIT_PATCH_AT(INTEGER,INTEGER)', 'jit.so')
176              LOAD('JIT_PATCH_ABS(INTEGER,INTEGER)', 'jit.so')
177              LOAD('JIT_PATCH(INTEGER)', 'jit.so')
178              LOAD('JIT_PREPARE()', 'jit.so')
        *
        -PUBLIC JIT_ALLOCAI(), JIT_DATA() JIT_FORWARD(), JIT_INDIRECT()
        *
179              LOAD('JIT_ALLOCAI(INTEGER)INTEGER', 'jit.so')
180              LOAD('JIT_DATA(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
181              LOAD('JIT_FORWARD()INTEGER', 'jit.so')
182              LOAD('JIT_INDIRECT()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LIVE(), JIT_LINK(), JIT_R_NUM_(), JIT_V_NUM_(), JIT_F_NUM()
        *
183              LOAD('JIT_LIVE(INTEGER)INTEGER', 'jit.so')
184              LOAD('JIT_LINK(INTEGER)', 'jit.so')
185              LOAD('JIT_R_NUM_()INTEGER', 'jit.so')
186              LOAD('JIT_V_NUM_()INTEGER', 'jit.so')
187              LOAD('JIT_F_NUM_()INTEGER', 'jit.so')
        *
        -PUBLIC R0_(), R1_(), R2_(), R3_(), V0_(), V1_(), V2()_, V3_()
        *
188              LOAD('R0_()INTEGER', 'jit.so')
189              LOAD('R1_()INTEGER', 'jit.so')
190              LOAD('R2_()INTEGER', 'jit.so')
191              LOAD('R3_()INTEGER', 'jit.so')
192              LOAD('V0_()INTEGER', 'jit.so')
193              LOAD('V1_()INTEGER', 'jit.so')
194              LOAD('V2_()INTEGER', 'jit.so')
195              LOAD('V3_()INTEGER', 'jit.so')
        *
        -PUBLIC F0_(), F1_(), F2_(), F3_(), F4_(), F5_(), F6_(), F7_(), FP_()
        *
196              LOAD('F0_()INTEGER', 'jit.so')
197              LOAD('F1_()INTEGER', 'jit.so')
198              LOAD('F2_()INTEGER', 'jit.so')
199              LOAD('F3_()INTEGER', 'jit.so')
200              LOAD('F4_()INTEGER', 'jit.so')
201              LOAD('F5_()INTEGER', 'jit.so')
202              LOAD('F6_()INTEGER', 'jit.so')
203              LOAD('F7_()INTEGER', 'jit.so')
204              LOAD('FP_()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDR(), JIT_ADDR_F(), JIT_ADDR_D()
        *
205              LOAD('JIT_ADDR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
206              LOAD('JIT_ADDR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
207              LOAD('JIT_ADDR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDI(), JIT_ADDI_F(), JIT_ADDI_D()
        *
208              LOAD('JIT_ADDI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
209              LOAD('JIT_ADDI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
210              LOAD('JIT_ADDI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDXR(), JIT_ADDXI(), JIT_ADDCR(), JIT_ADDCI()
        *
211              LOAD('JIT_ADDXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
212              LOAD('JIT_ADDXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
213              LOAD('JIT_ADDCR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
214              LOAD('JIT_ADDCI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SUBR(), JIT_SUBR_F(), JIT_SUBR_D()
        *
215              LOAD('JIT_SUBR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
216              LOAD('JIT_SUBR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
217              LOAD('JIT_SUBR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SUBI(), JIT_SUBI_F(), JIT_SUBI_D()
        *
218              LOAD('JIT_SUBI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
219              LOAD('JIT_SUBI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
220              LOAD('JIT_SUBI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SUBXR(), JIT_SUBXI(), JIT_SUBCR(), JIT_SUBCI()
        *
221              LOAD('JIT_SUBXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
222              LOAD('JIT_SUBXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
223              LOAD('JIT_SUBCR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
224              LOAD('JIT_SUBCI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MULR(), JIT_MULR_F(), JIT_MULR_D()
        *
225              LOAD('JIT_MULR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
226              LOAD('JIT_MULR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
227              LOAD('JIT_MULR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MULTI(), JIT_MULI_F(), JIT_MULI_D()
        *
228              LOAD('JIT_MULI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
229              LOAD('JIT_MULI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
230              LOAD('JIT_MULI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_DIVR(), JIT_DIVR_U(), JIT_DIVR_F(), JIT_DIVR_D()
        *
231              LOAD('JIT_DIVR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
232              LOAD('JIT_DIVR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
233              LOAD('JIT_DIVR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
234              LOAD('JIT_DIVR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_DIVI(), JIT_DIVI_U(), JIT_DIVI_F(), JIT_DIVI_D()
        *
235              LOAD('JIT_DIVI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
236              LOAD('JIT_DIVI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
237              LOAD('JIT_DIVI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
238              LOAD('JIT_DIVI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_REMR(), JIT_REMR_U(), JIT_REMI(), JIT_REMI_U()
        *
239              LOAD('JIT_REMR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
240              LOAD('JIT_REMR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
241              LOAD('JIT_REMI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
242              LOAD('JIT_REMI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ANDR(), JIT_ANDI(), JIT_ORR(), JIT_ORI()
        *
243              LOAD('JIT_ANDR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
244              LOAD('JIT_ANDI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
245              LOAD('JIT_ORR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
246              LOAD('JIT_ORI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_XORR(), JIT_XORI()
        *
247              LOAD('JIT_XORR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
248              LOAD('JIT_XORI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LSHR(), JIT_LSHI()
        *
249              LOAD('JIT_LSHR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
250              LOAD('JIT_LSHI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_RSHR(), JIT_RSHR_U(), JIT_RSHI(), JIT_RSHI_U()
        *
251              LOAD('JIT_RSHR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
252              LOAD('JIT_RSHR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
253              LOAD('JIT_RSHI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
254              LOAD('JIT_RSHI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_NEGR(), JIT_NEGR_F(), JIT_NEGR_D()
        *
255              LOAD('JIT_NEGR(INTEGER,INTEGER)INTEGER', 'jit.so')
256              LOAD('JIT_NEGR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
257              LOAD('JIT_NEGR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_COMR()
        *
258              LOAD('JIT_COMR(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ABSR_F(), JIT_ABSR_D()
        *
259              LOAD('JIT_ABSR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
260              LOAD('JIT_ABSR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SQRTR_F(), JIT_SQRTR_D()
        *
261              LOAD('JIT_SQRTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
262              LOAD('JIT_SQRTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LTR(), JIT_LTR_U(), JIT_LTR_F(), JIT_LTR_D()
        *
263              LOAD('JIT_LTR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
264              LOAD('JIT_LTR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
265              LOAD('JIT_LTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
266              LOAD('JIT_LTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LTI(), JIT_LTI_U(), JIT_LTI_F(), JIT_LTI_D()
        *
267              LOAD('JIT_LTI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
268              LOAD('JIT_LTI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
269              LOAD('JIT_LTI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
270              LOAD('JIT_LTI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LER(), JIT_LER_U(), JIT_LER_F(), JIT_LER_D()
        *
271              LOAD('JIT_LER(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
272              LOAD('JIT_LER_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
273              LOAD('JIT_LER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
274              LOAD('JIT_LER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LEI(), JIT_LEI_U(), JIT_LEI_F(), JIT_LEI_D()
        *
275              LOAD('JIT_LEI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
276              LOAD('JIT_LEI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
277              LOAD('JIT_LEI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
278              LOAD('JIT_LEI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GTR(), JIT_GTR_U(), JIT_GTR_F(), JIT_GTR_D()
        *
279              LOAD('JIT_GTR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
280              LOAD('JIT_GTR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
281              LOAD('JIT_GTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
282              LOAD('JIT_GTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GTI(), JIT_GTI_U(), JIT_GTI_F(), JIT_GTI_D()
        *
283              LOAD('JIT_GTI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
284              LOAD('JIT_GTI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
285              LOAD('JIT_GTI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
286              LOAD('JIT_GTI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GER(), JIT_GER_U(), JIT_GER_F(), JIT_GER_D()
        *
287              LOAD('JIT_GER(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
288              LOAD('JIT_GER_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
289              LOAD('JIT_GER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
290              LOAD('JIT_GER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GEI(), JIT_GEI_U(), JIT_GEI_F(), JIT_GEI_D()
        *
291              LOAD('JIT_GEI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
292              LOAD('JIT_GEI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
293              LOAD('JIT_GEI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
294              LOAD('JIT_GEI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EQR(), JIT_EQR_F(), JIT_EQR_D()
        *
295              LOAD('JIT_EQR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
296              LOAD('JIT_EQR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
297              LOAD('JIT_EQR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EQI(), JIT_EQI_F(), JIT_EQI_D()
        *
298              LOAD('JIT_EQI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
299              LOAD('JIT_EQI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
300              LOAD('JIT_EQI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_NER(), JIT_NER_F(), JIT_NER_D()
        *
301              LOAD('JIT_NER(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
302              LOAD('JIT_NER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
303              LOAD('JIT_NER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_NEI(), JIT_NEI_F(), JIT_NEI_D()
        *
304              LOAD('JIT_NEI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
305              LOAD('JIT_NEI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
306              LOAD('JIT_NEI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNLTR_F(), JIT_UNLTR_D()
        *
307              LOAD('JIT_UNLTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
308              LOAD('JIT_UNLTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNLER_F(), JIT_UNLER_D()
        *
309              LOAD('JIT_UNLER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
310              LOAD('JIT_UNLER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNGTR_F(), JIT_UNGTR_D()
        *
311              LOAD('JIT_UNGTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
312              LOAD('JIT_UNGTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNGER_F(), JIT_UNGER_D()
        *
313              LOAD('JIT_UNGER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
314              LOAD('JIT_UNGER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNEQR_D(), JIT_UNEQR_D()
        *
315              LOAD('JIT_UNEQR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
316              LOAD('JIT_UNEQR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LTGTR_F(), JIT_LTGTR_D()
        *
317              LOAD('JIT_LTGTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
318              LOAD('JIT_LTGTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ORDR_F(), JIT_ORDR_D()
        *
319              LOAD('JIT_ORDR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
320              LOAD('JIT_ORDR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNORDR_F(), JIT_UNORDR_D()
        *
321              LOAD('JIT_UNORDR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
322              LOAD('JIT_UNORDR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MOVR(), JIT_MOVR_F(), JIT_MOVR_D()
        *
323              LOAD('JIT_MOVR(INTEGER,INTEGER)INTEGER', 'jit.so')
324              LOAD('JIT_MOVR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
325              LOAD('JIT_MOVR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MOVI(), JIT_MOVI_F(), JIT_MOVI_D()
        *
326              LOAD('JIT_MOVI(INTEGER,INTEGER)INTEGER', 'jit.so')
327              LOAD('JIT_MOVI_F(INTEGER,REAL)INTEGER', 'jit.so')
328              LOAD('JIT_MOVI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EXTR_C(), JIT_EXTR_UC(), JIT_EXTR_S(), JIT_EXTR_US()
        *
329              LOAD('JIT_EXTR_C(INTEGER,INTEGER)INTEGER', 'jit.so')
330              LOAD('JIT_EXTR_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
331              LOAD('JIT_EXTR_S(INTEGER,INTEGER)INTEGER', 'jit.so')
332              LOAD('JIT_EXTR_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EXTR_I(), JIT_EXTR_UI(), JIT_EXTR_F(), JIT_EXTR_D_F()
        *
333              LOAD('JIT_EXTR_I(INTEGER,INTEGER)INTEGER', 'jit.so')
334              LOAD('JIT_EXTR_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
335              LOAD('JIT_EXTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
336              LOAD('JIT_EXTR_D_F(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EXTR_D(), JIT_EXTR_F_D()
        *
337              LOAD('JIT_EXTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
338              LOAD('JIT_EXTR_F_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_TRUNCR_F_I(), JIT_TRUNCR_F(), JIT_TRUNCR_F_L()
        *
339              LOAD('JIT_TRUNCR_F_I(INTEGER,INTEGER)INTEGER', 'jit.so')
340              LOAD('JIT_TRUNCR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
341              LOAD('JIT_TRUNCR_F_L(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_TRUNCR_D_I(), JIT_TRUNCR_D(), JIT_TRUNCR_D_L()
        *
342              LOAD('JIT_TRUNCR_D_I(INTEGER,INTEGER)INTEGER', 'jit.so')
343              LOAD('JIT_TRUNCR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
344              LOAD('JIT_TRUNCR_D_L(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_HTONR(), JIT_NTOHR()
        *
345              LOAD('JIT_HTONR(INTEGER,INTEGER)INTEGER', 'jit.so')
346              LOAD('JIT_NTOHR(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDR(), JIT_LDR_C(), JIT_LDR_UC(), JIT_LDR_S(), JIT_LDR_US()
        *
347              LOAD('JIT_LDR(INTEGER,INTEGER)INTEGER', 'jit.so')
348              LOAD('JIT_LDR_C(INTEGER,INTEGER)INTEGER', 'jit.so')
349              LOAD('JIT_LDR_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
350              LOAD('JIT_LDR_S(INTEGER,INTEGER)INTEGER', 'jit.so')
351              LOAD('JIT_LDR_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDR_I(), JIT_LDR_UI(), JIT_LDR_L(), JIT_LDR_F(), JIT_LDR_D()
        *
352              LOAD('JIT_LDR_I(INTEGER,INTEGER)INTEGER', 'jit.so')
353              LOAD('JIT_LDR_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
354              LOAD('JIT_LDR_L(INTEGER,INTEGER)INTEGER', 'jit.so')
355              LOAD('JIT_LDR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
356              LOAD('JIT_LDR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDI(), JIT_LDI_C(), JIT_LDI_UC(), JIT_LDI_S(), JIT_LDI_US()
        *
357              LOAD('JIT_LDI(INTEGER,INTEGER)INTEGER', 'jit.so')
358              LOAD('JIT_LDI_C(INTEGER,INTEGER)INTEGER', 'jit.so')
359              LOAD('JIT_LDI_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
360              LOAD('JIT_LDI_S(INTEGER,INTEGER)INTEGER', 'jit.so')
361              LOAD('JIT_LDI_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDI_I(), JIT_LDI_UI(), JIT_LDI_L(), JIT_LDI_F(), JIT_LDI_D()
        *
362              LOAD('JIT_LDI_I(INTEGER,INTEGER)INTEGER', 'jit.so')
363              LOAD('JIT_LDI_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
364              LOAD('JIT_LDI_L(INTEGER,INTEGER)INTEGER', 'jit.so')
365              LOAD('JIT_LDI_F(INTEGER,INTEGER)INTEGER', 'jit.so')
366              LOAD('JIT_LDI_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXR(), JIT_LDXR_C(), JIT_LDXR_UC(), JIT_LDXR_S()
        *
367              LOAD('JIT_LDXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
368              LOAD('JIT_LDXR_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
369              LOAD('JIT_LDXR_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
370              LOAD('JIT_LDXR_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXR_US(), JIT_LDXR_I(), JIT_LDXR_UI(), JIT_LDXR_L()
        *
371              LOAD('JIT_LDXR_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
372              LOAD('JIT_LDXR_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
373              LOAD('JIT_LDXR_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
374              LOAD('JIT_LDXR_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXR_F(), JIT_LDXR_D()
        *
375              LOAD('JIT_LDXR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
376              LOAD('JIT_LDXR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXI(), JIT_LDXI_C(), JIT_LDXI_UC(), JIT_LDXI_S()
        *
377              LOAD('JIT_LDXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
378              LOAD('JIT_LDXI_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
379              LOAD('JIT_LDXI_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
380              LOAD('JIT_LDXI_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXI_US(), JIT_LDXI_I(), JIT_LDXI_UI(), JIT_LDXI_L()
        *
381              LOAD('JIT_LDXI_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
382              LOAD('JIT_LDXI_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
383              LOAD('JIT_LDXI_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
384              LOAD('JIT_LDXI_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXI_F(), JIT_LDXI_D()
        *
385              LOAD('JIT_LDXI_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
386              LOAD('JIT_LDXI_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STR(), JIT_STR_C(), JIT_STR_UC(), JIT_STR_S(), JIT_STR_US()
        *
387              LOAD('JIT_STR(INTEGER,INTEGER)INTEGER', 'jit.so')
388              LOAD('JIT_STR_C(INTEGER,INTEGER)INTEGER', 'jit.so')
389              LOAD('JIT_STR_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
390              LOAD('JIT_STR_S(INTEGER,INTEGER)INTEGER', 'jit.so')
391              LOAD('JIT_STR_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STR_I(), JIT_STR_UI(), JIT_STR_L(), JIT_STR_F(), JIT_STR_D()
        *
392              LOAD('JIT_STR_I(INTEGER,INTEGER)INTEGER', 'jit.so')
393              LOAD('JIT_STR_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
394              LOAD('JIT_STR_L(INTEGER,INTEGER)INTEGER', 'jit.so')
395              LOAD('JIT_STR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
396              LOAD('JIT_STR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STI(), JIT_STI_C(), JIT_STI_UC(), JIT_STI_S(), JIT_STI_US()
        *
397              LOAD('JIT_STI(INTEGER,INTEGER)INTEGER', 'jit.so')
398              LOAD('JIT_STI_C(INTEGER,INTEGER)INTEGER', 'jit.so')
399              LOAD('JIT_STI_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
400              LOAD('JIT_STI_S(INTEGER,INTEGER)INTEGER', 'jit.so')
401              LOAD('JIT_STI_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STI_I(), JIT_STI_UI(), JIT_STI_L(), JIT_STI_F(), JIT_STI_D()
        *
402              LOAD('JIT_STI_I(INTEGER,INTEGER)INTEGER', 'jit.so')
403              LOAD('JIT_STI_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
404              LOAD('JIT_STI_L(INTEGER,INTEGER)INTEGER', 'jit.so')
405              LOAD('JIT_STI_F(INTEGER,INTEGER)INTEGER', 'jit.so')
406              LOAD('JIT_STI_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXR(), JIT_STXR_C(), JIT_STXR_UC(), JIT_STXR_S()
        *
407              LOAD('JIT_STXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
408              LOAD('JIT_STXR_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
409              LOAD('JIT_STXR_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
410              LOAD('JIT_STXR_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXR_US(), JIT_STXR_I(), JIT_STXR_UI(), JIT_STXR_L()
        *
411              LOAD('JIT_STXR_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
412              LOAD('JIT_STXR_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
413              LOAD('JIT_STXR_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
414              LOAD('JIT_STXR_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXR_F(), JIT_STXR_D()
        *
415              LOAD('JIT_STXR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
416              LOAD('JIT_STXR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXI(), JIT_STXI_C(), JIT_STXI_S(), JIT_STXI_I()
        *
417              LOAD('JIT_STXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
418              LOAD('JIT_STXI_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *        LOAD('JIT_STXI_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
419              LOAD('JIT_STXI_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *        LOAD('JIT_STXI_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
420              LOAD('JIT_STXI_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *        LOAD('JIT_STXI_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXI_L(), JIT_STXI_F(), JIT_STXI_D()
        *
421              LOAD('JIT_STXI_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
422              LOAD('JIT_STXI_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
423              LOAD('JIT_STXI_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_PUSHARGR(), JIT_PUSHARGR_F(), JIT_PUSHARGR_D()
        *
424              LOAD('JIT_PUSHARGR(INTEGER)', 'jit.so')
        *         LOAD('JIT_PUSHARGR_C(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_UC(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_S(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_US(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_I(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_UI(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_L(INTEGER)INTEGER', 'jit.so')
425              LOAD('JIT_PUSHARGR_F(INTEGER)', 'jit.so')
426              LOAD('JIT_PUSHARGR_D(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_PUSHARGI(), JIT_PUSHARGI_F(), JIT_PUSHARGI_D()
        *
427              LOAD('JIT_PUSHARGI(INTEGER)', 'jit.so')
        *         LOAD('JIT_PUSHARGI_C(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_UC(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_S(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_US(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_I(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_UI(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_L(INTEGER)INTEGER', 'jit.so')
428              LOAD('JIT_PUSHARGI_F(REAL)', 'jit.so')
429              LOAD('JIT_PUSHARGI_D(REAL)', 'jit.so')
        *
        -PUBLIC JIT_ARG(), JIT_ARG_C(), JIT_ARG_UC(), JIT_ARG_S(), JIT_ARG_US()
        *
430              LOAD('JIT_ARG()INTEGER', 'jit.so')
431              LOAD('JIT_ARG_C(INTEGER)INTEGER', 'jit.so')
432              LOAD('JIT_ARG_UC(INTEGER)INTEGER', 'jit.so')
433              LOAD('JIT_ARG_S(INTEGER)INTEGER', 'jit.so')
434              LOAD('JIT_ARG_US(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ARG_I(), JIT_ARG_UI(), JIT_ARG_L(), JIT_ARG_F(), JIT_ARG_D()
        *
435              LOAD('JIT_ARG_I(INTEGER)INTEGER', 'jit.so')
436              LOAD('JIT_ARG_UI(INTEGER)INTEGER', 'jit.so')
437              LOAD('JIT_ARG_L(INTEGER)INTEGER', 'jit.so')
438              LOAD('JIT_ARG_F()INTEGER', 'jit.so')
439              LOAD('JIT_ARG_D()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GETARG(), JIT_GETARG_C(), JIT_GETARG_UC(), JIT_GETARG_S()
        *
440              LOAD('JIT_GETARG(INTEGER,INTEGER)', 'jit.so')
441              LOAD('JIT_GETARG_C(INTEGER,INTEGER)', 'jit.so')
442              LOAD('JIT_GETARG_UC(INTEGER,INTEGER)', 'jit.so')
443              LOAD('JIT_GETARG_S(INTEGER,INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_GETARG_US(), JIT_GETARG_I(), JIT_GETARG_UI(), JIT_GETARG_L()
        *
444              LOAD('JIT_GETARG_US(INTEGER,INTEGER)', 'jit.so')
445              LOAD('JIT_GETARG_I(INTEGER,INTEGER)', 'jit.so')
446              LOAD('JIT_GETARG_UI(INTEGER,INTEGER)', 'jit.so')
447              LOAD('JIT_GETARG_L(INTEGER,INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_GETARG_F(), JIT_GETARG_D()
        *
448              LOAD('JIT_GETARG_F(INTEGER,INTEGER)', 'jit.so')
449              LOAD('JIT_GETARG_D(INTEGER,INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_RET(), JIT_RETR(), JIT_RETR_C(), JIT_RETR_UC(), JIT_RETR_S()
        *
450              LOAD('JIT_RET()', 'jit.so')
451              LOAD('JIT_RETR(INTEGER)', 'jit.so')
452              LOAD('JIT_RETR_C(INTEGER)INTEGER', 'jit.so')
453              LOAD('JIT_RETR_UC(INTEGER)INTEGER', 'jit.so')
454              LOAD('JIT_RETR_S(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_RETR_US(), JIT_RETR_I(), JIT_RETR_UI(), JIT_RETR_L()
        *
455              LOAD('JIT_RETR_US(INTEGER)INTEGER', 'jit.so')
456              LOAD('JIT_RETR_I(INTEGER)INTEGER', 'jit.so')
457              LOAD('JIT_RETR_UI(INTEGER)INTEGER', 'jit.so')
458              LOAD('JIT_RETR_L(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_RETR_F(), JIT_RETR_D()
        *
459              LOAD('JIT_RETR_F(INTEGER)', 'jit.so')
460              LOAD('JIT_RETR_D(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_RETI(), JIT_RETI_C(), JIT_RETI_UC(), JIT_RETI_S()
        *
461              LOAD('JIT_RETI(INTEGER)', 'jit.so')
462              LOAD('JIT_RETI_C(INTEGER)INTEGER', 'jit.so')
463              LOAD('JIT_RETI_UC(INTEGER)INTEGER', 'jit.so')
464              LOAD('JIT_RETI_S(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_RETI_US(), JIT_RETI_I(), JIT_RETI_UI(), JIT_RETI_L()
        *
465              LOAD('JIT_RETI_US(INTEGER)INTEGER', 'jit.so')
466              LOAD('JIT_RETI_I(INTEGER)INTEGER', 'jit.so')
467              LOAD('JIT_RETI_UI(INTEGER)INTEGER', 'jit.so')
468              LOAD('JIT_RETI_L(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_RETI_F(), JIT_RETI_D()
        *
469              LOAD('JIT_RETI_F(REAL)', 'jit.so')
470              LOAD('JIT_RETI_D(REAL)', 'jit.so')
        *
        -PUBLIC JIT_RETVAL(), JIT_RETVAL_C(), JIT_RETVAL_UC(), JIT_RETVAL_S()
        *
471              LOAD('JIT_RETVAL(INTEGER)', 'jit.so')
472              LOAD('JIT_RETVAL_C(INTEGER)', 'jit.so')
473              LOAD('JIT_RETVAL_UC(INTEGER)', 'jit.so')
474              LOAD('JIT_RETVAL_S(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_RETVAL_US(), JIT_RETVAL_I(), JIT_RETVAL_UI(), JIT_RETVAL_L()
        *
475              LOAD('JIT_RETVAL_US(INTEGER)', 'jit.so')
476              LOAD('JIT_RETVAL_I(INTEGER)', 'jit.so')
477              LOAD('JIT_RETVAL_UI(INTEGER)', 'jit.so')
478              LOAD('JIT_RETVAL_L(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_RETVAL_F(), JIT_RETVAL_D()
        *
479              LOAD('JIT_RETVAL_F(INTEGER)', 'jit.so')
480              LOAD('JIT_RETVAL_D(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_BLTR(), JIT_BLTR_U(), JIT_BLTR_F(), JIT_BLTR_D()
        *
481              LOAD('JIT_BLTR(INTEGER,INTEGER)INTEGER', 'jit.so')
482              LOAD('JIT_BLTR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
483              LOAD('JIT_BLTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
484              LOAD('JIT_BLTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BLTI(), JIT_BLTI_U(), JIT_BLTI_F(), JIT_BLTI_D()
        *
485              LOAD('JIT_BLTI(INTEGER,INTEGER)INTEGER', 'jit.so')
486              LOAD('JIT_BLTI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
487              LOAD('JIT_BLTI_F(INTEGER,REAL)INTEGER', 'jit.so')
488              LOAD('JIT_BLTI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BLER(), JIT_BLER_U(), JIT_BLER_F(), JIT_BLER_D()
        *
489              LOAD('JIT_BLER(INTEGER,INTEGER)INTEGER', 'jit.so')
490              LOAD('JIT_BLER_U(INTEGER,INTEGER)INTEGER', 'jit.so')
491              LOAD('JIT_BLER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
492              LOAD('JIT_BLER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BLEI(), JIT_BLEI_U(), JIT_BLEI_F(), JIT_BLEI_D()
        *
493              LOAD('JIT_BLEI(INTEGER,INTEGER)INTEGER', 'jit.so')
494              LOAD('JIT_BLEI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
495              LOAD('JIT_BLEI_F(INTEGER,REAL)INTEGER', 'jit.so')
496              LOAD('JIT_BLEI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BGTR(), JIT_BGTR_U(), JIT_BGTR_F(), JIT_BGTR_D()
        *
497              LOAD('JIT_BGTR(INTEGER,INTEGER)INTEGER', 'jit.so')
498              LOAD('JIT_BGTR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
499              LOAD('JIT_BGTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
500              LOAD('JIT_BGTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GBTI(), JIT_BGTI_U(), JIT_BGTI_F(), JIT_BGTI_D()
        *
501              LOAD('JIT_BGTI(INTEGER,INTEGER)INTEGER', 'jit.so')
502              LOAD('JIT_BGTI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
503              LOAD('JIT_BGTI_F(INTEGER,REAL)INTEGER', 'jit.so')
504              LOAD('JIT_BGTI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BGER(), JIT_BGER_U(), JIT_BGER_F(), JIT_BGER_D()
        *
505              LOAD('JIT_BGER(INTEGER,INTEGER)INTEGER', 'jit.so')
506              LOAD('JIT_BGER_U(INTEGER,INTEGER)INTEGER', 'jit.so')
507              LOAD('JIT_BGER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
508              LOAD('JIT_BGER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BGEI(), JIT_BGEI_U(), JIT_BGEI_F(), JIT_BGEI_D()
        *
509              LOAD('JIT_BGEI(INTEGER,INTEGER)INTEGER', 'jit.so')
510              LOAD('JIT_BGEI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
511              LOAD('JIT_BGEI_F(INTEGER,REAL)INTEGER', 'jit.so')
512              LOAD('JIT_BGEI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BEQR(), JIT_BEQR_F(), JIT_BEQR_D()
        *
513              LOAD('JIT_BEQR(INTEGER,INTEGER)INTEGER', 'jit.so')
514              LOAD('JIT_BEQR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
515              LOAD('JIT_BEQR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BEQI(), JIT_BEQI_F(), JIT_BEQI_D()
        *
516              LOAD('JIT_BEQI(INTEGER,INTEGER)INTEGER', 'jit.so')
517              LOAD('JIT_BEQI_F(INTEGER,REAL)INTEGER', 'jit.so')
518              LOAD('JIT_BEQI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BNER(), JIT_BNER_F(), JIT_BNER_D()
        *
519              LOAD('JIT_BNER(INTEGER,INTEGER)INTEGER', 'jit.so')
520              LOAD('JIT_BNER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
521              LOAD('JIT_BNER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BNEI(), JIT_BNEI_F(), JIT_BNEI_D()
        *
522              LOAD('JIT_BNEI(INTEGER,INTEGER)INTEGER', 'jit.so')
523              LOAD('JIT_BNEI_F(INTEGER,REAL)INTEGER', 'jit.so')
524              LOAD('JIT_BNEI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BUNLTR_F(), JIT_BUNLTR_D()
        *
525              LOAD('JIT_BUNLTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
526              LOAD('JIT_BUNLTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BUNLER_F(), JIT_BUNLER_D()
        *
527              LOAD('JIT_BUNLER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
528              LOAD('JIT_BUNLER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BUNGTR_F(), JIT_BUNGTR_D()
        *
529              LOAD('JIT_BUNGTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
530              LOAD('JIT_BUNGTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BUNGER_F(), JIT_BUNGER_D()
        *
531              LOAD('JIT_BUNGER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
532              LOAD('JIT_BUNGER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BUNEQR_F(), JIT_BUNEQR_D()
        *
533              LOAD('JIT_BUNEQR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
534              LOAD('JIT_BUNEQR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BLTGTR_F(), JIT_BLTGTR_D()
        *
535              LOAD('JIT_BLTGTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
536              LOAD('JIT_BLTGTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BORDR_F(), JIT_BORDR_D()
        *
537              LOAD('JIT_BORDR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
538              LOAD('JIT_BORDR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BUNORDR_F(), JIT_BUNORDR_D()
        *
539              LOAD('JIT_BUNORDR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
540              LOAD('JIT_BUNORDR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BMSR(), JIT_BMSI(), JIT_BMCR(), JIT_BMCI()
        *
541              LOAD('JIT_BMSR(INTEGER,INTEGER)INTEGER', 'jit.so')
542              LOAD('JIT_BMSI(INTEGER,INTEGER)INTEGER', 'jit.so')
543              LOAD('JIT_BMCR(INTEGER,INTEGER)INTEGER', 'jit.so')
544              LOAD('JIT_BMCI(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BOADDR(), JIT_BOADDR_U(), JIT_BOADDI(), JIT_BOADDI_U()
        *
545              LOAD('JIT_BOADDR(INTEGER,INTEGER)INTEGER', 'jit.so')
546              LOAD('JIT_BOADDR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
547              LOAD('JIT_BOADDI(INTEGER,INTEGER)INTEGER', 'jit.so')
548              LOAD('JIT_BOADDI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BXADDR(), JIT_BXADDR_U(), JIT_BXADDI(), JIT_BXADDI_U()
        *
549              LOAD('JIT_BXADDR(INTEGER,INTEGER)INTEGER', 'jit.so')
550              LOAD('JIT_BXADDR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
551              LOAD('JIT_BXADDI(INTEGER,INTEGER)INTEGER', 'jit.so')
552              LOAD('JIT_BXADDI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BOSUBR(), JIT_BOSUBR_U(), JIT_BOSUBI(), JIT_BOSUBI_U()
        *
553              LOAD('JIT_BOSUBR(INTEGER,INTEGER)INTEGER', 'jit.so')
554              LOAD('JIT_BOSUBR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
555              LOAD('JIT_BOSUBI(INTEGER,INTEGER)INTEGER', 'jit.so')
556              LOAD('JIT_BOSUBI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BXSUBR(), JIT_BXSUBR_U(), JIT_BXSUBI(), JIT_BXSUBI_U()
        *
557              LOAD('JIT_BXSUBR(INTEGER,INTEGER)INTEGER', 'jit.so')
558              LOAD('JIT_BXSUBR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
559              LOAD('JIT_BXSUBI(INTEGER,INTEGER)INTEGER', 'jit.so')
560              LOAD('JIT_BXSUBI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_CALLR(), JIT_CALLI()
        *
561              LOAD('JIT_CALLR(INTEGER)INTEGER', 'jit.so')
562              LOAD('JIT_CALLI(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_FINISHR(), JIT_FINISHI()
        *
563              LOAD('JIT_FINISHR(INTEGER)', 'jit.so')
564              LOAD('JIT_FINISHI(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_JMPR(), JIT_JMPI()
        *
565              LOAD('JIT_JMPR(INTEGER)', 'jit.so')
566              LOAD('JIT_JMPI()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GET_NOTE()
        *
567              DEFINE('JIT_GET_NOTE(P)')                            :(END_JIT)
        *
568     JIT_GET_NOTE
569              GET_NOTE_JIT(P)                                     :F(FRETURN)
570              JIT_GET_NOTE = ARRAY(3)
571              JIT_GET_NOTE<1> = GET_NOTE_S1()
572              JIT_GET_NOTE<2> = GET_NOTE_S2()
573              JIT_GET_NOTE<3> = GET_NOTE_I                          :(RETURN)
        *
574     END_JIT
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CHARS.INC'
        -MODULE CHARS
        -LINE 12 "CHARS.lss"
        -IN72
        -LINE 100 "CHARS.lss"
        -STITL CHARS
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #####   #     #     #     ######    #####               *
        *             #     #  #     #    # #    #     #  #     #              *
        *             #        #     #   #   #   #     #  #                    *
        *             #        #######  #     #  ######    #####               *
        *             #        #     #  #######  #   #          #              *
        *             #     #  #     #  #     #  #    #   #     #              *
        *              #####   #     #  #     #  #     #   #####               *
        *                                                                      *
        * CHARS             SYMBOLIC NAMES FOR CHARACTERS                      *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * DECEMBER 2001                                                        *
        *                                                                      *
        ************************************************************************
        *
        * CHARS.lss
        *
        -LINE 15 "CHARS.lss"
        -PUBLIC CHARS_NUL, CHARS_SOH, CHARS_STX, CHARS_ETX, CHARS_EOT, CHARS_ENQ
        -PUBLIC CHARS_ACK, CHARS_BEL, CHARS_HT, CHARS_BS, CHARS_NL, CHARS_VT
        -PUBLIC CHARS_NP, CHARS_CR, CHARS_SO, CHARS_SI, CHARS_DLE, CHARS_DC1
        -PUBLIC CHARS_DC2, CHARS_DC3, CHARS_DC4, CHARS_NAK, CHARS_SYN, CHARS_ETB
        -PUBLIC CHARS_CAN, CHARS_EM, CHARS_SUB, CHARS_ESC, CHARS_FS, CHARS_GS
        -PUBLIC CHARS_RS, CHARS_US, CHARS_SP, CHARS_DEL, CHARS_TAB, CHARS_SPACE
        -PUBLIC CHARS_FF, CHARS_LF, CHARS_CONTROL, CHARS_PRINTABLE, CHARS_HIGH
        *
575     CHARS    CHARS_NUL = CHAR( 0)
576              CHARS_SOH = CHAR( 1)
577              CHARS_STX = CHAR( 2)
578              CHARS_ETX = CHAR( 3)
579              CHARS_EOT = CHAR( 4)
580              CHARS_ENQ = CHAR( 5)
581              CHARS_ACK = CHAR( 6)
582              CHARS_BEL = CHAR( 7)
583              CHARS_BS  = CHAR( 8)
584              CHARS_HT  = CHAR( 9)
585              CHARS_NL  = CHAR(10)
586              CHARS_VT  = CHAR(11)
587              CHARS_NP  = CHAR(12)
588              CHARS_CR  = CHAR(13)
589              CHARS_SO  = CHAR(14)
590              CHARS_SI  = CHAR(15)
591              CHARS_DLE = CHAR(16)
592              CHARS_DC1 = CHAR(17)
593              CHARS_DC2 = CHAR(18)
594              CHARS_DC3 = CHAR(19)
595              CHARS_DC4 = CHAR(20)
596              CHARS_NAK = CHAR(21)
597              CHARS_SYN = CHAR(22)
598              CHARS_ETB = CHAR(23)
599              CHARS_CAN = CHAR(24)
600              CHARS_EM  = CHAR(25)
601              CHARS_SUB = CHAR(26)
602              CHARS_ESC = CHAR(27)
603              CHARS_FS  = CHAR(28)
604              CHARS_GS  = CHAR(29)
605              CHARS_RS  = CHAR(30)
606              CHARS_US  = CHAR(31)
607              CHARS_SP  = CHAR(32)
608              CHARS_DEL = CHAR(127)
        -LINE 68 "CHARS.lss"
        *
609              CHARS_TAB   = CHARS_HT
610              CHARS_SPACE = CHARS_SP
611              CHARS_FF    = CHARS_NP
612              CHARS_LF    = CHARS_NL
        -LINE 78 "CHARS.lss"
        *
613              &ALPHABET LEN(32) .  CHARS_CONTROL
613     +                  LEN(95) .  CHARS_PRINTABLE
613     +                  LEN(129) . CHARS_HIGH
        *
614              CODE('CHARS')
        *
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'KEYST.INC'
        -MODULE KEYST
        -LINE 10 "KEYST.lss"
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 40 "KEYST.lss"
        -STITL KEYST
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #    #  #######  #     #   #####   #######              *
        *              #   #   #         #   #   #     #     #                 *
        *              #  #    #          # #    #           #                 *
        *              ###     #####       #      #####      #                 *
        *              #  #    #           #           #     #                 *
        *              #   #   #           #     #     #     #                 *
        *              #    #  #######     #      #####      #                 *
        *                                                                      *
        * KEYST                      KEYS IN TABLE                             *
        *                                                                      *
        ************************************************************************
        *
        * KEYST.lss
        *
        -LINE 15 "KEYST.lss"
        -PUBLIC KEYST()
        *
615              DEFINE('KEYST(T)A,N,I')                            :(KEYST_END)
        *
616     KEYST    A = (CONVERT(T, 'ARRAY'), ARRAY0)
617              PROTOTYPE(A) BREAK(',') . N                         :F(FRETURN)
618              KEYST = (NE(N) ARRAY(N), ARRAY0)
619              SEQ(' KEYST<I> = A<I,1> ', .I)                        :(RETURN)
        *
620     KEYST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BREAKQ.INC'
        -MODULE BREAKQ
        -INCLUDE 'UNIQUE.INC'
        -LINE 24 "UNIQUE.lss"
        -INCLUDE 'REPL.INC'
        -MODULE REPL
        -LINE 13 "REPL.lss"
        -IN72
        -LINE 45 "REPL.lss"
        -STITL REPL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                   ######   #######  ######   #                       *
        *                   #     #  #        #     #  #                       *
        *                   #     #  #        #     #  #                       *
        *                   ######   #####    ######   #                       *
        *                   #   #    #        #        #                       *
        *                   #    #   #        #        #                       *
        *                   #     #  #######  #        #######                 *
        *                                                                      *
        * REPL                   REPLACE STRINGS                               *
        *                                                                      *
        ************************************************************************
        *
        * REPL.lss
        *
        -LINE 16 "REPL.lss"
        -PUBLIC REPL()
        *
621              DEFINE('REPL(S1,S2,S3)C,T,FINDC')                   :(REPL_END)
        *
622     REPL     S2 LEN(1) . C =                                     :F(FRETURN)
623              FINDC = BREAK(C) . T LEN(1)
624              S2 = POS(0) S2
625     REPL_1   S1 FINDC =                                           :F(REPL_2)
626              S1 S2 =                                              :F(REPL_3)
627              REPL = REPL T S3                                      :(REPL_1)
628     REPL_3   REPL = REPL T C                                       :(REPL_1)
629     REPL_2   REPL = REPL S1                                        :(RETURN)
        *
630     REPL_END
        *
        * CE: .MSNOBOL4;
        -STITL UNIQUE
        -EJECT
        -LINE 73 "UNIQUE.lss"
        *
        ************************************************************************
        *                                                                      *
        *           #     #  #     #  ###   #####   #     #  #######           *
        *           #     #  ##    #   #   #     #  #     #  #                 *
        *           #     #  # #   #   #   #     #  #     #  #                 *
        *           #     #  #  #  #   #   #     #  #     #  #####             *
        *           #     #  #   # #   #   #   # #  #     #  #                 *
        *           #     #  #    ##   #   #    #   #     #  #                 *
        *            #####   #     #  ###   #### #   #####   #######           *
        *                                                                      *
        * UNIQUE                 GENERATE UNIQUE NAME                          *
        *                                                                      *
        ************************************************************************
        *
        * UNIQUE.lss
        *
        -LINE 28 "UNIQUE.lss"
        -MODULE UNIQUE
        -PUBLIC MAKE_UNIQUE(), UNIQUE()
631              DEFINE('MAKE_UNIQUE(SUF)S')
632              MAKE_UNIQUE()
633              OPSYN('UNIQUE', 'UNIQUE_')                        :(UNIQUE_END)
        *
634     MAKE_UNIQUE
635              S =
635     + 'UNIQUE_SUF  UNIQUE_SUF_ = IDENT(I) UNIQUE_SUF_ + 1  :F(UNIQUECSUF);'
635     + '            UNIQUE_SUF = "USUF" UNIQUE_SUF_ "_"          :(RETURN);'
635     + 'UNIQUECSUF $("USUF" UNIQUE_SUF_ "_") = '
635     + '           ?(UNIQUE_SUF_ = GT(UNIQUE_SUF_,0) UNIQUE_SUF_ - 1)'
635     + '                                           :S(UNIQUECSUF)F(RETURN);'
636              CODE(REPL(S, 'SUF', SUF))
637              DEFINE('UNIQUE_' SUF '(I)')                           :(RETURN)
        *
638     UNIQUE_END
        *
        * CE: .MSNOBOL4;
        -STITL BREAKQ
        *
        ************************************************************************
        *                                                                      *
        *         ######   ######   #######     #     #    #   #####           *
        *         #     #  #     #  #          # #    #   #   #     #          *
        *         #     #  #     #  #         #   #   #  #    #     #          *
        *         ######   ######   #####    #     #  ###     #     #          *
        *         #     #  #   #    #        #######  #  #    #   # #          *
        *         #     #  #    #   #        #     #  #   #   #    #           *
        *         ######   #     #  #######  #     #  #    #   #### #          *
        *                                                                      *
        *                                                                      *
        * BREAKQ           FASBOL II BREAKQ PATTERN                            *
        *                                                                      *
        ************************************************************************
        *
        * BREAKQ.INC
        *
        -PUBLIC BREAKQ()
        *
639              DEFINE('BREAKQ(S)NAME,R,P1,P2,P3')                :(END_BREAKQ)
        *
640     BREAKQ   NAME = UNIQUE()
641              R = CONVERT(NAME, 'EXPRESSION')
642              P1 = BREAK('"' "'" S)
643              P2 = "'" BREAK("'") "'" R
644              P3 = '"' BREAK('"') '"' R
645              BREAKQ = P1 (P2 | P3 | BREAK(S))
646              $NAME = BREAKQ                                        :(RETURN)
        *
647     END_BREAKQ
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'NSPAN.INC'
        -MODULE NSPAN
        -STITL NSPAN
        *
        ************************************************************************
        *                                                                      *
        *             #     #   #####   ######      #     #     #              *
        *             ##    #  #     #  #     #    # #    ##    #              *
        *             # #   #  #        #     #   #   #   # #   #              *
        *             #  #  #   #####   ######   #     #  #  #  #              *
        *             #   # #        #  #        #######  #   # #              *
        *             #    ##  #     #  #        #     #  #    ##              *
        *             #     #   #####   #        #     #  #     #              *
        *                                                                      *
        * NSPAN               FASBOL II NSPAN PATTERN                          *
        *                                                                      *
        ************************************************************************
        *
        * NSPAN.INC
        *
        -PUBLIC NSPAN()
        *
648              DEFINE('NSPAN(P)')                                 :(END_NSPAN)
        *
649     NSPAN    NSPAN = SPAN(P) | ''                                  :(RETURN)
        *
650     END_NSPAN
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'LINK.INC'
        -MODULE LINK
        -LINE 10 "LINK.lss"
        -IN72
        -LINE 73 "LINK.lss"
        -STITL LINK
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #        ###  #     #  #    #                     *
        *                    #         #   ##    #  #   #                      *
        *                    #         #   # #   #  #  #                       *
        *                    #         #   #  #  #  ###                        *
        *                    #         #   #   # #  #  #                       *
        *                    #         #   #    ##  #   #                      *
        *                    #######  ###  #     #  #    #                     *
        *                                                                      *
        * LINK                        LINK TYPE                                *
        *                                                                      *
        ************************************************************************
        *
        * LINK.lss
        *
        -LINE 13 "LINK.lss"
        -PUBLIC LINK(), NEXT()
        *
651              DATA('LINK(VALUE,NEXT)')
        *
        -PUBLIC CONS(), CAR(), CDR()
        *
652              OPSYN('CONS', 'LINK')
653              OPSYN('CAR', 'VALUE')
654              OPSYN('CDR', 'NEXT')
        *
        -PUBLIC CAAR(), CDAR(), CADR(), CDDR()
        *
655              DEFINE('CAAR(L)')
656              DEFINE('CDAR(l)')
657              DEFINE('CADR(L)')
658              DEFINE('CDDR(L)')
        *
        -PUBLIC CAAAR(), CAADR(), CADAR(), CADDR()
        -PUBLIC CDAAR(), CDADR(), CDDAR(), CDDDR()
        *
659              DEFINE('CAAAR(L)')
660              DEFINE('CAADR(L)')
661              DEFINE('CADAR(L)')
662              DEFINE('CADDR(L)')
663              DEFINE('CDAAR(L)')
664              DEFINE('CDADR(L)')
665              DEFINE('CDDAR(L)')
666              DEFINE('CDDDR(L)')
667                                                                  :(LINK_END)
        *
668     CAAAR    CAAAR = CAR(CAAR(L))                                  :(RETURN)
669     CAADR    CAADR = CAR(CADR(L))                                  :(RETURN)
670     CADAR    CADAR = CAR(CDAR(L))                                  :(RETURN)
671     CADDR    CADDR = CAR(CDDR(L))                                  :(RETURN)
672     CDAAR    CDAAR = CDR(CAAR(L))                                  :(RETURN)
673     CDADR    CDADR = CDR(CADR(L))                                  :(RETURN)
674     CDDAR    CDDAR = CDR(CDAR(L))                                  :(RETURN)
675     CDDDR    CDDDR = CDR(CDDR(L))                                  :(RETURN)
        *
676     CAAR     CAAR = CAR(CAR(L))                                    :(RETURN)
677     CDAR     CDAR = CDR(CAR(L))                                    :(RETURN)
678     CADR     CADR = CAR(CDR(L))                                    :(RETURN)
679     CDDR     CDDR = CDR(CDR(L))                                    :(RETURN)
        *
680     LINK_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'UNIX.INC'
        -MODULE UNIX
        -INCLUDE 'FFI.INC'
        -MODULE FFI
        -CASE 1
        -PLUSOPS 1
        -LINE 650 "FFI.lss"
        -LINE 17 "FFI.lss"
        -IN72
        -STITL FFI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #######  #######  ###                        *
        *                         #        #         #                         *
        *                         #        #         #                         *
        *                         #####    #####     #                         *
        *                         #        #         #                         *
        *                         #        #         #                         *
        *                         #        #        ###                        *
        *                                                                      *
        * FFI                  FOREIGN FUNCTION INTERFACE                      *
        *                                                                      *
        ************************************************************************
        *
        * FFI.lss
        *
        -LINE 22 "FFI.lss"
        -LINE 23 "FFI.lss"
        -LINE 24 "FFI.lss"
        -LINE 25 "FFI.lss"
        -LINE 26 "FFI.lss"
        -LINE 27 "FFI.lss"
        -LINE 28 "FFI.lss"
        -LINE 31 "FFI.lss"
681              FFI = 'ffi.c'
        -LINE 538 "FFI.lss"
        -LINE 539 "FFI.lss"
        -LINE 540 "FFI.lss"
        -LINE 541 "FFI.lss"
        -LINE 542 "FFI.lss"
        -LINE 543 "FFI.lss"
        -LINE 553 "FFI.lss"
682              LOAD('FFI_FREE(INTEGER)', 'ffi.so')
683              LOAD('FFI_CLEAR(INTEGER)', 'ffi.so')
684              LOAD('FFI_NEW(STRING,STRING)INTEGER', 'ffi.so')
685              LOAD('FFI_PAR_N_NEEDFREE(INTEGER,INTEGER)', 'ffi.so')
686              LOAD('FFI_PAR_N_INTEGER(INTEGER,INTEGER,INTEGER)', 'ffi.so')
687              LOAD('FFI_PAR_N_PTR(INTEGER,INTEGER,INTEGER)', 'ffi.so')
688              LOAD('FFI_PAR_N_REAL(INTEGER,INTEGER,REAL)', 'ffi.so')
689              LOAD('FFI_PAR_N_STRING(INTEGER,INTEGER,STRING)', 'ffi.so')
690              LOAD('FFI_PAR_N_F(INTEGER,INTEGER,REAL)', 'ffi.so')
691              LOAD('FFI_PAR_N_D(INTEGER,INTEGER,REAL)', 'ffi.so')
692              LOAD('FFI_PAR_N_LD(INTEGER,INTEGER,REAL)', 'ffi.so')
693              LOAD('FFI_SET_CALLP(INTEGER,INTEGER)', 'ffi.so')
694              LOAD('FFI_RESULTP(INTEGER)INTEGER', 'ffi.so')
695              LOAD('CALL_FFI(INTEGER)', 'ffi.so')
696              LOAD('CALL_INTEGER_FFI(INTEGER)INTEGER', 'ffi.so')
697              LOAD('CALL_PTR_FFI(INTEGER)INTEGER', 'ffi.so')
698              LOAD('CALL_REAL_FFI(INTEGER)REAL', 'ffi.so')
699              LOAD('CALL_STRING_FFI(INTEGER)STRING', 'ffi.so')
        *
700              RTLD_LAZY   = 1
701              RTLD_NOW    = 2
702              RTLD_GLOBAL = 256
703              RTLD_LOCAL  = 0
        *
704              LOAD('DLOPEN_(STRING,INTEGER)INTEGER', 'ffi.so')
705              LOAD('DLERROR_()STRING', 'ffi.so')
706              LOAD('DLSYM_(INTEGER,STRING)', 'ffi.so')
707              LOAD('DLCLOSE_(INTEGER)INTEGER', 'ffi.so')
        *
        -LINE 587 "FFI.lss"
        -PUBLIC DLOPEN(), DLERROR(), DLSYM(), DLCLOSE()
        *
708              DEFINE('DLOPEN(S,I)')
709              DEFINE('DLERROR()')
710              DEFINE('DLSYM(H,S)')
711              DEFINE('DLCLOSE(H)')
        *
        -PUBLIC FFI_NEW(), FFI_FREE(), FFI_CLEAR(), FFI_PAR_N_NEEDFREE()
        -PUBLIC FFI_PAR_N_INTEGER(), FFI_PAR_N_PTR(), FFI_PAR_N_REAL()
        -PUBLIC FFI_PAR_N_STRING(),  FFI_SET_CALLP()
        -PUBLIC FFI_CALL_VOID(), FFI_CALL_INTEGER(), FFI_CALL_REAL()
        -PUBLIC FFI_CALL_STRING(), FFI_CALL_PTR(), CALL_FFI(), FFI_RESULTP()
        *
712              DEFINE('FFI_CALL_INTEGER(FFI)')
713              DEFINE('FFI_CALL_REAL(FFI)')
714              DEFINE('FFI_CALL_STRING(FFI)')
715              DEFINE('FFI_CALL_PTR(FFI)')
716              DEFINE('FFI_CALL_VOID(FFI)')                         :(FFI_END)
        *
717     DLOPEN   DLOPEN = DLOPEN_(S, I)                                :(RETURN)
        *
718     DLERROR  DLERROR = DLERROR_()                                  :(RETURN)
        *
719     DLSYM    DLSYM = DLSYM_(H, S)                                  :(RETURN)
        *
720     DLCLOSE  DLCLOSE = DLCLOSE_(H)                                 :(RETURN)
        *
721     FFI_CALL_VOID
722              CALL_FFI(FFI)
723              FFI_CLEAR(FFI)                                        :(RETURN)
        *
724     FFI_CALL_INTEGER
725              FFI_CALL_INTEGER = CALL_INTEGER_FFI(FFI)
726              FFI_CLEAR(FFI)                                        :(RETURN)
        *
727     FFI_CALL_REAL
728              FFI_CALL_REAL = CALL_REAL_FFI(FFI)
729              FFI_CLEAR(FFI)                                        :(RETURN)
        *
730     FFI_CALL_STRING
731              FFI_CALL_STRING = CALL_STRING_FFI(FFI)
732              FFI_CLEAR(FFI)                                        :(RETURN)
        *
733     FFI_CALL_PTR
734              FFI_CALL_PTR = CALL_PTR_FFI(FFI)
735              FFI_CLEAR(FFI)                                        :(RETURN)
        *
736     FFI_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'P64.INC'
        -MODULE P64
        -LINE 37 "P64.lss"
        -IN72
        -LINE 217 "P64.lss"
        -CASE 1
        -STITL P64
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       ######    ###   #   #                          *
        *                       #     #  #   #  #   #                          *
        *                       #     #  #      #   #                          *
        *                       ######   ####   #####                          *
        *                       #        #   #      #                          *
        *                       #        #   #      #                          *
        *                       #         ###       #                          *
        *                                                                      *
        * P64                    POINTER UTILITIES                             *
        *                                                                      *
        ************************************************************************
        *
        * P64.lss
        *
        -LINE 40 "P64.lss"
        -LINE 41 "P64.lss"
        -LINE 42 "P64.lss"
        -LINE 43 "P64.lss"
        -LINE 44 "P64.lss"
        -LINE 45 "P64.lss"
        -LINE 50 "P64.lss"
737              P64 = 'p64.c'
        -LINE 164 "P64.lss"
        -LINE 165 "P64.lss"
        -LINE 166 "P64.lss"
        -LINE 167 "P64.lss"
        -LINE 168 "P64.lss"
        -LINE 176 "P64.lss"
        -PUBLIC PEEK_STRING(), POKE_STRING(), PEEK_BUFFER(), POKE_BUFFER()
        *
738              LOAD('PEEK_STRING(INTEGER)STRING', 'p64.so')
739              LOAD('POKE_STRING(INTEGER,STRING)', 'p64.so')
740              LOAD('PEEK_BUFFER(INTEGER,INTEGER)STRING', 'p64.so')
741              LOAD('POKE_BUFFER(INTEGER,STRING)', 'p64.so')
        *
        -PUBLIC PEEK_P(), PEEK_C(), PEEK_S(), PEEK_I(), PEEK_D(), PEEK_F()
        -PUBLIC PEEK_LD()
        -PUBLIC POKE_P(), POKE_C(), POKE_S(), POKE_I(), POKE_D(), POKE_F()
        -PUBLIC POKE_LD()
        *
742              LOAD('PEEK_P(INTEGER)INTEGER', 'p64.so')
743              LOAD('PEEK_C(INTEGER)INTEGER', 'p64.so')
744              LOAD('PEEK_S(INTEGER)INTEGER', 'p64.so')
745              LOAD('PEEK_I(INTEGER)INTEGER', 'p64.so')
746              LOAD('PEEK_D(INTEGER)REAL', 'p64.so')
747              LOAD('PEEK_F(INTEGER)REAL', 'p64.so')
748              LOAD('PEEK_LD(INTEGER)REAL', 'p64.so')
749              LOAD('POKE_P(INTEGER,INTEGER)', 'p64.so')
750              LOAD('POKE_C(INTEGER,INTEGER)', 'p64.so')
751              LOAD('POKE_S(INTEGER,INTEGER)', 'p64.so')
752              LOAD('POKE_I(INTEGER,INTEGER)', 'p64.so')
753              LOAD('POKE_D(INTEGER,REAL)', 'p64.so')
754              LOAD('POKE_F(INTEGER,REAL)', 'p64.so')
755              LOAD('POKE_LD(INTEGER,REAL)', 'p64.so')
        *
        * CE: .F.MSNOBOL4;
        -IN72
        -STITL UNIX
        *
        ************************************************************************
        *                                                                      *
        *                    #     #  #     #  ###  #     #                    *
        *                    #     #  ##    #   #    #   #                     *
        *                    #     #  # #   #   #     # #                      *
        *                    #     #  #  #  #   #      #                       *
        *                    #     #  #   # #   #     # #                      *
        *                    #     #  #    ##   #    #   #                     *
        *                     #####   #     #  ###  #     #                    *
        *                                                                      *
        * UNIX                       UNIX SUPPORT                              *
        *                                                                      *
        ************************************************************************
        *
        * UNIX.INC
        *
        * AFTER CSNOBOL4 FUNCTIONS REFACTORED TO UNIX, ADD PEEK_STRING()
        * AND REFACTOR TEMPORARY FILE TO HERE AS WELL.
        * ADD SPRINTF() TO unix.so
        *
        -PUBLIC SIZEOF_INT(), SIZEOF_LONG(), SIZEOF_TIMEVAL(), SIZEOF_FD_SET()
        *
756              LOAD('SIZEOF_INT()INTEGER', 'unix.so')
757              LOAD('SIZEOF_LONG()INTEGER', 'unix.so')
758              LOAD('SIZEOF_TIMEVAL()INTEGER', 'unix.so')
759              LOAD('SIZEOF_FD_SET()INTEGER', 'unix.so')
        *
        -PUBLIC GET_ERRNO(), CLEAR_ERRNO()
        *
760              LOAD('GET_ERRNO()INTEGER', 'unix.so')
761              LOAD('CLEAR_ERRNO()INTEGER', 'unix.so')
        *
        -PUBLIC SET_TIMEVAL()
        *
762              LOAD('SET_TIMEVAL(INTEGER,INTEGER)', 'unix.so')
        *
        -PUBLIC FD_ISSET(), FD_ZERO(), FD_SET(), FD_CLR()
        *
763              LOAD('FD_ISSET_(INTEGER,INTEGER)INTEGER', 'unix.so')
764              LOAD('FD_ZERO_(INTEGER)', 'unix.so')
765              LOAD('FD_CLR_(INTEGER,INTEGER)', 'unix.so')
766              LOAD('FD_SET_(INTEGER,INTEGER)', 'unix.so')
        *
        -PUBLIC FORK(), WAIT(), WAITPID(), GET_STATUS(), PERROR()
        *
767              LOAD('WAITPID(INTEGER,INTEGER)', 'unix.so')
768              LOAD('GET_STATUS()INTEGER', 'unix.so')
        *
769              FFI_PERROR = FFI_NEW('V', 'P')
770              FFI_SET_CALLP(FFI_PERROR, DLSYM(0, 'perror'))
771              FFI_MALLOC = FFI_NEW('P', 'I')
772              FFI_SET_CALLP(FFI_MALLOC, DLSYM(0, 'malloc'))
773              FFI_FREE = FFI_NEW('V', 'I')
774              FFI_SET_CALLP(FFI_FREE, DLSYM(0, 'free'))
775              FFI_STRDUP = FFI_NEW('P', 'P')
776              FFI_SET_CALLP(FFI_STRDUP, DLSYM(0, 'strdup'))
777              FFI_STRLEN = FFI_NEW('I', 'P')
778              FFI_SET_CALLP(FFI_STRLEN, DLSYM(0, 'strlen'))
        *
779              FFI_PIPE = FFI_NEW('I', 'P')
780              FFI_SET_CALLP(FFI_PIPE, DLSYM(0, 'pipe'))
781              FFI_FORK = FFI_NEW('I', '')
782              FFI_SET_CALLP(FFI_FORK, DLSYM(0, 'fork'))
783              FFI_WAIT = FFI_NEW('I', '')
784              FFI_SET_CALLP(FFI_WAIT, DLSYM(0, 'wait'))
785              FFI_FILENO = FFI_NEW('I', 'P')
786              FFI_SET_CALLP(FFI_FILENO, DLSYM(0, 'fileno'))
787              FFI_CLOSE = FFI_NEW('I', 'I')
788              FFI_SET_CALLP(FFI_CLOSE, DLSYM(0, 'close'))
789              FFI_SELECT = FFI_NEW('I', 'I,P,P,P,P')
790              FFI_SET_CALLP(FFI_SELECT, DLSYM(0, 'select'))
791              FFI_READ = FFI_NEW('I', 'I,P,I')
792              FFI_SET_CALLP(FFI_READ, DLSYM(0, 'read'))
793              FFI_WRITE = FFI_NEW('I', 'I,P,I')
794              FFI_SET_CALLP(FFI_WRITE, DLSYM(0, 'write'))
795              FFI_GETPID = FFI_NEW('I', '')
796              FFI_SET_CALLP(FFI_GETPID, DLSYM(0, 'getpid'))
797              FFI_GETPPID = FFI_NEW('I', '')
798              FFI_SET_CALLP(FFI_GETPPID, DLSYM(0, 'getppid'))
799              FFI_KILL = FFI_NEW('I', 'I,I')
800              FFI_SET_CALLP(FFI_KILL, DLSYM(0, 'kill'))
801              FFI_RAISE = FFI_NEW('I', 'I')
802              FFI_SET_CALLP(FFI_RAISE, DLSYM(0, 'raise'))
803              FFI_OPEN = FFI_NEW('I', 'P,I')
804              FFI_SET_CALLP(FFI_OPEN, DLSYM(0, 'open'))
805              FFI_CREAT = FFI_NEW('I', 'P,I')
806              FFI_SET_CALLP(FFI_CREAT, DLSYM(0, 'creat'))
807              FFI_DUP = FFI_NEW('I', 'I')
808              FFI_SET_CALLP(FFI_DUP, DLSYM(0, 'dup'))
        *
        -PUBLIC O_RDONLY, O_WRONLY, O_RDWR
        *
809              O_RDONLY = 0
810              O_WRONLY = 1
811              O_RDWR   = 2
        *
        * SIGNAL DEFINITIONS
        *
        -PUBLIC SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS
        *
812              SIGHUP    = 1
813              SIGINT    = 2
814              SIGQUIT   = 3
815              SIGILL    = 4
816              SIGTRAP   = 5
817              SIGABRT   = 6
818              SIGBUS    = 7
        *
        -PUBLIC SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGALRM, SIGTERM
        *
819              SIGFPE    = 8
820              SIGKILL   = 9
821              SIGUSR1   = 10
822              SIGSEGV   = 11
823              SIGUSR2   = 12
824              SIGPIPE   = 13
825              SIGALRM   = 14
826              SIGTERM   = 15
        *
        -PUBLIC SIGSTKFLT, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
        *
827              SIGSTKFLT = 16
828              SIGCHLD   = 17
829              SIGCONT   = 18
830              SIGSTOP   = 19
831              SIGTSTP   = 20
832              SIGTTIN   = 21
833              SIGTTOU   = 22
        *
        -PUBLIC SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH
        *
834              SIGURG    = 23
835              SIGXCPU   = 24
836              SIGXFSZ   = 25
837              SIGVTALRM = 26
838              SIGPROF   = 27
839              SIGWINCH  = 28
        *
        -PUBLIC SIGIO, SIGPWR, SIGSYS
        *
840              SIGIO     = 29
841              SIGPWR    = 30
842              SIGSYS    = 31
        *
        -PUBLIC FILENO(), READ(), WRITE(), GETPID(), GETPPID(), KILL(), RAISE()
        -PUBLIC OPEN(), CREAT(), DUP()
        *
843              DEFINE('KILL(PID,SIG)')
844              DEFINE('RAISE(SIG)')
845              DEFINE('GETPID()')
846              DEFINE('GETPPID()')
847              DEFINE('READ(FD,BUF,NBYTES)')
848              DEFINE('CLOSE(FD)')
849              DEFINE('OPEN(FN,F)')
850              DEFINE('CREAT(FN,M)')
851              DEFINE('DUP(FD)')
852              DEFINE('SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)')
853              DEFINE('FILENO(FP)')
854              DEFINE('FORK()')
855              DEFINE('WAIT()')
856              DEFINE('FD_ZERO(FDS)')
857              DEFINE('FD_ISSET(FD,FDS)')
858              DEFINE('FD_CLR(FD,FDS)')
859              DEFINE('FD_SET(FD,FDS)')
860              DEFINE('NEW_FD_SET()')
861              DEFINE('NEW_TIMEVAL()')
        *
        -PUBLIC PIPE(), MALLOC(), FREE(), STRDUP(), STRLEN(), CLOSE()
        -PUBLIC SELECT()
        *
862              DEFINE('PIPE()R,P')
863              DEFINE('PERROR(S)')
864              DEFINE('MALLOC(N)')
865              DEFINE('FREE(P)')
866              DEFINE('STRDUP(S)')
867              DEFINE('STRLEN(S)')                                 :(UNIX_END)
        *
868     PERROR   FFI_PAR_N_STRING(FFI_PERROR, 1, S)
869              FFI_CALL_VOID(FFI_PERROR)                             :(RETURN)
        *
870     KILL     FFI_PAR_N_INTEGER(FFI_KILL, 1, PID)
871              FFI_PAR_N_INTEGER(FFI_KILL, 2, SIG)
872              KILL = FFI_CALL_INTEGER(FFI_KILL)                     :(RETURN)
        *
873     RAISE    FFI_PAR_N_INTEGER(FFI_RAISE, 1, SIG)
874              RAISE = FFI_CALL_INTEGER(FFI_RAISE)                   :(RETURN)
        *
875     GETPID   GETPID = FFI_CALL_INTEGER(FFI_GETPID)                 :(RETURN)
        *
876     GETPPID  GETPPID = FFI_CALL_INTEGER(FFI_GETPPID)               :(RETURN)
        *
877     WRITE    FFI_PAR_N_INTEGER(FFI_WRITE, 1, FD)
878              FFI_PAR_N_PTR(FFI_WRITE, 2, BUF)
879              FFI_PAR_N_PTR(FFI_WRITE, 3, NBYTES)
880              WRITE = FFI_CALL_INTEGER(FFI_WRITE)                   :(RETURN)
        *
881     READ     FFI_PAR_N_INTEGER(FFI_READ, 1, FD)
882              FFI_PAR_N_PTR(FFI_READ, 2, BUF)
883              FFI_PAR_N_PTR(FFI_READ, 3, NBYTES)
884              READ = FFI_CALL_INTEGER(FFI_READ)                     :(RETURN)
        *
885     OPEN     FFI_PAR_N_STRING(FFI_OPEN, 1, FN)
886              FFI_PAR_N_INTEGER(FFI_OPEN, 2, F)
887              OPEN = FFI_CALL_INTEGER(FFI_OPEN)                     :(RETURN)
        *
888     CREAT    FFI_PAR_N_STRING(FFI_CREAT, 1, FN)
889              FFI_PAR_N_INTEGER(FFI_CREAT, 2, M)
890              CREAT = FFI_CALL_INTEGER(FFI_CREAT)                   :(RETURN)
        *
891     DUP      FFI_PAR_N_INTEGER(FFI_DUP, 1, FD)
892              DUP = FFI_CALL_INTEGER(FFI_DUP)                       :(RETURN)
        *
893     CLOSE    FFI_PAR_N_INTEGER(FFI_CLOSE, 1, FD)
894              CLOSE = FFI_CALL_INTEGER(FFI_CLOSE)                   :(RETURN)
        *
895     SELECT   FFI_PAR_N_INTEGER(FFI_SELECT, 1, NFDS)
896              FFI_PAR_N_PTR(FFI_SELECT, 2, READFDS)
897              FFI_PAR_N_PTR(FFI_SELECT, 3, WRITEFDS)
898              FFI_PAR_N_PTR(FFI_SELECT, 4, EXCEPTFDS)
899              FFI_PAR_N_PTR(FFI_SELECT, 5, TIMEOUT)
900              SELECT = FFI_CALL_INTEGER(FFI_SELECT)                 :(RETURN)
        *
901     FILENO   FFI_PAR_N_PTR(FFI_FILENO, 1, FP)
902              FILENO = FFI_CALL_INTEGER(FFI_FILENO)                 :(RETURN)
        *
903     FORK     FORK = FFI_CALL_INTEGER(FFI_FORK)                     :(RETURN)
        *
904     WAIT     WAIT = FFI_CALL_INTEGER(FFI_WAIT)                     :(RETURN)
        *
905     FD_ZERO  FD_ZERO_(FDS)                                         :(RETURN)
        *
906     FD_ISSET FD_ISSET = FD_ISSET_(FD, FDS)                         :(RETURN)
        *
907     FD_CLR   FD_CLR_(FD, FDS)                                      :(RETURN)
        *
908     FD_SET   FD_SET_(FD, FDS)                                      :(RETURN)
        *
909     NEW_FD_SET
910              NEW_FD_SET = MALLOC(SIZEOF_FD_SET())                  :(RETURN)
        *
911     NEW_TIMEVAL
912              NEW_TIMEVAL = MALLOC(SIZEOF_TIMEVAL())                :(RETURN)
        *
913     MALLOC   FFI_PAR_N_INTEGER(FFI_MALLOC, 1, N)
914              MALLOC = FFI_CALL_PTR(FFI_MALLOC)                     :(RETURN)
        *
915     FREE     FFI_PAR_N_PTR(FFI_FREE, 1, P)
916              FFI_CALL_VOID(FFI_FREE)                               :(RETURN)
        *
917     STRDUP   FFI_PAR_N_STRING(FFI_STRDUP, 1, S)
918              STRDUP = FFI_CALL_PTR(FFI_STRDUP)                     :(RETURN)
        *
919     STRLEN   FFI_PAR_N_PTR(FFI_STRLEN, 1, S)
920              STRLEN = FFI_CALL_INTEGER(FFI_STRLEN)                 :(RETURN)
        *
921     PIPE     P = MALLOC(2 * SIZEOF_INT())
922              FFI_PAR_N_PTR(FFI_PIPE, 1, P)
923              R = FFI_CALL_INTEGER(FFI_PIPE)
924              NE(R) FREE(P)                                       :S(FRETURN)
925              PIPE = ARRAY(2)
926              PIPE<1> = PEEK_I(P)
927              PIPE<2> = PEEK_I(P + SIZEOF_INT())
928              FREE(P)                                               :(RETURN)
        *
929     UNIX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'P64.INC'
        -INCLUDE 'LOGIC.INC'
        -MODULE LOGIC
        -LINE 8 "LOGIC.lss"
        -IN72
        -LINE 85 "LOGIC.lss"
        -STITL LOGIC
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             #        #######   #####   ###   #####                   *
        *             #        #     #  #     #   #   #     #                  *
        *             #        #     #  #         #   #                        *
        *             #        #     #  #  ####   #   #                        *
        *             #        #     #  #     #   #   #                        *
        *             #        #     #  #     #   #   #     #                  *
        *             #######  #######   #####   ###   #####                   *
        *                                                                      *
        * LOGIC       CATSPAW SPITBOL COMPATIBLE LOGIC() FUNCTIONS             *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * JANUARY 21, 2002                                                     *
        *                                                                      *
        ************************************************************************
        *
        * LOGIC.lss
        *
        -LINE 11 "LOGIC.lss"
        *
        * NOTE! BASE ARGUMENT MUST BE PASSED A EXPLICIT NULL STRING FOR DEFAULT
        *
        * INTEGER/INTEGER, STRING/INTEGER, STRING/STRING
        *
        -PUBLIC LOGIC()
        *
930              LOAD('LOGIC(INTEGER,,)')
        *
        -PUBLIC NOT(), AND(), OR(), XOR(), NAND(), NOR(), UPLUS(), UMINUS()
        -PUBLIC  UMUL(), UDIV(), SHL(), SHR(), SAR(), ROL(), ROR()
        -PUBLIC HI(), IH(), DIB(), IDB()
        *
931              DEFINE('NOT(ARG)')
932              DEFINE('AND(ARG1,ARG2)')
933              DEFINE('OR(ARG1,ARG2)')
934              DEFINE('XOR(ARG1,ARG2)')
935              DEFINE('NAND(ARG1,ARG2)')
936              DEFINE('NOR(ARG1,ARG2)')
937              DEFINE('UPLUS(ARG1,ARG2)')
938              DEFINE('UMINUS(ARG1,ARG2)')
939              DEFINE('UMUL(ARG1,ARG2)')
940              DEFINE('UDIV(ARG1,ARG2)')
941              DEFINE('SHL(ARG1,ARG2)')
942              DEFINE('SHR(ARG1,ARG2)')
943              DEFINE('SAR(ARG1,ARG2)')
944              DEFINE('ROL(ARG1,ARG2)')
945              DEFINE('ROR(ARG1,ARG2)')
946              DEFINE('HI(ARG)')
947              DEFINE('IH(ARG)')
948              DEFINE('DIB(ARG,BASE)')
949              DEFINE('IDB(ARG,BASE)')                            :(LOGIC_END)
        *
950     NOT      NOT    = LOGIC( 1, ARG)                    :S(RETURN)F(FRETURN)
951     AND      AND    = LOGIC( 2, ARG1, ARG2)             :S(RETURN)F(FRETURN)
952     OR       OR     = LOGIC( 3, ARG1, ARG2)             :S(RETURN)F(FRETURN)
953     XOR      XOR    = LOGIC( 4, ARG1, ARG2)             :S(RETURN)F(FRETURN)
954     NAND     NAND   = LOGIC( 5, ARG1, ARG2)             :S(RETURN)F(FRETURN)
955     NOR      NOR    = LOGIC( 6, ARG1, ARG2)             :S(RETURN)F(FRETURN)
956     UPLUS    UPLUS  = LOGIC( 7, ARG1, ARG2)             :S(RETURN)F(FRETURN)
957     UMINUS   UMINUS = LOGIC( 8, ARG1, ARG2)             :S(RETURN)F(FRETURN)
958     UMUL     UMUL   = LOGIC( 9, ARG1, ARG2)             :S(RETURN)F(FRETURN)
959     UDIV     UDIV   = LOGIC(10, ARG1, ARG2)             :S(RETURN)F(FRETURN)
960     SHL      SHL    = LOGIC(11, ARG1, ARG2)             :S(RETURN)F(FRETURN)
961     SHR      SHR    = LOGIC(12, ARG1, ARG2)             :S(RETURN)F(FRETURN)
962     SAR      SAR    = LOGIC(13, ARG1, ARG2)             :S(RETURN)F(FRETURN)
963     ROL      ROL    = LOGIC(14, ARG1, ARG2)             :S(RETURN)F(FRETURN)
964     ROR      ROR    = LOGIC(15, ARG1, ARG2)             :S(RETURN)F(FRETURN)
965     HI       HI     = LOGIC(16, CONVERT(ARG, 'STRING'), '')
965     +                                                   :S(RETURN)F(FRETURN)
966     IH       IH     = LOGIC(17, CONVERT(ARG, 'INTEGER'), '')
966     +                                                   :S(RETURN)F(FRETURN)
967     DIB      DIB    = LOGIC(16, CONVERT(ARG, 'STRING'), BASE)
967     +                                                   :S(RETURN)F(FRETURN)
968     IDB      IDB    = LOGIC(17, CONVERT(ARG, 'INTEGER'), BASE)
968     +                                                   :S(RETURN)F(FRETURN)
        *
969     LOGIC_END
970              CODE('LOGIC')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COPYT.INC'
        -MODULE COPYT
        -LINE 8 "COPYT.lss"
        -IN72
        -LINE 34 "COPYT.lss"
        -STITL COPYT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #####   #######  ######   #     #  #######              *
        *             #     #  #     #  #     #   #   #      #                 *
        *             #        #     #  #     #    # #       #                 *
        *             #        #     #  ######      #        #                 *
        *             #        #     #  #           #        #                 *
        *             #     #  #     #  #           #        #                 *
        *              #####   #######  #           #        #                 *
        *                                                                      *
        * COPYT                      COPY A TABLE                              *
        *                                                                      *
        ************************************************************************
        *
        * COPYT.lss
        *
        -LINE 11 "COPYT.lss"
        -PUBLIC COPYT()
        *
971              DEFINE('COPYT(T)')                                 :(COPYT_END)
        *
972     COPYT    COPYT = TABLE()
973              COPYT = CONVERT(CONVERT(T, 'ARRAY'), 'TABLE')         :(RETURN)
        *
974     COPYT_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -STITL TRIMB
        -EJECT
        *
        -LINE 38 "TRIMB.lss"
        ************************************************************************
        *                                                                      *
        *               #######  ######   ###  #     #  ######                 *
        *                  #     #     #   #   ##   ##  #     #                *
        *                  #     #     #   #   # # # #  #     #                *
        *                  #     ######    #   #  #  #  ######                 *
        *                  #     #   #     #   #     #  #     #                *
        *                  #     #    #    #   #     #  #     #                *
        *                  #     #     #  ###  #     #  ######                 *
        *                                                                      *
        * TRIMB            TRIM BOTH LEFT AND RIGHT OF STRING                  *
        *                                                                      *
        ************************************************************************
        *
        * TRIMB.lss
        *
        -LINE 12 "TRIMB.lss"
        -MODULE TRIMB
        -PUBLIC TRIMB()
975              DEFINE('LTRIM(S)')
976              DEFINE('TRIMB(S)')                                 :(TRIMB_END)
        *
977     LTRIM    LTRIM = REVERSE(TRIM(REVERSE(S)))                     :(RETURN)
978     TRIMB    TRIMB = LTRIM(TRIM(S))                                :(RETURN)
        *
979     TRIMB_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FFI.INC'
        -IN72
        -STITL ASM
        -CASE 1
        -PLUSOPS 1
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #      #####   #     #                       *
        *                        # #    #     #  ##   ##                       *
        *                       #   #   #        # # # #                       *
        *                      #     #   #####   #  #  #                       *
        *                      #######        #  #     #                       *
        *                      #     #  #     #  #     #                       *
        *                      #     #   #####   #     #                       *
        *                                                                      *
        * ASM                  ASSEMBLER/LOADER FOR JIT                        *
        *                                                                      *
        ************************************************************************
        *
        * ASM.INC
        *
        * A SIMPLE ASSEMBLER/LOADER FOR JIT CODE. THIS IS A BIT BRITTLE.
        *
        * THE BASIC IDEA IS THAT EACH ASSEMBLER LINE IS EXAMINED, AND LABEL,
        * OPCODE AND UP TO THREE PARAMETERS EXTRACTED. THE OPCODE MAY MATCH
        * A FUNCTION IN THE ASSEMBLER (WITH '__' APPENDED), OR, WITH JIT_
        * PREPENDED, A JIT GENERATION INSTRUCTION. THE FUNCTION IS THEN CALLED
        * WITH UP TO THREE PARAMETERS. EACH PARAMETER IS A STRING, A NUMBER, A
        * SYMBOL REFERENCE OR A REGISTER. EACH LABEL ON A JIT_ OPCODE IS ENTERED
        * INTO A LOCAL SYMBOL TABLE.
        *
        * ASM() WORKS IN TWO PHASES - THE FIRST PHASE CREATES SYMBOLS IN
        * THE SYMBOLS1 TABLE. AFTER PHASE1, WE PREPARE THE DSS AND BSS AREAS
        * (THIS COULD BE CONSIDERED PHASE1A - BUT WE ONLY COUNT SOURCE SCANS
        * AS PHASES). THE SECOND PHASE ACTUALLY GENERATES CODE, USING THE
        * SYMBOLS CREATED IN PHASE1. ON COMPLETIION OF PHASE2, WE RESOLVE
        * INTERNAL LOCAL SYMBOLS (BRANCHES IN THE CODE -- THIS IS PHASE 2A).
        * NOTE THAT 'EXTERN' SYMBOLS ARE PUT INTO THE EXPORTS TABLE. THESE
        * CAN BE DSS, BSS OR ADDRESS SYMBOLS. THIS TABLE CAN BE MERGED WITH
        * OTHER EXPORT TABLES (USING MERGET), AND PASSED TO ASM_CREATE TO
        * ESTABLISH THE IMPORTS NEEDED. EXPORTS(ASM) ACCESSES THIS TABLE
        * FOR A MODULE.
        *
        * A = ASM_CREATE()
        * S = ASM(A, SRC) :F(ERROR)
        * ASM_DESTROY(A)
        *
        * THIS IS A PART OF A "MACHINE CODE LOADER", AND ENTRY AND USAGE ISSUES
        * ARE MEANT TO BE COVERED ELSEWHERE. THIS MODULE HANDLES INTEPRETING THE
        * FORMAT, AND RESOLVING (MOST) SYMBOLS, PREPARING THE OBJECT FOR
        * EVENTUAL EXECUTION.
        *
        * THE ASM_TYPE() OBJECT IS CREATED AND IS SOMEWHAT INDEPENDENT OF THE
        * ASM SOURCE AND ASM() CALL. THIS ALLOWS THE ACTUAL ASM RESULTS TO BE
        * USED INDEPENDENTLY WITH (MOST) USING CODE BEING UNAWARE OF THE
        * IMPLEMENTATION USING JIT. AS FAR AS THE USING CODE IS CONCERNED,
        * ASM MAY HAVE BEEN IMPLEMENTED USING AN INTERPRETER.
        *
        * FOR FINAL USE OF THE ASM JIT CODE, JIT(A) WILL RETRIEVE THE JIT STATE,
        * WHICH CAN BE USED WITH JIT FUNCTIONS FOR DEBUG, AND TO EMIT CODE WHICH
        * CAN BE PASSED TO OTHER FUNCTIONS LIKE FFI TO PREPARE FOR FINAL
        * EXECUTION.
        *
        * CE: .MSNOBOL4;
        *
        -PUBLIC JIT(), EXPORTS(), OBJ(), ASM_CREATE(), ASM_DESTROY(), ASM()
        -PUBLIC DSSBASE(), BSSBASE()
        *
980              DATA('ASM_TYPE(JIT,SYMBOLS1,SYMBOLS,REFERENCES,DSS,BSS,SZBSS,'
980     +                      'DINIT,DSSBASE,BSSBASE,ENTRIES,SRC,OBJ,DAREFS,'
980     +                      'DPREFS,EXPORTS)')
        *
981              DEFINE('ASM_CREATE(SYMBOLS1)')
982              DEFINE('ASM_DESTROY(ASM)')
983              DEFINE('ASM(ASM,SRC)')
        *
984              DEFINE('ASM_EMIT()')
985              DEFINE('ASM_BSS()A,I')
986              DEFINE('ASM_DA()A,I,P')
987              DEFINE('ASM_DSS()A,I,S')
988              DEFINE('ASM_LINK()SYMBOLS,A,I,P,R,S')
989              DEFINE('ASM_PHASE(ASM_PHASE)'
989     +               'SRC,LINE,ELINE,R,SYMBOL,LAB,OP,P1,P2,P3,S,OP1')
        *
990              ASET = &UCASE &LCASE &DIGITS '_.$'
991              AWHT = NSPAN(' ' CHARS_TAB)
992              ASM_PAT = FENCE NSPAN(ASET) . LAB
992     +                  AWHT NSPAN(ASET) . OP
992     +                  AWHT ((BREAKQ(',') . P1 ',') | NULL)
992     +                  AWHT ((BREAK(',') . P2 ',') | NULL)
992     +                  AWHT ((BREAK(',') . P3 ',') | NULL)
        *
993              DEFINE('ASM_PARM(X)OFFSET,S,SIGN')
994              DEFINE('ALIGN_BSS(A),N')
        *
995              DEFINE('PHASE1__(P1)')
996              DEFINE('PHASE2__(P2)')
997              DEFINE('EXTERN__(P1,P2,P3)H')
998              DEFINE('DEFINE__(P1,P2,P3)H')
999              DEFINE('USES__(P1)A')
1000             DEFINE('EQU__(P1)')
1001             DEFINE('ADDRESS__()')
1002             DEFINE('EXPORT__()')
        *
1003             DEFINE('COMMON__(P1)')
1004             DEFINE('RESB__(P1)')
1005             DEFINE('RESW__(P1)')
1006             DEFINE('RESD__(P1)')
1007             DEFINE('RESQ__(P1)')
1008             DEFINE('RES(P1,P2)')
        *
1009             DEFINE('DB__(P1)')
1010             DEFINE('DW__(P1)')
1011             DEFINE('DD__(P1)')
1012             DEFINE('DQ__(P1)')
1013             DEFINE('DA__(P1)')
1014             DEFINE('DP__(P1)')
1015             DEFINE('DS__(P1)')
        *
        * SET TO NON-NULL TO HAVE ASM GIVE DEBUG OUTPUT
        *
1016             ASM_DEBUG =
        *
        * FOR REGISTER LOOKUP - OPTIMIZATION
        *
1017             AS_REGS = TABLE()
        *
        * SIZES OF TYPES. THESE ARE DEFINE TO ALLOW THEM TO BE USED IN ASM
        * FILES. THEY AREN'T ACTUALLY USED IN THIS FILE.
        *
1018             BYTE = 1
1019             WORD = 2
1020             DWORD = 4
1021             QWORD = 8
1022             FLOAT = 4
1023             DOUBLE = 8
        *
        * STORAGE USED FOR DATA CONVERSIONS.
        *
1024             ASM_P = MALLOC(128)
        *
        * TABLE FOR OPEN SHARED OBJECTS.
        *
1025             DL_TABLE = TABLE()
1026             DL_TABLE<0> = 0
        *
        * NOT USED AS TABLES, THESE ARE SIMPLY UNIQUE NON-STRINGS USED TO
        * IDENTIFY EMPTY AND SYMBOL REFERENCE PARAMETERS.
        *
1027             ASM_PEMPTY = TABLE(1, 1)
1028             ASM_PSYMBOL = TABLE(1, 1)                            :(END_ASM)
        *
        * STANDARD EXTRA OPERATIONS FOR ASM CODE. OF COURSE, ANY APPLICATION
        * SPECIFICS CAN BE DEFINED IN THE USING CODE AND ARE FREELY AVAILABLE
        * THIS ALLOWS THE CODE GENERATOR TO BE EASILY TAILORED FOR SPECIFIC
        * NEEDS. FOR EXAMPLE, MACROS COULD BE DEFINED. ALL THREE OF THE
        * PARAMETERS CAN BE STRINGS OR NUMBERS. THE LABEL IS AVAILABLE AS LAB.
        *
        * BE WARNED THOUGH, THAT THIS IS NOT ONLY AN "ASSEMBLER" FORMAT, IT IS
        * ALSO MEANT TO BE USED AS THE RELOCATING LOADER. SO, KEEP AN EYE
        * ON PERFORMANCE!
        *
        * USES - DECLARES OBJECT CODE USES GIVEN LIST OF REGISTERS. IF A NEEDED
        * REGISTER IS NOT AVAIABLE, GIVES A MESSAGES, AND FAILS. IF ALL
        * REGISTERS ARE AVAILABLE, RETURNS SUCCESS.
        *
        * (FIXME - THERE ARE SOME MINOR DIFFERENCES BETWEEN 32 BIT AND 64 BIT
        * CODE GENERATION THAT SHOULD ALSO BE "HIDDEN").
        *
1029    USES__   NE(ASM_PHASE, 1)                                     :S(RETURN)
1030    USES2    P1 ANY('%') =                                         :S(USES2)
1031             P1 = CRACK(P1, ',')
1032             I = 1
1033    USES3    P1<I>                                                :F(RETURN)
1034             FUNCTION(P1<I> '_')                                   :F(USES4)
1035             EQ(APPLY(P1<I> '_',), -1)                             :S(USES4)
1036             I = I + 1                                              :(USES3)
1037    USES4    TERMINAL = 'REGISTER ' P1<I> ' NOT AVAILABLE'        :(FRETURN)
        *
        * ADDRESS - ADDS SYMBOL(ASM) ENTRY ON PHASE2 THAT CAN BE EVALUATED
        * TO AN ADDRESS WITH JIT_ADDRESS(). USEFUL FOR ENTRY POINTS AND
        * CONSTRUCTING JUMP TABLES. COULD USE NOTE(NULL, 0) HERE AS WELL.
        *
1038    ADDRESS__
1039             NE(ASM_PHASE, 2)                                     :S(RETURN)
1040             ENTRIES(ASM)<LAB> = SYMBOLS(ASM)<LAB> = JIT_INDIRECT()
1040    +                                                              :(RETURN)
        *
        * SYMBOL TO BE EXPORTED. BSS, DSS OR ADDRESS. JUST MAKE THE TABLE
        * ENTRY NON-NULL.
        *
1041    EXPORT__ SYMBOL = NE(ASM_PHASE, 1)                            :S(RETURN)
1042             EXPORTS(ASM)<OP1> = ' '
1043             EXPORTS(ASM)<OP1> = VDIFFER(SYMBOLS1(ASM)<OP1>)
1044             SYMBOL =                                              :(RETURN)
        *
        * PHASE1 EVALUATION ONLY. EVAL P1 DURING PHASE1.
        *
1045    PHASE1__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1046             PHASE1 = EVAL(P1)                          :S(RETURN)F(FRETURN)
        *
        * PHASE2 EVALUATION ONLY. EVAL P1 DURING PHASE2.
        *
1047    PHASE2__ NE(ASM_PHASE, 2)                                     :S(RETURN)
1048             PHASE2 = EVAL(P1)                          :S(RETURN)F(FRETURN)
        *
        * ENTER VALUE INTO SYMBOLS1 TABLE. THIS MAY BE INTEGER OR REAL.
        * ALSO NOTE THAT VALUE WILL BE ENTERED INTO THE EXPORTS TABLE IF NEEDED.
        *
        * NOTE THAT EXTERN ADDS TO EXPORTS ON THE DA RESOLUTION PASS, SO IT
        * ISN'T DONE HERE.
        *
1049    DEFINE__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1050             SYMBOLS1(ASM)<LAB> = INTEGER(P1) +P1               :S(DEFINE_2)
1051             SYMBOLS1(ASM)<LAB> = REAL(P1) +P1                   :F(FRETURN)
1052    DEFINE_2 EXPORTS(ASM)<LAB> = DIFFER(EXPORTS(ASM)<LAB>)
1052    +           SYMBOLS1(ASM)<LAB>                                 :(RETURN)
        *
        * ENTER EXTERNAL LINK INTO SYMBOLS1 TABLE. THERE ARE THREE FORMS FOR
        * THIS DIRECTIVE:
        *
        * LABEL EXTERN 'NAME' ; DEFINE LABEL AS DLSYM(, 'NAME')
        * LABEL EXTERN 'NAME','SO' ; 'NAME' IN 'SO'
        * LABEL EXTERN 'NAME','SO',FLAGS ; IN 'SO' OPEN WITH FLAGS
        *
        * P1 = ENTRY NAME, P2 = MODULE NAME, P3 = OPEN FLAGS
        *
1053    EXTERN__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1054             P2 = IDENT(P2) 0
1055             P3 = IDENT(P3) RTLD_NOW
1056             H = DL_TABLE<P2>
1057             DIFFER(H)                                           :S(EXTERN2)
1058             H = DIFFER(P2) DLOPEN(P2, P3)
1059             NE(+H, 0)                                           :S(EXTERN3)
1060             TERMINAL = 'DLOPEN FAILED: ' DLERROR()               :(FRETURN)
1061    EXTERN3  DL_TABLE<P2> = H
1062    EXTERN2  SYMBOLS1(ASM)<LAB> = DLSYM(H, P1)
        *
        * WE CAN AMORTIZE DLOPEN/DLSYM. INSTEAD OF EXTERN IN EACH MODULE,
        * THESE CAN BE EXPORT, AND THEN WE CAN IMPORT IN ANOTHER ASSEMBLY
        *
1063             EXPORTS(ASM)<LAB> = DIFFER(EXPORTS(ASM)<LAB>)
1063    +           SYMBOLS1(ASM)<LAB>                                 :(RETURN)
        *
        * ENTER VALUE AS GLOBAL VARIABLE IN PHASE1. CAN BE USED BY
        * '(EXPRESSION)' AS PARAMETER.
        *
1064    EQU__    NE(ASM_PHASE, 1)                                     :S(RETURN)
1065             $LAB = P1                                             :(RETURN)
        *
        * FOR DATA DEFINITION, WE USE POKE AND THEN PEEK BYTES BACK TO ADD
        * TO THE DINIT STRING. THIS IS DONE TO TAKE CARE OF ENDIAN ISSUES
        * WITH DATA VALUES. EG. POKE_S WILL DEPOSIT THE BYTES IN EITHER
        * BIG OR LITTLE ENDIAN, DEPENDING ON THE ARCHITURE. PEEK WITH THEN
        * RETRIEVE THE BYTES IN THE CORRECT ORDER FOR THAT MACHINE. WHEN THE
        * DSS BLOCK IS POPULATED, DINIT WILL BE READ SIMPLY AS A STREAM OF
        * BYTES, WHICH WILL BE TRANSFERRED INTO MEMORY LINEARLY.
        *
        * FROM NASM - DB/DW/DD/DQ
        * DS IS DEFINE STRING
        *
        * ENTER VALUES INTO DSS
        *
1066    DB__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1067             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
        *
        * A SINGLE BYTE IS NOT CHANGED BY ENDIAN CHARACTERISTICS. JUST APPEND
        * THE BYTE TO THE DINIT STRING.
        *
1068             DINIT(ASM) = INTEGER(P1) DINIT(ASM) CHAR(P1)          :(RETURN)
        *
1069    DW__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1070             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1071             POKE_S(ASM_P, P1)
1072             DINIT(ASM) = DINIT(ASM) PEEK_BUFFER(ASM_P, 2)         :(RETURN)
        *
1073    DD__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1074             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1075             (INTEGER(P1) POKE_I(ASM_P, P1), POKE_F(ASM_P, P1))
1076             DINIT(ASM) = DINIT(ASM) PEEK_BUFFER(ASM_P, 4)         :(RETURN)
        *
1077    DQ__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1078             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1079             (INTEGER(P1) POKE_P(ASM_P, P1), POKE_D(ASM_P, P1))
1080             DINIT(ASM) = DINIT(ASM) PEEK_BUFFER(ASM_P, 8)         :(RETURN)
        *
        * DP IS DEFINE POINTER - ADD TO DPREFS TABLE TO BE RESOLVED (FIXED)
        * FROM SYMBOLS1 ON COMPLETION.
        *
1081    DP__     SYMBOL = NE(ASM_PHASE, 1)                            :S(RETURN)
1082             SYMBOL =
1083             OP1 = TRIM(OP1)
1084             TERMINAL = DIFFER(ASM_DEBUG)
1084    +           'ADDING DP REF ' OP1 ' ' SIZE(DINIT(ASM))
1085             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1086             DPREFS(ASM)<OP1> = LINK(SIZE(DINIT(ASM)), DPREFS(ASM)<OP1>)
        *
        * ACTUAL DATA IS UNKNOWN -- ALL WE KNOW NOW IS THAT IT IS 8 BYTES IN
        * LENGTH
        *
1087             DINIT(ASM) = DINIT(ASM) DUPL(' ', 8)                  :(RETURN)
        *
        * DA IS DEFINE ADDRESS - ADD TO DAREFS TABLE TO BE RESOLVED FROM
        * ENTRIES ON COMPLETION.
        *
1088    DA__     SYMBOL = NE(ASM_PHASE, 1)                            :S(RETURN)
1089             TERMINAL = DIFFER(ASM_DEBUG) 'ADDING DA REF '
1089    +           SYMBOL ' DSS OFFSET ' SIZE(DINIT(ASM))
1090             DAREFS(ASM)<SYMBOL> =
1090    +           LINK(SIZE(DINIT(ASM)), DAREFS(ASM)<SYMBOL>)
1091             SYMBOL =
1092             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
        *
        * ACTUAL DATA IS UNKNOWN -- ALL WE KNOW NOW IS THAT IT IS 8 BYTES IN
        * LENGTH
        *
1093             DINIT(ASM) = DINIT(ASM) DUPL(' ', 8)                  :(RETURN)
        *
1094    DS__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1095             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1096             DINIT(ASM) = DINIT(ASM) P1                            :(RETURN)
        *
        * ALIGN BSS DATA ITEM TO ITS NATURAL SIZE. THIS IS NEEDED ON SOME
        * ARCHITECTURES, OR MAY GREATLY INCREASE PERFORMANCE ON OTHERS. WE
        * ONLY DO THIS FOR BSS ITEMS, AND NOT FOR DSS. FOR DSS, EITHER ORDER
        * THE DECLARATIONS, OR PAD MANUALLY.
        *
        * IF IT BECOMES IMPORTANT FOR DSS, WE CAN INTRODUCE AN ALIGN OP THAT
        * CAN DO IT (ALIGN 1,2,4,8). FIXME - AGAIN, DON'T OVER-IMPLEMENT UNTIL
        * IT IS ACTUALLY NEEDED.
        *
1097    ALIGN_BSS
1098             N = REMDR(SZBSS(ASM), A)
1099             EQ(N)                                                :S(RETURN)
1100             SZBSS(ASM) = SZBSS(ASM) + A - N                       :(RETURN)
        *
        * COMMON N - IF LAB IS NOT DEFINED, DEFINE IT IN BSS WITH LENGTH
        * N. MAKE IT EXPORT. IF SYMBOL DOES EXIST, IGNORE, WE ARE JUST LINKING
        * TO THE SAME THING AGAIN.
        *
        * WITHIN COMMON, VARIABLES HAVE OFFSETS FROM THE COMMON BASE. USE
        * DEFINE TO CREATE THESE. COMMON MAKES NO SENSE UNLESS IT IS EXPORTED.
        * (SINCE COMMON SHARES DATA BETWEEN MODULES). SO, AUTOMATICALLY
        * EXPORT THE COMMON DECLARATION. THE COMMON DECLARATION ONLY WORKS
        * IN BSS SPACE. HOWEVER, THE SYMBOL CAN BE RESOLVED TO DSS SPACE.
        *
        *        EXPORT COMMON
        * COMMON DS ''
        * ... OTHER COMMON DSS ITEMS ...
        *
        * WOULD SUFFICE TO DECLARE A COMMON AREA THAT IS INITIALIZED. NOTE
        * THAT, AS USUAL, DSS AND BSS ARE COMPLETELY SEPARATE AREAS, SO ONCE
        * A COMMON IS ESTABLISHED IN DSS SPACE, IT MUST BE *COMPLETELY*
        * INITIALIZED.
        *
1101    COMMON__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1102             IDENT(LAB)                                           :S(RETURN)
1103             DIFFER(SYMBOLS1(ASM)<LAB>)                           :S(RETURN)
1104             ALIGN_BSS(16)
1105             BSS(ASM)<LAB> =
1106             BSS(ASM)<LAB> = SZBSS(ASM)
1107             SZBSS(ASM) = SZBSS(ASM) + P1
1108             SYMBOL = LAB                                        :(EXPORT__)
        *
        * FROM NASM: RESB/RESW/RESD/RESQ (ADDITIONALLY, RES) TO RESERVE SPACE
        * IN BSS.
        *
1109    RESB__   RES(P1, 1)                                            :(RETURN)
1110    RESW__   RES(P1, 2)                                            :(RETURN)
1111    RESD__   RES(P1, 4)                                            :(RETURN)
1112    RESQ__   RES(P1, 8)                                            :(RETURN)
1113    RES      NE(ASM_PHASE, 1)                                     :S(RETURN)
1114             P1 = IDENT(P1) 1
1115             P2 = IDENT(P2) 1
1116             ALIGN_BSS(P2)
1117             BSS(ASM)<LAB> = DIFFER(LAB) SZBSS(ASM)
1118             SZBSS(ASM) = SZBSS(ASM) + (P1 * P2)                   :(RETURN)
        *
        * PARSE PARAMETER. THE PARAMETER MAY BE %REGISTER (EG. %R0, %V1, %F2)
        * %R0-2, %V0-2 AND %F0-5 ARE ALWAYS AVAILABLE. %R3, %V3, %F6-7 MAY
        * BE AVAILABLE. %FP IS THE FRAME POINTER (IF ONE AVAILABLE).
        *
        * 'STRING' OR "STRING". 1234, -1234, +1234 (INTEGER), OR REAL.
        *
        * SYMBOL (A SYMBOL OR LABEL NAME). IF THIS CAN BE RESOLVED FROM
        * THE SYMBOLS1 TABLE IT WILL BE RETURNED AS A SIMPLE NUMBER. HOWEVER,
        * THIS MAY BE A LOCAL LABEL THAT REQUIRES PATCHING.
        *
        * (EXPRESSION). THE EXPRESSION IS RUN THROUGH EVAL(). IT MAY REFERENCE
        * EQU GENERATED SYMBOLS, OR ANY VARIABLES IN THE SNOBOL4 ENVIRONMENT.
        *
1119    ASM_PARM ASM_PARM = ASM_PEMPTY
1120             IDENT(X)                                             :S(RETURN)
1121             X FENCE '%' REM . X                                   :S(ASREG)
1122             X FENCE ('0x' | '0X')  REM . X                        :S(ASHEX)
1123             X FENCE ANY('"' "'" '(')                              :S(ASTRG)
1124             &ERRLIMIT = 1
        *
        * SIMPLE INTEGER OR REAL VALUE
        *
1125             ASM_PARM = +X                                        :S(RETURN)
        *
        * VALUE FROM SYMBOLS1
        *
1126             ASM_PARM = VDIFFER(SYMBOLS1(ASM)<X>)                 :S(RETURN)
        *
        * SYMBOLS1 SYMBOL + OR - OFFSET
        *
1127             X BREAK('+-') . X (ANY('+-') REM) . OFFSET            :F(ASSYM)
1128             X = TRIM(X)
1129             OFFSET FENCE ANY('+-') . SIGN REM . S
1130             S = TRIMB(S)
1131             T = ASM_PARM(S)
1132             S = INTEGER(T) EVAL(SIGN T)                         :F(FRETURN)
1133             ASM_PARM = SYMBOLS1(ASM)<X> + T                       :(RETURN)
        *
        * NOT IN SYMBOLS1, THIS SYMBOL REQUIRES PATCHING DURING THE LINK
        * PROCESS
        *
1134    ASSYM    ASM_PARM = ASM_PSYMBOL
1135             SYMBOL = X                                            :(RETURN)
        *
        * PARAMETER IS A STRING DELIMITED BY SINGLE OR DOUBLE QUOTES. MAY
        * ALSO BE '(EXPRESSION)' WHICH WILL ALSO BE EVAL'D AND GIVES A
        * WAY TO GET SNOBOL ENVIRONMENT EASILY INTO THE ASSEMBLY.
        *
1136    ASTRG    ASM_PARM = EVAL(X)                         :S(RETURN)F(FRETURN)
        *
        * PARAMETER IS A REGISTER. SEE IF ITS CACHED. IF NOT, EVALUATE THE
        * JIT PROCEDURE TO DETERMINE THE REGISTER NUMBER. MAY YIELD -1, WHICH
        * WOULD MEANS THE REGISTER DOESN'T EXIST. 'USES' MUST BE USED TO
        * ELIMINATE THAT CASE. NOTE THAT THE CACHEING IS DONE ONLY TO PREVENT
        * CALLING THE REGISTER FUNCTION IN THE JIT LAYER.
        *
1137    ASREG    ASM_PARM = VDIFFER(AS_REGS<X>)                       :S(RETURN)
1138             FUNCTION(X '_')                                     :F(FRETURN)
1139             AS_REGS<X> = ASM_PARM = APPLY(X '_',)                :S(RETURN)
        *
        * 0XHEX. 0xHEX.
        *
1140    ASHEX    ASM_PARM = +HI(X)                                     :(RETURN)
        *
        * THE DRIVER ASM() FUNCTION. PHASE1 EXTRACTS D?, RES?, EXTERN,
        * EXPORT, DEFINE, AND OTHER NEEDED PHASE1 INFORMATION. THEN, THE
        * BSS AND DSS SECTIONS ARE CREATED. PHASE2 THEN GENERATES THE CODE.
        * LINK RESOLVES INTERNAL BRANCH TARGETS. EMIT ACTUALLY GENERATES THE
        * MACHINE CODE. DA THEN FIXES UP DA (ADDRESS TO CODE OBJECTS), AND
        * FINAL CODE EXPORTS.
        *
1141    ASM      SRC(ASM) = SRC
1142             JIT_SET_STATE(JIT(ASM))
1143             ASM_PHASE(1)                                        :F(FRETURN)
1144             ASM_BSS()                                           :F(FRETURN)
1145             ASM_DSS()                                           :F(FRETURN)
1146             ASM_PHASE(2)                                        :F(FRETURN)
1147             ASM_LINK()                                          :F(FRETURN)
1148             ASM_EMIT()                                          :F(FRETURN)
1149             ASM_DA()                                            :F(FRETURN)
        *
        * CLEAN UP ASM_TYPE STRUCTURE. KEEP JIT, OBJ, EXPORTS, DSSBASE, BSSBASE
        *
1150             SYMBOLS1(ASM) =
1151             SYMBOLS(ASM) =
1152             REFERENCES(ASM) =
1153             DSS(ASM) =
1154             BSS(ASM) =
1155             SZBSS(ASM) =
1156             DINIT(ASM) =
1157             ENTRIES(ASM) =
1158             SRC(ASM) =
1159             DAREFS(ASM) =
1160             DPREFS(ASM) =                                         :(RETURN)
        *
        * ENTRIES ADJUST. FIXUP DA REFERENCES (JUMP TABLES, CODE REFERENCES
        * IN DSS)
        *
1161    ASM_DA   TERMINAL = DIFFER(ASM_DEBUG) '*** DA ***'
1162             A = KEYST(ENTRIES(ASM))
1163             I = 1
1164    ASM_L_13 ENTRIES(ASM)<A<I>> = JIT_ADDRESS(ENTRIES(ASM)<A<I>>)
1164    +                                                             :F(RETURN)
1165             EXPORTS(ASM)<A<I>> = DIFFER(EXPORTS(ASM)<A<I>>)
1165    +           ENTRIES(ASM)<A<I>>
1166             P = DAREFS(ASM)<A<I>>
1167    ASM_L_16 IDENT(P)                                           :S(ASM_L_15)
1168             TERMINAL = DIFFER(ASM_DEBUG)
1168    +           'DA ' VALUE(P) ' TO ' ENTRIES(ASM)<A<I>>
1169             POKE_P(DSSBASE(ASM) + VALUE(P), ENTRIES(ASM)<A<I>>)
1170             P = NEXT(P)                                         :(ASM_L_16)
1171    ASM_L_15 I = I + 1                                           :(ASM_L_13)
        *
        * ASM_EMIT: PRODUCE OBJECT CODE
        *
1172    ASM_EMIT TERMINAL = DIFFER(ASM_DEBUG) '*** EMIT ***'
1173             OBJ(ASM) = JIT_EMIT()                                 :(RETURN)
        *
        * ASM_DSS: ALLOCATE AND INITIALIZE DSS SECTION
        *
1174    ASM_DSS  TERMINAL = DIFFER(ASM_DEBUG) '*** DSS ALLOCATE ***'
1175             DSSBASE(ASM) = MALLOC(SIZE(VDIFFER(DINIT(ASM))))
        *
        * COPY DINIT(ASM) TO MEMORY DSSBASE(ASM)
        *
1176             POKE_BUFFER(DSSBASE(ASM), DINIT(ASM))
        *
1177    ASM_L_12 A = KEYST(DSS(ASM))                                 :F(ASM_DS1)
1178             I = 1
1179    ASM_L_9  SYMBOLS1(ASM)<A<I>> = DSS(ASM)<A<I>> + DSSBASE(ASM)
1179    +                                                            :F(ASM_DS1)
1180             EXPORTS(ASM)<A<I>> = DIFFER(EXPORTS(ASM)<A<I>>)
1180    +           SYMBOLS1(ASM)<A<I>>
        *
1181             TERMINAL = DIFFER(ASM_DEBUG)
1181    +           'PHASE 1 DSS SYMBOL ' A<I> ' = ' IH(SYMBOLS1(ASM)<A<I>>)
        *
1182             I = I + 1                                            :(ASM_L_9)
        *
        * PATCH DSS SECTION POINTERS TO OTHER DSS (OR BSS) VARIABLES.
1183    ASM_DS1  A = KEYST(DPREFS(ASM))                               :F(RETURN)
1184             I = 1
1185    ASM_DS4  P = DPREFS(ASM)<A<I>>                                :F(RETURN)
1186    ASM_DS2  IDENT(P)                                            :S(ASM_DS3)
1187             POKE_P(DSSBASE(ASM) + VALUE(P), SYMBOLS1(ASM)<A<I>>)
1188             P = NEXT(P)                                          :(ASM_DS2)
1189    ASM_DS3  I = I + 1                                            :(ASM_DS4)
        *
        *
        * ALLOCATE BSS SECTION
        *
1190    ASM_BSS  TERMINAL = DIFFER(ASM_DEBUG) '*** BSS ALLOCATE ***'
1191             BSSBASE(ASM) = NE(SZBSS(ASM)) MALLOC(SZBSS(ASM))
1192             A = KEYST(BSS(ASM))
1193             I = 1
1194    ASM_L_7  SYMBOLS1(ASM)<A<I>> = BSS(ASM)<A<I>> + BSSBASE(ASM)  :F(RETURN)
1195             EXPORTS(ASM)<A<I>> = DIFFER(EXPORTS(ASM)<A<I>>)
1195    +           SYMBOLS1(ASM)<A<I>>
        *
1196             TERMINAL = DIFFER(ASM_DEBUG)
1196    +           'PHASE 1 BSS SYMBOL ' A<I> ' = ' IH(SYMBOLS1(ASM)<A<I>>)
        *
1197             I = I + 1                                            :(ASM_L_7)
        *
        * ASM PHASE 1 OR 2.
        *
        * INTERPOLATE A FILE OR A VARIABLE. IF ITS A VARIABLE, ADD A NEWLINE
        * FOR CONVENIENCE.
        *
1198    ASM_INTERPOLATE
1199             TERMINAL = DIFFER(ASM_DEBUG) 'INTERPOLATE ' P1
1200             IDENT(P1)                                            :S(RETURN)
1201             S = (
1201    +              (?(P1 ? FENCE ANY("'" '"')) READFILE(EVAL(P1))),
1201    +              ($P1 CHARS_NL)
1201    +            )
1202             SRC POS(BL) LEN(0) = S                                 :(ASM_2)
        *
1203    ASM_PHASE
1204             TERMINAL = DIFFER(ASM_DEBUG) '*** PHASE ' ASM_PHASE '***'
1205             SRC = SRC(ASM)
1206             BL = 0
1207             EL = 0
        *
        * SPEED OPTIMIZATION. DON'T REMOVE EACH LINE FROM SRC AS IT IS
        * PROCESSED. ALSO, DON'T DO EVER LONGER 'TAB()' (OR POS) TO EACH LINE.
        * INSTEAD, PROCESS EACH LINE, RECORDING THE BEGINNING OF THE NEXT
        * LINE. AFTER WE ARE 4096 CHARACTERS (OR MORE) IN THE STRING,
        * REMOVE THE LEADING BLOCK. THIS REDUCES GC, AND PERFORMS ABOUT
        * TWICE AS WELL AS THE NAIVE CODE. TESTED WITH 10,000 LINES OF
        * ASM INPUT.
        *
        *        SRC FENCE BREAK(CHARS_NL) . LINE CHARS_NL =          :F(RETURN)
1208    ASM_2    SRC FENCE TAB(BL) BREAK(CHARS_NL) CHARS_NL @EL       :F(RETURN)
1209             LINE = SUBSTR(SRC, BL + 1, EL - BL)
1210             BL = EL
1211             LT(BL, 4096)                                         :S(ASM_X1)
1212             SRC FENCE LEN(BL - 1) =
1213             BL = 0
        *
1214    ASM_X1   TERMINAL = DIFFER(ASM_DEBUG) LINE
        *
1215             LINE FENCE NSPAN(' ' CHARS_TAB) ANY(';*')             :S(ASM_2)
1216             LINE = TRIM(LINE)
1217             IDENT(LINE)                                           :S(ASM_2)
1218             ELINE = LINE
1219             LINE FENCE BREAKQ(';') . LINE
1220             LINE = TRIM(LINE) ',,,'
1221             LAB = OP = P1 = P2 = P3 = SYMBOL =
1222             LINE ASM_PAT                                          :S(ASM_4)
1223    ASM_3    TERMINAL = 'ASM: ERROR IN: ' ELINE                   :(FRETURN)
1224    ASM_4    IDENT(OP, 'END')                                     :S(RETURN)
1225             IDENT(OP, 'end')                                     :S(RETURN)
        *
        * INTERPOLATE A FILE OR STRING INTO THE ASSEMBLY
        * INCLUDE 'NAME', OR INCLUDE SYM
        *
1226             IDENT(OP, 'INCLUDE')                        :S(ASM_INTERPOLATE)
1227             IDENT(OP, 'include')                        :S(ASM_INTERPOLATE)
1228             OP = FUNCTION(OP '__') OP '__'                        :S(ASM_5)
1229             OP = EQ(ASM_PHASE, 1)                                 :S(ASM_2)
1230             OP = (IDENT(OP), FUNCTION('JIT_' OP) 'JIT_' OP)       :F(ASM_3)
1231             TERMINAL = VDIFFER(SYMBOLS(ASM)<LAB>) 'REDEFINED'     :S(ASM_3)
1232             SYMBOLS(ASM)<LAB> = DIFFER(LAB) JIT_LABEL()
1233             IDENT(OP)                                             :S(ASM_2)
1234    ASM_5    OP1 = P1
1235             P1 = ASM_PARM(P1)                                     :F(ASM_3)
1236             P1 = IDENT(P1, ASM_PSYMBOL) 0
1237             P2 = ASM_PARM(P2)                                     :F(ASM_3)
1238             P2 = IDENT(P2, ASM_PSYMBOL) 0
1239             P3 = ASM_PARM(P3)                                     :F(ASM_3)
1240             P3 = IDENT(P3, ASM_PSYMBOL) ASM_PEMPTY
1241             &ERRLIMIT = 1
1242             DIFFER(P1, ASM_PEMPTY)                                :S(ASM_6)
1243             R = APPLY(OP,)                                :S(ASM_9)F(ASM_3)
1244    ASM_6    DIFFER(P2, ASM_PEMPTY)                                :S(ASM_7)
1245             R = APPLY(OP, P1,)                            :S(ASM_9)F(ASM_3)
1246    ASM_7    DIFFER(P3, ASM_PEMPTY)                                :S(ASM_8)
1247             R = APPLY(OP, P1, P2,)                        :S(ASM_9)F(ASM_3)
1248    ASM_8    R = APPLY(OP, P1, P2, P3)                     :S(ASM_9)F(ASM_3)
1249    ASM_9
        * JIT_ARG IS SPECIAL, DON'T PATCH THIS SYMBOL. THE LABEL IS RECORDED
        * IN SYMBOLS1 BECAUSE THIS WILL BE THE "BASE" FOR ARGUMENT RETRIEVAL.
        * JIT_ARG IS THE ONLY INSTRUCTION THAT BEHAVES THIS WAY (EVEN NOTE
        * DOESN'T).
1250             IDENT(OP, 'JIT_ARG')                                 :S(ASM_X3)
1251             IDENT(OP, 'jit_arg')                                 :F(ASM_X2)
1252    ASM_X3   SYMBOLS1(ASM)<LAB> = R
1253             SYMBOLS(ASM)<LAB> =                                   :S(ASM_2)
1254    ASM_X2   IDENT(SYMBOL)                                         :S(ASM_2)
1255             EQ(ASM_PHASE, 1)                                      :S(ASM_2)
1256             TERMINAL = IDENT(R) 'INSTRUCTION NOT PATCHABLE'       :S(ASM_3)
        *
1257             TERMINAL =
1257    +           DIFFER(ASM_DEBUG) 'REFERENCE: AT : ' IH(R) ' TO: ' SYMBOL
        *
1258             REFERENCES(ASM)<SYMBOL> = LINK(R, REFERENCES(ASM)<SYMBOL>)
1258    +                                                               :(ASM_2)
        *
1259    ASM_LINK TERMINAL = DIFFER(ASM_DEBUG) '*** LINK ***'
1260             SYMBOLS = SYMBOLS(ASM)
1261             A = KEYST(REFERENCES(ASM))                           :F(RETURN)
1262             I = 1
1263    ASM_L_2  P = REFERENCES(ASM)<A<I>>                           :F(ASM_L_5)
1264             R = SYMBOLS<A<I>>
1265             IDENT(R)                                            :S(ASM_L_4)
        *
1266             TERMINAL = DIFFER(ASM_DEBUG)
1266    +           'ASM_LINK: RESOLVING ' A<I> ' TO ' IH(R)
        *
1267             REFERENCES(ASM)<A<I>> =
1268    ASM_L_3  IDENT(P)                                            :S(ASM_L_4)
        *
1269             TERMINAL =
1269    +      DIFFER(ASM_DEBUG) 'ASM_LINK: PATCHING ' IH(VALUE(P)) ' TO ' IH(R)
1270             JIT_PATCH_AT(VALUE(P), R)
1271             P = NEXT(P)                                          :(ASM_L_3)
1272    ASM_L_4  I = I + 1                                            :(ASM_L_2)
1273    ASM_L_5  A = KEYST(REFERENCES(ASM))                           :F(RETURN)
1274             I = 1
1275    ASM_L_U  TERMINAL = 'UNRESOLVED: ' A<I>                      :F(FRETURN)
1276             I = I + 1                                            :(ASM_L_U)
        *
1277    ASM_CREATE
1278             ASM_CREATE = ASM_TYPE()
        *
        * WE COPY THE INCOMING SYMBOL TABLE. NOTE THAT TEMPORARY SYMBOLS WILL
        * ADDED TO THIS TABLE (EG. FROM JIT_ARG), THAT WE DON'T WANT TO KEEP.
        * IT IS UP TO THE CALLER TO MANAGE GLOBAL SYMBOLS AS APPROPRIATE. THE
        * INCOMING TABLE IS COPIED TO LESSEN THE MANAGEMENT BURDEN ON THE
        * CALLING CODE, AND ISOLATE ANY CHANGES ASM() ITSELF MAKES.
        *
1279             SYMBOLS1(ASM_CREATE) =
1279    +           (DIFFER(SYMBOLS1) COPYT(SYMBOLS1), TABLE())
1280             EXPORTS(ASM_CREATE) = TABLE()
1281             SYMBOLS(ASM_CREATE) = TABLE()
1282             ENTRIES(ASM_CREATE) = TABLE()
1283             DAREFS(ASM_CREATE) = TABLE()
1284             DPREFS(ASM_CREATE) = TABLE()
1285             REFERENCES(ASM_CREATE) = TABLE()
1286             DSS(ASM_CREATE) = TABLE()
1287             BSS(ASM_CREATE) = TABLE()
1288             SZBSS(ASM_CREATE) = 0
1289             DINIT(ASM_CREATE) =
1290             DSSBASE(ASM_CREATE) = 0
1291             BSSBASE(ASM_CREATE) = 0
1292             JIT(ASM_CREATE) = JIT_NEW_STATE()                     :(RETURN)
        *
1293    ASM_DESTROY
1294             FREE(DSSBASE(ASM))
1295             FREE(BSSBASE(ASM))
1296             JIT_SET_STATE(JIT(ASM))
1297             JIT_DESTROY_STATE()                                   :(RETURN)
        *
1298    END_ASM
        -INCLUDE 'ATOL.INC'
        -MODULE ATOL
        -USES LINK()
        -LINE 11 "ATOL.lss"
        -INCLUDE 'LINK.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'REVL.INC'
        -MODULE REVL
        -LINE 11 "REVL.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 45 "REVL.lss"
        -STITL REVL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    ######   #######  #     #  #                      *
        *                    #     #  #        #     #  #                      *
        *                    #     #  #        #     #  #                      *
        *                    ######   #####    #     #  #                      *
        *                    #   #    #         #   #   #                      *
        *                    #    #   #          # #    #                      *
        *                    #     #  #######     #     #######                *
        *                                                                      *
        * REVL                      REVERSE LIST                               *
        *                                                                      *
        ************************************************************************
        *
        * REVL.lss
        *
        -LINE 15 "REVL.lss"
        -PUBLIC REVL()
        *
1299             DEFINE('REVL(L)T')                                  :(REVL_END)
        *
1300    REVL     REVL = L
1301             IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
1302             L = NEXT(REVL)
1303             NEXT(REVL) =
1304    REVL_1   IDENT(L)                                             :S(RETURN)
1305             T = NEXT(L)
1306             NEXT(L) = REVL
1307             REVL = L
1308             L = T                                                 :(REVL_1)
        *
1309    REVL_END
        *
        * CE: .MSNOBOL4;
        -LINE 40 "ATOL.lss"
        -IN72
        -STITL ATOL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                     #     #######  #######  #                        *
        *                    # #       #     #     #  #                        *
        *                   #   #      #     #     #  #                        *
        *                  #     #     #     #     #  #                        *
        *                  #######     #     #     #  #                        *
        *                  #     #     #     #     #  #                        *
        *                  #     #     #     #######  #######                  *
        *                                                                      *
        * ATOL                      ARRAY TO LIST                              *
        *                                                                      *
        ************************************************************************
        *
        * ATOL.lss
        *
        -LINE 17 "ATOL.lss"
        -PUBLIC ATOL()
        *
1310             DEFINE('ATOL(A)I')                                  :(END_ATOL)
        *
1311    ATOL     SEQ(' ATOL = LINK(A<I>, ATOL)', .I)
1312             ATOL = REVL(ATOL)                                     :(RETURN)
        *
1313    END_ATOL
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'AUTOLDR.INC'
        -MODULE AUTOLDR
        -INCLUDE 'SLOAD.INC'
        -LINE 12 "SLOAD.lss"
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'HOST.INC'
        -MODULE HOST
        -LINE 8 "HOST.lss"
        -IN72
        -LINE 162 "HOST.lss"
        -STITL HOST
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #     #  #######   #####   #######                   *
        *                 #     #  #     #  #     #     #                      *
        *                 #     #  #     #  #           #                      *
        *                 #######  #     #   #####      #                      *
        *                 #     #  #     #        #     #                      *
        *                 #     #  #     #  #     #     #                      *
        *                 #     #  #######   #####      #                      *
        *                                                                      *
        * HOST               HOST() FUNCTION CODES                             *
        *                                                                      *
        ************************************************************************
        *
        * HOST.lss
        *
        -LINE 11 "HOST.lss"
1314    HOST
        *
        *
        * MACRO SPITBOL
        *
        -PUBLIC HOST_SYSINFO, HOST_PARAMS
        *
        * ARCH:OS:SNOBOL_VERSION
1315             HOST_SYSINFO = ''
        * ARGUMENT FROM -u OR ENTIRE COMMAND LINE
1316             HOST_PARAMS = 0
        *
        * CATSPAW SPITBOL
        *
        -PUBLIC HOST_SYSCMD, HOST_ARGN, HOST_FIRSTARG, HOST_GETENV
        *
        * EXEC ARG AS SHELL COMMAND, RETURN STATUS
1317             HOST_SYSCMD = 1
        * N'TH TOKEN ON COMMAND LINE (INTEGER)
1318             HOST_ARGN = 2
        * INDEX OF 1ST USER COMMAND LINE ARG TOKEN
1319             HOST_FIRSTARG = 3
        * RETURNS ENVIRONMENT VARIABLE, OR FAILS
1320             HOST_GETENV = 4
        *
        -PUBLIC HOST_SNOLIB_DIR
        *
        * DEFAULT SNOLIB DIR (-INCLUDE, LOAD())
1321             HOST_SNOLIB_DIR = 2200
        *
        -PUBLIC HOST_CC, HOST_COPT
        *
        * C COMPILER USED TO BUILD CSNOBOL4
1322             HOST_CC = 2202
        * C OPTIMIZER FLAGS USED TO BUILD CSNOBOL4
1323             HOST_COPT = 2203
        *
        -PUBLIC HOST_DL_EXT, HOST_DL_CFLAGS, HOST_DL_LD,HOST_DL_LDFLAGS
        *
        * DYNAMIC LOADABLE LIBRARY EXTENSION
1324             HOST_DL_EXT = 2208
        * C COMPILER FLAGS FOR DYNAMIC LOADABLES
1325             HOST_DL_CFLAGS = 2209
        * DYNAMIC LOADABLE FILE LOAD COMMAND
1326             HOST_DL_LD = 2210
        * DYNAMIC LOADABLE FILE LOAD SWITCHES
1327             HOST_DL_LDFLAGS = 2211
        *
        -PUBLIC HOST_DIR_SEP, HOST_PATH_SEP
        *
        * DIRECTORY SEPARATOR CHAR (MAY BE EMPTY)
1328             HOST_DIR_SEP = 2212
        * PATH SEPARATOR CHARACTER
1329             HOST_PATH_SEP = 2213
        *
        * CSNOBOL4 1.5
        *
        -PUBLIC HOST_DEF_SNOPATH, HOST_INCUDE_DIR
        *
        * DEFAULT LIBRARY SEARCH PATH
1330             HOST_DEF_SNOPATH = 2214
        * PATH FOR C HEADERS
1331             HOST_INCLUDE_DIR = 2215
        *
        -PUBLIC HOST_INTEGER_BITS, HOST_REAL_BITS, HOST_POINTER_BITS
        -PUBLIC HOST_LONG_BITS, HOST_DESCR_BITS, HOST_SPEC_BITS, HOST_CHAR_BITS
        *
        * NUMBER OF BITS FOR SNOBOL4 INTEGER TYPE
1332             HOST_INTEGER_BITS = 2300
        * NUMBER OF BITS FOR SNOBOL4 REAL TYPE
1333             HOST_REAL_BITS = 2301
        * NUMBER OF BITS FOR C POINTER TYPE
1334             HOST_POINTER_BITS = 2302
        * NUMBER OF BITS FOR C LONG TYPE
1335             HOST_LONG_BITS = 2303
        * NUMBER OF BITS FOR SIL 'DESCRIPTOR' TYPE
1336             HOST_DESCR_BITS = 2304
        * NUMBER OF BITS FOR SIL 'SPECIFIER' TYPE
1337             HOST_SPEC_BITS = 2305
        * NUMBER OF BITS FOR C CHAR TYPE
1338             HOST_CHAR_BITS = 2306
        *
        -PUBLIC HOST_DYNAMIC_SIZE, HOST_PMSTACK_SIZE, HOST_ISTACK_SIZE
        *
        * SIZE OF 'DYNAMIC' STORAGE IN DESCRIPTORS
1339             HOST_DYNAMIC_SIZE = 2400
        * SIZE OF PATTERN MATCH STACK IN DESCRS
1340             HOST_PMSTACK_SIZE = 2401
        * SIZE OF INTERPRETER STACK IN DESCRIPTORS
1341             HOST_ISTACK_SIZE = 2402
        *
1342        CODE('HOST')
        *
1343    HOST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -STITL SLOAD
        -EJECT
        -LINE 112 "SLOAD.lss"
        *
        ************************************************************************
        *                                                                      *
        *              #####   #        #######     #     ######               *
        *             #     #  #        #     #    # #    #     #              *
        *             #        #        #     #   #   #   #     #              *
        *              #####   #        #     #  #     #  #     #              *
        *                   #  #        #     #  #######  #     #              *
        *             #     #  #        #     #  #     #  #     #              *
        *              #####   #######  #######  #     #  ######               *
        *                                                                      *
        * SLOAD                LOAD SNOBOL4 SOURCE                             *
        *                                                                      *
        * (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *
        *                                                                      *
        * MODIFIED TO SUPPORT /DEV FILES, SEARCH CSNOBOL4 PATHS                *
        *                                                                      *
        ************************************************************************
        *
        * SLOAD.lss
        *
        -LINE 18 "SLOAD.lss"
        -MODULE SLOAD
        -PUBLIC SLOAD()
1344             DEFINE('SLOAD(FILENAME)'
1344    +               'LIB,CODE,PATH,X,A,I,P,PS,DS,TRIM_SAV,POSITION,UNIT')
1345             Q_ = "'"
1346             QQ_ = '"'
1347             SLOAD_STMT = ARBNO(Q_ BREAK(Q_) Q_ | QQ_ BREAK(QQ_) QQ_ |
1347    +                     NOTANY(Q_ QQ_) BREAK(Q_ QQ_ ';')) ';'
1348             SLOAD_STMTS = FENCE (';' ARBNO(SLOAD_STMT)) . X '*' REM
        * NOTE THAT ; FOLLOWED BY ANYTHING OTHER THAN . OR + IS ALSO A COMMENT
1349             SLOAD_CCPAT = FENCE ('*' | '-' | '#' | '!' | '|' | RPOS(0))
1350             SLOAD_CNPAT = FENCE (';.' | ';+')
1351             SLOAD_INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
1351    +                                (ANY('Cc') ('OPY' | 'opy')))
1351    +                      BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
1352             SLOAD_TAB = TABLE()                                :(SLOAD_END)
        *
        * FUNCTION TO READ AND COMPILE SNOBOL4 FUNCTIONS FROM A DISK FILE.
        * THE FILENAME IS SPECIFIED AS THE ARGUMENT TO FUNCTION SLOAD.
        *
1353    SLOAD    UNIT = IO_FINDUNIT()
1354             PATH = FILENAME
1355             INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
1356             DS = HOST(HOST_DIR_SEP)
1357             PS = HOST(HOST_PATH_SEP)
1358             X = HOST(HOST_GETENV, 'SNOPATH')                    :S(SLOAD_8)
1359             X = HOST(HOST_GETENV, 'SNOLIB')                     :S(SLOAD_8)
1360             X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
1361    SLOAD_8  A = CRACK(X, PS)
1362             I = 1
1363    SLOAD_10 P = TRIMB(A<I>)                                     :F(FRETURN)
1364             PATH = P DS FILENAME
1365             INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
1366             I = I + 1                                           :(SLOAD_10)
        *
1367    SLOAD_0  TRIM_SAV = &TRIM
1368             &TRIM = 1
        *
1369    SLOAD_1  X = LIB                                             :F(SLOAD_2)
1370             X SLOAD_CCPAT                                       :S(SLOAD_4)
1371             X = ';' X
1372             X SLOAD_CNPAT = ' '
1373             X SLOAD_STMTS
1374             CODE = CODE X                                        :(SLOAD_1)
        *
1375    SLOAD_4  X SLOAD_INPAT                                       :F(SLOAD_1)
1376             DIFFER(SLOAD_TAB<X>)                                :S(SLOAD_1)
        *
1377             POSITION = SET(UNIT, 0, 1)
1378             ENDFILE(UNIT)
1379             DETACH(.LIB)
        *
1380             SLOAD(X)                                            :F(FRETURN)
        *
1381             INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
        *
1382             SLOAD_TAB<X> = 1
1383             FILENAME FENCE '/dev/'                              :S(SLOAD_1)
1384             EQ(SET(UNIT, POSITION, 0), POSITION)      :S(SLOAD_1)F(FRETURN)
        *
1385    SLOAD_2  ENDFILE(UNIT)
1386             DETACH(.LIB)
1387             CODE = CODE(CODE '; :(SLOAD_3)')                       :S<CODE>
1388             TERMINAL = 'COMPILATION ERROR, FILE: ' FILENAME
        *
        * ERROR. TAKE CODE APART STATEMENT BY STATEMENT TO FIND THE PROBLEM.
        * FIRST REMOVE FROM INCLUDE FILE TABLE, THEN REMOVE INITIAL ';'
        *
1389             SLOAD_TAB<X> =
1390             CODE = SUBSTR(CODE, 2)
1391    SLOAD_6  CODE FENCE SLOAD_STMT . X =                         :F(SLOAD_7)
1392             CODE(X)                                             :S(SLOAD_6)
1393             X RTAB(1) . TERMINAL
1394    SLOAD_7  &TRIM = TRIM_SAV
1395             TERMINAL = &ERRTEXT                                  :(FRETURN)
        *
1396    SLOAD_3  &TRIM = TRIM_SAV                                      :(RETURN)
        *
1397    SLOAD_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'JSON.INC'
        -MODULE JSON
        -LINE 40 "JSON.lss"
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'CH.INC'
        -MODULE CH
        -LINE 10 "CH.lss"
        -INCLUDE 'HEX.INC'
        -MODULE HEX
        -LINE 13 "HEX.lss"
        -INCLUDE 'BLEND.INC'
        -MODULE BLEND
        -LINE 10 "BLEND.lss"
        -IN72
        -LINE 50 "BLEND.lss"
        -STITL BLEND
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              ######   #        #######  #     #  ######              *
        *              #     #  #        #        ##    #  #     #             *
        *              #     #  #        #        # #   #  #     #             *
        *              ######   #        #####    #  #  #  #     #             *
        *              #     #  #        #        #   # #  #     #             *
        *              #     #  #        #        #    ##  #     #             *
        *              ######   #######  #######  #     #  ######              *
        *                                                                      *
        * BLEND                      BLEND STRINGS                             *
        *                                                                      *
        ************************************************************************
        *
        * BLEND.lss
        *
        -LINE 13 "BLEND.lss"
        -PUBLIC BLEND()
        *
1398             DEFINE('BLEND(S1,S2)T1,T2,ABC,XYZ,L1,L2')
1399             &ALPHABET LEN(128) . ABC LEN(128) . XYZ
1400    BLE_1    ABC LEN(1) . T1 =                                 :F(BLEND_END)
1401             XYZ LEN(1) . T2 =
1402             BLENDED_ALPHABET = BLENDED_ALPHABET T1 T2              :(BLE_1)
        *
1403    BLEND    L1 = SIZE(S1)
1404             GT(L1, 128)                                         :F(BLEND_1)
1405             EQ(L1, 0)                                            :S(RETURN)
1406             S1 LEN(128) . S1 REM . T1
1407             S2 LEN(128) . S2 REM . T2
1408             BLEND = REPLACE(BLENDED_ALPHABET, &ALPHABET, S1 S2)
1409             BLEND(T1, T2)                                         :(RETURN)
1410    BLEND_1  L2 = SIZE(S2)
1411             &ALPHABET LEN(*L1) . ABC TAB(128) LEN(*L2) . XYZ
1412             BLENDED_ALPHABET LEN(*(L1 + L2)) . AXBYCZ
1413             BLEND = REPLACE(AXBYCZ, ABC XYZ, S1 S2)               :(RETURN)
        *
1414    BLEND_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 51 "HEX.lss"
        -STITL HEX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #     #  #######  #     #                       *
        *                      #     #  #         #   #                        *
        *                      #     #  #          # #                         *
        *                      #######  #####       #                          *
        *                      #     #  #          # #                         *
        *                      #     #  #         #   #                        *
        *                      #     #  #######  #     #                       *
        *                                                                      *
        * HEX                    RETURN HEX FOR STRING                         *
        *                                                                      *
        ************************************************************************
        *
        * HEX.lss
        *
        -LINE 17 "HEX.lss"
        -PUBLIC HEX()
        *
1415             DEFINE('HEX(S)S2')
        *
1416             H = '0123456789ABCDEF'
1417             HEX_2ND = DUPL(H, 16)
1418    HEX_1    H LEN(1) . T =                                      :F(HEX_END)
1419             HEX_1ST = HEX_1ST DUPL(T, 16)                          :(HEX_1)
        *
1420    HEX      IDENT(S)                                             :S(RETURN)
1421             LE(SIZE(S), 128)                                      :S(HEX_2)
1422             S LEN(128) . S REM . S2
1423             HEX = HEX(S) HEX(S2)                                  :(RETURN)
1424    HEX_2    HEX = BLEND(REPLACE(S, &ALPHABET, HEX_1ST),
1424    +           REPLACE(S, &ALPHABET, HEX_2ND))                    :(RETURN)
        *
1425    HEX_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 47 "CH.lss"
        -STITL CH
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                            #####   #     #                           *
        *                           #     #  #     #                           *
        *                           #        #     #                           *
        *                           #        #######                           *
        *                           #        #     #                           *
        *                           #     #  #     #                           *
        *                            #####   #     #                           *
        *                                                                      *
        * CH                         HEX TO STRING                             *
        *                                                                      *
        ************************************************************************
        *
        * CH.lss
        *
        -LINE 14 "CH.lss"
        -PUBLIC CH()
        *
1426             DEFINE('CH(H)C,P')
        *
1427             CH_H_ = ' ' HEX(&ALPHABET)
1428    CH_2     CH_H_ ' ' LEN(2) . C1
1428    +          (ANY('0123456789ABCDEF') LEN(1)) . C2 = ' ' C1 ' ' C2
1428    +                                                      :S(CH_2)F(CH_END)
        *
1429    CH       H = REPLACE(H, &LCASE, &UCASE)
1430    CH_3     H LEN(2) . C =                                       :F(RETURN)
1431             CH_H_ ' ' C @P                                      :F(FRETURN)
1432             P = (P - 1) / 3
1433             &ALPHABET LEN(P) LEN(1) . C
1434             CH = CH C                                               :(CH_3)
        *
1435    CH_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HEX.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'LOG.INC'
        -MODULE LOG
        -LINE 13 "LOG.lss"
        -INCLUDE 'DEXP.INC'
        -MODULE DEXP
        -LINE 13 "DEXP.lss"
        -IN72
        -LINE 41 "DEXP.lss"
        -STITL DEXP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                   ######   #######  #     #  ######                  *
        *                   #     #  #         #   #   #     #                 *
        *                   #     #  #          # #    #     #                 *
        *                   #     #  #####       #     ######                  *
        *                   #     #  #          # #    #                       *
        *                   #     #  #         #   #   #                       *
        *                   ######   #######  #     #  #                       *
        *                                                                      *
        * DEXP                 SIMPLE FUNCTION DEFINTION                       *
        *                                                                      *
        ************************************************************************
        *
        * DEXP.lss
        *
        -LINE 16 "DEXP.lss"
        -PUBLIC DEXP()
        *
1436             DEFINE('DEXP(PROTO)NAME,ARGS')                      :(DEXP_END)
        *
1437    DEXP     PROTO POS(0) SPAN(' ') =
1438             PROTO BREAK('(') . NAME BAL . ARGS = NAME
1439             CODE(NAME ' ' PROTO ' :S(RETURN)F(FRETURN)')
1440             DEFINE(NAME ARGS)                                     :(RETURN)
        *
1441    DEXP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FLOOR.INC'
        -MODULE FLOOR
        -LINE 11 "FLOOR.lss"
        -INCLUDE 'DEXP.INC'
        -IN72
        -LINE 40 "FLOOR.lss"
        -STITL FLOOR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #######  #        #######  #######  ######              *
        *              #        #        #     #  #     #  #     #             *
        *              #        #        #     #  #     #  #     #             *
        *              #####    #        #     #  #     #  ######              *
        *              #        #        #     #  #     #  #   #               *
        *              #        #        #     #  #     #  #    #              *
        *              #        #######  #######  #######  #     #             *
        *                                                                      *
        * FLOOR              FLOOR AND CEIL FUNCTIONS                          *
        *                                                                      *
        ************************************************************************
        *
        * FLOOR.lss
        *
        -LINE 15 "FLOOR.lss"
        -PUBLIC FLOOR(), CEIL()
        *
1442             DEFINE('FLOOR(X)')
1443             DEXP('CEIL(X) = -FLOOR(-X)')                       :(FLOOR_END)
        *
1444    FLOOR    FLOOR = CONVERT(X, 'INTEGER')
1445             GE(X, 0)                                             :S(RETURN)
1446             FLOOR = NE(X, FLOOR) FLOOR - 1                        :(RETURN)
        *
1447    FLOOR_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 34 "LOG.lss"
        -STITL LOG
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #        #######   #####                        *
        *                      #        #     #  #     #                       *
        *                      #        #     #  #                             *
        *                      #        #     #  #  ####                       *
        *                      #        #     #  #     #                       *
        *                      #        #     #  #     #                       *
        *                      #######  #######   #####                        *
        *                                                                      *
        * LOG                       LOG FUNCTIONS                              *
        *                                                                      *
        ************************************************************************
        *
        * LOG.lss
        *
        * CONSTANTS TO 50 PLACES
        *
        * SEE
        * http://numbers.computation.free.fr/Constants/Miscellaneous/digits.html
        *
        -PUBLIC LN_10, EULERS_NUMBER, PI
1448             LN_10    =
1448    +                   2.30258509299404568401799145468436420760110148862877
1449             EULERS_NUMBER =
1449    +                   2.71828182845904523536028747135266249775724709369995
1450             PI =
1450    +                   3.14159265358979323846264338327950288419716939937510
        *
        -PUBLIC CLOG(), LOGB()
        *
1451             DEXP('CLOG(X) = LN(X) / LN_10')
1452             DEXP('LOGB(X,B) = NE(B, 0) LN(X) / LN(B) ;'
1452    +             'LOGB      = EQ(B, 0) LN(X)         ;')
        *
1453    LOG_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SDIFF.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 386 "JSON.lss"
        -STITL JSON
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                        #   #####   #######  #     #                  *
        *                        #  #     #  #     #  ##    #                  *
        *                        #  #        #     #  # #   #                  *
        *                        #   #####   #     #  #  #  #                  *
        *                  #     #        #  #     #  #   # #                  *
        *                  #     #  #     #  #     #  #    ##                  *
        *                   #####    #####   #######  #     #                  *
        *                                                                      *
        * JSON                  CONVERT TO AND FROM JSON                       *
        *                                                                      *
        ************************************************************************
        *
        * JSON.lss
        *
        -LINE 51 "JSON.lss"
        -PUBLIC JSON_ENCODE(), JSON_DECODE()
        *
1454             DEFINE('JSON_ENCODE(X)L')
1455             DEFINE('JSON_DECODE(X)')
        *
1456             DEFINE('JSON_DECODE_STRING()S')
1457             DEFINE('JSON_DECODE_VALUE()')
1458             DEFINE('JSON_DECODE_OBJECT()T,T2')
1459             DEFINE('JSON_DECODE_ARRAY()T,I')
1460             DEFINE('JSON_ESCAPE(C)')
1461             DEFINE('JSON_INDENT()')
1462             DEFINE('JSON_ENCODE_OBJECT(X)K,I')
1463             DEFINE('JSON_ENCODE_ARRAY(X)I')
1464             DEFINE('JSON_ENCODE_STRING(S)L,C')
1465             DEFINE('JSON_ENCODE_VALUE(X)')
        *
        * JSON WHITESPACE. THIS CAN BE BETWEEN TOKENS, AND WILL BE IGNORED
        *
        * ALSO EATS 'COMMENTS' DEFINED AS # TO END OF LINE, // TO END OF
        * LINE AND /* TO */
        *
1466             JSON_WS2 = SPAN(CHARS_TAB CHARS_SPACE CHARS_FF CHARS_LF
1466    +                        CHARS_CR) |
1466    +                   ('#' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
1466    +                   ('//' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
1466    +                   ('/*' BREAK('*') '*/')
1467             JSON_WS = (JSON_WS2 *JSON_WS) |
1467    +                  NULL
        *
        * A JSON NUMBER. PATTERN JSON_NUMBER IS ONLY USED TO DECODE JSON.
        * ENCODING USES THE NORMAL OUTPUT FORMATTING, WITH THE RULE THAT
        * A TRAILING '0' IS ADDED IF THE NUMBER OUTPUT ENDS IN '.'
        *
1468             JSON_DIGIT19 = ANY("123456789")
1469             JSON_DIGIT = ANY("0123456789")
1470             JSON_DIGITS = JSON_DIGIT (*JSON_DIGITS | NULL)
1471             JSON_E = 'e+' | 'e-' | 'E+' | 'E-' | 'e' | 'E'
1472             JSON_EXP = JSON_E JSON_DIGITS
1473             JSON_FRAC = "." JSON_DIGITS
1474             JSON_INT = ("-" | NULL)
1474    +                   ((JSON_DIGIT19 JSON_DIGITS) | JSON_DIGIT)
1475             JSON_NUMBER = JSON_INT (JSON_FRAC | NULL) (JSON_EXP | NULL)
        *
        * JSON CONSTANTS. THESE ARE NOT IN THE SNOBOL4 LEXICON, SO WE
        * CREATE A TYPE THAT REPRESENT THESE VALUES UNIQUELY.
        *
        -PUBLIC JSON_NULL, JSON_TRUE, JSON_FALSE
        *
1476             DATA('JSON_CONSTANT(VALUE)')
1477             JSON_NULL = JSON_CONSTANT('null')
1478             JSON_TRUE = JSON_CONSTANT('true')
1479             JSON_FALSE = JSON_CONSTANT('false')
        *
        * JSON_NL AND JSON_IN ARE PRODUCED FOR NEWLINE AND INDENT SEPARATION.
        * DEFAULT IS A NEWLINE AND TWO SPACES. TO PRODUCE COMPACT JSON, REPLACE
        * WITH NULL.
        *
        -PUBLIC JSON_NL, JSON_IN
        *
1480             JSON_NL = CHARS_NL
1481             JSON_IN = '  '
        *
        * JSON_REST IS THE REST OF THE INPUT AFTER PARSING A JSON DOCUMENT
        * FROM THE FRONT. THIS IS MEANT TO ALLOW CONCATENATION OF JSON
        * DOCUMENTS.
        *
        -PUBLIC JSON_REST
        *
1482             JSON_REST =
        *
        * JSON_HEX IS A HEX DIGIT USED BY THE \u CHARACTER IS A JSON STRING.
        * JSON_NSET IS THE SET OF CHARACTERS WHICH CAN BE SIMPLY ACCEPTED IN
        * A STRING. ANY CHARACTER NOT IN JSON_NSET (NORMAL SET) IS ESCAPED.
        *
1483             JSON_HEX = ANY('0123456789abcdefABCDEF')
1484             JSON_NSET = SDIFF(CHARS_PRINTABLE, '"\/')           :(JSON_END)
        *
1485    JSON_ESCAPE
1486             JSON_ESCAPE = IDENT(C, '"') '\"'                     :S(RETURN)
1487             JSON_ESCAPE = IDENT(C, '\') '\\'                     :S(RETURN)
1488             JSON_ESCAPE = IDENT(C, '/') '\/'                     :S(RETURN)
1489             JSON_ESCAPE = IDENT(C, CHARS_BS) '\b'                :S(RETURN)
1490             JSON_ESCAPE = IDENT(C, CHARS_FF) '\f'                :S(RETURN)
1491             JSON_ESCAPE = IDENT(C, CHARS_NL) '\n'                :S(RETURN)
1492             JSON_ESCAPE = IDENT(C, CHARS_HT) '\t'                :S(RETURN)
1493             JSON_ESCAPE = IDENT(C, CHARS_CR) '\r'                :S(RETURN)
        *
        * FIXME: NOT RIGHT. SHOULD PASS THROUGH UTF-8, AND ONLY CONVERT CONTROL
        *        WE ARE CHEATING BY JUST USING THIS TO CONVERT BYTES.
        *
1494             JSON_ESCAPE = '\u00' HEX(C)                           :(RETURN)
        *
1495    JSON_ENCODE_STRING
1496             L =
1497             S (SPAN(JSON_NSET) | NULL) . L REM . S
1498             JSON_ENCODE_STRING = JSON_ENCODE_STRING L
1499             IDENT(S)                               :S(JSON_ENCODE_STRING_2)
1500             S LEN(1) . C REM . S
1501             JSON_ENCODE_STRING = JSON_ENCODE_STRING JSON_ESCAPE(C)
1501    +                                                  :(JSON_ENCODE_STRING)
1502    JSON_ENCODE_STRING_2
1503             JSON_ENCODE_STRING = '"' JSON_ENCODE_STRING '"'       :(RETURN)
        *
        * CAREFUL WITH REAL VALUES. CSNOBOL4 WILL PRINT '4.' (FOR EXAMPLE).
        * BY THE SYNTAX SPECIFIED, THIS IS NOT LEGAL. '4.0' IS THE LEGAL
        * FORM. FIX THIS BY APPENDING A '0' IF THE FINAL CHARACTER OF A REAL
        * CONVERSION IS '.'.
        *
        * BOTH TABLE AND ARRAY TYPES CAUSE A RECURSION. DATA() TYPES CANNOT
        * BE SERIALIZED.
        *
1504    JSON_ENCODE_VALUE
1505             JSON_ENCODE_VALUE = IDENT(X, JSON_NULL) 'null'       :S(RETURN)
1506             JSON_ENCODE_VALUE = IDENT(X, JSON_TRUE) 'true'       :S(RETURN)
1507             JSON_ENCODE_VALUE = IDENT(X, JSON_FALSE) 'false'     :S(RETURN)
1508             JSON_ENCODE_VALUE = IDENT(X) '""'                    :S(RETURN)
1509             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'INTEGER') X  :S(RETURN)
1510             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'REAL') X
1510    +                                                :F(JSON_ENCODE_VALUE_2)
        *
        * THE FOLLOWING CONDITION WILL NOT HAPPEN WITH SPITBOL.EXE
        *
1511             JSON_ENCODE_VALUE 'nan' | 'inf'         :S(JSON_ENCODE_VALUE_3)
1512             JSON_ENCODE_VALUE RTAB(1) '.'                        :F(RETURN)
1513             JSON_ENCODE_VALUE = JSON_ENCODE_VALUE '0'             :(RETURN)
1514    JSON_ENCODE_VALUE_2
1515             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'STRING')
1515    +                            JSON_ENCODE_STRING(X)            :S(RETURN)
1516             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'TABLE')
1516    +                            JSON_ENCODE_OBJECT(X)            :S(RETURN)
1517             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'ARRAY')
1517    +                            JSON_ENCODE_ARRAY(X)             :S(RETURN)
1518    JSON_ENCODE_VALUE_3
1519             TERMINAL = 'JSON_ENCODE_VALUE: CANNOT ENCODE: '
1519    +                   DATATYPE(X) ' ' X
1520                                                                      :(END)
        *
1521    JSON_INDENT
1522             JSON_INDENT = DUPL(JSON_IN, L)                        :(RETURN)
        *
1523    JSON_ENCODE_ARRAY
1524             JSON_ENCODE_ARRAY = '['
1525             L = L + 1
1526             DIFFER(DATATYPE(X), 'ARRAY')            :S(JSON_ENCODE_ARRAY_2)
1527             I = 1
1528             X<I>                                    :F(JSON_ENCODE_ARRAY_2)
1529    JSON_ENCODE_ARRAY_1
1530             JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
1530    +                            JSON_INDENT()
1530    +                            JSON_ENCODE_VALUE(X<I>)
1531             I = I + 1
1532             X<I>                                    :F(JSON_ENCODE_ARRAY_2)
1533             JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY ','
1533    +                                                 :(JSON_ENCODE_ARRAY_1)
1534    JSON_ENCODE_ARRAY_2
1535             L = L - 1
1536             JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
1536    +                            JSON_INDENT() ']'                 :(RETURN)
        *
1537    JSON_ENCODE_OBJECT
1538             JSON_ENCODE_OBJECT = '{'
1539             L = L + 1
1540             DIFFER(DATATYPE(X), 'TABLE')           :S(JSON_ENCODE_OBJECT_2)
1541             K = KEYST(X)                           :F(JSON_ENCODE_OBJECT_2)
1542             I = 1
1543    JSON_ENCODE_OBJECT_1
1544             JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
1544    +                             JSON_INDENT()
1544    +                             JSON_ENCODE_STRING(K<I>) ': '
1544    +                             JSON_ENCODE_VALUE(X<K<I>>)
1545             I = I + 1
1546             K<I>                                   :F(JSON_ENCODE_OBJECT_2)
1547             JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT ','
1547    +                                                :(JSON_ENCODE_OBJECT_1)
1548    JSON_ENCODE_OBJECT_2
1549             L = L - 1
1550             JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
1550    +                             JSON_INDENT() '}'                :(RETURN)
        *
1551    JSON_ENCODE
1552             L = 0
1553             JSON_ENCODE = JSON_ENCODE_VALUE(X)                    :(RETURN)
        *
1554    JSON_DECODE_STRING
1555             X BREAK('\"') . S =                                 :F(FRETURN)
1556             JSON_DECODE_STRING = JSON_DECODE_STRING S
1557             X POS(0) '"' =                                       :S(RETURN)
1558             JSON_DECODE_STRING = ?(X ? POS(0) '\b' =)
1558    +                     JSON_DECODE_STRING CHARS_BS :S(JSON_DECODE_STRING)
1559             JSON_DECODE_STRING = ?(X ? POS(0) '\f' =)
1559    +                     JSON_DECODE_STRING CHARS_FF :S(JSON_DECODE_STRING)
1560             JSON_DECODE_STRING = ?(X ? POS(0) '\n' =)
1560    +                     JSON_DECODE_STRING CHARS_NL :S(JSON_DECODE_STRING)
1561             JSON_DECODE_STRING = ?(X ? POS(0) '\t' =)
1561    +                     JSON_DECODE_STRING CHARS_HT :S(JSON_DECODE_STRING)
1562             JSON_DECODE_STRING = ?(X ? POS(0) '\r' =)
1562    +                     JSON_DECODE_STRING CHARS_CR :S(JSON_DECODE_STRING)
1563             JSON_DECODE_STRING = ?(X ? POS(0) '\"' =)
1563    +                     JSON_DECODE_STRING '"'      :S(JSON_DECODE_STRING)
1564             JSON_DECODE_STRING = ?(X ? POS(0) '\\' =)
1564    +                     JSON_DECODE_STRING '\'      :S(JSON_DECODE_STRING)
1565             JSON_DECODE_STRING = ?(X ? POS(0) '\/' =)
1565    +                     JSON_DECODE_STRING '/'      :S(JSON_DECODE_STRING)
        * FIXME: HANDLE UTF SEQUENCES PROPERLY
1566             X POS(0) '\u00' (JSON_HEX JSON_HEX) . C =
1566    +                                               :F(JSON_DECODE_STRING_2)
1567             JSON_DECODE_STRING = JSON_DECODE_STRING CH(C)
1567    +                                                  :(JSON_DECODE_STRING)
1568    JSON_DECODE_STRING_2
1569             TERMINAL = 'JSON_DECODE_STRING: ' X                      :(END)
        *
1570    JSON_DECODE_VALUE
1571             X POS(0) JSON_WS =
1572             IDENT(X)                                            :S(FRETURN)
1573             JSON_DECODE_VALUE = ?(X ? POS(0) 'null' =) JSON_NULL
1573    +                                                             :S(RETURN)
1574             JSON_DECODE_VALUE = ?(X ? POS(0) 'true' =) JSON_TRUE
1574    +                                                             :S(RETURN)
1575             JSON_DECODE_VALUE = ?(X ? POS(0) 'false' =) JSON_FALSE
1575    +                                                             :S(RETURN)
1576             X POS(0) '"' =                          :F(JSON_DECODE_VALUE_2)
1577             JSON_DECODE_VALUE =  JSON_DECODE_STRING()  :S(RETURN)F(FRETURN)
1578    JSON_DECODE_VALUE_2
1579             X POS(0) '{' =                          :F(JSON_DECODE_VALUE_3)
1580             JSON_DECODE_VALUE = JSON_DECODE_OBJECT()   :S(RETURN)F(FRETURN)
1581    JSON_DECODE_VALUE_3
1582             X POS(0) '[' =                          :F(JSON_DECODE_VALUE_4)
1583             JSON_DECODE_VALUE = JSON_DECODE_ARRAY()    :S(RETURN)F(FRETURN)
1584    JSON_DECODE_VALUE_4
1585             X JSON_NUMBER . JSON_DECODE_VALUE =                 :F(FRETURN)
1586             JSON_DECODE_VALUE = +JSON_DECODE_VALUE                :(RETURN)
        *
1587    JSON_DECODE_ARRAY
1588             T = TABLE()
1589             I = 0
1590    JSON_DECODE_ARRAY_1
1591             X POS(0) JSON_WS =
1592             IDENT(X)                                            :S(FRETURN)
1593             X POS(0) ']' =                          :S(JSON_DECODE_ARRAY_2)
1594             I = I + 1
1595             T<I> = JSON_DECODE_VALUE()                          :F(FRETURN)
1596             X POS(0) JSON_WS ',' =                   :(JSON_DECODE_ARRAY_1)
1597    JSON_DECODE_ARRAY_2
1598             JSON_DECODE_ARRAY = EQ(I) ARRAY0                     :S(RETURN)
1599             JSON_DECODE_ARRAY = ARRAY(I)
1600             SEQ(' JSON_DECODE_ARRAY<I> = T<I> ', .I)              :(RETURN)
        *
1601    JSON_DECODE_OBJECT
1602             JSON_DECODE_OBJECT = TABLE()
1603    JSON_DECODE_OBJECT_1
1604             X POS(0) JSON_WS =
1605             IDENT(X)                                            :S(FRETURN)
1606             X POS(0) '}' =                                       :S(RETURN)
1607             X POS(0) '"' =                                      :F(FRETURN)
1608             T = JSON_DECODE_STRING()                            :F(FRETURN)
1609             X POS(0) JSON_WS ':' =                              :F(FRETURN)
1610             T2 = JSON_DECODE_VALUE()                            :F(FRETURN)
1611             JSON_DECODE_OBJECT<T> = T2
1612             X POS(0) JSON_WS ',' =                  :(JSON_DECODE_OBJECT_1)
        *
1613    JSON_DECODE
1614             X = X CHARS_NL
1615             JSON_DECODE = JSON_DECODE_VALUE()                   :F(FRETURN)
1616             JSON_REST = X                                         :(RETURN)
        *
1617    JSON_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -MODULE READFILE
        -LINE 15 "READFILE.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'SYSTEM.INC'
        -IN72
        -LINE 55 "READFILE.lss"
        -STITL READLINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  ######   #######     #     ######   #######  ###  #        #######  *
        *  #     #  #          # #    #     #  #         #   #        #        *
        *  #     #  #         #   #   #     #  #         #   #        #        *
        *  ######   #####    #     #  #     #  #####     #   #        #####    *
        *  #   #    #        #######  #     #  #         #   #        #        *
        *  #    #   #        #     #  #     #  #         #   #        #        *
        *  #     #  #######  #     #  ######   #        ###  #######  #######  *
        *                                                                      *
        * READFILE          READ COMPLETE FILE INTO STRING                     *
        *                                                                      *
        ************************************************************************
        *
        * READFILE.lss
        *
        -LINE 21 "READFILE.lss"
        -PUBLIC READFILE()
        *
1618             DEFINE('READFILE(FILE)F,U,E')                   :(READFILE_END)
        *
1619    READFILE SYSTEM() 'CSNOBOL4'                               :S(READFILE3)
1620             U = 20
1621             E = CHARS_NL
1622             INPUT(.F, U, FILE)                      :S(READFILE2)F(FRETURN)
1623    READFILE3
1624             U = IO_FINDUNIT()                                   :F(FRETURN)
1625             INPUT(.F, U, 'B,65536', FILE)                       :F(FRETURN)
1626    READFILE2
1627             READFILE = READFILE F E                           :S(READFILE2)
1628    READFILE4
1629             ENDFILE(U)
1630             DETACH(.F)                                            :(RETURN)
        *
1631    READFILE_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'KEYST.INC'
        -IN72
        -STITL AUTOLDR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *       #     #     #  #######  #######  #        ######   ######      *
        *      # #    #     #     #     #     #  #        #     #  #     #     *
        *     #   #   #     #     #     #     #  #        #     #  #     #     *
        *    #     #  #     #     #     #     #  #        #     #  ######      *
        *    #######  #     #     #     #     #  #        #     #  #   #       *
        *    #     #  #     #     #     #     #  #        #     #  #    #      *
        *    #     #   #####      #     #######  #######  ######   #     #     *
        *                                                                      *
        * AUTOLDR                FUNCTION AUTO-LOADER                          *
        *                                                                      *
        ************************************************************************
        *
        * AUTOLDR USES THE INFORMATON GATHERED BY BLDIDX IN FILE 'IDX' TO CREATE
        * STUBS AND TRACE() CALLS FOR FUNCTIONS IN SNOLIB. WHEN ONE OF THE
        * FUNCTIONS IS CALLED, THE SOURCE CODE IS BROUGHT IN. NOTE THAT THIS
        * IN TURN MAY BRING IN OTHER SOURCE FILES. THESE ARE RECORDED IN
        * SLOAD(). IF THE SOURCE FILE IS ALREADY RESIDENT, SLOAD() WILL NOT
        * RELOAD IT, AND THE CALL WILL BE ISSUED NORMALLY AND THE TRACE REMOVED.
        * THIS IS DONE WHETHER OR NOT THE COMPONENT NEEDS LOADING. NOTE THAT
        * THE TRACE IS ESTABLISHED TO CAPTURE THE NAME OF THE FUNCTION. EACH
        * FUNCTION IS INITIALLY DEFINED WITH THE SAME ENTRY POINT (AUTOFUNC).
        * A SINGLE TRACE ON AUTOFUNC IS NOT SUFFICIENT -- EACH FUNCTION MUST
        * BE INDIVIDUALLY TRACED.
        *
        * VARIABLES ARE NOT TRACED -- WE CAN PRE-DECLARE THESE.
        *-INCLUDE 'ARRAY0.INC'
        *-INCLUDE 'CHARS.INC'
        *-INCLUDE 'DISPLAY.INC'
        *-INCLUDE 'GETKEY.INC'
        *-INCLUDE 'HOST.INC'
        *-INCLUDE 'UNIX.INC'
        *
1632             DEFINE('AUTOLDR()F,T,K,I,S')
1633             DEFINE('AUTOTRC(NAME,TAG)')
1634             DEFINE('AUTOFUNC(P1_,P2_,P3_,P4_,P5_,P6_,P7_,P8_)'
1634    +               'FNAME__,RET__')                          :(END_AUTOLDR)
        *
        * THIS IS THE TRACE() HANDLER FOR THE AUTOLOADER. ALL PARAMETERS OF
        * THE FUNCTION HAVE BEEN EVALUATED. LOCALS HAVE BEEN ESTABLISHED, AND
        * FUNCTION RETURN NAME IS AVAILABLE. CAPTURE THE NAME OF THE FUNCTION
        * FROM 'NAME' INTO AUTOFUNC LOCAL FNAME__. REMOVE TRACING FROM THE
        * FUNCTION.
        *
1635    AUTOTRC  FNAME__ = NAME
1636             STOPTR(FNAME__, 'CALL')                               :(RETURN)
        *
        * AUTOFUNC, THE AUTOLOADER FUNCTION LOADER. AUTOTRC (THE TRACE FUNCTION)
        * HAS EXECUTED AND SET THE FUNCTION NAME INTO FNAME__ FIND AND LOAD THE
        * SOURCE FOR THE FUNCTION, APPLY THE FUNCTION. CAPTURE THE RETURN TYPE
        * AND REPLICATE IT BACK TO THE CALLER, ALONG WITH THE FUNCTION RESULTS.
        *
1637    AUTOFUNC SLOAD(FUNCS__<FNAME__ '()'>)
1638             $FNAME__ =
1638    +           APPLY(FNAME__, P1_, P2_, P3_, P4_, P5_, P6_, P7_, P8_)
1639             RET__ = &RTNTYPE                                      :($RET__)
        *
        * READ IDX. ITERATE ALL FUNCTIONS, DEFINING THOSE THAT ARE NOT ALREADY
        * FUNCTIONS AND ESTABLISH TRACE ON THOSE.
        *
1640    AUTOLDR  F = READFILE('IDX')                                 :F(FRETURN)
1641    AUTOLDR2 T = JSON_DECODE(F)
1642             F = JSON_REST
1643             FUNCS__ = IDENT(T<'#'>, 'FUNCTIONS') T
1644             IDENT(FUNCS__)                                     :S(AUTOLDR2)
1645             FUNCS__<'#'> =
1646             K = KEYST(FUNCS__)                                  :F(FRETURN)
1647             I = 1
1648    AUTOLDR3 F = K<I>                                             :F(RETURN)
1649             F '()' =                                           :F(AUTOLDR4)
1650             IDENT(F)                                           :S(AUTOLDR4)
1651             FUNCTION(F)                                        :S(AUTOLDR4)
1652             DEFINE(F '(P1_,P2_,P3_,P4_,P5_,P6_,P7_,P8_)', 'AUTOFUNC')
1653             TRACE(F, 'CALL',, 'AUTOTRC')
1654             AUTOLDR = AUTOLDR + 1
1655    AUTOLDR4 I = I + 1                                          :S(AUTOLDR3)
        *
1656    END_AUTOLDR
        *
        * RETURN IS NUMBER OF FUNCTIONS TRACED
        *
        *        N = AUTOLDR()
        *        &TRACE = 999999999999
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'BALREV.INC'
        -MODULE BALREV
        -LINE 11 "BALREV.lss"
        -IN72
        -LINE 37 "BALREV.lss"
        -STITL BALREV
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *           ######      #     #        ######   #######  #     #       *
        *           #     #    # #    #        #     #  #        #     #       *
        *           #     #   #   #   #        #     #  #        #     #       *
        *           ######   #     #  #        ######   #####    #     #       *
        *           #     #  #######  #        #   #    #         #   #        *
        *           #     #  #     #  #        #    #   #          # #         *
        *           ######   #     #  #######  #     #  #######     #          *
        *                                                                      *
        * BALREV                   BALANCED REVERSE                            *
        *                                                                      *
        ************************************************************************
        *
        * BALREV.lss
        *
        -LINE 14 "BALREV.lss"
        -PUBLIC BALREV()
        *
1657             DEFINE('BALREV(S)')                               :(BALREV_END)
        *
1658    BALREV   BALREV = REPLACE(REVERSE(S), ')(', '()')              :(RETURN)
        *
1659    BALREV_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BALX.INC'
        -MODULE BALX
        -LINE 19 "BALX.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 53 "BALX.lss"
        -STITL BALX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  ######      #     #        #     #                  *
        *                  #     #    # #    #         #   #                   *
        *                  #     #   #   #   #          # #                    *
        *                  ######   #     #  #           #                     *
        *                  #     #  #######  #          # #                    *
        *                  #     #  #     #  #         #   #                   *
        *                  ######   #     #  #######  #     #                  *
        *                                                                      *
        * BALX                      BAL EXTENDED                               *
        *                                                                      *
        ************************************************************************
        *
        * BALX.lss
        *
        -LINE 23 "BALX.lss"
        -PUBLIC BALX()
        *
1660             DEFINE('BALX(PARENS,QTS)Q,GBAL,NAME,STAR,LP,RP')    :(BALX_END)
        *
1661    BALX     NAME = UNIQUE()
1662             STAR = CONVERT(NAME, 'EXPRESSION')
1663             GBAL = NOTANY(PARENS QTS)
1664    BALX_1   QTS LEN(1) . Q =                                     :F(BALX_2)
1665             GBAL = Q BREAK(Q) Q | GBAL                            :(BALX_1)
1666    BALX_2   PARENS LEN(1) . LP  RTAB(1) . PARENS  LEN(1) . RP    :F(BALX_3)
1667             GBAL = LP  (STAR | NULL) RP  |  GBAL                  :(BALX_2)
1668    BALX_3   BALX = GBAL ARBNO(GBAL)
1669             $NAME = BALX                                          :(RETURN)
        *
1670    BALX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BLEND.INC'
        -INCLUDE 'BQ.INC'
        -MODULE BQ
        -LINE 17 "BQ.lss"
        -IN72
        -LINE 75 "BQ.lss"
        -STITL BQ
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                          ######    #####                             *
        *                          #     #  #     #                            *
        *                          #     #  #     #                            *
        *                          ######   #     #                            *
        *                          #     #  #   # #                            *
        *                          #     #  #    #                             *
        *                          ######    #### #                            *
        *                                                                      *
        * BQ          EXECUTE A SHELL COMMAND LINE AND CAPTURE STDOUT          *
        *                                                                      *
        * P BUDNE, JUNE 20, 1994                                               *
        *                                                                      *
        ************************************************************************
        *
        * BQ.lss
        *
        -LINE 20 "BQ.lss"
        -WEAK DDT_ACTIVE, DDT_SUSPEND(), DDT_RESUME()
        -PUBLIC BQ()
        *
1671             DEFINE('BQ(COMMAND,OFS)DDTF')
1672             DEFINE('BQ2(COMMAND,OFS)X,UNIT')                      :(BQ_END)
        *
        -LINE 37 "BQ.lss"
1673    BQ       DDTF = DDT_ACTIVE
1674             NE(DDTF) DDT_SUSPEND()
1675             BQ = BQ2(COMMAND, OFS)                                  :F(BQ3)
1676             NE(DDTF) DDT_RESUME()                                 :(RETURN)
1677    BQ3      NE(DDTF) DDT_RESUME()                                :(FRETURN)
        -LINE 49 "BQ.lss"
1678    BQ2      UNIT = IO_FINDUNIT()                                :F(FRETURN)
1679             INPUT(.X, UNIT,, '|' COMMAND)                       :F(FRETURN)
1680             OFS = IDENT(OFS) ' '
1681             BQ2 = X                                                 :S(BQ4)
1682             ENDFILE(UNIT)
1683             DETACH(.X)                                           :(FRETURN)
1684    BQ4      BQ2 = BQ2 OFS X                                         :S(BQ4)
1685             ENDFILE(UNIT)
1686             DETACH(.X)                                            :(RETURN)
        *
1687    BQ_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BREAKQ.INC'
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CATA.INC'
        -MODULE CATA
        -LINE 11 "CATA.lss"
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 50 "CATA.lss"
        -STITL CATA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #####      #     #######     #                    *
        *                   #     #    # #       #       # #                   *
        *                   #         #   #      #      #   #                  *
        *                   #        #     #     #     #     #                 *
        *                   #        #######     #     #######                 *
        *                   #     #  #     #     #     #     #                 *
        *                    #####   #     #     #     #     #                 *
        *                                                                      *
        * CATA                     CONCATENATE ARRAYS                          *
        *                                                                      *
        ************************************************************************
        *
        * CATA.lss
        *
        -LINE 15 "CATA.lss"
        -PUBLIC CATA()
        *
1688             DEFINE('CATA(A1,A2)I,N1')                           :(CATA_END)
        *
1689    CATA     N1 = PROTOTYPE(A1)
1690             CATA = ARRAY(N1 + PROTOTYPE(A2))
1691             SEQ(' CATA<I> = A1<I> ', .I)
1692             SEQ(' CATA<N1 + I> = A2<I> ', .I)                     :(RETURN)
        *
1693    CATA_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CGI.INC'
        -MODULE CGI
        -USES CRACK(), HOST(), URL_DECODE(), COOKIE_FIX_NAME()
        -WEAK USE_FCGI, FCGI_ENV, FCGI_IN, FCGI_REQUEST_COMPLETE
        -LINE 606 "CGI.lss"
        -WEAK FCGI_SEND(), FCGI_END()
        -LINE 58 "CGI.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'COOKIE.INC'
        -MODULE COOKIE
        -LINE 49 "COOKIE.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'DEXP.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'TIME.INC'
        -STITL TIME
        -EJECT
        *
        -LINE 78 "TIME.lss"
        ************************************************************************
        *                                                                      *
        *                    #######  ###  #     #  #######                    *
        *                       #      #   ##   ##  #                          *
        *                       #      #   # # # #  #                          *
        *                       #      #   #  #  #  #####                      *
        *                       #      #   #     #  #                          *
        *                       #      #   #     #  #                          *
        *                       #     ###  #     #  #######                    *
        *                                                                      *
        * TIME                    DATE/TIME FUNCTIONS                          *
        *                                                                      *
        * PHILE BUDNE <PHIL@ULTIMATE.COM>                                      *
        * DECEMBER 15, 2010                                                    *
        *                                                                      *
        ************************************************************************
        *
        * TIME.lss
        *
        -LINE 11 "TIME.lss"
        -MODULE TIME
        -PUBLIC TIMEVAL(), TV_SEC(), TV_USEC()
1694             DATA('TIMEVAL(TV_SEC,TV_USEC)')
        -PUBLIC TM(), TM_SEC(), TM_MIN(), TM_HOUR(), TM_MDAY(), TM_MON()
        -PUBLIC TM_YEAR(), TM_WDAY(), TM_YDAY(), TM_ISDST(), TM_GMTOFF()
1695             DATA('TM(TM_SEC,TM_MIN,TM_HOUR,TM_MDAY,TM_MON,'
1695    +                'TM_YEAR,TM_WDAY,TM_YDAY,TM_ISDST,TM_GMTOFF)')
        *
1696             LOAD('GETTIMEOFDAY_(TIMEVAL)')
1697             LOAD('LOCALTIME_(INTEGER,TM)')
1698             LOAD('GMTIME_(INTEGER,TM)')
        -PUBLIC STRFTIME()
1699             LOAD('STRFTIME(STRING,TM)STRING')
        -PUBLIC MKTIME()
1700             LOAD('MKTIME(TM)INTEGER')
        -PUBLIC SLEEP()
1701             LOAD('SLEEP(REAL)')
1702             LOAD('STRPTIME_(STRING,STRING,TM)')
        *
        -PUBLIC GETTIMEOFDAY()
1703             DEFINE('GETTIMEOFDAY()TIMEVAL')             :(GETTIMEOFDAY_END)
        *
1704    GETTIMEOFDAY
1705             GETTIMEOFDAY = TIMEVAL()
1706             GETTIMEOFDAY_(GETTIMEOFDAY)                :S(RETURN)F(FRETURN)
        *
1707    GETTIMEOFDAY_END
        *
        -PUBLIC LOCALTIME()
1708             DEFINE('LOCALTIME(T)TM')                       :(LOCALTIME_END)
        *
1709    LOCALTIME
1710             LOCALTIME = TM()
1711             LOCALTIME_(T, LOCALTIME)                   :S(RETURN)F(FRETURN)
        *
1712    LOCALTIME_END
        *
        -PUBLIC GMTIME()
1713             DEFINE('GMTIME(T)TM')                             :(GMTIME_END)
        *
1714    GMTIME   GMTIME = TM()
1715             GMTIME_(T, GMTIME)                         :S(RETURN)F(FRETURN)
        *
1716    GMTIME_END
        *
        -PUBLIC STRPTIME()
1717             DEFINE('STRPTIME(S,F)TM')                       :(STRPTIME_END)
        *
1718    STRPTIME STRPTIME = TM()
1719             STRPTIME_(S, F, STRPTIME)                  :S(RETURN)F(FRETURN)
        *
1720    STRPTIME_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'VDIFFER.INC'
        -LINE 10 "VDIFFER.lss"
        -INCLUDE 'SYSTEM.INC'
        -STITL VDIFFER
        -EJECT
        -LINE 37 "VDIFFER.lss"
        *
        ************************************************************************
        *                                                                      *
        *      #     #  ######   ###  #######  #######  #######  ######        *
        *      #     #  #     #   #   #        #        #        #     #       *
        *      #     #  #     #   #   #        #        #        #     #       *
        *      #     #  #     #   #   #####    #####    #####    ######        *
        *       #   #   #     #   #   #        #        #        #   #         *
        *        # #    #     #   #   #        #        #        #    #        *
        *         #     ######   ###  #        #        #######  #     #       *
        *                                                                      *
        * VDIFFER            RETURN FIRST ARG IF DIFFER                        *
        *                                                                      *
        ************************************************************************
        *
        * VDIFFER.lss
        *
        -LINE 14 "VDIFFER.lss"
        -MODULE VDIFFER
1721             SYSTEM() 'CSNOBOL4'                             :S(VDIFFER_END)
        -PUBLIC VDIFFER()
1722             DEFINE('VDIFFER(P1,P2)')                         :(VDIFFER_END)
        *
1723    VDIFFER  VDIFFER = DIFFER(P1, P2) P1                :F(FRETURN)S(RETURN)
        *
1724    VDIFFER_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 212 "COOKIE.lss"
        -STITL COOKIE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *            #####   #######  #######  #    #  ###  #######            *
        *           #     #  #     #  #     #  #   #    #   #                  *
        *           #        #     #  #     #  #  #     #   #                  *
        *           #        #     #  #     #  ###      #   #####              *
        *           #        #     #  #     #  #  #     #   #                  *
        *           #     #  #     #  #     #  #   #    #   #                  *
        *            #####   #######  #######  #    #  ###  #######            *
        *                                                                      *
        * COOKIE                    HANDLE COOKIES                             *
        *                                                                      *
        ************************************************************************
        *
        * COOKIE.lss
        *
        -LINE 58 "COOKIE.lss"
        -PUBLIC NEW_COOKIE_JAR(), NEW_COOKIE(), COOKIE_SET_VALUE()
        -PUBLIC COOKIE_VALUE(), COOKIE_SET_CRUMB(), COOKIE_GET_CRUMB()
        -PUBLIC PUT_COOKIE_IN_JAR(), GET_COOKIE_FROM_JAR(), COOKIES_IN_JAR()
        -PUBLIC CRUMBS_IN_COOKIE(), COOKIE_EXPIRY(), COOKIE_STRING()
        -PUBLIC COOKIE_FIX_NAME()
        *
1725             DEFINE('NEW_COOKIE_JAR()')
1726             DEFINE('NEW_COOKIE(VALUE)')
1727             DEFINE('COOKIE_SET_VALUE(COOKIE,VALUE)')
1728             DEFINE('COOKIE_VALUE(COOKIE)')
1729             DEFINE('COOKIE_SET_CRUMB(COOKIE,CRUMB_NAME,VALUE)')
1730             DEFINE('COOKIE_GET_CRUMB(COOKIE,CRUMB_NAME)')
1731             DEFINE('PUT_COOKIE_IN_JAR(COOKIE_JAR,COOKIE_NAME,COOKIE)')
1732             DEFINE('GET_COOKIE_FROM_JAR(COOKIE_JAR,COOKIE_NAME)')
1733             DEFINE('COOKIES_IN_JAR(COOKIE_JAR)')
1734             DEFINE('CRUMBS_IN_COOKIE(COOKIE)')
1735             DEFINE('COOKIE_EXPIRY(N)T,D,M,S')
1736             DEXP('L20_(S) = LPAD(S, 2, "0")')
1737             DEFINE('COOKIE_STRING(COOKIE_JAR)A,B,C,I,J,S,V')
1738             DEFINE('COOKIE_FIX_NAME(S)')
1739                                                               :(COOKIE_END)
        *
        * RETURN COOKIE STRING
        *
1740    COOKIE_STRING
1741             A = COOKIES_IN_JAR(COOKIE_JAR)                       :F(RETURN)
1742    COOKIE_STRING_2
1743             I = I + 1
1744             C = GET_COOKIE_FROM_JAR(COOKIE_JAR, A<I>)   :F(COOKIE_STRING_5)
1745             B = CRUMBS_IN_COOKIE(C)                     :F(COOKIE_STRING_2)
1746             S = S 'Set-Cookie: ' A<I> '=' COOKIE_VALUE(C)
1747             J = 1
1748    COOKIE_STRING_3
1749             J = J + 1
1750             V = COOKIE_GET_CRUMB(C, B<J>)               :F(COOKIE_STRING_4)
1751             S = S '; ' B<J>
1752             S = S '=' VDIFFER(V)                         :(COOKIE_STRING_3)
1753    COOKIE_STRING_4
1754             S = S CHARS_CR CHARS_NL                      :(COOKIE_STRING_2)
1755    COOKIE_STRING_5
1756             COOKIE_STRING = S                                     :(RETURN)
        *
        * RETURN EXPIRES STRING FOR N SECONDS IN THE FUTURE. THIS STRING IS
        * IN THE FORMAT:
        * Wed, 09 Jun 2021 10:18:14 GMT
        * ALL COOKIE EXPIRY IS IN GMT.
        *
1757    COOKIE_EXPIRY
1758             T = TV_SEC(GETTIMEOFDAY()) + N
1759             T = GMTIME(T)
1760             '0Sun1Mon2Tue3Wed4Thu5Fri6Sat' TM_WDAY(T) LEN(3) . D
1761             '0Jan1Feb2Mar3Apr4May5Jun6Jul7Aug8Sep9Oct10Nov11Dec'
1761    +           TM_MON(T) LEN(3) . M
1762             S = D ', ' L20_(TM_MDAY(T)) ' ' M ' ' (TM_YEAR(T) + 1900)
1762    +        ' ' L20_(TM_HOUR(T)) ':' L20_(TM_MIN(T)) ':' L20_(TM_SEC(T))
1762    +        ' GMT'
1763             COOKIE_EXPIRY = S                                     :(RETURN)
        *
        * MAKE A NEW COOKIE JAR
        *
1764    NEW_COOKIE_JAR
1765             NEW_COOKIE_JAR = TABLE()                              :(RETURN)
        *
        * MAKE A NEW COOKIE
        *
1766    NEW_COOKIE
1767             NEW_COOKIE = TABLE()
1768             NEW_COOKIE<''> = VDIFFER(VALUE)                       :(RETURN)
        *
        * SET THE VALUE OF THE COOKIE (ATRIBUTE '')
        *
1769    COOKIE_SET_VALUE
1770             COOKIE<''> = VALUE                                    :(RETURN)
        *
        * RETURN THE VALUE OF THE COOKIE (ATTRIBUTE '')
        *
1771    COOKIE_VALUE
1772             COOKIE_VALUE = COOKIE<''>                             :(RETURN)
        *
1773    COOKIE_FIX_NAME
1774             S = TRIMB(S)
1775             S POS(0) '$' REM . S
1776             COOKIE_FIX_NAME = S                                   :(RETURN)
        *
        * SET AN ATTRIBUTE ON THE COOKIE
        *
1777    COOKIE_SET_CRUMB
1778             CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
1779             COOKIE<CRUMB_NAME> = VALUE                            :(RETURN)
        *
        * GET VALUE OF AN ATTRIBUTE FROM THE COOKIE
        *
1780    COOKIE_GET_CRUMB
1781             CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
1782             COOKIE_GET_CRUMB = COOKIE<CRUMB_NAME>                 :(RETURN)
        *
        * PUT THE COOKIE INTO THE COOKIE JAR, WITH NAME COOKIE_NAME
        *
1783    PUT_COOKIE_IN_JAR
1784             COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
1785             COOKIE_JAR<COOKIE_NAME> = COOKIE                      :(RETURN)
        *
        * GET COOKIE NAMED COOKIE_NAME FROM THE COOKIE JAR
        *
1786    GET_COOKIE_FROM_JAR
1787             COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
1788             GET_COOKIE_FROM_JAR = COOKIE_JAR<COOKIE_NAME>         :(RETURN)
        *
        * RETURN ARRAY OF COOKIE NAMES IN THE COOKIE JAR, SORTED.
        *
1789    COOKIES_IN_JAR
1790             COOKIES_IN_JAR = KEYST(COOKIE_JAR)                  :F(FRETURN)
1791             COOKIES_IN_JAR = SORT(COOKIES_IN_JAR)                 :(RETURN)
        *
        * RETURN ARRAY OF CRUMBS IN THE COOKIE, SORTED. THE FIRST CRUMB WILL
        * BE THE UNAMED VALUE OF THE COOKIE.
        *
1792    CRUMBS_IN_COOKIE
1793             CRUMBS_IN_COOKIE = KEYST(COOKIE)                    :F(FRETURN)
1794             CRUMBS_IN_COOKIE = SORT(CRUMBS_IN_COOKIE)             :(RETURN)
        *
1795    COOKIE_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'DSERVE.INC'
        -MODULE DSERVE
        -LINE 48 "DSERVE.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -MODULE CSNOBOL4
        -LINE 15 "CSNOBOL4.lss"
        -INCLUDE 'FFI.INC'
        -IN72
        -LINE 81 "CSNOBOL4.lss"
        -STITL CSNOBOL4
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  #####    #####   #     #  #######  ######   #######  #        #   # *
        * #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *
        * #        #        # #   #  #     #  #     #  #     #  #        #   # *
        * #         #####   #  #  #  #     #  ######   #     #  #        ##### *
        * #              #  #   # #  #     #  #     #  #     #  #            # *
        * #     #  #     #  #    ##  #     #  #     #  #     #  #            # *
        *  #####    #####   #     #  #######  ######   #######  #######      # *
        *                                                                      *
        * CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *
        *                                                                      *
        ************************************************************************
        *
        * CSNOBOL4.lss
        *
        -LINE 27 "CSNOBOL4.lss"
        -PUBLIC SPRINTF()
        *
1796             LOAD('SPRINTF(STRING,)STRING')
        -LINE 42 "CSNOBOL4.lss"
        *
        -PUBLIC IO_GETFP()
        *
1797             IO_GETFP_FFI = FFI_NEW('P', 'I')
1798             FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, 'io_getfp'))
1799             DEFINE('IO_GETFP(UNIT)')                        :(CSNOBOL4_END)
        *
1800    IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
1801             IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 :(RETURN)
        *
1802    CSNOBOL4_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'P64.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'DDT.INC'
        -MODULE DDT
        -WEAK DSERVE_APPNAME
        -USES SLOAD()
        -LINE 706 "DDT.lss"
        -LINE 65 "DDT.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'FREEZE.INC'
        -MODULE FREEZE
        -LINE 7 "FREEZE.lss"
        -INCLUDE 'SYSTEM.INC'
        -IN72
        -LINE 36 "FREEZE.lss"
        -STITL FREEZE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #######  ######   #######  #######  #######  #######         *
        *         #        #     #  #        #             #   #               *
        *         #        #     #  #        #            #    #               *
        *         #####    ######   #####    #####      #      #####           *
        *         #        #   #    #        #         #       #               *
        *         #        #    #   #        #        #        #               *
        *         #        #     #  #######  #######  #######  #######         *
        *                                                                      *
        * FREEZE            FREEZE AND THAW FOR SPITBOL                        *
        *                                                                      *
        ************************************************************************
        *
        * FREEZE.lss
        *
        -LINE 11 "FREEZE.lss"
        -MODULE FREEZE
1803             SYSTEM() 'CSNOBOL4'                              :S(FREEZE_END)
        -PUBLIC FREEZE(), THAW()
1804             DEFINE('FREEZE(X)')
1805             DEFINE('THAW(X)')                                 :(FREEZE_END)
        *
1806    FREEZE
1807    THAW                                                           :(RETURN)
        *
1808    FREEZE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HOST.INC'
        -INCLUDE 'QUOTE.INC'
        -MODULE QUOTE
        -LINE 11 "QUOTE.lss"
        -INCLUDE 'REPL.INC'
        -IN72
        -LINE 38 "QUOTE.lss"
        -STITL QUOTE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #####   #     #  #######  #######  #######             *
        *              #     #  #     #  #     #     #     #                   *
        *              #     #  #     #  #     #     #     #                   *
        *              #     #  #     #  #     #     #     #####               *
        *              #   # #  #     #  #     #     #     #                   *
        *              #    #   #     #  #     #     #     #                   *
        *               #### #   #####   #######     #     #######             *
        *                                                                      *
        * QUOTE                      QUOTE A STRING                            *
        *                                                                      *
        ************************************************************************
        *
        * QUOTE.lss
        *
        -LINE 15 "QUOTE.lss"
        -PUBLIC QUOTE()
        *
1809             DEFINE('QUOTE(S)Q,QQ')                             :(QUOTE_END)
        *
1811    QUOTE    Q = "'"; QQ = '"'
1812             QUOTE = Q REPL(S, Q, Q ' ' QQ Q QQ ' ' Q) Q           :(RETURN)
        *
1813    QUOTE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READLINE.INC'
        -MODULE READLINE
        -LINE 9 "READLINE.lss"
        -IN72
        -LINE 34 "READLINE.lss"
        -STITL READLINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  ######   #######     #     ######   #        ###  #     #  #######  *
        *  #     #  #          # #    #     #  #         #   ##    #  #        *
        *  #     #  #         #   #   #     #  #         #   # #   #  #        *
        *  ######   #####    #     #  #     #  #         #   #  #  #  #####    *
        *  #   #    #        #######  #     #  #         #   #   # #  #        *
        *  #    #   #        #     #  #     #  #         #   #    ##  #        *
        *  #     #  #######  #     #  ######   #######  ###  #     #  #######  *
        *                                                                      *
        * READLINE                 READLINE FUNCTIONS                          *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * JANUARY 3, 2011                                                      *
        *                                                                      *
        ************************************************************************
        *
        * READLINE.lss
        *
        -LINE 12 "READLINE.lss"
        -PUBLIC READLINE(), ADD_HISTORY(), HISTORY_EXPAND()
        *
1814    READLINE LOAD('READLINE(STRING)STRING')
1815             LOAD('ADD_HISTORY(STRING)STRING')
1816             LOAD('HISTORY_EXPAND(STRING)STRING')
        *
1817             CODE('READLINE')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SLOAD.INC'
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'VDIFFER.INC'
        -INCLUDE 'EDITLINE.INC'
        -MODULE EDITLINE
        -LINE 10 "EDITLINE.lss"
        -IN72
        -LINE 163 "EDITLINE.lss"
        -STITL EDITLINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #######  ######   ###  #######  #        ###  #     #  #######    *
        *    #        #     #   #      #     #         #   ##    #  #          *
        *    #        #     #   #      #     #         #   # #   #  #          *
        *    #####    #     #   #      #     #         #   #  #  #  #####      *
        *    #        #     #   #      #     #         #   #   # #  #          *
        *    #        #     #   #      #     #         #   #    ##  #          *
        *    #######  ######   ###     #     #######  ###  #     #  #######    *
        *                                                                      *
        * EDITLINE                 EDIT LINE FUNCTIONS                         *
        *                                                                      *
        ************************************************************************
        *
        * EDITLINE.lss
        *
        -LINE 13 "EDITLINE.lss"
        -LINE 14 "EDITLINE.lss"
        -LINE 15 "EDITLINE.lss"
        -LINE 16 "EDITLINE.lss"
        -LINE 17 "EDITLINE.lss"
        -LINE 18 "EDITLINE.lss"
        -LINE 19 "EDITLINE.lss"
        -LINE 22 "EDITLINE.lss"
1818             EDITLINE = 'editline.c'
        -LINE 122 "EDITLINE.lss"
        -LINE 123 "EDITLINE.lss"
        -LINE 124 "EDITLINE.lss"
        -LINE 125 "EDITLINE.lss"
        -LINE 126 "EDITLINE.lss"
        -LINE 127 "EDITLINE.lss"
        -LINE 136 "EDITLINE.lss"
        *
        -PUBLIC EDITLINE(), RLAPPNAME(), CLEAR_HISTORY(), STIFLE_HISTORY()
        -PUBLIC READ_HISTORY(), WRITE_HISTORY()
        *
1819    EDITLINE LOAD('EDITLINE(STRING,STRING)STRING', 'editline.so')
1820             LOAD('RLAPPNAME(STRING)', 'editline.so')
1821             LOAD('CLEAR_HISTORY()', 'editline.so')
1822             LOAD('STIFLE_HISTORY(INTEGER)', 'editline.so')
1823             LOAD('READ_HISTORY(STRING)INTEGER', 'editline.so')
1824             LOAD('WRITE_HISTORY(STRING)INTEGER', 'editline.so')
        *
1825             CODE('EDITLINE')
        *
        * CE: .MSNOBOL4;
        -IN72
        -STITL DDT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      ######   ######   #######                       *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      ######   ######      #                          *
        *                                                                      *
        * DDT             AN INTERACTIVE SNOBOL4 DEBUGGER                      *
        *                                                                      *
        ************************************************************************
        *
        * DDT.lss
        *
        -LINE 77 "DDT.lss"
        -PUBLIC DDT(), DEBUG(), DDT_LOADED, DDT_ACTIVE
        *
1826             DEFINE('DDT(S)')
1827             DEFINE('DEBUG(S)', 'DDT')
        *
1828             DDT_LOADED = 1
1829             DDT_ACTIVE = 0
        *
        * REMOTE DEBUG, DDT_USE_R IS FLAG TO GET INPUT FROM REMOTE (= 1).
        * IF 2, WE ARE IN GUI.
        * DDT_T IS OUTPUT (ALWAYS) AND DDT_R IN READ CHANNEL. IF DDT_USE_R
        * IS NULL, READLINE() WILL BE USED. IF IT IS NOT NULL, DDT_R WILL
        * BE USED FOR COMMANDS AND INPUT.
        *
        -PUBLIC DDT_T, DDT_USE_R, DDT_R
        *
1830             DDT_T_UNIT = IO_FINDUNIT()
1831             OUTPUT(.DDT_T, DDT_T_UNIT, 'W', '/dev/stderr')
1832             DDT_USE_R =
        *        DDT_R_UNIT = IO_FINDUNIT()
        *        INPUT(.DDT_R, DDT_R_UNIT,, '/dev/stdin')
1833                                                                  :(DDT_END)
        *
1834    DDT      DDT_ACTIVE = 1
1835             DDT_COUNT = 0
1836             DDT_IGNORE =
1837             DDT_UNIT2 =
1838             RLAPPNAME('DDT')
1839             READ_HISTORY('.DDT')
1840             STIFLE_HISTORY(50)
1841             DEFINE('DDT(S)', 'DDT_')
1842             DEFINE('DEBUG(S)', 'DDT_')
1843             DEFINE('DDT_SOURCE()')
        -LINE 120 "DDT.lss"
        -PUBLIC DDT_SUSPEND(), DDT_RESUME(), DDT_TOUT()
1844             DEFINE('DDT_SUSPEND()', 'DDT.O')
1845             DEFINE('DDT_RESUME()')
1846             DEFINE('DDT_TOUT(S)')
        *
1847             DDT_TOUT('DDT (FRI MAY 23 15:30:53 EDT 2014)')
1848             DDT_TOUT('TRY H FOR HELP')
1849             DDT_SOURCE =
1850             DDT_LIST_F =
1851             DDT_LIST_L =
1852             DDT_FINAL_STMT =
1853             DDT_CURR_STMT =
1854             DDT_BREAK_TAB = TABLE()
1855             DDT_BREAK_TEMP = TABLE()
1856             DDT_STEP_COUNT = 1
1857             DDT_FNCLEVEL = 50000
1858             DDT_WHITE = CHARS_HT ' '
1859             DDT_G_PAT = FENCE '=' (BREAK(DDT_WHITE ',') | REM)
1859    +           . DDT_CMD (SPAN(DDT_WHITE ',') | RPOS(0))
1860             DDT_CHARU = CHARS_HT ' CBE=GHKLPQRTI+-?!XOSMV*.'
1861             DDT_CHARL = CHARS_HT ' cbe=ghklpqrti+-?!xosmv*.'
1862             DDT_CHARR =      'C' 'CCBEEGHKLPQRTI+-HXXOSMV*.'
1863             DDT_CHARS = FENCE ANY(DDT_CHARU DDT_CHARL) . DDT_C
1863    +           (SPAN(DDT_WHITE) | '')
1864             DDT_DL_PAT = FENCE LEN(8) (NOTANY(DDT_WHITE)
1864    +           (BREAK(DDT_WHITE CHARS_NL) | REM)) . DDT_LABEL
1865             DDT_GET_PAT1 = FENCE SPAN(&DIGITS) . DDT_GET_STMT
1865    +           (SPAN(DDT_WHITE ',') | RPOS(0))
1866             DDT_GET_PAT2 = FENCE (BREAK(',') | REM) . LABEL
1866    +           (SPAN(DDT_WHITE ',') | RPOS(0))
1867             DDT_GET_PAT3 = FENCE BREAK('+-' DDT_WHITE) . LABEL
1867    +           BREAK('+-') LEN(1) . SIGN BREAK(&DIGITS)
1867    +           SPAN(&DIGITS) . OFFSET
1867    +           (SPAN(DDT_WHITE ',') | RPOS(0))
1868             DEFINE('DDT_LABEL(STNO)OFFSET')
1869             DEFINE('DDT_GET_STMT(S)LABEL,SIGN,OFFSET')
1870             DEFINE('DDT_FNC()')
1871             DEFINE('DDT_CASE(DDT_CASE)')
1872             DEFINE('DDT_CMD()'
1872    +           'DDT_A,DDT_B,DDT_C,DDT_IN,DDT_I,DDT_FIELD,DDT_RESULT,DDT_V')
1873             DEFINE('DDT_READLIST(LABTAB,LAST)'
1873    +           'STNO,STMT,LINE,LABEL,PAT1,PAT2,PAT3,PAT4,PAT5')
1874             DDT_STMTS = TABLE()
1875             DDT_LBLS = TABLE(50, 50)
1876             FREEZE(DDT_STMTS)
1877             FREEZE(DDT_LBLS)
1878             FREEZE(DDT_BREAK_TAB)
1879             FREEZE(DDT_BREAK_TEMP)
1880             HOST(HOST_GETENV, 'LIST')                              :F(DDT_)
1881             DDT_SOURCE()
        *
        -LINE 181 "DDT.lss"
1882    DDT_     S DDT_IGNORE                                          :F(DDT2_)
1883             DDT_COUNT = GT(DDT_COUNT) DDT_COUNT - 1              :S(RETURN)
1884    DDT2_    DDT_STEP_COUNT = 1
1885             DDT_FNCLEVEL = 50000
1886             DDT_TOUT('DDT(' S ')')
1887    DDT_RESUME
1888             &STLIMIT = 999999999
1889             &TRACE = 999999999
1890             TRACE('STCOUNT', 'KEYWORD',, 'DDT_FNC')               :(RETURN)
        *
        * CURRENT STATEMENT
        *
1891    DDT_FNC  DDT_CURR_STMT = &LASTNO
        *
        * IF NOT SINGLE-STEPPING AND DID NOT HIT A BREAKPOINT, JUST RETURN.
        *
1892             (LE(DDT_STEP_COUNT)
1892    +           IDENT(DDT_BREAK_TAB<DDT_CURR_STMT>)
1892    +           IDENT(DDT_BREAK_TEMP<DDT_CURR_STMT>))             :S(RETURN)
        *
        * IF IT WAS A BREAKPOINT, TURN OFF ANY SINGLE-STEPPING.
        *
1893             DDT_STEP_COUNT = DIFFER(DDT_BREAK_TAB<DDT_CURR_STMT>)
1893    +                                                        :S(DDT_DISPLAY)
1894             DDT_STEP_COUNT = DIFFER(DDT_BREAK_TEMP<DDT_CURR_STMT>)
1894    +                                                        :S(DDT_DISPLAY)
        *
        * IF DOING A P TRACE, DON'T STOP IF DOWN IN A FUNCTION.
        *
1895             GT(&FNCLEVEL, DDT_FNCLEVEL)                          :S(RETURN)
        *
        * MUST HAVE BEEN SINGLE-STEPPING. DECREMENT COUNT.
        *
1896             DDT_STEP_COUNT = DDT_STEP_COUNT - 1
        *
        * DISPLAY CURRENT STATEMENT.
        *
1897    DDT_DISPLAY
1898             DIFFER(DDT_HOOK)                              :S(DDT_DISPLAY_2)
1899             DDT_FNC = DDT_LABEL(DDT_CURR_STMT)
1900             DDT_TOUT(VDIFFER(DDT_FNC))
1901             DDT_TOUT(DIFFER(DDT_FINAL_STMT) DDT_STMTS<DDT_CURR_STMT>)
1902             DDT_TOUT(IDENT(DDT_FINAL_STMT) DDT_CURR_STMT)
        *
        * CALL EXTERNAL ROUTINE IF DEFINED TO REGISTER BREAK. THIS CAN
        * REPLICATE SOME OF THE ABOVE IF NEEDED.
        *
        -PUBLIC DDT_HOOK
1903    DDT_DISPLAY_2
1904             DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'BREAK', DDT_CURR_STMT)
        *
        * LISTING BEGINS HERE
        *
1905             DDT_LIST_F = DDT_CURR_STMT
1906             DDT_LIST_L = DDT_CURR_STMT
        *
        * IF MORE SINGLE-STEPPING TO DO, JUST EXIT
        *
1907             GT(DDT_STEP_COUNT)                                   :S(RETURN)
        *
        -LINE 251 "DDT.lss"
1908             THAW(DDT_BREAK_TAB)
1909             THAW(DDT_BREAK_TEMP)
1910             DDT_BREAK_TEMP = TABLE()
1911             DDT_ACTIVE = 1
1912             DDT_CURR_STMT = DDT_CMD()                            :F(RETURN)
        *
        * JUMP TO USER'S LABEL WITHOUT CLEARING INTERRUPT
        *
1913             &TRACE = 999999999                            :($DDT_CURR_STMT)
        *
        * CONVERT TO UPPERCASE IF SOURCE IS NOT CASE SENSITIVE
        *
1914    DDT_CASE DDT_CASE = NE(&CASE)
1914    +           REPLACE(DDT_CASE, &LCASE, &UCASE)                  :(RETURN)
        *
        -LINE 273 "DDT.lss"
1915    DDT_LABEL
1916             IDENT(DDT_FINAL_STMT)                                :S(RETURN)
1917    DDT_LAB2 DDT_STMTS<STNO> DDT_DL_PAT                         :S(DDT_LAB1)
1918             STNO = GT(STNO, 1) STNO - 1                        :F(DDT_LAB1)
1919             OFFSET = OFFSET + 1                                 :(DDT_LAB2)
1920    DDT_LAB1 DDT_LABEL = IDENT(OFFSET) '(' DDT_LABEL ')'          :S(RETURN)
1921             DDT_LABEL = '(' DDT_LABEL ' + ' OFFSET ')'            :(RETURN)
        *
        -LINE 293 "DDT.lss"
1922    DDT_GET_STMT
1923             IDENT($S)                                            :S(RETURN)
        * CHECK FOR SIMPLE NUMBER
1924             $S DDT_GET_PAT1 =                                    :S(RETURN)
        * CHECK FOR TEXT LABEL
1925             $S DDT_GET_PAT2 =                                  :F(DDT_GET1)
        * CHECK FOR OPTIONAL +N OR -N AFTER LABEL
1926             LABEL DDT_GET_PAT3
1927             OFFSET = IDENT(SIGN, '-') -OFFSET
        * MAP CASE-CONVERTED LABEL TO STATEMENT NUMBER
1928             DDT_GET_STMT = DDT_LBLS<DDT_CASE(LABEL)>
        * CHECK IF LABEL UNKNOWN TO US, AND ADD OFFSET.
1929             DDT_GET_STMT = VDIFFER(DDT_GET_STMT)
1929    +           + OFFSET                                          :S(RETURN)
1930    DDT_GET1 DDT_TOUT('BAD LABEL OR STATEMENT NUMBER')            :(FRETURN)
        *
        -LINE 318 "DDT.lss"
1931    DDT_READLIST
1932             PAT1 = FENCE (LEN(4) | SPAN(&DIGITS)) . STNO
1932    +           (LEN(4) | '') REM . STMT
1933             PAT2 = FENCE (NOTANY('-+.*;|#! ' CHARS_NP CHARS_HT)
1933    +           BREAK(CHARS_HT ' ') ) . LABEL
1934             PAT3 = FENCE NOTANY(&DIGITS ' ' CHARS_HT)
1935             PAT4 = FENCE ANY('+.')
1936             PAT5 = FENCE ANY('*;|#!')
1937             DDT_READLIST = TABLE(151)
1938    DDT_RL1  LINE = TRIM(DDT_SOURCE)                              :F(RETURN)
1939             IDENT(LINE)                                         :S(DDT_RL1)
1940             LINE PAT1                                           :F(DDT_RL1)
        * IGNORE PAGE THROW, ERROR MESSAGE, FORM FEED, AND TITLES IN LISTING
        * FILE.
1941             STNO PAT3                                           :S(DDT_RL1)
1942             STNO = TRIM(STNO)
1943             INTEGER(STNO)                                       :F(DDT_RL4)
        * IGNORE COMMENTS
1944             STMT PAT5                                           :S(DDT_RL1)
        * CONTINUATION LINES
1945             STMT PAT4                                           :S(DDT_RL2)
        * ADJUST $LAST IF NEW STATEMENT NUMBER
1946             $LAST = +VDIFFER(STNO)                    :S(DDT_RL3)F(DDT_RL1)
        * APPEND LF TO EXISTING TEXT IF CONTINUED STATEMENT
1947    DDT_RL2  DDT_READLIST<$LAST> = VDIFFER(DDT_READLIST<$LAST>) CHARS_NL
        * PLACE STATEMENT IN TABLE
1948    DDT_RL3  DDT_READLIST<$LAST> = DDT_READLIST<$LAST> LINE
        * EXTRACT LABEL
1949             (STMT ' ') PAT2                                     :F(DDT_RL1)
        * RECORD CASE-CONVERTED LABEL TO STATEMENT NUMBER MAPPING
1950             ITEM(LABTAB, DDT_CASE(LABEL)) = $LAST                :(DDT_RL1)
1951    DDT_RL4  DDT_TOUT('INCORRECT PROGRAM LIST FILE, LINE IN ERROR:')
1952             DDT_TOUT(LINE)                                       :(FRETURN)
        *
        -LINE 363 "DDT.lss"
1953    DDT_CMD  IDENT(DDT_UNIT2)                                   :S(DDT_CMD2)
1954             DDT_IN = DDT_INPUT                                 :F(DDT_CMD4)
1955             DDT_TOUT('DDT: ' DDT_IN)                            :(DDT_CMD3)
1956    DDT_CMD4 ENDFILE(DDT_UNIT2)
1957             DETACH(.DDT_INPUT)
1958             DDT_UNIT2 =
1959    DDT_CMD2 DDT_LL2 = DDT_LL
1960             IDENT(DDT_USE_R)                                   :S(DDT_CMD5)
1961             DDT_TOUT(EQ(DDT_USE_R, 1) 'DDT REMOTE (' DSERVE_APPNAME ')')
        *
        * NOTE: THIS IS THE ONLY READ FROM DDT_R.
        *
        * IF DDT_HOOK IS DEFINED, WE WILL CALL WITH THAT WITH 'READ'. SEE
        * DDT_HOOK CALL WITH 'DISPLAY' ABOVE. IF THIS FAILS, WE ASSUME NORMAL
        * READ IS NEEDED. IF USE_DDT_R, AND DDT_HOOK IS NOT SET, WE READ
        * FROM DDT_R.
        *
1962             IDENT(DDT_HOOK)                                    :S(DDT_CMD7)
1963             DDT_IN = TRIM(APPLY(DDT_HOOK, 'READ'))  :F(DDT_CMD5)S(DDT_CMD3)
1964    DDT_CMD7 DDT_IN = TRIM(DDT_R)                       :S(DDT_CMD3)F(DDT.O)
1965    DDT_CMD5 DDT_IN = TRIM(HISTORY_EXPAND(READLINE('DDT: ')))      :F(DDT.O)
        *
        * ONLY ADD NON-NULL COMMANDS THAT DIFFER FROM LAST COMMAND TO HISTORY
        *
1966    DDT_CMD6 IDENT(DDT_IN)                                       :S(DDT_CMD)
1967             DDT_LL = DDT_IN
1968             ADD_HISTORY(VDIFFER(DDT_IN, DDT_LL2))
1969    DDT_CMD3 IDENT(DDT_IN)                                       :S(DDT_CMD)
        *
        * TEST FOR VALID COMMAND AND BRANCH TO APPROPRIATE PROCESSOR (DDT.?).
        * LOWER-CASE COMMANDS ARE EQUIVALENT TO UPPER-CASE, AND BLANK AND
        * TAB ARE CONVERTED TO THE COMMAND 'C'.
        *
1970             DDT_IN DDT_CHARS =                              :F(DDT_CMD_ERR)
1971             DDT_STEP_COUNT = 0
1972                           :($('DDT.' REPLACE(DDT_C, DDT_CHARL, DDT_CHARR)))
        *
        *** INVALID COMMAND
        *
1973    DDT_CMD_ERR
1974             DDT_TOUT('?')                                        :(DDT_CMD)
        *
        *** TURN OFF DEBUGGER
        *
1975    DDT.O    DDT_ACTIVE = 0
1976             WRITE_HISTORY('.DDT')
1977             &STLIMIT = -1
1978             STOPTR('STCOUNT', 'KEYWORD')                         :(FRETURN)
        *
        *** V - VIEW FILE
        *
1979    DDT.V    DDT_IN = IDENT(DDT_IN) DDT_FNAME
1980             (IDENT(DDT_IN) DIFFER(DDT_USE_R))                    :S(DDT.V2)
1981             DDT_IN = IDENT(DDT_IN) READLINE('FILE: ')
1982             DDT_FNAME = VDIFFER(DDT_IN)                         :F(DDT_CMD)
        *
        * FIXME: NEED SOMETHING BETTER. LIST FOR LOCAL, BUT DUMP TO DDT_T FOR
        * REMOTE.
        *
1983             HOST(HOST_SYSCMD, 'LIST ' DDT_IN)                    :(DDT_CMD)
1984    DDT.V2   DDT_TOUT('USE V FILENAME')                           :(DDT_CMD)
        *
        *** M - MODIFY VARIABLE
        *
1985    DDT.M    IDENT(DDT_IN)                                       :S(DDT_CMD)
1986             DDT_TOUT(DIFFER(DDT_USE_R) 'SORRY, NEED EDITLINE')  :S(DDT_CMD)
1987             DATATYPE($DDT_IN) 'STRING' | 'NAME' | 'INTEGER' | 'REAL'
1987    +                                                             :S(DDT.M2)
1988             DDT_TOUT("SORRY, CAN'T MODIFY " DATATYPE($DDT_IN))   :(DDT_CMD)
1989    DDT.M2   $DDT_IN = EDITLINE('EDIT<' DDT_IN '>: ', $DDT_IN)    :(DDT_CMD)
        *
        *** . - SOURCE FILE
        *
1990    DDT..    IDENT(DDT_UNIT2)                                     :S(DDT..1)
1991             DDT_TOUT('. COMMANDS CANNOT BE NESTED')               :(DDT..2)
1992    DDT..1   IDENT(DDT_IN)                                       :S(DDT_CMD)
1993             DDT_TOUT('SOURCING ' DDT_IN)
1994             DDT_UNIT2 = IO_FINDUNIT()
1995             INPUT(.DDT_INPUT, DDT_UNIT2,, DDT_IN)               :S(DDT_CMD)
1996             DDT_TOUT('CANNOT OPEN ' DDT_IN)
1997    DDT..2   ENDFILE(DDT_UNIT2)
1998             DETACH(.DDT_INPUT)
1999             DDT_UNIT2 =                                          :(DDT_CMD)
        *
        *** * - COMMENT
        *
2000    DDT.*                                                         :(DDT_CMD)
        *
        *** H OR ? - HELP
        *
        -LINE 611 "DDT.lss"
2001    DDT.H
2002     DDT_TOUT('STNO - STATEMENT NUMBERS SPECIFIED AS INTEGERS, OR LABEL+-N')
2003     DDT_TOUT('          BRACKETED ITEMS ARE OPTIONAL')
2004     DDT_TOUT('H            (OR ?)     HELP (THIS LIST)')
2005     DDT_TOUT('C STATEMENT  (OR TAB)   IMMEDIATE EXECUTION OF STATEMENT')
2006     DDT_TOUT('E EXPRESSION (OR =EXP)  EVALUATE EXPRESSION')
2007     DDT_TOUT('X COMMAND    (OR !)     EXECUTE SHELL COMMAND')
2008     DDT_TOUT('T [N]                   TRACE N STATEMENTS (INTO PROCS)')
2009     DDT_TOUT('P [N]                   TRACE N STATEMENTS (NO PROCEDURES)')
2010     DDT_TOUT('B STNO [,STNO,...]      SET BREAKPOINT(S)')
2011     DDT_TOUT('K BKPT [,BKPT,...]      KILL BREAKPOINT(S)')
2012     DDT_TOUT('R                       REPORT BREAKPOINTS SET')
2013     DDT_TOUT('G [=LABEL,](STNO1,...]  GO (FROM SPECIFIED LABEL),')
2014     DDT_TOUT('                          SET TEMPORARY BREAKPOINT(S)')
2015     DDT_TOUT('L [STNO1 [,STNO2]]      LIST STATEMENT OR RANGE')
2016     DDT_TOUT('+ [N]  OR  -[N]         LIST NEXT/PREVIOUS N STATEMENTS')
2017     DDT_TOUT('++ OR --                LIST 12 STATEMENTS FORWARD OR BACK')
2018     DDT_TOUT('Q                       QUIT')
2019     DDT_TOUT('O (OR ^D)               OFF - RESUME PROGRAM, STOP DEBUG')
2020     DDT_TOUT('S [FILE]                LOAD SOURCE')
2021     DDT_TOUT('M NAME                  MODIFY VARIABLE')
2022     DDT_TOUT("I 'MSG' N               IGNORE NEXT N CALLS TO DDT(MSG)")
2023     DDT_TOUT('* COMMENT               COMMENT (NO ACTION)')
2024     DDT_TOUT('. FILE                  SOURCE FILE (DO NOT NEST)')
2025     DDT_TOUT('V (FILE)                VIEW FILE (DEFAULT TO LIST FILE)')
2026                                                                  :(DDT_CMD)
        *
        *** I - IGNORE
        *
        *       CALLS TO DDT() OR DEBUG() MAY HAVE A STRING. THE I COMMAND
        *       IGNORES THE NEXT N CALLS TO DDT() WITH A MATCHING STRING.
        *       NORMALLY, I IS FOLLOWED BY O TO EXECUTE AT FULL SPEED.
        *
2027    DDT.I    DDT_IGNORE =
2028             DDT_IN (("'" ARB . DDT_IGNORE "'") | '') SPAN(DDT_WHITE ',')
2028    +           SPAN(&DIGITS) . DDT_COUNT RPOS(0)                :S(DDT_CMD)
2029             DDT_TOUT('BAD I SYNTAX')                             :(DDT_CMD)
        *
        *** Q - QUIT
        *
2030    DDT.Q    WRITE_HISTORY('.DDT')                                    :(END)
        *
        *** X - EXECUTE SHELL COMMAND
        *
2031    DDT.X    HOST(HOST_SYSCMD, DDT_IN)
2032             DDT_TOUT()                                           :(DDT_CMD)
        *
        *** C - IMMEDIATE EXECUTION OF AN UNLABELED CODE STATEMENT.
        *       APPEND OUR OWN GOTOS TO REGAIN CONTROL AFTER EXECUTION.
        *
2033    DDT.C    DDT_C = CODE(' ' DDT_IN ' :S(DDT_SS)F(DDT_FF)')       :S<DDT_C>
2034             DDT_TOUT('COMPILATION ERROR: ' &ERRTEXT)             :(DDT_CMD)
2035    DDT_SS   DDT_TOUT('SUCCESS')                                  :(DDT_CMD)
2036    DDT_FF   DDT_TOUT('FAILURE')                                  :(DDT_CMD)
        *
        *** E - EXAMINE VARIABLE OR EVALUATE EXPRESSION. WE DISPLAY STRINGS,
        *       NUMBERS AS SCALARS, ARRAYS AND TABLES AS PROTOTYPES, CODE,
        *       EXPRESSION, PATTERN AS TYPE NAME, USER TYPES ARE DISPLAYED AS
        *       MEMBERS
        *
        * FIXME - DATATYPE 'NAME' MAY BE AN ISSUE, SEE READL.INC AND FIX HERE
        *         AND IN MODIFY DDT.M
        *
2037    DDT.E    DDT_RESULT = EVAL(DDT_IN)                            :F(DDT.E2)
2038             DDT_V = DATATYPE(DDT_RESULT)
2039             IDENT(DDT_RESULT)                                    :S(DDT.E3)
2040             DDT_RESULT = ?(DDT_V ? 'STRING' | 'NAME') QUOTE(DDT_RESULT)
2040    +                                                             :S(DDT.E3)
2041             DDT_V 'INTEGER' | 'REAL'                             :S(DDT.E3)
2042             DDT_RESULT = ?(DDT_V ? 'CODE' | 'EXPRESSION' | 'PATTERN' |
2042    +           'TABLE' | 'ARRAY') CONVERT(DDT_RESULT, 'STRING')  :S(DDT.E3)
        *
        * USER DEFINED DATATYPE - FIELD('TYPE',1..N)
        *
2043             DDT_TOUT(DATATYPE(DDT_RESULT))
2044             DDT_I =
2045    DDT.E4   DDT_I = DDT_I + 1
2046             DDT_FIELD = FIELD(DATATYPE(DDT_RESULT), DDT_I)      :F(DDT_CMD)
2047             DDT_V = DATATYPE(APPLY(DDT_FIELD, DDT_RESULT))
2048             DDT_V = IDENT(APPLY(DDT_FIELD, DDT_RESULT))          :S(DDT.E5)
2049             DDT_V = ?(DDT_V ? 'STRING' | 'NAME')
2049    +           QUOTE(APPLY(DDT_FIELD, DDT_RESULT))               :S(DDT.E5)
2050             DDT_V = ?(DDT_V ? 'INTEGER' | 'REAL')
2050    +           APPLY(DDT_FIELD, DDT_RESULT)                      :S(DDT.E5)
2051             DDT_V = CONVERT(APPLY(DDT_FIELD, DDT_RESULT), 'STRING')
2052    DDT.E5   DDT_TOUT('    ' RPAD(DDT_FIELD, 10) ': ' DDT_V)       :(DDT.E4)
2053    DDT.E3   DDT_TOUT(DDT_RESULT)                                 :(DDT_CMD)
2054    DDT.E2   DDT_TOUT('EVALUATION ERROR: ' &ERRTEXT)              :(DDT_CMD)
        *
        *** T - STEP N STATEMENTS, DESCENDING INTO PROCEDURES
        *
2055    DDT.T    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
2056             FREEZE(DDT_BREAK_TAB)
2057             FREEZE(DDT_BREAK_TEMP)
2058             DDT_FNCLEVEL = 50000
2059             DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
        *
        *** P - STEP N STATEMENTS, TREAT PROCEDURES AS INTACT ENTITIES
        *
2060    DDT.P    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
2061             FREEZE(DDT_BREAK_TAB)
2062             FREEZE(DDT_BREAK_TEMP)
2063             DDT_FNCLEVEL = &FNCLEVEL - 1
2064             DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
        *
        *** R - REPORT BREAKPOINTS
        *
2065    DDT.R    DDT_A = SORT(DDT_BREAK_TAB)                          :F(DDT_R2)
2066             DDT_C = 0
2067    DDT_R1   DDT_C = DDT_C + 1
2068             DDT_TOUT(DDT_A<DDT_C, 1> ' '
2068    +           DDT_LABEL(DDT_A<DDT_C, 1>))             :S(DDT_R1)F(DDT_CMD)
2069    DDT_R2   DDT_TOUT('NONE')                                     :(DDT_CMD)
        *
        *** K - KILL BREAKPOINT(S)
        *
2070    DDT.K    IDENT(DDT_IN)                                       :S(DDT_CMD)
2071             DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> =     :S(DDT.K)F(DDT_CMD)
        *
        *** B - SET BREAKPOINT(S)
        *
2072    DDT.B    IDENT(DDT_IN)                                       :S(DDT_CMD)
2073             DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> = 1   :S(DDT.B)F(DDT_CMD)
        *
        *** G - GO <=OPTIONAL DIRECT TRANSFER LABEL> <OPTIONAL BREAKPOINTS(S)>
        *
        * FIRST TEST FOR SIMPLE G BY ITSELF
2074    DDT.G    DDT_STEP_COUNT = 0
2075             IDENT(DDT_IN)                                       :S(FRETURN)
        * CHECK FOR =LABEL, ASSIGN LABEL TO DDT_CMD
2076             DDT_IN DDT_G_PAT =                                   :F(DDT_G1)
2077             DDT_CMD = DDT_CASE(DDT_CMD)
        * ERROR IF LABEL UNKNOWN
2078             DDT_TOUT(IDENT(DDT_LBLS<DDT_CMD>) 'UNKNOWN LABEL ='
2078    +           DDT_CMD)                                         :S(DDT_CMD)
        * PROCESS ANY BREAKPOINTS
2079    DDT_G1   DIFFER(DDT_IN)                                       :F(DDT_G2)
2080             DDT_BREAK_TEMP<+DDT_GET_STMT(.DDT_IN)> = 1 :S(DDT_G1)F(DDT_CMD)
        * CHOOSE FRETURN TO RESUME EXECUTION WHERE INTERRUPTED, RETURN TO
        * TRANSFER TO THE LABEL IN DDT_CMD.
2081    DDT_G2   FREEZE(DDT_BREAK_TEMP)
2082             FREEZE(DDT_BREAK_TAB)
2083             DIFFER(DDT_CMD)                            :S(RETURN)F(FRETURN)
        -LINE 648 "DDT.lss"
        *
        *** L - LIST STATEMENT(S)
        *
        * DISPATCH IF L BY ITSELF
2084    DDT.L    DDT_A = IDENT(DDT_IN) DDT_CURR_STMT                  :S(DDT_L1)
        * GET FIRST LINE NUMBER
2085             DDT_A = +DDT_GET_STMT(.DDT_IN)                      :F(DDT_CMD)
        * IF JUST ONE, DISPLAY IT BY ITSELF
2086             IDENT(DDT_IN)                                        :S(DDT_L1)
        * IF ANOTHER, GET IT AS THE ENDING LINE NUMBER
2087             DDT_C = +DDT_GET_STMT(.DDT_IN)             :S(DDT_L2)F(DDT_CMD)
        * DISPLAY ONE LINE AT DDT_A
2088    DDT_L1   DDT_C = DDT_A
        * USE DDT_C AS THE REFERENCE FOR SUBSEQUENT DISPLAY
2089    DDT_L2   DDT_B = .DDT_C
        * CHECK RANGE OF VALUES SPECIFIED
2090             IDENT(DDT_FINAL_STMT)                               :S(DDT_CMD)
2091             DDT_A = LT(DDT_A, 1) 1
2092             DDT_A = GT(DDT_A, DDT_FINAL_STMT) DDT_FINAL_STMT
2093             DDT_C = LT(DDT_C, DDT_A) DDT_A
2094             DDT_C = GT(DDT_C, DDT_FINAL_STMT) DDT_FINAL_STMT
2095             DDT_LIST_F = DDT_A
2096             DDT_LIST_L = DDT_C
        * DISPLAY LOOP
2097    DDT_L3   DDT_TOUT(VDIFFER(DDT_STMTS<DDT_A>))
2098             DDT_A = LT(DDT_A, DDT_C) DDT_A + 1         :S(DDT_L3)F(DDT_CMD)
        *
        *** +<N> - LIST NEXT STATEMENT(S), ++ LISTS THE NEXT 12 LINES.
        *
2099    DDT.+    DDT_A = DDT_LIST_L + 1
2100             DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L4)
2101             DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
2102             DDT_C = LE(DDT_C) 1
2103    DDT_L4   DDT_C = DDT_A + DDT_C - 1                             :(DDT_L2)
        *
        *** -<N> - LIST PREVIOUS STATEMENT(S), -- LISTS THE PREVIOUS 12 LINES.
        *
2104    DDT.-    DDT_B = DDT_LIST_F - 1
2105             DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L5)
2106             DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
2107             DDT_C = LE(DDT_C) 1
2108    DDT_L5   DDT_A = DDT_B - DDT_C + 1
2109             DDT_C = DDT_B                                         :(DDT_L2)
2110    DDT_TOUT DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'DISPLAY', S)
2111             DDT_T = S                                             :(RETURN)
        *
        *** S(FILE) - LOAD SOURCE LISTING
        *
2112    DDT.S    DDT_SOURCE()                                         :(DDT_CMD)
        *
2113    DDT_SOURCE
2114             THAW(DDT_STMTS)
2115             THAW(DDT_LBLS)
2116             DDT_LBLS = TABLE(50, 50)
2117             DDT_FINAL_STMT =
2118             DDT_UNIT = IO_FINDUNIT()
2119             DDT_FNAME = TRIMB(DDT_IN)
2120             DIFFER(DDT_FNAME)                                    :S(DDT_S3)
2121             INPUT('DDT_SOURCE', DDT_UNIT,,
2121    +              DDT_FNAME = HOST(HOST_GETENV, 'LIST'))         :S(DDT_S1)
2122             DDT_TOUT(DIFFER(DDT_USE_R) 'USE S FILE')             :S(DDT_S2)
2123             DDT_FNAME = TRIM(HISTORY_EXPAND(READLINE('LISTING: ')))
2124    DDT_S3   INPUT('DDT_SOURCE', DDT_UNIT,, DDT_FNAME)            :S(DDT_S1)
2125             DDT_FNAME =
2126             DDT_TOUT('NO LISTING FILE PROVIDED')                  :(DDT_S2)
2127    DDT_S1   DDT_STMTS = DDT_READLIST(DDT_LBLS, .DDT_FINAL_STMT)
2128             ENDFILE(DDT_UNIT)
2129             DETACH(.DDT_SOURCE)
2130             DDT_TOUT(DIFFER(DDT_FINAL_STMT) 'SOURCE LISTING LOADED')
2131    DDT_S2   FREEZE(DDT_STMTS)
2132             FREEZE(DDT_LBLS)                                      :(RETURN)
        *
2133    DDT_END
        *
        *
        * CE: .F.MSNOBOL4;
        -IN72
        -LINE 252 "DSERVE.lss"
        -STITL DSERVE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######    #####   #######  ######   #     #  #######         *
        *         #     #  #     #  #        #     #  #     #  #               *
        *         #     #  #        #        #     #  #     #  #               *
        *         #     #   #####   #####    ######   #     #  #####           *
        *         #     #        #  #        #   #     #   #   #               *
        *         #     #  #     #  #        #    #     # #    #               *
        *         ######    #####   #######  #     #     #     #######         *
        *                                                                      *
        * DSERVE                  DDT TELNET SERVER                            *
        *                                                                      *
        ************************************************************************
        *
        * DSERVE.lss
        *
        -LINE 58 "DSERVE.lss"
        -PUBLIC DSERVE_INIT(), DSERVE()
        -PUBLIC DSERVE_PORT, DSERVE_APPNAME
        *
2134             DEFINE('DSERVE_INIT(APPNAME,PORT,KEY,INTR)') :(DSERVE_INIT_END)
        *
2135    DSERVE_INIT
2136             DSERVE_KEY = KEY
2137             DSERVE_PORT = PORT
2138             DSERVE_APPNAME = APPNAME
2139             DSERVE_INTR = INTR
        *
2140             DSERVE_PID = GETPID()
2141             P1 = PIPE()                                         :F(DSERVE9)
2142             DSERVE_P1_RFD = P1<1>
2143             DSERVE_P1_WFD = P1<2>
2144             P2 = PIPE()                                         :F(DSERVE9)
2145             DSERVE_P2_RFD = P2<1>
2146             DSERVE_P2_WFD = P2<2>
2147             PID = FORK()                                        :F(DSERVE9)
2148             LT(PID)                                             :S(DSERVE9)
2149             EQ(PID)                                             :S(DSERVE2)
        *
        * PRIMORDIAL PROCESS - POLLS WITH DSERVE() WAITING FOR CONNECTION AND
        * DEBUGGER ENTRY
        *
        * NEEDS FD SET AND TIMEVAL FOR SELECT
        *
2150             DSERVE_FDS = NEW_FD_SET()
2151             DSERVE_TV = NEW_TIMEVAL()
2152             IDENT(DSERVE_INTR)                                   :S(RETURN)
        *
2153             &ERRLIMIT = 1
2154             SETEXIT('DSERVE_TRAP')                                :(RETURN)
        *
2155    DSERVE_INIT_END
        *
2156             DEFINE('DSERVE()N,S')                             :(DSERVE_END)
        *
        * IF DDT IS ALREADY ACTIVE, WE ARE DEBUGGING THROUGH A DSERVE() POLL,
        * JUST RETURN. IF DSERVE_APPNAME IS NULL, RETURN, DSERVE HAS NOT
        * BEEN SET UP CORRECTLY YET.
        *
2157    DSERVE   NE(DDT_ACTIVE)                                       :S(RETURN)
2158             IDENT(DSERVE_APPNAME)                                :S(RETURN)
        *
        * SEE IF THERE IS INPUT AVAILABLE FROM THE NET. USE SELECT() TO POLL
        * THE READ FILE DESCRIPTOR, WITH A TIMEOUT OF 0 (NO WAIT)
        *
2159             SET_TIMEVAL(DSERVE_TV, 0, 0)
2160             FD_ZERO(DSERVE_FDS)
2161             FD_SET(DSERVE_P2_RFD, DSERVE_FDS)
2162             N = SELECT(DSERVE_P2_RFD + 1, DSERVE_FDS, 0, 0, DSERVE_TV)
2163             EQ(N)                                                :S(RETURN)
        *
        * WE HAVE DATA ON THE READ FD. CREATE I/O CHANNELS TO TELNET I/O
        * PROCESSES.
        *
2164             OUTPUT(.DDT_T, 10, 'W', '/dev/fd/' DSERVE_P1_WFD)   :F(DSERVE9)
2165             INPUT(.DDT_R, 11,, '/dev/fd/' DSERVE_P2_RFD)        :F(DSERVE9)
        *
        * READ MESSAGE FROM NET PROCESS. WE HAVE A MESSAGE TO BE READ
        * (BUT IT MAY NOT BE COMPLETE YET). WE RELY ON NORMAL I/O MECHANISM
        * TO DELIVER COMPLETE MESSAGE LINE.
        *
2166             S = DDT_R
2167             IDENT(S, 'DDT')                                     :S(DSERVE7)
2168             DSERVE = S                                            :(RETURN)
2169    DSERVE7  DDT_T = NE(DDT_ACTIVE) 'APP ALREADY IN DDT'          :S(RETURN)
2170             DDT_USE_R = 1
2171             DSERVE = 'DDT'
        *
        * THE MESSAGE IS 'DDT' WHICH MEANS ENTER DEBUGGER. THE DEBUGGER IS
        * NOT YET ACTIVE. WHEN DSERVE() RETURNS, IT WILL BE UNDER DDT CONTROL.
        * WE SET DDT_USE_R TO 1 TO INFORM DDT OF THE I/O NEEDED (READLINE
        * CANNOT BE USED).
        *
2172             DDT(DSERVE_APPNAME)
2173                                                                   :(RETURN)
        *
        * SETEXIT() TRAP TO ENTER DDT -- NEED DDT() ENTRY THAT DOES ONE STEP
        * COMMAND.
        *
2174    DSERVE_TRAP
2175             OUTPUT(.DDT_T, 10, 'W', '/dev/fd/' DSERVE_P1_WFD)   :F(DSERVE9)
2176             INPUT(.DDT_R, 11,, '/dev/fd/' DSERVE_P2_RFD)        :F(DSERVE9)
2177             S = DDT_R
2178             IDENT(S, 'DDT')                                    :S(DSERVET2)
2179             DSERVE = S                                          :(DSERVET3)
2180    DSERVET2 DDT_T = NE(DDT_ACTIVE) 'APP ALREADY IN DDT'        :S(DSERVET3)
2181             DDT_USE_R = 1
2182             DSERVE = 'DDT'
2183             DDT(DSERVE_APPNAME)
2184                                                                :(SCONTINUE)
2185    DSERVET3 SETEXIT('DSERVE_TRAP')
2186             &ERRLIMIT = 1                                      :(SCONTINUE)
        *
        * CONNECTION LISTENER PROCESS
        *
        * CREATE I/O CHANNELS TO PRIMORDIAL PROCESS. THE PRIMORDIAL PROCESS
        * WILL POLL WAITING FOR A MESSAGE TO BE WRITTEN TO TO_PRIMORDIAL.
        *
2187    DSERVE2  INPUT(.FROM_PRIMORDIAL, 12,, '/dev/fd/' DSERVE_P1_RFD)
2187    +                                                            :F(DSERVE9)
2188             OUTPUT(.TO_PRIMORDIAL, 13, 'W', '/dev/fd/' DSERVE_P2_WFD)
2188    +                                                            :F(DSERVE9)
        *
        * WAIT FOR A CONNECTION ON DSERVE_PORT
        *
2189    DSERVE3  FDN = SERV_LISTEN('inet', 'stream', DSERVE_PORT)    :F(DSERVE9)
2190             INPUT(.NET, 9, 'UWT', '/dev/fd/' FDN)               :F(DSERVE9)
2191             OUTPUT(.NET, 9)                                     :F(DSERVE9)
2192             CRLF = CHARS_CR CHARS_LF
        *
        * WE HAVE A CONNECTION. DISPLAY SIGNON, AND REQUEST LOGIN. THE LOGIN
        * IS A SIMPLE STRING PASSED AS DSERVE_KEY
        *
2193             NET = 'DSERVE ' DSERVE_APPNAME CRLF
2194             NET = CRLF
2195             NET = 'LOGIN REQUIRED: ' CRLF
2196             S = NET
2197             S = REPL(S, CRLF)
2198             S = TRIMB(S)
        *
        * LOGIN IS PLAINTEXT. THIS SHOULD ONLY BE USED OVER TELNET RUNNING ON
        * THE SAME HOST AS THE APPLICATION BEING DEBUGGED. THERE IS NO USER
        * NAME/PASSWORD -- JUST A SINGLE MAGIC WORD.
        *
2199             IDENT(S, DSERVE_KEY)                                :S(DSERVE8)
2200             NET = 'BAD LOGIN' CRLF                                   :(END)
2201    DSERVE8  NET = 'LOGIN CONFIRMED' CRLF
2202             NET = 'REDIRECT TO /dev/fd/' DSERVE_P1_WFD ' TO SEND OUTPUT '
2202    +              'TO TELNET USING X (EG ls)' CRLF
        *
        * THE CORRECT KEY WAS SUPPLIED. SEND MESSAGE TO PRIMORDIAL.
        *
2203             TO_PRIMORDIAL = 'DDT'
        *
        * SIGNAL TO ENTER DDT
        *
2204             KILL(DIFFER(DSERVE_INTR) DSERVE_PID, 2)
        *
        * FORK TO TWO COPY LOOPS: PRIMORDIAL -> NET AND NET -> PRIMORDIAL
        *
2205             PID = FORK()
2206             LT(PID)                                             :S(DSERVE9)
2207             EQ(PID)                                            :S(DSERVE12)
        *
        * PRIMORDIAL -> NET COPY PROCESS
        *
2208    DSERVE11 S = FROM_PRIMORDIAL                                     :F(END)
2209             NET = S CRLF                                        :(DSERVE11)
        *
        * NET -> PRIMORDIAL COPY PROCESS
        *
2210    DSERVE12 S = NET                                                 :F(END)
2211             S = REPL(S, CHARS_CR)
2212             S = REPL(S, CHARS_LF)
2213             TO_PRIMORDIAL = S                                   :(DSERVE12)
        *
2214    DSERVE9  TERMINAL = 'DSERVE: INTERNAL FAILURE'                    :(END)
        *
2215    DSERVE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FCGI.INC'
        -MODULE FCGI
        -LINE 28 "FCGI.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'FFI.INC'
        -INCLUDE 'JSON.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'TIME.INC'
        -IN72
        -LINE 305 "FCGI.lss"
        -STITL FCGI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #######   #####    #####   ###                    *
        *                    #        #     #  #     #   #                     *
        *                    #        #        #         #                     *
        *                    #####    #        #  ####   #                     *
        *                    #        #        #     #   #                     *
        *                    #        #     #  #     #   #                     *
        *                    #         #####    #####   ###                    *
        *                                                                      *
        * FCGI                   FCGI SUPPORT FUNCTIONS                        *
        *                                                                      *
        ************************************************************************
        *
        * FCGI.lss
        *
        -LINE 37 "FCGI.lss"
2216             FCGI_LOGUNIT = IO_FINDUNIT()
2217             OUTPUT(.FCGI_LOG, FCGI_LOGUNIT, 'W',
2217    +               '|/usr/bin/logger -n localhost -t FCGI')
2218             STDIN_FILENO = 0
2219             FCGI_LISTENSOCK_FILENO = STDIN_FILENO
        *
2220             FCGI_BEGIN_REQUEST     =  1
2221             FCGI_ABORT_REQUEST     =  2
2222             FCGI_END_REQUEST       =  3
2223             FCGI_PARAMS            =  4
2224             FCGI_STDIN             =  5
2225             FCGI_STDOUT            =  6
2226             FCGI_STDERR            =  7
2227             FCGI_DATA              =  8
2228             FCGI_GET_VALUES        =  9
2229             FCGI_GET_VALUES_RESULT = 10
2230             FCGI_UNKNOWN_TYPE      = 11
        *
2231             FCGI_RESPONDER  = 1
2232             FCGI_AUTHORIZER = 2
2233             FCGI_FILTER     = 3
        *
        -PUBLIC FCGI_REQUEST_COMPLETE, FCGI_CANT_MPX_CONN, FCGI_OVERLOADED
        -PUBLIC FCGI_UNKNOWN_ROLE
2234             FCGI_REQUEST_COMPLETE = 0
2235             FCGI_CANT_MPX_CONN    = 1
2236             FCGI_OVERLOADED       = 2
2237             FCGI_UNKNOWN_ROLE     = 3
        *
        * getpeername RETURNS PEER NAME FOR STDIN IF RUNNING UNDER FCGI. IT
        * ACTUALLY RETURNS TRANSPORT END-POINT NOT CONNECTED. IF IT ISN'T A
        * SOCKET AT ALL, DEFINITELY CGI CASE.
        *
2238             PEER = BQ('/usr/bin/getpeername 2>&1')             :F(NOT_FCGI)
2239             PEER 'Socket operation on non-socket'              :S(NOT_FCGI)
        *
2240             FCGI_LOG = 'FCGI'
        *
        * INFORM CGI THAT FAST CGI IS IN USE. DEFINE THE ACCEPT() FUNCTION.
        * LISTEN() HAS ALREADY BEEN DONE IN THE WEB SERVER.
        *
2241             USE_FCGI = 1
2242    NOT_FCGI FCGI_LOG = IDENT(USER_FCGI) 'NORMAL CGI'
2243             FFI_ACCEPT = FFI_NEW('I', 'I,P,P')
2244             FFI_SET_CALLP(FFI_ACCEPT, DLSYM(0, 'accept'))
        -PUBLIC FCGI_ACCEPT(), ACCEPT(), FCGI_SEND(), FCGI_SEND_ERR(),
        -PUBLIC FCGI_END()
2245             DEFINE('FCGI_ACCEPT()')
2246             DEFINE('ACCEPT(SOCKET,P1,P2)')
2247             DEFINE('FCGI_NAMES(T,A)')
2248             DEFINE('FCGI_SEND(S)')
2249             DEFINE('FCGI_SEND_ERR(S)')
2250             DEFINE('FCGI_SEND_(D,S)B')
2251             DEFINE('FCGI_END(APP_STATUS,PROT_STATUS)S,B0,B1,B2,B3')
2252             DEFINE('FCGI_GET()')                               :(FCGI_END_)
        *
2253    ACCEPT   CLEAR_ERRNO()
2254             FFI_PAR_N_INTEGER(FFI_ACCEPT, 1, SOCKET)
2255             FFI_PAR_N_PTR(FFI_ACCEPT, 2, P1)
2256             FFI_PAR_N_PTR(FFI_ACCEPT, 3, P2)
2257             ACCEPT = FFI_CALL_INTEGER(FFI_ACCEPT)                 :(RETURN)
        *
        * IF THE DATA TO SEND IS 0...65535 BYTES, SEND IT. IF GREATER,
        * SEND THE FIRST 65535, AND LOOP FOR THE REST
        *
2258    FCGI_SEND_
2259             LT(SIZE(S), 65536)                              :S(FCGI_SEND_2)
2260             S LEN(65535) . B REM . S
2261             FCGI_SEND_(D, B)                                  :(FCGI_SEND_)
2262    FCGI_SEND_2
2263             FCGI_LOG = 'FCGI_SEND: '  D ' ' SIZE(S)
2264             S = CHAR(1) CHAR(D)
2264    +            CHAR(FCGI_REQUESTID / 256) CHAR(REMDR(FCGI_REQUESTID, 256))
2264    +            CHAR(SIZE(S) / 256) CHAR(REMDR(SIZE(S), 256))
2264    +            CHAR(0) CHAR(0) S
2265             FCGI_OUT = S                                          :(RETURN)
        *
2266    FCGI_SEND
2267             FCGI_SEND_(FCGI_STDOUT, S)                            :(RETURN)
        *
2268    FCGI_SEND_ERR
2269             FCGI_SEND_(FCGI_STDERR, S)                            :(RETURN)
        *
2270    FCGI_END FCGI_LOG = 'FCGI_END: ' APP_STATUS ' ' PROT_STATUS
2271             B3 = APP_STATUS / 16777216
2272             APP_STATUS = REMDR(APP_STATUS, 16777216)
2273             B2 = APP_STATUS / 65536
2274             APP_STATUS = REMDR(APP_STATUS, 65536)
2275             B1 = APP_STATUS / 256
2276             B0 = REMDR(APP_STATUS, 256)
2277             S = CHAR(B3) CHAR(B2) CHAR(B1) CHAR(B0) CHAR(PROT_STATUS)
2277    +            CHAR(0) CHAR(0) CHAR(0)
2278             B1 = FCGI_REQUESTID / 256
2279             B0 = REMDR(FCGI_REQUESTID, 256)
2280             S = CHAR(1) CHAR(FCGI_END_REQUEST) CHAR(B1) CHAR(B0)
2280    +            CHAR(0) CHAR(8) CHAR(0) CHAR(0) S
2281             FCGI_OUT = S                                          :(RETURN)
        *
2282    FCGI_GET VERSION = ORD(FCGI)
2283             FCGI_LOG = DIFFER(VERSION, 1) 'VERSION <> 1'            :S(END)
2284             TYPE = ORD(FCGI)
2285             REQUESTID = ORD(FCGI) * 256
2286             REQUESTID = REQUESTID + ORD(FCGI)
2287             CONTENTLENGTH = ORD(FCGI) * 256
2288             CONTENTLENGTH = CONTENTLENGTH + ORD(FCGI)
2289             PADDINGLENGTH = ORD(FCGI)
2290             RESERVED = ORD(FCGI)
        *
        * WE COULD READ THIS IN ONE GULP, AND AVOID CONVERTING TO ARRAY AND
        * THEN BACK INTO STRING.
        *
2291             FCGI_GET = NE(CONTENTLENGTH) ARRAY(CONTENTLENGTH)
2292             I = 1
2293    FCGI_4   GT(I, CONTENTLENGTH)                                 :S(FCGI_5)
2294             FCGI_GET<I> = ORD(FCGI)
2295             I = I + 1                                             :(FCGI_4)
2296    FCGI_5   I = 1
2297    FCGI_6   GT(I, PADDINGLENGTH)                                 :S(RETURN)
2298             S = FCGI
2299             I = I + 1                                             :(FCGI_6)
        *
        * EXTRACT NAMES FROM ARRAY. TWO LENGTH FIELDS, EITHER 1 OR 4 BYTES,
        * THEN THE ACTUAL NAME AND DATA.
        *
2300    FCGI_NAMES
2301             I = 1
2302    FCGI_NAMES_7
2303             NL = A<I>
2304             EQ(AND(NL, 128))                               :S(FCGI_NAMES_2)
2305             NL = AND(A<I>, 127) * 16777216 +
2305    +             A<I + 1> * 65536 +
2305    +             A<I + 2> * 256 +
2305    +             A<I + 3>
2306             I = I + 3
2307    FCGI_NAMES_2
2308             I = I + 1
2309             DL = A<I>
2310             EQ(AND(NL, 128))                               :S(FCGI_NAMES_3)
2311             DL = AND(A<I>, 127) * 16777216 +
2311    +             A<I + 1> * 65536 +
2311    +             A<I + 2> * 256 +
2311    +             A<I + 3>
2312             I = I + 3
2313    FCGI_NAMES_3
2314             I = I + 1
2315             NM =
2316             DA =
2317    FCGI_NAMES_4
2318             EQ(NL)                                         :S(FCGI_NAMES_5)
2319             NM = NM CHAR(A<I>)
2320             I = I + 1
2321             NL = NL - 1                                     :(FCGI_NAMES_4)
2322    FCGI_NAMES_5
2323             EQ(DL)                                         :S(FCGI_NAMES_6)
2324             DA = DA CHAR(A<I>)
2325             I = I + 1
2326             DL = DL - 1                                     :(FCGI_NAMES_5)
2327    FCGI_NAMES_6
2328             T<NM> = DA
2329             A<I>                                  :F(RETURN)S(FCGI_NAMES_7)
        *
        * MAIN FCGI FUNCTION
        *
2330    FCGI_ACCEPT
2331             IDENT(USE_FCGI)                                      :S(RETURN)
2332             FCGI_LOG = 'FCGI_ACCEPT: WAITING'
2333             SOCKET = ACCEPT(FCGI_LISTENSOCK_FILENO, 0, 0)
2334             FCGI_LOG = 'AFTER ACCEPT'
2335             GE(SOCKET)                                           :S(FCGI_2)
        *
        * ON ERROR IN ACCEPT, WE DISPLAY ERRNO AND EXIT THE PROCESS
        *
2336             ERRNO = GET_ERRNO()
2337             FCGI_LOG = 'ACCEPT: ERRNO = ' ERRNO                      :(END)
        *
        * READ AND DIGEST PACKETS FROM SOCKET. CLEAN UP OLD INSTANCE I/O
        * (FCGI IS GOING TO STAY AROUND EXECUTING REQUESTS). THEN
        * OPEN THE SOCKET PASSED TO US BY ACCEPT().
        *
2338    FCGI_2   IDENT(FCGI_INSTANCE_UNIT)                            :S(FCGI_8)
2339             DETACH(.FCGI)
2340             DETACH(.FCGI_OUT)
2341             ENDFILE(FCGI_INSTANCE_UNIT)
2342    FCGI_8   FCGI_LOG = 'SOCKET = ' SOCKET
2343             FCGI_INSTANCE_UNIT = IO_FINDUNIT()
2344             FCGI_LOG = 'UNIT = ' FCGI_INSTANCE_UNIT
2345             INPUT(.FCGI, FCGI_INSTANCE_UNIT, 'U,B,1', '/dev/fd/' SOCKET)
2346             OUTPUT(.FCGI_OUT, FCGI_INSTANCE_UNIT, 'W,B,1')
        *
2347             FCGI_ENV = TABLE()
2348             FCGI_IN =
2349             FCGI_REQUESTID =
        *
        * PACKET LOOP
        *
2350    FCGI_PLOOP
2351             CONTENT = FCGI_GET()
2352             FCGI_REQUESTID = IDENT(FCGI_REQUESTID) REQUESTID
2353             EQ(REQUESTID, FCGI_REQUESTID)                  :S(FCGI_PLOOP_2)
2354             FCGI_LOG = 'ONLY SINGLE REQUESTID SUPPORTED'             :(END)
        *
        * WE DO NOT MULTIPLEX REQUESTID, NEED TO SET INDICATION OF THAT
        * IN FCGI_GET().
        *
2355    FCGI_PLOOP_2
2356             EQ(TYPE, FCGI_BEGIN_REQUEST)                        :F(FCGI_10)
2357             FCGI_LOG = 'FCGI_BEGIN_REQUEST'
2358             FCGI_ROLE = CONTENT<1> * 256 + CONTENT<2>
2359             FCGI_LOG = NE(FCGI_ROLE, FCGI_RESPONDER)
2359    +           'ROLE NOT RESPONDER'                                 :S(END)
2360             FCGI_FLAGS = CONTENT<3>
2361             FCGI_REQUESTID = REQUESTID                        :(FCGI_PLOOP)
        *
2362    FCGI_10  EQ(TYPE, FCGI_PARAMS)                               :F(FCGI_11)
2363             FCGI_LOG = 'FCGI_PARAMS'
2364             IDENT(CONTENT)                                   :S(FCGI_PLOOP)
2365             FCGI_NAMES(FCGI_ENV, CONTENT)                     :(FCGI_PLOOP)
        *
2366    FCGI_11  EQ(TYPE, FCGI_STDIN)                                :F(FCGI_12)
2367             FCGI_LOG = 'FCGI_STDIN'
2368             IDENT(CONTENT)                                      :S(FCGI_GO)
2369             I = 1
        * FIXME: WE READ IT AS A STRING, CONVERT TO ARRAY OF SMALL INTEGERS,
        * AND THEN MAKE IT A STRING AGAIN. THIS IS DONE BECAUSE WE ARE GOING
        * TO DO PACKET DISASSEMBLY, AND THAT IS ARGUABLY EASIER IN THE SMALL
        * INTEGER SPACE. STILL, IT SHOULD BE FIXED.
2370    FCGI_13  FCGI_IN = FCGI_IN CHAR(CONTENT<I>)               :F(FCGI_PLOOP)
2371             I = I + 1                                            :(FCGI_13)
        *
2372    FCGI_12
2373             FCGI_LOG = 'BAD TYPE: ' TYPE                             :(END)
        *
2374    FCGI_GO
2375             FCGI_LOG = 'FCGI_GO'
        *
        * HERE WE ILLUSTRATE AN INTERESTING TECHNIQUE. SINCE JSON_ENCODE WILL
        * TRAVERSE TABLES AND ARRAYS, WE CAN USE IT TO EXAMINE VARIABLES BY
        * SENDING THE JSON ENCODING TO A LOG FILE.
        *
2376             FCGI_LOG = 'FCGI_ENV: '
2377             FCGI_LOG = JSON_ENCODE(FCGI_ENV)
        *
        * BUG ALERT: IF THIS IS NOT DONE, GETTIMEOFDAY(), GMTIME() ETC.
        * FAULT ON THE SECOND PASS THROUGH FCGI. HAPPENS WITH CSNOBOL4 1.5
        *
        * TRY TO ISOLATE THIS FURTHER.
        *
2378             T = GETTIMEOFDAY()
2379                                                                   :(RETURN)
        *
2380    FCGI_END_
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'HASH.INC'
        -MODULE HASH
        -LINE 54 "HASH.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'COPYT.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'MERGET.INC'
        -MODULE MERGET
        -LINE 13 "MERGET.lss"
        -INCLUDE 'COPYT.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 42 "MERGET.lss"
        -STITL MERGET
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #     #  #######  ######    #####   #######  #######         *
        *         ##   ##  #        #     #  #     #  #           #            *
        *         # # # #  #        #     #  #        #           #            *
        *         #  #  #  #####    ######   #  ####  #####       #            *
        *         #     #  #        #   #    #     #  #           #            *
        *         #     #  #        #    #   #     #  #           #            *
        *         #     #  #######  #     #   #####   #######     #            *
        *                                                                      *
        * MERGET                     MERGE TABLES                              *
        *                                                                      *
        ************************************************************************
        *
        * MERGET.lss
        *
        -LINE 18 "MERGET.lss"
        -PUBLIC MERGET()
        *
2381             DEFINE('MERGET(T1,T2)A,I')                        :(MERGET_END)
        *
2382    MERGET   MERGET = COPYT(T1)
2383             A = CONVERT(T2, 'ARRAY')
2384             SEQ(' MERGET<A<I, 1>> = A<I, 2> ', .I)                :(RETURN)
        *
2385    MERGET_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -LINE 126 "HASH.lss"
        -STITL HASH
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                  #     #     #      #####   #     #                  *
        *                  #     #    # #    #     #  #     #                  *
        *                  #     #   #   #   #        #     #                  *
        *                  #######  #     #   #####   #######                  *
        *                  #     #  #######        #  #     #                  *
        *                  #     #  #     #  #     #  #     #                  *
        *                  #     #  #     #   #####   #     #                  *
        *                                                                      *
        * HASH                   INITIALIZE A TABLE                            *
        *                                                                      *
        ************************************************************************
        *
        * HASH.lss
        *
        -LINE 63 "HASH.lss"
        -PUBLIC HASH(), #1
        *
2386             DEFINE('HASH(S,E,P,TS,TI,FK,FV,SP)K,V,C')
2387             DEFINE('HASH_3(S)')
2388             OPSYN('#', 'HASH', 1)                               :(HASH_END)
        *
2389    HASH     HASH = TABLE(TS, TI)
2390             E = IDENT(E) '='
2391             P = IDENT(P) ','
2392             FK = IDENT(FK) 'HASH_3'
2393             FV = IDENT(FV) 'HASH_3'
2394    HASH_2   IDENT(S)                                             :S(RETURN)
2395             S POS(0) BREAK(E P) LEN(1) . C                       :F(HASH_5)
2396             C E                                                  :F(HASH_5)
2397             S POS(0) BREAK(E) . K E =                            :S(HASH_4)
2398    HASH_5   K =
2399    HASH_4   S POS(0) BRKREM(P) . V (P | RPOS(0)) =               :F(RETURN)
2400             K = APPLY(FK, K)
2401             V = APPLY(FV, V)
2402             HASH<K> = VDIFFER(HASH<K>) VDIFFER(SP) V             :S(HASH_2)
2403             HASH<K> = V                                           :(HASH_2)
        *
2404    HASH_3   HASH_3 = S                                            :(RETURN)
        *
2405    HASH_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HTMLESC.INC'
        -MODULE HTMLESC
        -LINE 14 "HTMLESC.lss"
        -INCLUDE 'CH.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HEX.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'SDIFF.INC'
        -IN72
        -LINE 110 "HTMLESC.lss"
        -STITL HTMLESC
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #     #  #######  #     #  #        #######   #####    #####      *
        *    #     #     #     ##   ##  #        #        #     #  #     #     *
        *    #     #     #     # # # #  #        #        #        #           *
        *    #######     #     #  #  #  #        #####     #####   #           *
        *    #     #     #     #     #  #        #              #  #           *
        *    #     #     #     #     #  #        #        #     #  #     #     *
        *    #     #     #     #     #  #######  #######   #####    #####      *
        *                                                                      *
        * HTMLESC             HTML (JS, URL) ESCAPING                          *
        *                                                                      *
        ************************************************************************
        *
        * HTMLESC.lss
        *
        -LINE 40 "HTMLESC.lss"
        -PUBLIC HTML_ESCAPE()
2406             DEFINE('HTML_ESCAPE(S)')                     :(END_HTML_ESCAPE)
        *
2407    HTML_ESCAPE
2408             S = REPL(S, '&', '&amp;')
2409             S = REPL(S, '<', '&lt;',)
2410             S = REPL(S, '>', '&gt;',)
2411             S = REPL(S, '"', '&quot;')
2412             S = REPL(S, "'", '&#39;')
2413             HTML_ESCAPE = S                                       :(RETURN)
        *
2414    END_HTML_ESCAPE
        *
        -LINE 57 "HTMLESC.lss"
        -PUBLIC JS_ESCAPE()
2415             DEFINE('JS_ESCAPE(S)')                         :(END_JS_ESCAPE)
        *
2416    JS_ESCAPE
2417             S = REPL(S, '\', '\\')
2418             S = REPL(S, "'", "\'")
2419             S = REPL(S, '"', '\"')
2420             S = REPL(S, CHARS_NL, '\n')
2421             S = REPL(S, CHARS_CR, '\r')
2422             JS_ESCAPE = S                                         :(RETURN)
        *
2423    END_JS_ESCAPE
        *
        -LINE 78 "HTMLESC.lss"
        -PUBLIC URL_ESCAPE(), URL_DECODE()
2424             DEFINE('URL_ESCAPE(S)L,C,R')
2425             DEFINE('URL_DECODE(S)L,C,R')
2426             URL_BAD = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789' '_-~.')
2427             URL_HEX = ANY('0123456789abcdefABCDEF')
2427    +                                                      :(END_URL_ESCAPE)
        *
2428    URL_DECODE_2
2429             S = R
2430    URL_DECODE
2431             C =
2432             S BREAK("+%") . L LEN(1) . C REM . R
2433             URL_DECODE = IDENT(C) URL_DECODE S                   :S(RETURN)
2434             URL_DECODE = IDENT(C, '+') URL_DECODE L ' '    :S(URL_DECODE_2)
2435             URL_DECODE = URL_DECODE L
2436             R (URL_HEX URL_HEX) . C =                      :F(URL_DECODE_2)
2437             URL_DECODE = URL_DECODE CH(C)                   :(URL_DECODE_2)
        *
2438    URL_ESCAPE
2439             S BREAK(URL_BAD) . L LEN(1) . C REM . R             :F(URLESC2)
2440             URL_ESCAPE = IDENT(C, ' ') URL_ESCAPE L '+'
2441             URL_ESCAPE = DIFFER(C, ' ') URL_ESCAPE L '%' HEX(C)
2442             S = R                                             :(URL_ESCAPE)
2443    URLESC2  URL_ESCAPE = URL_ESCAPE S                             :(RETURN)
        *
2444    END_URL_ESCAPE
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HTMLTMPL.INC'
        -PLUSOPS 1
2445      :(HTMLTMPL.1)
        -MODULE HTMLTMPL
        -SNOCONE
        -LINE 28 "HTMLTMPL.lss"
        -LINE 293 "HTMLTMPL.lss"
        -IN1024
        -LINE 72 "HTMLTMPL.lss"
        -LINE 84 "HTMLTMPL.lss"
2446      :(TMPL_INIT.END)
        -LINE 88
2447    TMPL_INIT TMPL_DIR = "./"
        -LINE 92
2448     TMPL_WS = SPAN(" " CHARS_TAB) | ""
        -LINE 93
2449     TMPL = ("/" | "") . H ANY("Tt") ANY("Mm") ANY("Pp") ANY("Ll") "_"
        -LINE 95
2450     TMPL_TAG = TMPL SPAN(&UCASE &LCASE) . TAG
        -LINE 96
2451     TMPL_C = "<!-- " TMPL_WS TMPL_TAG ARB . ARG " -->"
        -LINE 97
2452     TMPL_T = "<" TMPL_TAG BREAK(">") . ARG ">"
        -LINE 98
2453     TMPL_PIECE = POS(0) BREAKX("<") . L (TMPL_T | TMPL_C) . P REM . R
        -LINE 100
2454     TMPL_KEYS = "var if unless else loop include "
        -LINE 104
2455     TMPL_ARG_VAR = TMPL_WS (ANY(&LCASE &UCASE) SPAN(&LCASE
2455    +&UCASE '0123456789' "_")) . N TMPL_WS
        -LINE 106
2456     TMPL_QVAL = '"' BREAK('"') . V '"'
        -LINE 107
2457     TMPL_SVAL = BREAK(" " CHARS_TAB) . V
        -LINE 108
2458     TMPL_ARG_P = (TMPL_ARG_VAR "=" | "") TMPL_WS (TMPL_QVAL
2458    +| TMPL_SVAL | REM . V) :(RETURN)
        -LINE 115
2459    TMPL_INIT.END  :(TMPL_COMPILE.END)
        -LINE 116
2460    TMPL_COMPILE L = TMPL_TOKENIZE(S) :S(HTMLTMPL.2)F(FRETURN)
        -LINE 118
2461    HTMLTMPL.2 L = TMPL_PARSE(L) :S(HTMLTMPL.3)F(FRETURN)
        -LINE 120
2462    HTMLTMPL.3 TMPL_COMPILE = L :(RETURN)
        -LINE 127
2463    TMPL_COMPILE.END  :(TMPL_INTERPRET.END)
        -LINE 128
2464    TMPL_INTERPRET INTERPRET_TMPL(P,A) :(RETURN)
        -LINE 133
2465    TMPL_INTERPRET.END  :(NONE_ESCAPE.END)
        -LINE 134
2466    NONE_ESCAPE NONE_ESCAPE = S :(RETURN)
        -LINE 139
2467    NONE_ESCAPE.END  :(INTERPRET_TMPL.END)
        -LINE 140
2468    INTERPRET_TMPL P
2469    HTMLTMPL.4 DIFFER(P,"") :F(HTMLTMPL.5)
        -LINE 141
2470     V = VALUE(VALUE(P))
        -LINE 142
2471     IDENT(TOKEN_TYPE(V),"text") :F(HTMLTMPL.6)
        -LINE 144
2472     TMPL_INTERPRET = TMPL_INTERPRET TOKEN_ARGS(V) :(HTMLTMPL.7)
        -LINE 146
2473    HTMLTMPL.6 T = TOKEN_ARGS(V)
        -LINE 147
2474     N = A<T<"name">>
        -LINE 148
2475     IDENT(TOKEN_TYPE(V),"var") :F(HTMLTMPL.8)
        -LINE 150
2476     IDENT(N,"") :F(HTMLTMPL.9)
        -LINE 151
2477     N = T<"default">
        -LINE 152
2478    HTMLTMPL.9 E = T<"escape">
        -LINE 154
2479     E = E "_escape"
        -LINE 155
2480     V = &ERRLIMIT
2481     &ERRLIMIT = 1
2482     N = APPLY(E,N)
2483     &ERRLIMIT = V
        -LINE 156
2484     TMPL_INTERPRET = TMPL_INTERPRET N :(HTMLTMPL.10)
        -LINE 157
2485    HTMLTMPL.8 "if unless" ? TOKEN_TYPE(V) :F(HTMLTMPL.11)
        -LINE 159
2486     P1 = VALUE(NEXT(VALUE(P)))
        -LINE 160
2487     P2 = NEXT(NEXT(VALUE(P)))
        -LINE 161
2488     IDENT(TOKEN_TYPE(V),"unless") :F(HTMLTMPL.12)
        -LINE 162
2489     SWAP(.P1,.P2)
        -LINE 163
2490    HTMLTMPL.12 (DIFFER(N,""),NE(+N,0)) :F(HTMLTMPL.13)
        -LINE 164
2491     INTERPRET_TMPL(P1,A) :(HTMLTMPL.14)
        -LINE 166
2492    HTMLTMPL.13 INTERPRET_TMPL(P2,A)
        -LINE 167
2493    HTMLTMPL.14  :(HTMLTMPL.15)
2494    HTMLTMPL.11 IDENT(TOKEN_TYPE(V),"loop") :F(HTMLTMPL.16)
        -LINE 169
2495     IDENT(DATATYPE(N),"ARRAY") :F(HTMLTMPL.17)
        -LINE 170
2496     P1 = VALUE(NEXT(VALUE(P)))
        -LINE 171
2497     I = 1
2498    HTMLTMPL.18 N<I> :F(HTMLTMPL.19)
        -LINE 172
2499     INTERPRET_TMPL(P1,N<I>)
2500     I = I + 1 :(HTMLTMPL.18)
2501    HTMLTMPL.19
2502    HTMLTMPL.17
2503    HTMLTMPL.16
2504    HTMLTMPL.15
2505    HTMLTMPL.10
        -LINE 176
2506    HTMLTMPL.7 P = NEXT(P) :(HTMLTMPL.4)
        -LINE 177
2507    HTMLTMPL.5  :(RETURN)
        -LINE 182
2508    INTERPRET_TMPL.END  :(TMPL_PARSE.END)
        -LINE 183
2509    TMPL_PARSE IDENT(L,"") :S(RETURN)F(HTMLTMPL.20)
        -LINE 185
2510    HTMLTMPL.20 R = TMPL_SEQ() :S(HTMLTMPL.21)F(FRETURN)
        -LINE 187
2511    HTMLTMPL.21 DIFFER(L,"") :S(FRETURN)F(HTMLTMPL.22)
        -LINE 189
2512    HTMLTMPL.22 TMPL_PARSE = R :(RETURN)
        -LINE 195
2513    TMPL_PARSE.END  :(TMPL_SEQ.END)
        -LINE 196
2514    TMPL_SEQ DIFFER(L,"") :F(HTMLTMPL.23)
        -LINE 197
2515     V = VALUE(L)
        -LINE 198
2516     "text var" ? TOKEN_TYPE(V) :F(HTMLTMPL.24)
        -LINE 199
2517     R = LINK(LINK(V),R)
        -LINE 200
2518     L = NEXT(L) :(HTMLTMPL.25)
        -LINE 201
2519    HTMLTMPL.24 "if unless loop" ? TOKEN_TYPE(V) :F(HTMLTMPL.26)
        -LINE 202
2520     DIFFER(TOKEN_END(V),"") :F(HTMLTMPL.27)
        -LINE 203
2521     TMPL_SEQ = REVL(R) :(RETURN)
        -LINE 204
2522    HTMLTMPL.27 L = NEXT(L)
        -LINE 205
2523     P1 = TMPL_SEQ() :S(HTMLTMPL.28)F(FRETURN)
        -LINE 207
2524    HTMLTMPL.28 IDENT(L,"") :S(FRETURN)F(HTMLTMPL.29)
        -LINE 209
2525    HTMLTMPL.29 P2 = ""
        -LINE 210
2526     V2 = VALUE(L)
        -LINE 211
2527     "if unless loop" ? TOKEN_TYPE(V2) :F(HTMLTMPL.30)
        -LINE 212
2528     L = NEXT(L) :(HTMLTMPL.31)
        -LINE 213
2529    HTMLTMPL.30 IDENT(TOKEN_TYPE(V2),"else") :F(HTMLTMPL.32)
        -LINE 214
2530     L = NEXT(L)
        -LINE 215
2531     P2 = TMPL_SEQ() :S(HTMLTMPL.33)F(FRETURN)
        -LINE 217
2532    HTMLTMPL.33 IDENT(L,"") :S(FRETURN)F(HTMLTMPL.34)
        -LINE 219
2533    HTMLTMPL.34 L = NEXT(L) :(HTMLTMPL.35)
        -LINE 221
2534    HTMLTMPL.32  :(FRETURN)
2535    HTMLTMPL.35
        -LINE 222
2536    HTMLTMPL.31 R = LINK(LINK(V,LINK(P1,P2)),R) :(HTMLTMPL.36)
        -LINE 223
2537    HTMLTMPL.26 IDENT(TOKEN_TYPE(V),"else") :F(HTMLTMPL.37)
        -LINE 224
2538     TMPL_SEQ = REVL(R) :(RETURN)
        -LINE 226
2539    HTMLTMPL.37  :(FRETURN)
2540    HTMLTMPL.38
2541    HTMLTMPL.36
        -LINE 227
2542    HTMLTMPL.25  :(TMPL_SEQ)
        -LINE 228
2543    HTMLTMPL.23 TMPL_SEQ = REVL(R) :(RETURN)
        -LINE 233
2544    TMPL_SEQ.END  :(TMPL_TOKENIZE.END)
        -LINE 234
2545    TMPL_TOKENIZE N = .TMPL_TOKENIZE
        -LINE 235
2546    HTMLTMPL.39 DIFFER(S,"") :F(HTMLTMPL.40)
        -LINE 236
2547     S ? TMPL_PIECE :F(HTMLTMPL.41)
        -LINE 237
2548     TAG = REPLACE(TAG,&UCASE,&LCASE)
        -LINE 238
2549     TMPL_KEYS ? TAG " " :F(HTMLTMPL.42)
        -LINE 239
2550     DIFFER(L,"") :F(HTMLTMPL.43)
        -LINE 240
2551     $N = LINK(TMPL_TOKEN("text","",L))
2552     N = .NEXT($N)
        -LINE 242
2553    HTMLTMPL.43 IDENT(TAG,"include") :F(HTMLTMPL.44)
        -LINE 247
2554     T = TMPL_PARSE_ARGS(ARG) :S(HTMLTMPL.45)F(FRETURN)
        -LINE 249
2555    HTMLTMPL.45 S = READFILE(TMPL_DIR T<'name'>) :F(HTMLTMPL.46)
        -LINE 250
2556     $N = TMPL_TOKENIZE(S) :S(HTMLTMPL.47)F(FRETURN)
        -LINE 252
2557    HTMLTMPL.47 N = .LAST(TMPL_TOKENIZE)
        -LINE 254
2558    HTMLTMPL.46  :(HTMLTMPL.48)
        -LINE 255
2559    HTMLTMPL.44 T = TMPL_TOKEN(TAG,H,TMPL_PARSE_ARGS(ARG))
        -LINE 256
2560     $N = LINK(T)
2561     N = .NEXT($N)
        -LINE 258
2562    HTMLTMPL.48  :(HTMLTMPL.49)
        -LINE 259
2563    HTMLTMPL.42 $N = LINK(TMPL_TOKEN("text","",L P))
2564     N = .NEXT($N)
        -LINE 261
2565    HTMLTMPL.49 S = R :(HTMLTMPL.50)
        -LINE 263
2566    HTMLTMPL.41 $N = LINK(TMPL_TOKEN("text","",S))
2567     N = .NEXT($N)
        -LINE 264
2568     S = ""
        -LINE 266
2569    HTMLTMPL.50  :(HTMLTMPL.39)
        -LINE 267
2570    HTMLTMPL.40  :(RETURN)
        -LINE 272
2571    TMPL_TOKENIZE.END  :(TMPL_PARSE_ARGS.END)
        -LINE 273
2572    TMPL_PARSE_ARGS TMPL_PARSE_ARGS = TABLE()
        -LINE 274
2573    HTMLTMPL.51 DIFFER(S,"") :F(HTMLTMPL.52)
        -LINE 275
2574     N = ""
        -LINE 276
2575     V = ""
        -LINE 277
2576     S ? TMPL_ARG_P = "" :F(HTMLTMPL.53)
        -LINE 278
2577     N = REPLACE(N,&UCASE,&LCASE)
        -LINE 279
2578     N = IDENT(N) "name"
        -LINE 280
2579     TMPL_PARSE_ARGS<N> = V :(HTMLTMPL.54)
        -LINE 282
2580    HTMLTMPL.53  :(FRETURN)
        -LINE 283
2581    HTMLTMPL.54  :(HTMLTMPL.51)
        -LINE 284
2582    HTMLTMPL.52  :(RETURN)
2583    TMPL_PARSE_ARGS.END
2584    HTMLTMPL.1
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'LAST.INC'
        -MODULE LAST
        -LINE 11 "LAST.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 39 "LAST.lss"
        -STITL LAST
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  #           #      #####   #######                  *
        *                  #          # #    #     #     #                     *
        *                  #         #   #   #           #                     *
        *                  #        #     #   #####      #                     *
        *                  #        #######        #     #                     *
        *                  #        #     #  #     #     #                     *
        *                  #######  #     #   #####      #                     *
        *                                                                      *
        * LAST                 RETURN LAST LIST ELEMENT                        *
        *                                                                      *
        ************************************************************************
        *
        * LAST.lss
        *
        -LINE 15 "LAST.lss"
        -PUBLIC LAST()
        *
2585             DEFINE('LAST(L)')                                   :(LAST_END)
        *
2586    LAST     IDENT(L)                                            :S(FRETURN)
2587    LAST_1   L = DIFFER(NEXT(L)) NEXT(L)                          :S(LAST_1)
2588             LAST = .NEXT(L)                                      :(NRETURN)
        *
2589    LAST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'LINK.INC'
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'REVL.INC'
        -INCLUDE 'SWAP.INC'
        -INCLUDE 'TIMER.INC'
        -LINE 12 "TIMER.lss"
        -INCLUDE 'RESOL.INC'
        -MODULE RESOL
        -LINE 9 "RESOL.lss"
        -LINE 50 "RESOL.lss"
        -IN72
        -STITL RESOL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 ######   #######   #####   #######  #                *
        *                 #     #  #        #     #  #     #  #                *
        *                 #     #  #        #        #     #  #                *
        *                 ######   #####     #####   #     #  #                *
        *                 #   #    #              #  #     #  #                *
        *                 #    #   #        #     #  #     #  #                *
        *                 #     #  #######   #####   #######  #######          *
        *                                                                      *
        * RESOL             TIMER RESOLUTION IN MILLISECONDS                   *
        *                                                                      *
        ************************************************************************
        *
        * RESOL.lss
        *
        -LINE 12 "RESOL.lss"
        -PUBLIC RESOLUTION()
        *
2590             DEFINE('RESOLUTION()T,N,R,T2')                :(RESOLUTION_END)
        *
2591    RESOLUTION
2592             DIFFER(RESOLUTION_)                                 :S(RESOL_4)
2593             R = 0.0
2594             T = TIME()
2595    RESOL_1  EQ(T, TIME())                                       :S(RESOL_1)
2596             T = TIME()
2597    RESOL_2  T2 = TIME()
2598    RESOL_3  EQ(T2, TIME())                                      :S(RESOL_3)
2599             RESOLUTION_ = TIME() - T
2600             R = R + (TIME() - T2)
2601             N = N + 1
2602             LE(N, 100000)                                       :S(RESOL_2)
2603             RESOLUTION_ = R / 100000
2604    RESOL_4  RESOLUTION = RESOLUTION_                              :(RETURN)
        *
2605    RESOLUTION_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SYSTEM.INC'
        -STITL TIMER
        -EJECT
        -LINE 78 "TIMER.lss"
        *
        ************************************************************************
        *                                                                      *
        *                 #######  ###  #     #  #######  ######               *
        *                    #      #   ##   ##  #        #     #              *
        *                    #      #   # # # #  #        #     #              *
        *                    #      #   #  #  #  #####    ######               *
        *                    #      #   #     #  #        #   #                *
        *                    #      #   #     #  #        #    #               *
        *                    #     ###  #     #  #######  #     #              *
        *                                                                      *
        * TIMER                       TIME STATEMENTS                          *
        *                                                                      *
        ************************************************************************
        *
        * TIMER.lss
        *
        -LINE 17 "TIMER.lss"
        -MODULE TIMER
        -PUBLIC TIMER()
2606             DEFINE('TIMER(S_,N_)C_,T_,I_,M_')                  :(TIMER_END)
        *
2607    TIMER    EQ(N_, 0)                                           :F(TIMER_N)
2608             N_ = 10
2609    TIMER_1  T_ = TIMER(' ;' S_, N_) - TIMER(, N_)               :F(FRETURN)
        * WAS 20 * RESOLUTION. NOW THAT RESOLUTION IS ON THE ORDER OF 4
        * MICROSECONDS, WE LOOK FOR 2000 * RESOLUTION (8 MILLISECONDS).
        *
        * FOR SPITBOL.EXE, RESOLUTION IS 1MS, CSNOBOL4, 4 MICROSECONDS FOR
        * ATOM, 1.5 MICROSECONDS FOR INTEL I3
        *
2610             M_ = RESOLUTION()
2611             M_ = ((LT(M_, 0.9) 2000), 20)
2612             N_ = LT(T_, M_ * RESOLUTION()) N_ * 2               :S(TIMER_1)
2613             T_ = CONVERT(T_, 'REAL')
2614             OUTPUT =
2615             OUTPUT = 'THE STATEMENT'
2616             OUTPUT = S_
        * CALCULATE THE TIME, AND SCALE TO MICROSECONDS, MILLISECONDS OR
        * SECONDS.
2617             T_ = T_ / N_
2618             C_ = ' MILLISECONDS'
2619             (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
2620             C_ = GE(T_, 1000.0) ' SECONDS'
2621             T_ = GE(T_, 1000.0) T_ / 1000.0                     :S(TIMER_2)
2622             T_ = T_ * 1000.0
2623             C_ = ' MICROSECONDS'
2624             (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
2625             T_ = T_ * 1000.0
2626             C_ = ' NANOSECONDS'
2627    TIMER_2  OUTPUT = 'REQUIRED ' T_ C_ ' +/- 10%'
2627    +           ' TO EXECUTE IN '  SYSTEM()                        :(RETURN)
        *
2628    TIMER_N  I_ = 1
2629             C_ = '          COLLECT()                             ;'
2629    +             '          TIMER = TIME()                        ;'
2629    +             'TIMER_4   EQ(TIMER, TIME())          :S(TIMER_4);'
2629    +             '          TIMER = TIME()                        ;'
2629    +             'TIMER_3 ' S_                                   ';'
2629    +             '          I_ = I_ + 1 LT(I_, ' N_ ') :S(TIMER_3);'
2629    +             '          TIMER = TIME() - TIMER       :(RETURN)'
2630             C_ = CODE(C_)                                  :S<C_>F(FRETURN)
        *
2631    TIMER_END
        *
        * CE: .MSNOBOL4;
2632     DATA('tmpl_token(token_type,token_end,token_args)')
        -USES HTML_ESCAPE(), JS_ESCAPE(), URL_ESCAPE()
        -PUBLIC TMPL_INIT()
2633     DEFINE('tmpl_init()')
        -PUBLIC TMPL_COMPILE()
2634     DEFINE('tmpl_compile(s)l')
        -PUBLIC TMPL_INTERPRET()
2635     DEFINE('tmpl_interpret(p,a)')
2636     DEFINE('none_escape(s)')
2637     DEFINE('interpret_tmpl(p,a)p1,p2,v,n,t,e,i')
2638     DEFINE('tmpl_parse(l)r')
2639     DEFINE('tmpl_seq()r,v,v2,p1,p2')
2640     DEFINE('tmpl_tokenize(s)l,r,p,tag,r,h,n,t')
2641     DEFINE('tmpl_parse_args(s)n,v')
2642      TMPL_INIT()
        -INCLUDE 'JSON.INC'
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'SCOOP.INC'
        -MODULE SCOOP
        -LINE 104 "SCOOP.lss"
        -INCLUDE 'TIMER.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -LINE 299 "SCOOP.lss"
        -EJECT
        -STITL SCOOP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #####    #####   #######  #######  ######               *
        *             #     #  #     #  #     #  #     #  #     #              *
        *             #        #        #     #  #     #  #     #              *
        *              #####   #        #     #  #     #  ######               *
        *                   #  #        #     #  #     #  #                    *
        *             #     #  #     #  #     #  #     #  #                    *
        *              #####    #####   #######  #######  #                    *
        *                                                                      *
        * SCOOP            OBJECT ORIENTED PROGRAMMING                         *
        *                                                                      *
        ************************************************************************
        *
        * SCOOP.lss
        *
        * THE SAFETY FLAG. IF 0, SOME CHECKS ARE NOT COMPILED IN. I RECOMMEND
        * THAT IT ALWAYS BE ENABLED.
        *
        -LINE 109 "SCOOP.lss"
        -PUBLIC OBJECT()
        *
2643             DATA('OBJECT(CLASS,IVARS,METHODS)')
        *
        -PUBLIC SEND(), SUPER(), SELF(), IVAR(), CVAR(), CLASS_OF(), |1
2644             DEFINE('SEND(THIS,METHOD,A1,A2,A3,A4,A5,A6,A7,A8)'
2644    +               'C,M,M_CLASS,T1,T2,T3')
2645             DEFINE('SUPER(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
2646             DEFINE('SELF(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
2647             DEFINE('FIND_METHOD(OBJ,METHOD)')
2648             DEFINE('IVAR(NAME)')
2649             DEFINE('CVAR(NAME)')
2650             DEFINE('CLASS_OF(OBJ)')
2651             OPSYN('|', 'IVAR', 1)
        *
        * INITIALIZE OOP SYSTEM, CREATE ROOT CLASS. MAKE SURE ROOT CLASS CAN
        * ANSWER NEW_CLASS, NEW, INIT, DOES_NOT_UNDERSTAND AND ADD_METHOD
        * MESSAGES. ALSO, ANSWER THE IS_A MESSAGE.
        *
        -PUBLIC CLASS:CLASS
2652             CLASS = OBJECT(, TABLE(), TABLE())
2653             IVARS(CLASS)<'CLASS'> = 'CLASS'
        -PUBLIC CLASS:'ADD_METHOD'
2654             METHODS(CLASS)<'ADD_METHOD'> =
2654    +           CODE(
2654    +              ' METHODS(THIS) = IDENT(METHODS(THIS)) TABLE();'
2654    +              ' THAW(METHODS(THIS));'
2654    +              ' METHODS(THIS)<A1> = A2;'
2654    +              ' FREEZE(METHODS(THIS)) :(RETURN)')
        *
        -PUBLIC CLASS:'NEW_CLASS'
2655             SEND(CLASS, 'ADD_METHOD', 'NEW_CLASS',
2655    +           CODE(
2655    +              ' THIS = OBJECT(THIS);'
2655    +              ' IVAR("CLASS") = A1;'
2655    +              ' SEND = THIS :(RETURN)'))
        -PUBLIC CLASS:'INIT'
2656             SEND(CLASS, 'ADD_METHOD', 'INIT',
2656    +           CODE(' :(RETURN)'))
        -PUBLIC CLASS:'NEW'
2657             SEND(CLASS, 'ADD_METHOD', 'NEW',
2657    +           CODE(
2657    +              ' THIS = OBJECT(THIS);'
2657    +              ' SELF("INIT", A1, A2, A3, A4, A5, A6, A7, A8);'
2657    +              ' SEND = THIS :(RETURN)'))
        -PUBLIC CLASS:'DOES_NOT_UNDERSTAND'
2658             SEND(CLASS, 'ADD_METHOD', 'DOES_NOT_UNDERSTAND',
2658    +           CODE(
2658    +            " TERMINAL = 'SCOOP: DOES NOT UNDERSTAND ' METHOD :(END)"))
2659             DEFINE('IS_A(ACLASS)')
        -PUBLIC CLASS:'IS_A'
2660             SEND(CLASS, 'ADD_METHOD', 'IS_A', 'IS_A')
2661                                                                  :(OOP_END)
        *
        * IS_A - IS OBJECT IN CLASS? ACLASS CAN BE A STRING WITH A CLASS NAME
        *        OR A CLASS OBJECT
        *
2662    IS_A     T1 = THIS
2663    IS_A_2   T1 = CLASS(T1)
2664             IDENT(T1)                                           :S(FRETURN)
2665             IDENT(T1, ACLASS)                                    :S(RETURN)
2666             IDENT(IVARS(T1)<'CLASS'>, ACLASS)           :S(RETURN)F(IS_A_2)
        *
        * ACCESS INSTANCE VARIABLE. CREATE THE INSTANCE VARIABLES IF THEY DO
        * NOT YET EXIST.
        *
2667    IVAR     IVARS(THIS) = IDENT(IVARS(THIS)) TABLE()
2668             IVAR = .(IVARS(THIS)<NAME>)                          :(NRETURN)
        *
        * ACCESS CLASS VARIABLE
        *
2669    CVAR     IVARS(CLASS(THIS)) = IDENT(IVARS(CLASS(THIS))) TABLE()
2670             CVAR = .(IVARS(CLASS(THIS))<NAME>)                   :(NRETURN)
        *
        * CLASS_OF RETURNS THE NAME OF THE CLASS OF THE PASSED OBJECT. THE
        * CLASS NAMES SHOULD BE UNIQUE WITHIN A PROGRAM. THE ROOT CLASS HAS
        * NAME 'CLASS' (ROOT'S SUPERCLASS IS NULL)
        *
2671    CLASS_OF CLASS_OF = IVARS(CLASS(OBJ))<'CLASS'>                 :(RETURN)
        *
        * FIND METHOD BEGINNING AT OBJ SEARCHING UP TO THE ROOT CLASS
        *
2672    FIND_METHOD
2673             M_CLASS =
2674             IDENT(OBJ)                                          :S(FRETURN)
2675             C = OBJ
2676    FIND_METHOD2
2677             FIND_METHOD = VDIFFER(METHODS(C))<METHOD>
2678             DIFFER(FIND_METHOD)                            :F(FIND_METHOD3)
2679             M_CLASS = C                                           :(RETURN)
2680    FIND_METHOD3
2681             IDENT(C = CLASS(C))                  :S(FRETURN)F(FIND_METHOD2)
        *
        * DISPATCH TO THE PARENT CLASS. THAT, IN TURN, MAY DISPATCH TO ITS
        * PARENT. THIS IS USED WITH 'INIT' (FOR EXAMPLE).
        *
        * TO IMPLEMENT SUPER, WE WANT TO START SEARCHING WITH THE CLASS OF THE
        * CLASS WE FOUND THE METHOD IN. THIS IS IN LOCAL SEND() VARIABLE
        * M_CLASS WHICH IS SET IN FIND_METHOD.
        *
2682    SUPER    SUPER = THIS
2683             IDENT(M_CLASS)                                       :S(RETURN)
2684             M = FIND_METHOD(CLASS(M_CLASS), METHOD)     :F(RETURN)S(SEND_3)
        *
        * DISPATCH METHOD FROM WITHIN A METHOD
        *
2685    SELF     SELF = THIS                                           :(SEND_2)
        *
        * DISPATCH METHOD TO OBJECT. DEFAULT ANSWER IS SIMPLY 'THIS' TO ALLOW
        * CHAINED METHODS
        *
2686    SEND     SEND = THIS
        *
        * ENSURE THAT THIS PARAMETER IS AN OBJECT (OR CLASS).
        *
2687             IDENT(THIS)                                         :S(FRETURN)
2688             IDENT(DATATYPE(THIS), 'OBJECT')                      :S(SEND_2)
2689             TERMINAL = 'SCOOP: SEND NEEDS OBJECT AS RECEIVER'        :(END)
        *
2690    SEND_2   M = FIND_METHOD(THIS, METHOD)                        :S(SEND_3)
2691             M = FIND_METHOD(THIS, 'DOES_NOT_UNDERSTAND')         :S(SEND_3)
        *
        * THIS ERROR SHOULD NOT HAPPEN! (THE ROOT CLASS SHOULD ALWAYS ANSWER
        * DOES_NOT_UNDERSTAND).
        *
2692             TERMINAL =
2692    +           'SCOOP: ROOT CLASS MISSING DOES_NOT_UNDERSTAND'       :(END)
        *
        * WE HAVE THE METHOD, DISPATCH IT. SINCE ALL VARIABLES ARE GLOBAL,
        * ACCESS TO 'THIS' WILL SIMPLY REFER TO SELF AS PASSED TO SEND()
        * WHICH IS WHAT WE WANT.
        *
        * IF THE METHOD IS CODE, EXECUTE IT. OTHERWISE, APPLY M TO THE PASSED
        * ARGUMENTS.
        *
2693    SEND_3   IDENT(DATATYPE(M), 'CODE')                                :S<M>
2694             SEND = APPLY(M, A1, A2, A3, A4, A5, A6, A7, A8)
2694    +                                                   :S(RETURN)F(FRETURN)
        *
2695    OOP_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'SESSION.INC'
        -LINE 81 "SESSION.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'JSON.INC'
        -INCLUDE 'NDBM.INC'
        -MODULE NDBM
        -LINE 10 "NDBM.lss"
        -IN72
        -LINE 70 "NDBM.lss"
        -STITL NDBM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #     #  ######   ######   #     #                   *
        *                 ##    #  #     #  #     #  ##   ##                   *
        *                 # #   #  #     #  #     #  # # # #                   *
        *                 #  #  #  #     #  ######   #  #  #                   *
        *                 #   # #  #     #  #     #  #     #                   *
        *                 #    ##  #     #  #     #  #     #                   *
        *                 #     #  ######   ######   #     #                   *
        *                                                                      *
        * NDBM               NDBM INTERFACE FOR CSNOBOL4                       *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * DECEMBER 3, 2005                                                     *
        *                                                                      *
        ************************************************************************
        *
        * NDBM.lss
        *
        -LINE 13 "NDBM.lss"
2696    NDBM_LOAD
        *
        -PUBLIC DBM_INSERT, DBM_REPLACE
        *
2697             DBM_INSERT = 0
2698             DBM_REPLACE = 1
        *
        -PUBLIC DBM_OPEN(), DBM_CLOSE()
        *
2699             LOAD('DBM_OPEN(STRING,STRING,STRING)INTEGER')
2700             LOAD('DBM_CLOSE(INTEGER)STRING')
        *
        -PUBLIC DBM_STORE(), DBM_FETCH(), DBM_DELETE()
        *
2701             LOAD('DBM_STORE(INTEGER,STRING,STRING,INTEGER)INTEGER')
2702             LOAD('DBM_FETCH(INTEGER,STRING)STRING')
2703             LOAD('DBM_DELETE(INTEGER,STRING)INTEGER')
        *
        -PUBLIC DBM_FIRSTKEY(), DBM_NEXTKEY()
        *
2704             LOAD('DBM_FIRSTKEY(INTEGER)STRING')
2705             LOAD('DBM_NEXTKEY(INTEGER)STRING')
        *
        -PUBLIC DBM_ERROR(), DBM_CLEARERR()
        *
2706             LOAD('DBM_ERROR(INTEGER)STRING')
2707             LOAD('DBM_CLEARERR(INTEGER)STRING')
        *
2708             CODE('NDBM_LOAD')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'WRTFILE.INC'
        -MODULE WRTFILE
        -LINE 13 "WRTFILE.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'SYSTEM.INC'
        -IN72
        -LINE 57 "WRTFILE.lss"
        -STITL WRTFILE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *      #     #  ######   #######  #######  ###  #        #######       *
        *      #  #  #  #     #     #     #         #   #        #             *
        *      #  #  #  #     #     #     #         #   #        #             *
        *      #  #  #  ######      #     #####     #   #        #####         *
        *      #  #  #  #   #       #     #         #   #        #             *
        *      #  #  #  #    #      #     #         #   #        #             *
        *       ## ##   #     #     #     #        ###  #######  #######       *
        *                                                                      *
        * WRTFILE          WRITE COMPLETE FILE FROM STRING                     *
        *                                                                      *
        ************************************************************************
        *
        * WRTFILE.lss
        *
        -LINE 19 "WRTFILE.lss"
2709             DEFINE('WRITEFILE(FILE,S)F,U,E,T')               :(WRTFILE_END)
        *
2710    WRITEFILE
2711             SYSTEM() 'CSNOBOL4'                              :S(WRITEFILE3)
2712             U = 20
2713             OUTPUT(.F, U, FILE)                                 :F(FRETURN)
2714    WRITEFILE2
2715             S BRKREM(CHARS_NL) . T (CHARS_NL | NULL) =
2716             F = T
2717             IDENT(S)                             :S(READFILE4)F(WRITEFILE2)
2718    WRITEFILE3
2719             U = IO_FINDUNIT()
2720             OUTPUT(.F, U, 'B,65536', FILE)
2721    WRITEFILE4
2722             T = LT(SIZE(S), 65536) S                         :F(WRITEFILE6)
2723             S =
2724    WRITEFILE5
2725             F = T
2726             IDENT(S)                             :S(READFILE4)F(WRITEFILE4)
2727    WRITEFILE6
2728             S LEN(65536) . T REM . S                          :(WRITEFILE5)
        *
2729    WRTFILE_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'REPL.INC'
        -INCLUDE 'TIME.INC'
        -STITL SESSION
        -EJECT
        -LINE 233 "SESSION.lss"
        *
        ************************************************************************
        *                                                                      *
        *       #####   #######   #####    #####   ###  #######  #     #       *
        *      #     #  #        #     #  #     #   #   #     #  ##    #       *
        *      #        #        #        #         #   #     #  # #   #       *
        *       #####   #####     #####    #####    #   #     #  #  #  #       *
        *            #  #              #        #   #   #     #  #   # #       *
        *      #     #  #        #     #  #     #   #   #     #  #    ##       *
        *       #####   #######   #####    #####   ###  #######  #     #       *
        *                                                                      *
        * SESSION               SESSION SUPPORT FOR CGI                        *
        *                                                                      *
        ************************************************************************
        *
        * SESSION.lss
        *
        -LINE 93 "SESSION.lss"
        -MODULE SESSION
        -PUBLIC SESSION_CREATE(), SESSION_DELETE(), SESSION_TOUCH()
        -PUBLIC SESSION_PERSIST(), SESSION_LOAD(), SESSION_EXPIRE()
        -PUBLIC SESSION_PERSIST_DIR
2730             DEFINE('SESSION_CREATE(EXPIRE_TIME)')
2731             DEFINE('SESSION_DELETE(SESSION)')
2732             DEFINE('SESSION_TOUCH(SESSION)')
2733             DEFINE('SESSION_PERSIST(SESSION)FILE,HANDLE,A,I')
2734             DEFINE('SESSION_LOAD(UUID)FILE,HANDLE,KEY,DATA,I')
2735             DEFINE('SESSION_EXPIRE()SESSION,TIME,UUID,L,I,S,P')
        *
2736             SESSION_PERSIST_DIR = '/var/lib/SESSION/'        :(SESSION_END)
        *
        * CREATE NEW SESSION. GENERATE UUID FOR SESSION. DEFAULT SESSION
        * EXPIRATION TO 10 MINUTES (UNLESS SPECIFIED).
        *
2737    SESSION_CREATE
2738             SESSION_CREATE = TABLE()
2739             SESSION_CREATE<'UUID'> = BQ('/usr/bin/uuid -v1')    :F(FRETURN)
2740             EXPIRE_TIME = IDENT(EXPIRE_TIME) 600
2741             SESSION_CREATE<'EXPIRE_TIME'> = EXPIRE_TIME           :(RETURN)
        *
        * TOUCH THE SESSION; SETS THE 'EXPIRE' TIME FOR NOW + EXPIRE_TIME.
        *
2742    SESSION_TOUCH
2743             IDENT(SESSION)                                      :S(FRETURN)
2744             SESSION<'EXPIRE'> = TV_SEC(GETTIMEOFDAY()) +
2744    +                               SESSION<'EXPIRE_TIME'>        :S(RETURN)
        *
        * PERSIST SESSION TO DISK. SCALAR VARIABLES ONLY. ARRAYS AND TABLES
        * ARE NOT PERSISTED (ONLY AS THEY PRINT).
        *
2745    SESSION_PERSIST
2746             FILE = SESSION_PERSIST_DIR 'session_' SESSION<'UUID'>
2747             SESSION_DELETE(SESSION)
2748             SESSION_TOUCH(SESSION)                              :F(FRETURN)
        *        A = CONVERT(SESSION, 'ARRAY')                       :F(FRETURN)
        *        HANDLE = DBM_OPEN(FILE, 'CW', '0660')               :F(FRETURN)
        *        SEQ(' DBM_STORE('
        *+                'HANDLE, A<I, 1>, VDIFFER(A<I, 2>), DBM_INSERT) ', .I)
        *        A<I>                                                :S(FRETURN)
        *        DBM_CLOSE(HANDLE)                          :S(RETURN)F(FRETURN)
2749             WRITEFILE(FILE '.db', JSON_ENCODE(SESSION))
2749    +                                                   :S(RETURN)F(FRETURN)
        *
        * DELETE SESSION
        *
2750    SESSION_DELETE
2751             DELETE(SESSION_PERSIST_DIR 'session_' SESSION<'UUID'> '.db')
2751    +                                                              :(RETURN)
        *
        * LOAD SESSION GIVEN UUID. USUALLY, THE UUID COMES FROM A COOKIE.
        *
2752    SESSION_LOAD
2753             UUID = REPL(UUID, ' ', '')
2754             UUID = REPL(UUID, CHARS_TAB, '')
2755             UUID = REPLACE(UUID, &UCASE, &LCASE)
2756             UUID POS(0) ANY('"' "'") REM . UUID
2757             UUID POS(0) SPAN(&DIGITS 'abcdef-') . UUID
        *        SESSION_LOAD = TABLE()
2758             FILE = SESSION_PERSIST_DIR 'session_' UUID
        *        HANDLE = DBM_OPEN(FILE, 'R')                        :F(FRETURN)
        *        KEY = DBM_FIRSTKEY(HANDLE)                    :F(SESSION_LOAD2)
        *        SEQ(' DATA = DBM_FETCH(HANDLE, KEY);'
        *+           ' SESSION_LOAD<KEY> = DATA;'
        *+           ' KEY = DBM_NEXTKEY(HANDLE) ', .I)
        *        DBM_CLOSE(HANDLE)                                   :F(FRETURN)
2759             SESSION_LOAD = JSON_DECODE(READFILE(FILE '.db'))    :F(FRETURN)
2760             IDENT(UUID, SESSION_LOAD<'UUID'>)          :S(RETURN)F(FRETURN)
2761    SESSION_LOAD2
2762             DBM_CLOSE(HANDLE)                                    :(FRETURN)
        *
        * REMOVE EXPIRED SESSIONS FROM DISK.
        *
2763    SESSION_EXPIRE
2764             L = BQ('ls ' SESSION_PERSIST_DIR 'session_*.db 2>/dev/null')
2764    +                                                             :F(RETURN)
2765             TIME = TV_SEC(GETTIMEOFDAY())
2766             L = CRACK(L, ' ')
2767             P = SESSION_PERSIST_DIR 'session_' BREAK('.') . UUID '.db'
2768    SESSION_EXPIRE2
2769             I = I + 1
2770             S = L<I>                                             :F(RETURN)
2771             S P                                                  :F(RETURN)
2772             SESSION = SESSION_LOAD(UUID)                :F(SESSION_EXPIRE2)
2773             GE(SESSION<'EXPIRE'>, TIME)                 :S(SESSION_EXPIRE2)
2774             SESSION_DELETE(SESSION)                      :(SESSION_EXPIRE2)
        *
2775    SESSION_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'UNIQUE.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -STITL CGI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                         #####    #####   ###                         *
        *                        #     #  #     #   #                          *
        *                        #        #         #                          *
        *                        #        #  ####   #                          *
        *                        #        #     #   #                          *
        *                        #     #  #     #   #                          *
        *                         #####    #####   ###                         *
        *                                                                      *
        * CGI                    CGI SUPPORT FUNCTIONS                         *
        *                                                                      *
        ************************************************************************
        *
        * CGI.lss
        *
        -LINE 77 "CGI.lss"
        *
        -PUBLIC CLASS:CGI_CLASS
        *
2776             CGI_CLASS = SEND(CLASS, 'NEW_CLASS', 'CGI_CLASS')
2777             DEFINE('CGI_INIT()A,C')
        *
        -PUBLIC CGI_CLASS:'INIT'
        *
2778             SEND(CGI_CLASS, 'ADD_METHOD', 'INIT', 'CGI_INIT')
        *
        -PUBLIC CGI_CLASS:'GET_COOKIE_JAR'
        *
2779             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_COOKIE_JAR', CODE(
2779    +           ' SEND = |.COOKIE_JAR :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'GET_HEADER'
        *
2780             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_HEADER', CODE(
2780    +           ' SEND = |.HEADER :(RETURN)'))
2781             DEFINE('CGI_SEND()S')
        *
        -PUBLIC CGI_CLASS:'SEND'
        *
2782             SEND(CGI_CLASS, 'ADD_METHOD', 'SEND', 'CGI_SEND')
        *
        -PUBLIC CGI_CLASS:'GET_LOG'
        *
2783             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_LOG', CODE(
2783    +           ' SEND = |.LOG :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'GET_CONTENT'
        *
2784             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_CONTENT', CODE(
2784    +           ' SEND = |.CONTENT :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'SET_CONTENT'
        *
2785             SEND(CGI_CLASS, 'ADD_METHOD', 'SET_CONTENT', CODE(
2785    +           ' |.CONTENT = A1 :(RETURN)'))
2786             DEFINE('CGI_CLOSE()A')
        *
        -PUBLIC CGI_CLASS:'CLOSE'
        *
2787             SEND(CGI_CLASS, 'ADD_METHOD', 'CLOSE', 'CGI_CLOSE')
        *
        -PUBLIC CGI_CLASS:'GET_ENV'
        *
2788             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_ENV', CODE(
2788    +           ' SEND = |.ENV :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'GET_QUERY'
        *
2789             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_QUERY', CODE(
2789    +           ' SEND = |.QUERY :(RETURN)'))
        *
2790                                                           :(CGI_OBJECT_END)
        *
        * CLOSE CGI OBJECT
        *
2791    CGI_CLOSE
2792             ENDFILE(|.OUT_UNIT)
2793             DETACH(|.OUT)
2794             ENDFILE(|.LOG_UNIT)
2795             DETACH(|.LOG)                                         :(RETURN)
        *
        * INITIALIZE CGI OBJECT
        *
2796    CGI_INIT CGI_INIT = SUPER('INIT')
        *
        * CREATE LOG CHANNEL
        *
2797             |.LOG_UNIT = IO_FINDUNIT()                          :F(FRETURN)
2798             |.LOG = UNIQUE()
        *
        * WITH ALL THE CHANGES GOING TO SYSTEMD, LOGGING APPEARS TO HAVE
        * SUFFERED. SPECIFICALLY, IF THE LOGGING IS ONLY FORWARDED TO
        * RSYSLOG, LOGGER LOCAL DOESN'T WORK. WE ENABLE RSYSLOG TO LISTEN TO
        * THE NETWORK, AND THEN LOGGER CAN LOG TO LOCALHOST. STRANGE, AND
        * PROBABLY NOT SUITABLE FOR PRODUCTION.
        *
        * IF USING SYSTEMD LOGGER, DON'T USE -n localhost
        *
2799             OUTPUT(|.LOG, |.LOG_UNIT, 'W',
2799    +               '|/usr/bin/logger -n localhost -t CGI')      :F(FRETURN)
        *+              '|/usr/bin/logger -t CGI')                   :F(FRETURN)
        *
        * CREATE OUT CHANNEL
        *
2800             |.OUT_UNIT = IO_FINDUNIT()                          :F(FRETURN)
2801             |.OUT = UNIQUE()
2802             OUTPUT(|.OUT, |.OUT_UNIT, 'B', '/dev/stdout')       :F(FRETURN)
        *
        * COLLECT ENVIRONMENT VARIABLES INTO INSTANCE VARIABLE ENV. WE ONLY
        * GATHER UP "KNOWN" ENVIRONMENT VARIABLES.
        *
2803             |.ENV = DIFFER(USE_FCGI) FCGI_ENV                 :S(CGI_ENV_2)
        *
2804             |.ENV = TABLE(38)
2805             A = %('AUTH_TYPE,CONTENT_LENGTH,CONTENT_TYPE,'
2805    +              'CONTEXT_DOCUMENT_ROOT,CONTEXT_PREFIX,DOCUMENT_ROOT,'
2805    +              'GATEWAY_INTERFACE,HTTP_ACCEPT,HTTP_ACCEPT_CHARSET,'
2805    +              'HTTP_ACCEPT_ENCODING,HTTP_ACCEPT_LANGUAGE,'
2805    +              'HTTP_CACHE_CONTROL,HTTP_CONNECTION,HTTP_COOKIE,'
2805    +              'HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,LIB_PATH,PATH,'
2805    +              'PATH_INFO,PATH_TRANSLATED,QUERY_STRING,REMOTE_ADDR,'
2805    +              'REMOTE_HOST,REMOTE_IDENT,REMOTE_PORT,REQUEST_METHOD,'
2805    +              'REQUEST_SCHEME,REQUEST_URI,SCRIPT_FILENAME,SCRIPT_NAME,'
2805    +              'SERVER_ADDR,SERVER_ADMIN,SERVER_NAME,SERVER_PORT,'
2805    +              'SERVER_PROTOCOL,SERVER_SIGNATURE,SERVER_SOFTWARE')
2806             SEQ(' (|.ENV)<A<I>> = HOST(HOST_GETENV, A<I>); A<I> ', .I)
2807    CGI_ENV_2
2808             $|.LOG = 'FCGI_ENV IN CGI'
2809             $|.LOG = JSON_ENCODE(FCGI_ENV)
2810             $|.LOG = 'QUERY_STRING: ' (|.ENV)<'QUERY_STRING'>
        *
        * FOR POST METHOD, READ (|.ENV)<'CONTENT_LENGTH'>. READ THAT NUMBER OF
        * BYTES, AND ONLY THAT NUMBER. NOTE THAT THIS MAY BE VERY LARGE. THIS
        * MAY FAIL DUE TO MEMORY EXHAUSTION. WE KNOW THAT WE CAN READ A LARGE
        * NUMBER OF BYTES, BUT I HAVE TO DETERMINE THE LIMIT.
        *
        * FOR FCGI, USE FCGI_IN. FIXME: SHOULD TEST CONTENT_LENGTH
        *
2811             (|.ENV)<'QUERY_STRING'> = DIFFER(USE_FCGI) VDIFFER(FCGI_IN)
2811    +                                                         :S(CGI_INIT_3)
2812             T3 = (|.ENV)<'CONTENT_LENGTH'>
2813             IDENT(T3)                                        :S(CGI_INIT_3)
2814             (INTEGER(T3) GT(T3))                             :F(CGI_INIT_3)
2815             T1 = IO_FINDUNIT()                                  :F(FRETURN)
2816             INPUT('T2', T1, 'B,' T3, '/dev/stdin')              :F(FRETURN)
2817             (|.ENV)<'QUERY_STRING'> = T2
2818             ENDFILE(T1)
2819             DETACH('T2')
2820    CGI_INIT_3
        *
        * PARSE QUERY_STRING INTO QUERY TABLE. HASH() IS USED TO PARSE
        * QUERY_STRING, BREAKING INTO NAME=VALUE SEPARATED BY &. EACH VALUE IS
        * PROCESSED WITH URL_DECODE().
        *
        * MULTI-VALUE FIELDS ARE SEPARATED BY 0. USED BY CHECKBOXES
        *
2821             |.QUERY = HASH((|.ENV)<'QUERY_STRING'>, '=', '&',,,,
2821    +                        'URL_DECODE', CHARS_NUL)
2822             $|.LOG = 'QUERY TABLE'
2823             $|.LOG = JSON_ENCODE(|.QUERY)
        *
        * PARSE HTTP_COOKIE INTO A COOKIE JAR. THERE MAY NOT BE ANY COOKIES,
        * IN WHICH CASE WE CREATE AN EMPTY COOKIE JAR. THE VALUES OF THE
        * COOKIES ARE NOT VALIDATED. HASH() PARSES THE COOKIE STRING. AFTER
        * THE TABLE IS GENERATED, IT IS CONVERTED TO AN ARRAY. SEQ() ADDS
        * EACH ELEMENT INTO THE COOKIE JAR.
        *
2824             |.COOKIE_JAR = NEW_COOKIE_JAR()
2825             A = HASH((|.ENV)<'HTTP_COOKIE'>, '=', ';',,,
2825    +                  'COOKIE_FIX_NAME', 'URL_DECODE')
2826             A = CONVERT(A, 'ARRAY')                          :F(CGI_INIT_2)
2827             SEQ(' PUT_COOKIE_IN_JAR(|.COOKIE_JAR,'
2827    +                               'A<I,1>, NEW_COOKIE(A<I,2>)) ', .I)
2828    CGI_INIT_2
        *
        * INITIALIZE HEADER. THE HEADER IS A TABLE() WITH AT LEAST CONTENT_TYPE
        * ENTRY.
        *
2829             |.HEADER = #'CONTENT_TYPE=TEXT/HTML,CHARSET='
        *
        * INITIALIZE CONTENT
        *
2830             |.CONTENT =
        *
        * WE NEED ROUTING IMPLEMENTED.
        *
        * WE NEED TO DO FURTHER PROCESSING ON THE FOLLOWING CGI ENVIRONMENT
        * VARIABLES.
        *
        * <ISINDEX> value1+value2+..
        * HTTP_ACCEPT
        *   ='TEXT/HTML,APPLICATION/XHTML+XML,APPLICATION/XML;Q=0.9,*/*;Q=0.8'
        * HTTP_ACCEPT_ENCODING='GZIP, DEFLATE'
        * HTTP_ACCEPT_LANGUAGE='EN-US,EN;Q=0.5'
        *
2831                                                                   :(RETURN)
        *
        * OUTPUT THE HEADER AND CONTENT
        *
2832    CGI_SEND
        *
        * FIRST, OUTPUT THE CONTENT-TYPE. IF CHARSET HAS BEEN SPECIFIED,
        * ADD THIS TO THE CONTENT-TYPE.
        *
2833             S = 'Content-type: ' (|.HEADER)<'CONTENT_TYPE'>
2834             S = S '; charset=' VDIFFER((|.HEADER)<'CHARSET'>)
2835             S = S CHARS_CR CHARS_NL
        *
        * GENERATE THE COOKIE STRING AND OUTPUT IF WE HAVE COOKIES TO SEND.
        *
2836             S = S VDIFFER(COOKIE_STRING(|.COOKIE_JAR))
        *
        * THE HEADER FINISHES WITH A CR/LF
        *
2837             S = S CHARS_CR CHARS_NL
2838             $|.OUT = IDENT(USE_FCGI) S
2839             DIFFER(USE_FCGI) FCGI_SEND(S)
        *
        * SEND CONTENT
        *
2840             $|.OUT = IDENT(USE_FCGI) |.CONTENT
2841             DIFFER(USE_FCGI) FCGI_SEND(|.CONTENT)
2842             DIFFER(USE_FCGI) FCGI_SEND('')
2843             DIFFER(USE_FCGI) FCGI_END(0, FCGI_REQUEST_COMPLETE)
2844                                                                   :(RETURN)
        *
2845    CGI_OBJECT_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'CH.INC'
        -INCLUDE 'COMB.INC'
        -MODULE COMB
        -LINE 9 "COMB.lss"
        -IN72
        -LINE 35 "COMB.lss"
        -STITL COMB
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                     #####   #######  #     #  ######                 *
        *                    #     #  #     #  ##   ##  #     #                *
        *                    #        #     #  # # # #  #     #                *
        *                    #        #     #  #  #  #  ######                 *
        *                    #        #     #  #     #  #     #                *
        *                    #     #  #     #  #     #  #     #                *
        *                     #####   #######  #     #  ######                 *
        *                                                                      *
        * COMB                        COMBINATIONS                             *
        *                                                                      *
        ************************************************************************
        *
        * COMB.lss
        *
        -LINE 12 "COMB.lss"
        -PUBLIC COMB()
        *
2846             DEFINE('COMB(N,M)')                                 :(COMB_END)
        *
2847    COMB     COMB = EQ(M, 0) 1                                    :S(RETURN)
2848             COMB = COMB(N - 1, M - 1) * N / M                     :(RETURN)
        *
2849    COMB_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COMPLEX.INC'
        -MODULE COMPLEX
        -LINE 8 "COMPLEX.lss"
        -IN72
        -LINE 59 "COMPLEX.lss"
        -STITL COMPLEX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *     #####   #######  #     #  ######   #        #######  #     #     *
        *    #     #  #     #  ##   ##  #     #  #        #         #   #      *
        *    #        #     #  # # # #  #     #  #        #          # #       *
        *    #        #     #  #  #  #  ######   #        #####       #        *
        *    #        #     #  #     #  #        #        #          # #       *
        *    #     #  #     #  #     #  #        #        #         #   #      *
        *     #####   #######  #     #  #        #######  #######  #     #     *
        *                                                                      *
        *                                                                      *
        * COMPLEX                   COMPLEX NUMBERS                            *
        *                                                                      *
        ************************************************************************
        *
        * COMPLEX.lss
        *
        -LINE 11 "COMPLEX.lss"
        -PUBLIC COMPLEX(), R(), I()
        *
2850             DATA('COMPLEX(R,I)')
        *
        -PUBLIC ADD_COMPLEX(), MUL_COMPLEX(), NEG_COMPLEX(), INV_COMPLEX()
        -PUBLIC PRINT_COMPLEX()
        *
2851             DEFINE('ADD_COMPLEX(X,Y)')
2852             DEFINE('MUL_COMPLEX(X,Y)A,B,C,D')
2853             DEFINE('NEG_COMPLEX(X)')
2854             DEFINE('INV_COMPLEX(X)D')
2855             DEFINE('PRINT_COMPLEX(X)SIGN')                   :(COMPLEX_END)
        *
2856    ADD_COMPLEX
2857             ADD_COMPLEX = COMPLEX(R(X) + R(Y), I(X) + I(Y))       :(RETURN)
        *
2858    MUL_COMPLEX
2862             A = R(X); B = I(X); C = R(Y); D = I(Y)
2863             MUL_COMPLEX = COMPLEX(A * C - B * D, B * C + A * D)   :(RETURN)
        *
2864    NEG_COMPLEX
2865             NEG_COMPLEX = COMPLEX(-R(X), -I(X))                   :(RETURN)
        *
2866    INV_COMPLEX
2867             D = (R(X) * R(X)) + (I(X) * I(X))
2868             INV_COMPLEX = COMPLEX(1.0 * R(X) / D, 1.0 * -I(X) / D)
2868    +                                                              :(RETURN)
        *
2869    PRINT_COMPLEX
2870             SIGN = GE(I(X)) '+'
2871             PRINT_COMPLEX = R(X) SIGN I(X) 'i'                    :(RETURN)
        *
2872    COMPLEX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COOKIE.INC'
        -INCLUDE 'COPYL.INC'
        -MODULE COPYL
        -LINE 10 "COPYL.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 47 "COPYL.lss"
        -STITL COPYL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #####   #######  ######   #     #  #                 *
        *                #     #  #     #  #     #   #   #   #                 *
        *                #        #     #  #     #    # #    #                 *
        *                #        #     #  ######      #     #                 *
        *                #        #     #  #           #     #                 *
        *                #     #  #     #  #           #     #                 *
        *                 #####   #######  #           #     #######           *
        *                                                                      *
        * COPYL                        COPY LIST                               *
        *                                                                      *
        ************************************************************************
        *
        * COPYL.lss
        *
        -LINE 14 "COPYL.lss"
        -PUBLIC COPYL()
        *
2873             DEFINE('COPYL(L)T')                                :(COPYL_END)
        *
2874    COPYL    DEFINE('COPYL(L)', 'COPYL_1')
2875             T = TABLE(100)
2876             COPYL = COPYL(L)
2877             DEFINE('COPYL(L)T')                                   :(RETURN)
2878    COPYL_1  COPYL = L
2879             IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
2880             COPYL = T<L>
2881             DIFFER(COPYL, NULL)                                  :S(RETURN)
2882             COPYL = COPY(L)
2883             T<L> = COPYL
2884             VALUE(COPYL) = COPYL(VALUE(L))
2885             NEXT(COPYL) = COPYL(NEXT(L))                          :(RETURN)
        *
2886    COPYL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COPYT.INC'
        -INCLUDE 'COUNT.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'CVAR.INC'
        -MODULE CVAR
        -USES HASH()
        -LINE 73 "CVAR.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HASH.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'P64.INC'
        -LINE 264 "CVAR.lss"
        -IN72
        -STITL CVAR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                   #####   #     #     #     ######                   *
        *                  #     #  #     #    # #    #     #                  *
        *                  #        #     #   #   #   #     #                  *
        *                  #        #     #  #     #  ######                   *
        *                  #         #   #   #######  #   #                    *
        *                  #     #    # #    #     #  #    #                   *
        *                   #####      #     #     #  #     #                  *
        *                                                                      *
        * CVAR           C VARIABLE DECLARATIONS, AND LOAD/STORE               *
        *                                                                      *
        ************************************************************************
        *
        * CVAR.lss
        *
        -LINE 80 "CVAR.lss"
        *
        * FIXME - ISOLATE BY PASSING CVARSYMS
        *
        * THIS WILL ALLOW SUPPORT OF MULTIPLE ROUTINES. BUT... PARAMETER
        * PASSING WILL BE... DIFFICULT. RECURSION IS TOUGH. WE CAN SIMPLY
        * SET PARAMETER VARIABLES IF NEEDED. PARAMETERS ARE TOUGHER. WE
        * CAN RETRIEVE POINTER. BUT THAT DOESN'T DEFINE STORAGE! ON RECURSIVE
        * CALL WE WOULD NEED TO SAVE ALL PARAMETERS TO A STACK. WHICH WOULD
        * WORK FOR DIRECT RECURSIVE CALL. ALTERNATIVE IS PUSH AND RETRIEVE,
        * AND COPY BACK ON RETURN.
        *
        * PUSH/POP OF PARAMETERS TO ALTERNATE STACK... CRIB STACK CODE.
        * TO PUSH DOUBLE, PUSH TWO WORDS, OR ONE QWORD. REGISTER IS QWORD.
        * PUSH MEMORY_WORD, PUSH MEMORY_QWORD WOULD BE USEFUL... (AND POP
        * VARIANTS): PUSHMW PUSHMQ POPMW POPMQ, AND PUSH POP.
        *
        * THEN,
        *
        * FUNCTION NAME(P1,P2...PN)
        * INTEGER V(D1,D2,D3),V...
        * REAL V
        * DOUBLE PRECISION V
        * LOGICAL V
        * DIMENSION V(D1,D2,D3)
        * COMMON /NAME/ V,V,V...
        *
        * BY DEFAULT, FUNCTION CREATE COMMON BLOCK NAME_
        *
        * LABEL EXPR
        *       IF (EXPR) EXPR
        *       GOTO LABEL
        *
        * CALL THIS LANGUAGE "F00" - MINI-FORTRAN. WE CAN INTRODUCE DO,
        * RETURN, ETC.
        *
        -PUBLIC CVARSYMS(), CV_BASE(), CV_SYMTAB(), CV_END()
        *
2887             DATA('CVARSYMS(CV_BASE,CV_SYMTAB,CV_END)')
        *
        -PUBLIC CVART(), CV_OFFSET(), CV_SIZE(), CV_DIM(), CV_SIGN(), CV_ISINT()
        *
2888             DATA('CVART(CV_OFFSET,CV_SIZE,CV_DIM,CV_SIGN,CV_ISINT)')
        *
        -PUBLIC PTRV(), LOADV(), STOREV(), NEWDECLV(), DECLAREV()
        *
2889             DEFINE('PTRV(B,V,I)')
2890             DEFINE('LOADV(B,V,I)')
2891             DEFINE('STOREV(B,V,I,X)')
2892             DEFINE('NEWDECLV()')
2893             DEFINE('DECLAREV(L)SIGN,INT,FLOAT,AL,NU,SP,BS,BN,IDENT,DIM,'
2893    +                          'INTDECL,FLOATDECL,DECL,SIZE,ALIGN,ISINT,'
2893    +                          'S,T,I,N,SIGNED')
2894                                                             :(DECLAREV_END)
        *
2895    PTRV     V = VTAB<V>
2896             IDENT(V)                                            :S(FRETURN)
2897             I = IDENT(I) 0
2898             PTRV = B + CV_OFFSET(V) + I * CV_SIZE(V)              :(RETURN)
        *
2899    STOREV   B = PTRV(B, V, I)                                   :F(FRETURN)
2900             V = VTAB<V>                          :($('STOREV_' CV_SIZE(V)))
2901    STOREV_1 POKE_C(B, X)                                          :(RETURN)
2902    STOREV_2 POKE_S(B, X)                                          :(RETURN)
2903    STOREV_4 (EQ(CV_ISINT(V)) POKE_F(B, X))                       :S(RETURN)
2904             POKE_I(B, X)                                          :(RETURN)
2905    STOREV_8 (EQ(CV_ISINT(V)) POKE_D(B, X))                       :S(RETURN)
2906             POKE_P(B, X)                                          :(RETURN)
        *
2907    LOADV    B = PTRV(B, V, I)                                   :F(FRETURN)
2908             V = VTAB<V>                           :($('LOADV_' CV_SIZE(V)))
2909    LOADV_1  LOADV = PEEK_C(B)
2910             NE(CV_SIGN(V))                                       :S(RETURN)
2911             LOADV = LT(LOADV) (2 ** 8) + LOADV                    :(RETURN)
2912    LOADV_2  LOADV = PEEK_S(B)
2913                                                                   :(RETURN)
2914             NE(CV_SIGN(V))                                       :S(RETURN)
2915             LOADV = LT(LOADV) (2 ** 16) + LOADV                   :(RETURN)
2916    LOADV_4  LOADV = EQ(CV_ISINT(V)) PEEK_F(B)                    :S(RETURN)
2917             LOADV = PEEK_I(B)
        -LINE 168 "CVAR.lss"
2918             NE(CV_SIGN(V))                                       :S(RETURN)
2919             LOADV = LT(LOADV) (2 ** 32) + LOADV                   :(RETURN)
2920    LOADV_8  LOADV = EQ(CV_ISINT(V)) PEEK_D(B)                    :S(RETURN)
2921             LOADV = PEEK_P(B)                                     :(RETURN)
        *
2922    NEWDECLV VTAB = TABLE()
2923             VOFFSET = 0                                           :(RETURN)
        *
2924    DECLAREV SIGN = ('signed' | 'SIGNED' | 'unsigned' | 'UNSIGNED') . S
2925             INT =  ('char' | 'CHAR' | 'short' | 'SHORT' | 'int' |
2925    +                'INT' | 'long' | 'LONG' | 'pointer' | 'POINTER') . T
2926             FLOAT = ('float' | 'FLOAT' | 'double' | 'DOUBLE') . T
2927             AL = &UCASE &LCASE
2928             NU = &DIGITS
2929             SP = '_'
2930             BS = SPAN(' ' CHARS_TAB)
2931             BN = BS | NULL
2932             IDENT = (ANY(AL SP) (SPAN(AL NU SP) | NULL)) . I
2933             DIM = '[' BN SPAN(&DIGITS) . N BN ']'
2934             INTDECL = (SIGN BS INT) | SIGN | INT
2935             FLOATDECL = FLOAT
2936             DECL = BN (INTDECL | FLOATDECL) BN IDENT BN (DIM | NULL)
        *
2937             SIZE =
2937    +           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
2938             ALIGN =
2938    +           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
2939             ISINT =
2939    +           #'CHAR=1,SHORT=1,INT=1,LONG=1,POINTER=1,FLOAT=,DOUBLE='
        *
        * ASSIGN PATTERN VARIABLE TO DEFAULTS - SIGNED INT [1]
        *
2940             S = 'SIGNED'
2941             T = 'INT'
2942             I =
2943             N = 1
        *
        * SCAN THE DECLARATION, SETTING PATTERN VARIABLES S, T, I, N
        *
2944             L DECL                                              :F(FRETURN)
        *
        * CONVERT T AND S TO UPPERCASE
        *
2945             T = REPLACE(T, &LCASE, &UCASE)
2946             S = REPLACE(S, &LCASE, &UCASE)
        *
        * SIGNED = 1 IF SIGNED, 0 IF UNSIGNED
        *
2947             SIGNED = 0
2948             S 'UNSIGNED'                                         :S(DECLV2)
2949             SIGNED = 1
        *
        * ADJUST OFFSET FOR ALIGNMENT
        *
2950    DECLV2   R = REMDR(VOFFSET, ALIGN<T>)
2951             VOFFSET = NE(R) VOFFSET + (ALIGN<T> - R)
        *
        * ALREADY DECLARED?
        *
2952             V = VTAB<I>
2953             IDENT(V)                                            :F(FRETURN)
        *
        * CREATE CVART() RECORD FOR NEW VARIABLE
        *
2954             V = CVART(VOFFSET, SIZE<T>, N, SIGNED, ISINT<T>)
        *
        * PUT VARIABLE INTO SYMBOL TABLE
        *
2955             VTAB<I> = V
        *
        * ADJUST OFFSET BY SIZE OF NEW VARIABLE (INCLUDING DIMENSION)
        *
2956             VOFFSET = VOFFSET + SIZE<T> * N
        *
2957             DECLAREV = VOFFSET                                    :(RETURN)
        *
2958    DECLAREV_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DAY.INC'
        -MODULE DAY
        -LINE 10 "DAY.lss"
        -IN72
        -LINE 59 "DAY.lss"
        -STITL DAY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      ######      #     #     #                       *
        *                      #     #    # #     #   #                        *
        *                      #     #   #   #     # #                         *
        *                      #     #  #     #     #                          *
        *                      #     #  #######     #                          *
        *                      #     #  #     #     #                          *
        *                      ######   #     #     #                          *
        *                                                                      *
        * DAY                         DAY OF WEEK                              *
        *                                                                      *
        ************************************************************************
        *
        * DAY.lss
        *
        -LINE 13 "DAY.lss"
        -PUBLIC DAY()
        *
2959             DEFINE('DAY(DATE)M,Y,CD')
2960             YEAR_ = 365
2961             YEAR_4 = 4 * YEAR_ + 1
2962             CENT_ = (25 * YEAR_4) - 1
2963             CENT_4 = 4 * CENT_ + 1
2964             DAY_ZERO = 2                                         :(DAY_END)
        *
2965    DAY      CD = DATE()
2966             DIFFER(DATE)                                          :S(DAY_3)
        * IF NO DATE GIVEN, USE TODAY
2967             CD ARB . DATE ' '
2968    DAY_3    DATE BREAK('/') . M LEN(1)
2968    +           (BREAK('/') . D LEN(1) REM . Y | REM . D)
        * IF NO YEAR GIVEN, USE THIS YEAR
2969             (IDENT(Y) CD) '/' ARB '/' LEN(4) . Y
        * TWO DIGIT YEAR IS 20XX
2970             Y = EQ(SIZE(Y), 2) '20' Y
2971             M = LE(M, 2) M + 12                                   :F(DAY_1)
2972             Y = Y - 1
2973    DAY_1    M = M - 3
2974    DAY_2    DAY = (Y / 400) * CENT_4 + (REMDR(Y, 400) / 100) * CENT_
2974    +           +  (REMDR(Y, 100) / 4) * YEAR_4 +  REMDR(Y, 4) * YEAR_
2975             DAY = DAY + ((153 * M) + 2) / 5 + D + DAY_ZERO
2976             D = REMDR(DAY, 7)
2977             '0SUN1MON2TUES3WEDNES4THURS5FRI6SATUR7'
2977    +           D BREAK('01234567') . DAY
2978             DAY = DAY 'DAY'                                       :(RETURN)
        *
2979    DAY_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DDT.INC'
        -INCLUDE 'DEDUPA.INC'
        -MODULE DEDUPA
        -LINE 14 "DEDUPA.lss"
        -INCLUDE 'SIZEA.INC'
        -INCLUDE 'HASH.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'ARRAY0.INC'
        -IN72
        -LINE 46 "DEDUPA.lss"
        -STITL DEDUPA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######   #######  ######   #     #  ######      #            *
        *         #     #  #        #     #  #     #  #     #    # #           *
        *         #     #  #        #     #  #     #  #     #   #   #          *
        *         #     #  #####    #     #  #     #  ######   #     #         *
        *         #     #  #        #     #  #     #  #        #######         *
        *         #     #  #        #     #  #     #  #        #     #         *
        *         ######   #######  ######    #####   #        #     #         *
        *                                                                      *
        *                                                                      *
        * DEDUPA                      DEDUP ARRAY                              *
        *                                                                      *
        ************************************************************************
        *
        * DEDUPA.lss
        *
        -LINE 21 "DEDUPA.lss"
        -PUBLIC DEDUPA()
        *
2980             DEFINE('DEDUPA(A)T,I')                            :(END_DEDUPA)
        *
2981    DEDUPA   DEDUPA = IDENT(A, ARRAY0) A                          :S(RETURN)
2982             T = TABLE()
2983             SEQ(' T<A<I>> = 1', .I)
2984             DEDUPA = KEYST(T)                                     :(RETURN)
        *
2985    END_DEDUPA
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DEXP.INC'
        -INCLUDE 'DISPLAY.INC'
        -MODULE DISPLAY
        -LINE 14 "DISPLAY.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -LINE 147 "DISPLAY.lss"
        -STITL DISPLAY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *     ######   ###   #####   ######   #           #     #     #        *
        *     #     #   #   #     #  #     #  #          # #     #   #         *
        *     #     #   #   #        #     #  #         #   #     # #          *
        *     #     #   #    #####   ######   #        #     #     #           *
        *     #     #   #         #  #        #        #######     #           *
        *     #     #   #   #     #  #        #        #     #     #           *
        *     ######   ###   #####   #        #######  #     #     #           *
        *                                                                      *
        * DISPLAY            DISPLAY CONTROL (FULL-SCREEN)                     *
        *                                                                      *
        ************************************************************************
        *
        * DISPLAY.lss
        *
        -LINE 20 "DISPLAY.lss"
        -PUBLIC DS_SMSO, DS_RMSO, DS_SMUL, DS_RMUL, DS_BLINK
        -PUBLIC DS_BOLD, DS_DIM, DS_REV, DS_SGR0, DS_CIVIS, DS_CNORM, DS_CVVIS
        -PUBLIC DS_GOTO(), DS_FOREGROUND_COLOR(), DS_BACKGROUND_COLOR()
        -PUBLIC DS_BLACK, DS_RED, DS_GREEN, DS_YELLOW, DS_BLUE, DS_PURPLE
        -PUBLIC DS_CYAN, DS_WHITE, DS_IND, DS_RI
        -PUBLIC DS_EL, DS_HOME, DS_CLEAR, DS_COLS, DS_LINES
        *
2986    DISPLAY
        *
        * GATHER STATIC TERMINAL STRINGS.
        *
        * STANDOUT (BOLD)
2987             DS_SMSO  = BQ('tput smso')
        * STANDOUT OFF
2988             DS_RMSO  = BQ('tput rmso')
        * UNDERLINE
2989             DS_SMUL  = BQ('tput smul')
        * UNDERLINE OFF
2990             DS_RMUL  = BQ('tput rmul')
        * BLINK
2991             DS_BLINK = BQ('tput blink')
        * BOLD
2992             DS_BOLD  = BQ('tput bold')
        * DIM (HALF-BRIGHT)
2993             DS_DIM   = BQ('tput dim')
        * REVERSE
2994             DS_REV   = BQ('tput rev')
        * RESET ALL
2995             DS_SGR0  = BQ('tput sgr0')
        *
        * CURSOR OFF
2996             DS_CIVIS = BQ('tput civis')
        * CURSOR ON
2997             DS_CNORM = BQ('tput cnorm')
        * CURSOR VERY VISIBLE
2998             DS_CVVIS = BQ('tput cvvis')
        *
        * ERASE TO END-LINE
2999             DS_EL    = BQ('tput el')
        * HOME CURSOR
3000             DS_HOME  = BQ('tput home')
        * CLEAR DISPLAY
3001             DS_CLEAR = BQ('tput clear')
        *
        * NUMBER OF COLUMNS
3002             DS_COLS  = BQ('tput cols')
        *
        * NUMBER OF LINES
3003             DS_LINES = BQ('tput lines')
        *
        * DYNAMIC STRINGS. THESE ARE CACHED IN TABLE DS_
        *
3004             DS_ = TABLE(DS_LINES * DS_COLS + 16)
        *
3005             DEFINE('DS_GOTO(ROW,COL)')
3006             DEFINE('DS_FOREGROUND_COLOR(N)')
3007             DEFINE('DS_BACKGROUND_COLOR(N)')
        *
        * DEFINED COLORS
        *
3008             DS_BLACK  = 0
3009             DS_RED    = 1
3010             DS_GREEN  = 2
3011             DS_YELLOW = 3
3012             DS_BLUE   = 4
3013             DS_PURPLE = 5
3014             DS_CYAN   = 6
3015             DS_WHITE  = 7                                    :(DS_GOTO_END)
        *
        -LINE 96 "DISPLAY.lss"
        *
        * SET FOREGROUND COLOR.
        *
3016    DS_FOREGROUND_COLOR
3017             DS_FOREGROUND_COLOR = VDIFFER(DS<'F' N>)             :S(RETURN)
3018             DS_<'F' N> = BQ('tput setaf ' N)         :(DS_FOREGROUND_COLOR)
        *
        * SET BACKGROUND COLOR.
        *
3019    DS_BACKGROUND_COLOR
3020             DS_BACKGROUND_COLOR = VDIFFER(DS<'B' N>)             :S(RETURN)
3021             DS_<'B' N> = BQ('tput setab ' N)         :(DS_BACKGROUND_COLOR)
        *
        * POSITION CURSOR TO (ROW, COLUMN)
        *
3022    DS_GOTO  DS_GOTO = VDIFFER(DS_<ROW ' ' COL>)                  :S(RETURN)
        *
        -LINE 119 "DISPLAY.lss"
3023             DS_<ROW ' ' COL> = BQ('tput cup ' ROW ' ' COL)       :(DS_GOTO)
        *
3024    DS_GOTO_END
        *
        * IND - SCROLL UP
        * NOTE THAT IND IS NL, SO BQ RETURNS IS NOT SUITABLE WE THEREFORE
        * DON'T USE BQ('tput ind') BUT CHARS_NL DIRECTLY
        *
3025             DS_IND = DS_GOTO(DS_LINES - 1, 0) CHARS_NL
        * RI - SCROLL DOWN
3026             DS_RI = DS_HOME BQ('tput ri')
        *
3027             CODE('DISPLAY')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DSERVE.INC'
        -INCLUDE 'DYNAMIC.INC'
        -MODULE DYNAMIC
        -LINE 11 "DYNAMIC.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'REPL.INC'
        -IN72
        -LINE 199 "DYNAMIC.lss"
        -STITL DYNAMIC
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    ######   #     #  #     #     #     #     #  ###   #####          *
        *    #     #   #   #   ##    #    # #    ##   ##   #   #     #         *
        *    #     #    # #    # #   #   #   #   # # # #   #   #               *
        *    #     #     #     #  #  #  #     #  #  #  #   #   #               *
        *    #     #     #     #   # #  #######  #     #   #   #               *
        *    #     #     #     #    ##  #     #  #     #   #   #     #         *
        *    ######      #     #     #  #     #  #     #  ###   #####          *
        *                                                                      *
        * DYNAMIC       CREATE DYNAMICALLY LOADABLE MODULE FOR LOAD()          *
        *                                                                      *
        * PHIL BUDNE, NOVEMBER 2005                                            *
        *                                                                      *
        ************************************************************************
        *
        * DYNAMIC.lss
        *
        -LINE 17 "DYNAMIC.lss"
        -PUBLIC COMPILE_COBOL(), COMPILE_FORTRAN(), COMPILE_SCHEME()
        -PUBLIC COMPILE_DYNAMIC(), LIBS_FORTRAN(), LIBS_COBOL(), LIBS_SCHEME()
        *
3028    DYNAMIC  DEFINE('COMPILE_COBOL(SRC)CMD,COBC')
3029             DEFINE('COMPILE_FORTRAN(SRC)CMD')
3030             DEFINE('COMPILE_SCHEME(SRC)CMD,CC,DL_CFLAGS,COPT')
3031             DEFINE('COMPILE_DYNAMIC(SRC)CMD,CC,DL_CFLAGS,COPT,CINC')
3032             DEFINE('LIBS_FORTRAN()')
3033             DEFINE('LIBS_COBOL()')
3034             DEFINE('LIBS_SCHEME()')                  :(COMPILE_DYNAMIC_END)
        *
        -LINE 33 "DYNAMIC.lss"
3035    LIBS_FORTRAN
3036             LIBS_FORTRAN = '-lgfortran'                           :(RETURN)
        *
        -LINE 42 "DYNAMIC.lss"
3037    LIBS_COBOL
3038             LIBS_COBOL = BQ('cob-config --libs')                  :(RETURN)
        *
        -LINE 50 "DYNAMIC.lss"
3039    LIBS_SCHEME
3040             LIBS_SCHEME = 'prog_.o -lgambc -ldl -lm -lutil'       :(RETURN)
        -LINE 59 "DYNAMIC.lss"
        *
        * DYNAMIC COMPILE COBOL SOURCE
        *
3041    COMPILE_COBOL
3042             CMD = 'cobc -C ' SRC
3043             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3044             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3045             COBC = BQ('cob-config --cflags')
3046             SRC '.cbl' =
3047             SRC '.CBL' =
3048             CC = HOST(HOST_CC)                                  :F(FRETURN)
3049             IDENT(CC)                                           :S(FRETURN)
3050             DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
3051             COPT = HOST(HOST_COPT) ' '
3052             CMD = CC ' -c ' COPT DL_CFLAGS ' -DPIC -O3 ' COBC ' ' SRC '.c'
3053             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3054             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3055             DELETE(SRC '.c')
3056             DELETE(SRC '.c.h')
3057             DELETE(SRC '.c.l.h')                                  :(RETURN)
        -LINE 90 "DYNAMIC.lss"
        *
        * DYNAMIC COMPILE FORTRAN SOURCE
        *
3058    COMPILE_FORTRAN
3059             CMD = 'gfortran -c -fpic -O3 -ff2c -std=legacy ' SRC
3060             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3061             HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
        *
        -LINE 105 "DYNAMIC.lss"
3062    COMPILE_SCHEME
3063             CMD = 'gsc -c ' SRC
3064             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3065             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
3066             SRC '.scm' = '.c'
3067             SRC '.six' = '.c'
3068             CMD = 'gsc -link -o prog_.c ' SRC
3069             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3070             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3071             CC = HOST(HOST_CC)                                  :F(FRETURN)
3072             IDENT(CC)                                           :S(FRETURN)
3073             DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
3074             COPT = HOST(HOST_COPT) ' '
3075             CMD = CC ' -c -D___LIBRARY ' COPT DL_CFLAGS ' ' SRC ' prog_.c'
3076             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3077             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3078             DELETE(SRC)
3079             DELETE('prog_.c')                                     :(RETURN)
        -LINE 131 "DYNAMIC.lss"
        *
        * DYNAMIC COMPILE C SOURCE
        *
3080    COMPILE_DYNAMIC
3081             CC = HOST(HOST_CC)                                  :F(FRETURN)
3082             IDENT(CC)                                           :S(FRETURN)
3083             DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
3084             COPT = HOST(HOST_COPT) ' '
3085             CINC = HOST(HOST_SNOLIB_DIR)
3086             CINC = HOST(HOST_INCLUDE_DIR)
3087             CMD = CC ' -c ' COPT DL_CFLAGS ' -I' CINC ' ' SRC
3088             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3089             HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
        *
3090    COMPILE_DYNAMIC_END
        *
        -PUBLIC LINK_DYNAMIC()
3091
3092             DEFINE('LINK_DYNAMIC(OUT,OBJ,LIBS)'
3092    +               'CMD,DL_LD,DL_EXT,DL_LDFLAGS,DSEP')  :(LINK_DYNAMIC_END)
        *
3093    LINK_DYNAMIC
3094             DL_LD = HOST(HOST_DL_LD)                            :F(FRETURN)
3095             IDENT(DL_LD)                                        :S(FRETURN)
3096             DL_EXT = HOST(HOST_DL_EXT)
3097             OUT = DIFFER(DL_EXT) OUT DL_EXT
3098             DL_LDFLAGS = HOST(HOST_DL_LDFLAGS) ' '
3099             CMD = DL_LD ' ' DL_LDFLAGS '-o ' OUT ' ' OBJ ' ' LIBS
3100             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3101             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
3102             LINK_DYNAMIC = OUT
3103             DSEP = HOST(HOST_DIR_SEP)
3104             LINK_DYNAMIC BREAK(DSEP) DSEP                        :S(RETURN)
3105             LINK_DYNAMIC = '.' DSEP LINK_DYNAMIC                  :(RETURN)
3106    LINK_DYNAMIC_END
        *
        * MAKE A DYNAMIC MODULE, GIVEN C SOURCES
        * LIBS MAY CONTAIN BOTH OBJECTS AND LIBRARIES
        *
        -PUBLIC MAKE_DYNAMIC_MODULE()
        *
3107             DEFINE('MAKE_DYNAMIC_MODULE(OUT,SRC,LIBS)OBJ')
3108                                                  :(MAKE_DYNAMIC_MODULE_END)
3109    MAKE_DYNAMIC_MODULE
3110             IDENT(SRC)                                         :S(MDM_LINK)
3111             COMPILE_DYNAMIC(SRC)                                :F(FRETURN)
3112             OBJ = REPL(SRC, '.o', '.c')
3113    MDM_LINK IDENT(OBJ LIBS)                                     :S(FRETURN)
3114             MAKE_DYNAMIC_MODULE = LINK_DYNAMIC(OUT, OBJ, LIBS)  :F(FRETURN)
3115                                                                   :(RETURN)
3116    MAKE_DYNAMIC_MODULE_END
        *
3117    DYNAMIC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'EDITLINE.INC'
        -INCLUDE 'FASTBAL.INC'
        -MODULE FASTBAL
        -LINE 20 "FASTBAL.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 99 "FASTBAL.lss"
        -STITL FASTBAL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #######     #      #####   #######  ######      #     #           *
        *    #          # #    #     #     #     #     #    # #    #           *
        *    #         #   #   #           #     #     #   #   #   #           *
        *    #####    #     #   #####      #     ######   #     #  #           *
        *    #        #######        #     #     #     #  #######  #           *
        *    #        #     #  #     #     #     #     #  #     #  #           *
        *    #        #     #   #####      #     ######   #     #  #######     *
        *                                                                      *
        * FASTBAL                                                              *
        *                                                                      *
        ************************************************************************
        *
        * FASTBAL.lss
        *
        -LINE 24 "FASTBAL.lss"
        -PUBLIC FASTBAL()
        *
3118             DEFINE('FASTBAL(PARENS,QTS,S)NAME,IBAL,SPCHARS,ELEM'
3118    +               ',LPS,Q,LP,RP')                           :(FASTBAL_END)
        *
3119    FASTBAL  NAME = UNIQUE()
3120             IBAL = CONVERT(NAME, 'EXPRESSION')
3121             IBAL = DIFFER(S, NULL) FASTBAL(PARENS, QTS)
3122             SPCHARS = PARENS QTS S
        -LINE 40 "FASTBAL.lss"
3123             ELEM = NOTANY(PARENS QTS) BREAK(SPCHARS)
        -LINE 48 "FASTBAL.lss"
3124    FASTBAL_1
3125             QTS LEN(1) . Q  =                                 :F(FASTBAL_2)
3126             ELEM = Q BREAK(Q) Q | ELEM                         :(FASTBAL_1)
        -LINE 59 "FASTBAL.lss"
3127    FASTBAL_2
3128             PARENS LEN(1) . LP RTAB(1) . PARENS LEN(1) . RP   :F(FASTBAL_3)
3129             ELEM = LP IBAL RP | ELEM                           :(FASTBAL_2)
        -LINE 79 "FASTBAL.lss"
3130    FASTBAL_3
3131             FASTBAL = BREAK(SPCHARS) ARBNO(ELEM)
3132             $NAME = FASTBAL                                       :(RETURN)
        *
3133    FASTBAL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FCGI.INC'
        -INCLUDE 'FENCE.INC'
        -MODULE FENCE
        -LINE 34 "FENCE.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 64 "FENCE.lss"
        -STITL FENCE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             #######  #######  #     #   #####   #######              *
        *             #        #        ##    #  #     #  #                    *
        *             #        #        # #   #  #        #                    *
        *             #####    #####    #  #  #  #        #####                *
        *             #        #        #   # #  #        #                    *
        *             #        #        #    ##  #     #  #                    *
        *             #        #######  #     #   #####   #######              *
        *                                                                      *
        ************************************************************************
        *
        * FENCE.lss
        *
        -LINE 38 "FENCE.lss"
        -PUBLIC FENCE()
        *
3134            DEFINE('FENCE(P)N')                                 :(FENCE_END)
        *
3135    FENCE   N = UNIQUE()
3136            FENCE = EVAL('@' N
3136    +                    ' P '
3136    +                    ' "" $ *$(.' N ' DIFFER(' N '))'
3136    +                   )                                          :(RETURN)
        *
3137    FENCE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FFI.INC'
        -INCLUDE 'FIND.INC'
        -MODULE FIND
        -LINE 14 "FIND.lss"
        -IN72
        -LINE 47 "FIND.lss"
        -STITL FIND
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #######  ###  #     #  ######                     *
        *                    #         #   ##    #  #     #                    *
        *                    #         #   # #   #  #     #                    *
        *                    #####     #   #  #  #  #     #                    *
        *                    #         #   #   # #  #     #                    *
        *                    #         #   #    ##  #     #                    *
        *                    #        ###  #     #  ######                     *
        *                                                                      *
        * FIND                       FIND EXTREME                              *
        *                                                                      *
        ************************************************************************
        *
        * FIND.lss
        *
        -LINE 17 "FIND.lss"
        -PUBLIC FIND()
        *
3138             DEFINE('FIND(A,PRED)EX,I,MAX,TEST')                 :(FIND_END)
        *
3139    FIND     EX = CONVERT(PRED '(MAX,TEST)', 'EXPRESSION')
3140             FIND = 1
3141             MAX = A<FIND>
3142             I = 1
3143    FIND_1   I = I + 1
3144             TEST = A<I>                                          :F(RETURN)
3145             EVAL(EX)                                             :S(FIND_1)
3146             MAX = TEST
3147             FIND = I                                              :(FIND_1)
        *
3148    FIND_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FLOOR.INC'
        -INCLUDE 'FOREACH.INC'
        -PLUSOPS 1
3149      :(FOREACH.1)
        -SNOCONE
        -MODULE FOREACH
        -LINE 11 "FOREACH.lss"
        -LINE 73 "FOREACH.lss"
        -IN1024
        -STITL FOREACH
        -EJECT
        -LINE 15 "FOREACH.lss"
        -PUBLIC FOREACH()
        -LINE 20 "FOREACH.lss"
3150      :(FOREACH.END)
        -LINE 21
3151    FOREACH I = DATATYPE(X)
        -LINE 22
3152     IDENT(I,'ARRAY') :F(FOREACH.2)
        -LINE 23
3153     I = 1
        -LINE 24
3154     PROTOTYPE(X) ? FENCE BREAK(':') . I
        -LINE 25
3155    FOREACH.3 A = X<I> :F(FOREACH.4)
        -LINE 26
3156     APPLY(PROC,A) :S(FOREACH.5)F(FRETURN)
        -LINE 28
3157    FOREACH.5 I = I + 1 :(FOREACH.3)
        -LINE 30
3158    FOREACH.4  :(FOREACH.6)
3159    FOREACH.2 IDENT(I,'TABLE') :F(FOREACH.7)
        -LINE 31
3160     X = CONVERT(X,'ARRAY') :S(FOREACH.8)F(FRETURN)
        -LINE 33
3161    FOREACH.8 X = SORT(X)
        -LINE 34
3162     I = 1
        -LINE 35
3163    FOREACH.9 A = X<I,2> :F(FOREACH.10)
        -LINE 36
3164     APPLY(PROC,A,X<I,1>) :S(FOREACH.11)F(FRETURN)
        -LINE 38
3165    FOREACH.11 I = I + 1 :(FOREACH.9)
        -LINE 40
3166    FOREACH.10  :(FOREACH.12)
3167    FOREACH.7 IDENT(I,'EXPRESSION') :F(FOREACH.13)
        -LINE 41
3168    FOREACH.14 A = EVAL(X) :F(FOREACH.15)
        -LINE 42
3169     APPLY(PROC,A) :S(FOREACH.16)F(FRETURN)
        -LINE 44
3170    FOREACH.16  :(FOREACH.14)
        -LINE 45
3171    FOREACH.15  :(FOREACH.17)
        -LINE 46
3172    FOREACH.13 APPLY(PROC,X) :S(RETURN)F(FOREACH.18)
        -LINE 49
3173    FOREACH.18  :(FRETURN)
3174    FOREACH.19
3175    FOREACH.17
3176    FOREACH.12
        -LINE 51
3177    FOREACH.6  :(RETURN)
3178    FOREACH.END
3179    FOREACH.1
        -INCLUDE 'DEXP.INC'
3180     DEFINE('foreach(x,proc)a,i')
        -INCLUDE 'FOR.INC'
        -MODULE FOR
        -LINE 61 "FOR.lss"
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'TIMER.INC'
        -IN72
        -LINE 260 "FOR.lss"
        -STITL FOR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #######  #######  ######                        *
        *                      #        #     #  #     #                       *
        *                      #        #     #  #     #                       *
        *                      #####    #     #  ######                        *
        *                      #        #     #  #   #                         *
        *                      #        #     #  #    #                        *
        *                      #        #######  #     #                       *
        *                                                                      *
        * FOR                         FOR LOOP                                 *
        *                                                                      *
        ************************************************************************
        *
        * FOR.lss
        *
        -LINE 66 "FOR.lss"
        -PUBLIC CODE_(), WHILE_COMPILE(), IF_COMPILE(), FOR_COMPILE()
        -PUBLIC STMT_COMPILE(), PROG2_COMPILE(), SET_RVAL(), EVAL_CODE_()
        -PUBLIC FOR(), WHILE()
        *
3181             DATA('CODE_(TYPE,INIT,TEST,INCR,STMT,ELSE,'
3181    +                        'INIT_,TEST_,INCR_,STMT_,ELSE_)')
3182             DEFINE('WHILE_COMPILE(TEST_,STMT_)')
3183             DEFINE('IF_COMPILE(TEST_,STMT_,ELSE_)')
3184             DEFINE('FOR_COMPILE(INIT_,TEST_,INCR_,STMT_)')
3185             DEFINE('STMT_COMPILE(STMT_)')
3186             DEFINE('PROG2_COMPILE(INIT_,STMT_)')
3187             DEFINE('SET_RVAL(R)')
3188             DEFINE('EVAL_CODE_(F_)')
        *
3189             OPSYN('FOR', 'EVAL_CODE_')
3190             OPSYN('WHILE', 'EVAL_CODE_')                         :(FOR_END)
        *
3191    SET_RVAL EVAL_CODE_ = R
3192             SET_RVAL = R                                          :(RETURN)
        *
3193    PROG2_COMPILE
3194             PROG2_COMPILE = CODE_('PROG2')
3195             INIT_(PROG2_COMPILE) = INIT_
3196             STMT_(PROG2_COMPILE) = STMT_
3197             INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
3197    +           ' EVAL_CODE_(INIT_(F_))'
3198             INIT(PROG2_COMPILE) =
3198    +           CODE(INIT_ ' :<STMT(F_)>')                         :F(ERROR)
3199             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3199    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3200             STMT(PROG2_COMPILE) =
3200    +           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
        *
3201    STMT_COMPILE
3202             STMT_COMPILE = CODE_('STMT')
3203             STMT_(STMT_COMPILE) = STMT_
3204             INIT(STMT_COMPILE) = CODE(' :<STMT(F_)>')
3205             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3205    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3206             STMT(STMT_COMPILE) =
3206    +           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
        *
3207    IF_COMPILE
3208             IF_COMPILE = CODE_('IF')
3209             TEST_(IF_COMPILE) = TEST_
3210             STMT_(IF_COMPILE) = STMT_
3211             ELSE_(IF_COMPILE) = ELSE_
3212             INIT(IF_COMPILE) = CODE(' :<TEST(F_)>')
3213             TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
3213    +           ' EVAL_CODE_(TEST_(F_))'
3214             TEST(IF_COMPILE) =
3214    +           CODE(TEST_ ' :S<STMT(F_)>F<ELSE(F_)>')             :F(ERROR)
3215             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3215    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3216             STMT(IF_COMPILE) =
3216    +           CODE(STMT_ ' :S(RETURN)F(FRETURN)')                :F(ERROR)
3217             ELSE_ = IDENT(DATATYPE(STMT_), 'CODE_')
3217    +           ' EVAL_CODE_ = EVAL_CODE_(ELSE_(F_))'
3218             ELSE(IF_COMPILE) =
3218    +           CODE(ELSE_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
        *
3219    WHILE_COMPILE
3220             WHILE_COMPILE = FOR_COMPILE(, TEST_,, STMT_)
3221             TYPE(WHILE_COMPILE) = 'WHILE'                         :(RETURN)
        *
3222    FOR_COMPILE
3223             FOR_COMPILE = CODE_('FOR')
3224             TEST_(FOR_COMPILE) = TEST_
3225             STMT_(FOR_COMPILE) = STMT_
3226             INCR_(FOR_COMPILE) = INCR_
3227             INIT_(FOR_COMPILE) = INIT_
3228             TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
3228    +           ' EVAL_CODE_(TEST_(F_))'
3229             TEST(FOR_COMPILE) =
3229    +           CODE(TEST_ ' :S<STMT(F_)>F(RETURN)')               :F(ERROR)
3230             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3230    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3231             STMT(FOR_COMPILE) =
3231    +           CODE(STMT_ ' :S<INCR(F_)>F(FRETURN)')              :F(ERROR)
3232             INCR_ = IDENT(DATATYPE(INCR_), 'CODE_')
3232    +           ' EVAL_CODE_(INCR_(F_))'
3233             INCR(FOR_COMPILE) =
3233    +           CODE(INCR_ ' :S<TEST(F_)>F(ERROR)')                :F(ERROR)
3234             INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
3234    +           ' EVAL_CODE_(INIT_(F_))'
3235             INIT(FOR_COMPILE) =
3235    +           CODE(INIT_ ' :S<TEST(F_)>F(ERROR)')       :S(RETURN)F(ERROR)
        *
3236    EVAL_CODE_                                                   :<INIT(F_)>
        *
3237    FOR_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FORMAT.INC'
        -MODULE FORMAT
        -LINE 8 "FORMAT.lss"
        -IN72
        -LINE 359 "FORMAT.lss"
        -STITL FORMAT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #######  #######  ######   #     #     #     #######         *
        *         #        #     #  #     #  ##   ##    # #       #            *
        *         #        #     #  #     #  # # # #   #   #      #            *
        *         #####    #     #  ######   #  #  #  #     #     #            *
        *         #        #     #  #   #    #     #  #######     #            *
        *         #        #     #  #    #   #     #  #     #     #            *
        *         #        #######  #     #  #     #  #     #     #            *
        *                                                                      *
        * FORMAT                 FORTRAN IV FORMAT()                           *
        *                                                                      *
        ************************************************************************
        *
        * FORMAT.lss
        *
        -LINE 11 "FORMAT.lss"
        -LINE 12 "FORMAT.lss"
        -LINE 13 "FORMAT.lss"
        -LINE 14 "FORMAT.lss"
        -LINE 15 "FORMAT.lss"
        -LINE 16 "FORMAT.lss"
        -LINE 17 "FORMAT.lss"
        -LINE 20 "FORMAT.lss"
3238             FORMAT = 'format.c'
        -LINE 271 "FORMAT.lss"
        -LINE 272 "FORMAT.lss"
        -LINE 273 "FORMAT.lss"
        -LINE 274 "FORMAT.lss"
        -LINE 275 "FORMAT.lss"
        -LINE 276 "FORMAT.lss"
        -LINE 341 "FORMAT.lss"
        -PUBLIC FTN_FORMAT()
        *
3239             LOAD('FTN_FORMAT(STRING,STRING)STRING', 'format.so')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FREEZE.INC'
        -INCLUDE 'GCD.INC'
        -MODULE GCD
        -LINE 8 "GCD.lss"
        -IN72
        -LINE 39 "GCD.lss"
        -STITL GCD
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       #####    #####   ######                        *
        *                      #     #  #     #  #     #                       *
        *                      #        #        #     #                       *
        *                      #  ####  #        #     #                       *
        *                      #     #  #        #     #                       *
        *                      #     #  #     #  #     #                       *
        *                       #####    #####   ######                        *
        *                                                                      *
        * GCD                   GREATEST COMMON DIVISOR                        *
        *                                                                      *
        ************************************************************************
        *
        * GCD.lss
        *
        -LINE 11 "GCD.lss"
        -PUBLIC GCD()
        *
3240             DEFINE('GCD(I,J)')                                   :(GCD_END)
        *
3241    GCD      EQ(I)                                               :S(FRETURN)
3242             EQ(J)                                               :S(FRETURN)
3243    GCD.1    GCD = REMDR(I, J)
3244             GCD = EQ(GCD) J                                      :S(RETURN)
3245             I = J
3246             J = GCD                                                :(GCD.1)
        *
3247    GCD_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'GDDT.INC'
        -LIST
        -INCLUDE 'GETKEY.INC'
        -MODULE GETKEY
        -LINE 44 "GETKEY.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HOST.INC'
        -IN72
        -LINE 150 "GETKEY.lss"
        -STITL GETKEY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *           #####   #######  #######  #    #  #######  #     #         *
        *          #     #  #           #     #   #   #         #   #          *
        *          #        #           #     #  #    #          # #           *
        *          #  ####  #####       #     ###     #####       #            *
        *          #     #  #           #     #  #    #           #            *
        *          #     #  #           #     #   #   #           #            *
        *           #####   #######     #     #    #  #######     #            *
        *                                                                      *
        * GETKEY      GET KEY, INCLUDING ARROWS AND FUNCTION KEYS              *
        *                                                                      *
        ************************************************************************
        *
        * GETKEY.lss
        *
        -LINE 50 "GETKEY.lss"
        -PUBLIC GETKEY()
        *
3248             DEFINE('GETKEY(IN)KEY,M')
        *
3249    GETKEY_INIT
        *
        -PUBLIC KEY_ESC, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_PAGEDN
        -PUBLIC KEY_PAGEUP, KEY_HOME, KEY_END, KEY_INS
        *
3250             KEY_ESC    = CHARS_ESC CHARS_ESC
3251             KEY_LEFT   = BQ('tput kcub1')
3252             KEY_RIGHT  = BQ('tput kcuf1')
3253             KEY_UP     = BQ('tput kcuu1')
3254             KEY_DOWN   = BQ('tput kcud1')
3255             KEY_PAGEDN = BQ('tput knp')
3256             KEY_PAGEUP = BQ('tput kpp')
3257             KEY_HOME   = BQ('tput khome')
3258             KEY_END    = BQ('tput kend')
3259             KEY_INS    = BQ('tput kich1')
        -LINE 79 "GETKEY.lss"
3260             BQ('echo $TERM') 'xterm'                         :F(GETKEY_END)
3261             KEY_LEFT   = REPLACE(KEY_LEFT,  'O', '[')
3262             KEY_RIGHT  = REPLACE(KEY_RIGHT, 'O', '[')
3263             KEY_UP     = REPLACE(KEY_UP,    'O', '[')
3264             KEY_DOWN   = REPLACE(KEY_DOWN,  'O', '[')
3265             KEY_HOME   = REPLACE(KEY_HOME,  'O', '[')
3266             KEY_END    = REPLACE(KEY_END,   'O', '[')
3267             KEY_INS    = REPLACE(KEY_INS,   'O', '[')
3268                                                               :(GETKEY_END)
        *
3270    GETKEY   &INPUT = 1; KEY =
3272    GK1      M = ; KEY = KEY $IN
        *
3273    GK2      M = ?(KEY_UP ? FENCE KEY) 1                             :F(GK3)
3274             EQ(SIZE(KEY), SIZE(KEY_UP))                             :S(GKR)
        *
3275    GK3      M = ?(KEY_DOWN ? FENCE KEY) 1                           :F(GK4)
3276             EQ(SIZE(KEY), SIZE(KEY_DOWN))                           :S(GKR)
        *
3277    GK4      M = ?(KEY_RIGHT ? FENCE KEY) 1                          :F(GK5)
3278             EQ(SIZE(KEY), SIZE(KEY_RIGHT))                          :S(GKR)
        *
3279    GK5      M = ?(KEY_LEFT ? FENCE KEY) 1                           :F(GK6)
3280             EQ(SIZE(KEY), SIZE(KEY_LEFT))                           :S(GKR)
        *
3281    GK6      M = ?(KEY_PAGEDN ? FENCE KEY) 1                         :F(GK7)
3282             EQ(SIZE(KEY), SIZE(KEY_PAGEDN))                         :S(GKR)
        *
3283    GK7      M = ?(KEY_PAGEUP ? FENCE KEY) 1                         :F(GK8)
3284             EQ(SIZE(KEY), SIZE(KEY_PAGEUP))                         :S(GKR)
        *
3285    GK8      M = ?(KEY_HOME ? FENCE KEY) 1                           :F(GK9)
3286             EQ(SIZE(KEY), SIZE(KEY_HOME))                           :S(GKR)
        *
3287    GK9      M = ?(KEY_END ? FENCE KEY) 1                           :F(GK10)
3288             EQ(SIZE(KEY), SIZE(KEY_END))                            :S(GKR)
        *
3289    GK10     M = ?(KEY_INS ? FENCE KEY) 1                           :F(GK11)
3290             EQ(SIZE(KEY), SIZE(KEY_INS))                            :S(GKR)
        *
3291    GK11     M = ?(KEY_ESC ? FENCE KEY) 1                           :F(GK12)
3292             EQ(SIZE(KEY), SIZE(KEY_ESC))                            :S(GKR)
3292    +                                                                 F(GK1)
        -LINE 129 "GETKEY.lss"
3293    GK12     DIFFER(M)                                               :S(GK1)
3294    GKR      GETKEY = KEY                                          :(RETURN)
        *
3295             CODE('GETKEY_INIT')
        *
3296    GETKEY_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HASH.INC'
        -INCLUDE 'HEX.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'HTMLESC.INC'
        -INCLUDE 'HTMLTMPL.INC'
        -INCLUDE 'INFINIP.INC'
        -MODULE INFINIP
        -LINE 10 "INFINIP.lss"
        -INCLUDE 'REDEFINE.INC'
        -MODULE REDEFINE
        -LINE 16 "REDEFINE.lss"
        -IN72
        -LINE 58 "REDEFINE.lss"
        -STITL REDEFINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  ######   #######  ######   #######  #######  ###  #     #  #######  *
        *  #     #  #        #     #  #        #         #   ##    #  #        *
        *  #     #  #        #     #  #        #         #   # #   #  #        *
        *  ######   #####    #     #  #####    #####     #   #  #  #  #####    *
        *  #   #    #        #     #  #        #         #   #   # #  #        *
        *  #    #   #        #     #  #        #         #   #    ##  #        *
        *  #     #  #######  ######   #######  #        ###  #     #  #######  *
        *                                                                      *
        * REDEFINE             REDEFINE OPERATORS                              *
        *                                                                      *
        ************************************************************************
        *
        * REDEFINE.lss
        *
        * FMGW:
        *
        * - ADD REDEFINERESTORE() TO ALLOW INFINIP.SNO TO ENABLE/DISABLE
        *   LONG INTEGERS
        * - FACTOR REDEFINECOMMON() TO ALLOW REDEFINE() AND REDEFINERESTORE()
        *   TO SHARE CODE
        *
        -LINE 19 "REDEFINE.lss"
        -PUBLIC REDEFINE(), REDEFINERESTORE()
        *
3297             DEFINE('REDEFINE(OP,DEF,LBL)NAME,N,FLAG')
3298             DEFINE('REDEFINERESTORE(OP,DEF)NAME,N,FLAG')
3299             DEFINE('REDEFINECOMMON()')                      :(REDEFINE_END)
        *
3300    REDEFINECOMMON
3301             DEF BREAK('(') . NAME '(' BREAK('),') LEN(1) . FLAG
3302             N = 1
3303             N = IDENT(FLAG, ',') 2
3304             N = IDENT(OP)
3305             OP = IDENT(OP) NAME
3306                                                                   :(RETURN)
        *
3307    REDEFINE REDEFINECOMMON()
3308             OPSYN(NAME '.', OP, N)
3309             DEFINE(DEF, LBL)
3310             OPSYN(OP, NAME, N)                                    :(RETURN)
        *
3311    REDEFINERESTORE
3312             REDEFINECOMMON()
3313             OPSYN(OP, NAME '.', N)                                :(RETURN)
        *
3314    REDEFINE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SWAP.INC'
        -IN72
        -LINE 190 "INFINIP.lss"
        -STITL INFINIP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *            ###  #     #  #######  ###  #     #  ###  ######          *
        *             #   ##    #  #         #   ##    #   #   #     #         *
        *             #   # #   #  #         #   # #   #   #   #     #         *
        *             #   #  #  #  #####     #   #  #  #   #   ######          *
        *             #   #   # #  #         #   #   # #   #   #               *
        *             #   #    ##  #         #   #    ##   #   #               *
        *            ###  #     #  #        ###  #     #  ###  #               *
        *                                                                      *
        * INFINIP          INFINITE PRECISION INTEGER MATH                     *
        *                                                                      *
        ************************************************************************
        *
        * INFINIP.lss
        *
        -LINE 15 "INFINIP.lss"
3315             SIGN_OFF  = POS(0) '-'
3316             LDG_ZEROS = BREAK('123456789') | RTAB(1)
3317             NO_DIGITS = 4
        *
        -PUBLIC INFINP_START(), INFINP_STOP()
3318             DEFINE('XYZERO()')
3319             DEFINE('INFFLOAT()')
3320             DEFINE('SMALL()')
3321             DEFINE('SPLIT(NAME,PAT)')
3322             DEFINE('INFINIP_START()')
3323             DEFINE('INFINIP_STOP()')                         :(INFINIP_END)
        *
3324    INFINIP_START
3325             REDEFINE('-', 'MINUS(X)Y')
3326             REDEFINE(   , 'GT(X,Y)')
3327             REDEFINE(   , 'EQ(X,Y)')
3328             REDEFINE(   , 'GE(X,Y)')
3329             REDEFINE(   , 'NE(X,Y)')
3330             REDEFINE(   , 'LT(X,Y)')
3331             REDEFINE(   , 'LE(X,Y)')
3332             REDEFINE('-', 'DIFF(X,Y)')
3333             REDEFINE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
3334             REDEFINE('*', 'MULT(X,Y)X1,X2,K')
3335             REDEFINE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
3336             REDEFINE(   , 'REMDR(X,Y)')                           :(RETURN)
        *
3337    INFINIP_STOP
3338             REDEFINERESTORE('-', 'MINUS(X)Y')
3339             REDEFINERESTORE(   , 'GT(X,Y)')
3340             REDEFINERESTORE(   , 'EQ(X,Y)')
3341             REDEFINERESTORE(   , 'GE(X,Y)')
3342             REDEFINERESTORE(   , 'NE(X,Y)')
3343             REDEFINERESTORE(   , 'LT(X,Y)')
3344             REDEFINERESTORE(   , 'LE(X,Y)')
3345             REDEFINERESTORE('-', 'DIFF(X,Y)')
3346             REDEFINERESTORE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
3347             REDEFINERESTORE('*', 'MULT(X,Y)X1,X2,K')
3348             REDEFINERESTORE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
3349             REDEFINERESTORE(   , 'REMDR(X,Y)')                    :(RETURN)
        *
        * FMGW:
        * ADDED XYZERO TO ALLOW '' + 1 ETC. TO WORK AS NORMAL
        * INFFLOAT TO ALLOW REAL TO WORK AS NORMAL
        *
        * THERE IS STILL THE PROBLEM OF MIXING A LARGE INTEGER WITH A REAL IN
        * ARITHMETIC. THIS WILL NOT WORK CORRECTLY. IF THE LARGE INTEGER CANNOT
        * BE CONVERTED, AN ERROR WILL BE RAISED. WE SHOULD CHECK THE RANGE,
        * AND CONVERT THE INTEGER TO REAL OURSELVES. THIS CAN BE DONE IN
        * THE INFFLOAT() FUNCTION. NOTE THAT INFFLOAT() IS CALLED AFTER
        * XYZERO(), SO BOTH X AND Y ARE (AT LEAST) 0, AND NOT THE EMPTY STRING.
        *
        * XYZERO() AND INFFLOAT() COULD BE MERGED, BUT ARE KEPT SEPARATE FOR
        * CLARITY.
        *
        * INFINIP_START() AND INFINIP_STOP() ADDED TO CONTROL THE REDEFINITION
        * OF OPERATIONS.
        *
3350    INFFLOAT DATATYPE(X) 'REAL'                                   :S(RETURN)
3351             DATATYPE(Y) 'REAL'                                   :S(RETURN)
3352                                                                  :(FRETURN)
        *
3353    XYZERO   X = IDENT(X) 0
3354             Y = IDENT(Y) 0                                        :(RETURN)
        *
3355    SMALL    (LE.(SIZE(X), NO_DIGITS)
3355    +         LE.(SIZE(Y), NO_DIGITS))                  :S(RETURN)F(FRETURN)
        *
3356    SPLIT    PAT = IDENT(PAT) LEN(SIZE($NAME) / 2)
3357             $NAME (PAT | '') . $(NAME 1) @SPLIT  (SPAN('0') | '')
3357    +           REM . $(NAME 2)
3358             SPLIT = SIZE($NAME) - SPLIT                           :(RETURN)
        *
3359    MINUS    XYZERO()
3360             MINUS = INFFLOAT() MINUS.(X)                         :S(RETURN)
3361             MINUS = SMALL() MINUS.(X)                            :S(RETURN)
3362             MINUS = X
3363             MINUS SIGN_OFF =                                     :S(RETURN)
3364             MINUS = '-' X                                         :(RETURN)
        *
3365    GT       XYZERO()
3366             INFFLOAT()                                             :S(GT_3)
3367             SMALL()                                                :F(GT_1)
3368    GT_3     GT.(X,Y)                                   :S(RETURN)F(FRETURN)
3369    GT_1     X SIGN_OFF =                                           :F(GT_2)
3370             Y SIGN_OFF =                                        :F(FRETURN)
3371             SWAP(.X, .Y)
3372    GT_2     Y SIGN_OFF =                                         :S(RETURN)
3373             LGT(LPAD(X, SIZE(Y), '0'),
3373    +            LPAD(Y, SIZE(X), '0'))                 :S(RETURN)F(FRETURN)
        *
3374    EQ       XYZERO()
3375             INFFLOAT()                                             :S(EQ_2)
3376             SMALL()                                                :F(EQ_1)
3377    EQ_2     EQ.(X, Y)                                  :S(RETURN)F(FRETURN)
3378    EQ_1     IDENT(X, Y)                                :S(RETURN)F(FRETURN)
        *
3379    GE       ~(~GT(X, Y) ~EQ(X, Y))                     :S(RETURN)F(FRETURN)
        *
3380    NE       EQ(X, Y)                                   :S(FRETURN)F(RETURN)
        *
3381    LT       GE(X, Y)                                   :S(FRETURN)F(RETURN)
        *
3382    LE       GT(X, Y)                                   :S(FRETURN)F(RETURN)
        *
3383    DIFF     DIFF = X + -Y                                         :(RETURN)
        *
3384    SUM      XYZERO()
3385             SUM = INFFLOAT() SUM.(X, Y)                          :S(RETURN)
3386             SUM = SMALL() SUM.(X, Y)                             :S(RETURN)
3387             SUM = LT(X,0) -(-X + -Y)                             :S(RETURN)
3388             Y SIGN_OFF =                                          :S(SUM_1)
3389             (LT(X, Y) SWAP(.X, .Y))
3390             K = SPLIT(.X)
3391             Y = Y + X2
3392             SPLIT(.Y, RTAB(K))
3393             SUM = (Y1 + X1) LPAD(Y2, K, '0')                      :(RETURN)
3394    SUM_1    SUM = GT(Y, X) -(Y - X)                              :S(RETURN)
3395             Y = LPAD(Y, SIZE(X), '0')
        * ADD 10's COMPLEMENT OF Y
3396             SUM = X + 1 + REPLACE(Y, '0123456789', '9876543210')
3397             SUM '1' LDG_ZEROS REM . SUM                           :(RETURN)
        *
3398    MULT     XYZERO()
3399             MULT = INFFLOAT() MULT.(X, Y)                        :S(RETURN)
3400             MULT = LE(SIZE(X) + SIZE(Y), NO_DIGITS)
3400    +           MULT.(X, Y)                                       :S(RETURN)
3401             MULT = LT(X, 0) -X * -Y                              :S(RETURN)
3402             MULT = LT(Y, 0) -(X * -Y)                            :S(RETURN)
3403             (GT(Y, X)  SWAP(.X, .Y))
3404             MULT = EQ(Y, 0) 0                                    :S(RETURN)
3405             K = SPLIT(.X)
3406             MULT = (Y * X1) DUPL('0', K)
3407             MULT = MULT + X2 * Y                                  :(RETURN)
        *
3408    DIV      XYZERO()
3409             DIV = INFFLOAT() DIV.(X, Y)                          :S(RETURN)
3410             DIV = SMALL() DIV.(X, Y)                             :S(RETURN)
3411             DIV = LT(X, 0) -(-X / Y)                             :S(RETURN)
3412             DIV = LT(Y, 0) -(X / -Y)                             :S(RETURN)
3413             DIV = GT(Y, X) 0                                     :S(RETURN)
        * ORIGINAL STATEMENTS FROM BOOK:
        *        KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
        *        KX = SPLIT(.X, LEN(NO_DIGITS))
        * SUGGESTED REPLACEMENT TO AVOID GENERATING ERROR TERMS THAT ARE
        * LARGER THAN THE INCOMING NUMERATOR. SUCH A SITUATION CAN PRODUCE
        * CYCLES.
3414             KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
3415             KX = SPLIT(.X, LEN(NO_DIGITS / 2) | REM)
3416             KX = LT.(X1, Y1) SPLIT(.X, LEN(NO_DIGITS / 2 + 1) | REM)
        * END OF REPLACEMENT STATEMENTS.
3417             T1 = X1 / Y1
3418             T2 = DUPL('0', KX - KY)
3419             T = X - ((T1 * Y)  T2)
3420             DIV = T1 T2
3421             T = LT(T, 0) T + 1 - Y
3422             DIV = DIV + (T / Y)                                   :(RETURN)
        *
3423    REMDR    REMDR = X - (X / Y) * Y                               :(RETURN)
        *
3424    INFINIP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ITERDIR.INC'
        -MODULE ITERDIR
        -LINE 45 "ITERDIR.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'ATOL.INC'
        -INCLUDE 'CHARS.INC'
        -IN72
        -LINE 105 "ITERDIR.lss"
        -STITL ITERDIR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *        ###  #######  #######  ######   ######   ###  ######          *
        *         #      #     #        #     #  #     #   #   #     #         *
        *         #      #     #        #     #  #     #   #   #     #         *
        *         #      #     #####    ######   #     #   #   ######          *
        *         #      #     #        #   #    #     #   #   #   #           *
        *         #      #     #        #    #   #     #   #   #    #          *
        *        ###     #     #######  #     #  ######   ###  #     #         *
        *                                                                      *
        * ITERDIR                   DIRECTORY ITERATOR                         *
        *                                                                      *
        ************************************************************************
        *
        * ITERDIR.lss
        *
        -LINE 52 "ITERDIR.lss"
        -PUBLIC VALUE_DIR(), ITER_DIR(), NEXT_DIR()
        *
3425             DEFINE('ITER_DIR(W)P,L')
3426             DEFINE('VALUE_DIR(D)')
3427             DEFINE('NEXT_DIR(D)')                           :(END_ITER_DIR)
        *
3428    VALUE_DIR
3429             VALUE_DIR = DIFFER(D) VALUE(D)             :S(RETURN)F(FRETURN)
        *
3430    ITER_DIR DIFFER(FORCEPATTERN)                               :S(ITERDIR2)
3431             DATATYPE(W) 'PATTERN'                              :S(ITERDIR2)
        *
3432             ITER_DIR = ATOL(CRACK(BQ('ls 2>/dev/null ' W, CHARS_NL),
3432    +           CHARS_NL))                              :S(RETURN)F(FRETURN)
        *
3433    ITERDIR2 ITER_DIR =
3433    +           ATOL(CRACK(BQ('ls 2>/dev/null', CHARS_NL), CHARS_NL))
3434             P = ITER_DIR
3435    ITERDIR3 IDENT(P)                                             :S(RETURN)
3436             VALUE(P) W                                         :S(ITERDIR4)
3437             NEXT(VDIFFER(L)) = NEXT(P)
3438             ITER_DIR = IDENT(L) NEXT(ITER_DIR)
3439             P = IDENT(L) ITER_DIR                              :S(ITERDIR3)
3440             P = NEXT(P)                                         :(ITERDIR3)
3442    ITERDIR4 L = P; P = NEXT(P)                                  :(ITERDIR3)
        *
3443    NEXT_DIR NEXT_DIR = DIFFER(D) NEXT(D)               :S(RETURN)F(FRETURN)
        *
3444    END_ITER_DIR
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'JIT.INC'
        -INCLUDE 'JSON.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'LAST.INC'
        -INCLUDE 'LIKE.INC'
        -MODULE LIKE
        -LINE 16 "LIKE.lss"
        -IN72
        -LINE 51 "LIKE.lss"
        -STITL LIKE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                     #        ###  #    #  #######                    *
        *                     #         #   #   #   #                          *
        *                     #         #   #  #    #                          *
        *                     #         #   ###     #####                      *
        *                     #         #   #  #    #                          *
        *                     #         #   #   #   #                          *
        *                     #######  ###  #    #  #######                    *
        *                                                                      *
        * LIKE                PATTERN TO MATCH LIKE STRING                     *
        *                                                                      *
        ************************************************************************
        *
        * LIKE.lss
        *
        -LINE 19 "LIKE.lss"
        -PUBLIC LIKE()
        *
3445             DEFINE('LIKE(S)C,T1,T2,N')                          :(LIKE_END)
        *
3446    LIKE     LIKE = S
3447    LIKE_1   S TAB(N) . T1 REM . T2                               :F(RETURN)
3448             N = N + 1
        * INSERTION OF CHARACTER AT POSITION N
3449             LIKE = LIKE | (T1 LEN(1) T2)
        * DELETION OF CHARACTER AT POSITION N
3450             T2 LEN(1) . C  =                                     :F(RETURN)
3451             LIKE = LIKE | (T1 T2)
        * TRANSPOSITION OF TWO CHARACTERS
3452             T2 POS(1) = C                                        :F(LIKE_1)
3453             LIKE = LIKE | (T1 T2)                                 :(LIKE_1)
        *
3454    LIKE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'LINK.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'LOG.INC'
        -INCLUDE 'LOWA.INC'
        -INCLUDE 'LPROG.INC'
        -MODULE LPROG
        -LINE 15 "LPROG.lss"
        -IN72
        -LINE 41 "LPROG.lss"
        -STITL LPROG
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #        ######   ######   #######   #####             *
        *               #        #     #  #     #  #     #  #     #            *
        *               #        #     #  #     #  #     #  #                  *
        *               #        ######   ######   #     #  #  ####            *
        *               #        #        #   #    #     #  #     #            *
        *               #        #        #    #   #     #  #     #            *
        *               #######  #        #     #  #######   #####             *
        *                                                                      *
        * LPROG                    LENGTH OF PROGRAM                           *
        *                                                                      *
        ************************************************************************
        *
        * LPROG.lss
        *
        -LINE 18 "LPROG.lss"
        -PUBLIC LPROG()
        *
3455             DEFINE('LPROG()')                                  :(LPROG_END)
        *
3456    LPROG                                :<CODE(' LPROG = &STNO :(RETURN)')>
        *
3457    LPROG_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MAX.INC'
        -MODULE MAX
        -LINE 9 "MAX.lss"
        -IN72
        -LINE 24 "MAX.lss"
        -STITL MAX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #     #     #     #     #                       *
        *                      ##   ##    # #     #   #                        *
        *                      # # # #   #   #     # #                         *
        *                      #  #  #  #     #     #                          *
        *                      #     #  #######    # #                         *
        *                      #     #  #     #   #   #                        *
        *                      #     #  #     #  #     #                       *
        *                                                                      *
        * MAX                      MAX/MIN FUNCTIONS                           *
        *                                                                      *
        ************************************************************************
        *
        * MAX.lss
        *
        -PUBLIC MAX(), MIN()
        *
3458             DEFINE('MAX(X,Y)')
3459             DEFINE('MIN(X,Y)')                                   :(MAX_END)
        *
3460    MAX      MAX = GT(X, Y) X                                     :S(RETURN)
3461             MAX = Y                                               :(RETURN)
        *
3462    MIN      MIN = LT(X, Y) X                                     :S(RETURN)
3463             MIN = Y                                               :(RETURN)
        *
3464    MAX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MBUG.INC'
        -MODULE MBUG
        -INCLUDE 'READLINE.INC'
        -INCLUDE 'EDITLINE.INC'
        -INCLUDE 'HASH.INC'
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'FFI.INC'
        -INCLUDE 'NSPAN.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'BRKREM.INC'
        -IN72
        -STITL MBUG
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                  #     #  ######   #     #   #####                   *
        *                  ##   ##  #     #  #     #  #     #                  *
        *                  # # # #  #     #  #     #  #                        *
        *                  #  #  #  ######   #     #  #  ####                  *
        *                  #     #  #     #  #     #  #     #                  *
        *                  #     #  #     #  #     #  #     #                  *
        *                  #     #  ######    #####    #####                   *
        *                                                                      *
        * MBUG                 MACHINE LEVEL DEBUGGER                          *
        *                                                                      *
        ************************************************************************
        *
        * MBUG. A SIMPLE MACHINE LEVEL DEBUG FACILITY FOR USE WITH FFI BASED
        * CODE. USES PTRACE(). FORK PROCESS. PARENT RUNS MBUG. CHILD ENTERS
        * PTRACE. PARENT ACCEPTS COMMANDS AND CONTROLS CHILD. NEVER TERMINATES.
        * ONCE MBUG IS IN CONTROL, THE ONLY EXIT IS EXIT! WE DO THIS BECAUSE
        * NORMALLY DATA IS FED INTO THE MACHINE CODE, AND RESULTS RETURNED.
        * UNDER PTRACE, THE PROCESS IS FORKED AND THE CHILD IS RUNNING IN
        * A COMPLETELY SEPARATE ADDRESS SPACE. NO DATA EXCHANGE IS POSSIBLE.
        * THE SIMPLEST SOLUTION IS TO DEMAND AN APPLICATION SHUTDOWN AFTER THE
        * DEBUG IS COMPLETE. IN FUTURE, MBUG MAY BE STARTED EARLIER, ALLOWING
        * THE PROCESS TO CONTINUE. BUT IT IS DIFFICULT TO DETERMINE WHERE TO
        * SET BREAKPOINTS IN THE DYNAMIC CODE (FROM JIT.INC OR ASM.INC LAYERS).
        * FOR THIS REASON, WE TAKE THE SIMPLE APPROACH (USEFUL, EVEN IF NOT
        * COMPLETE).
        *
        * MBUG IS NOT A VERY SOPHISTICATED DEBUGGER. HOWEVER, MBUG IS
        * INTEGRATED WITH ASM/JIT. SYMBOL TABLES ARE SUPPLIED, AND DISASSEMBLY
        * OF CODE PROVIDED FROM ASM/JIT TO MBUG.
        *
        * HOW TO USE:
        *
        * MAKE SURE ROUTINES AND VARIABLES OF INTEREST ARE MARKED 'EXPORT' IN
        * THE ASM SOURCE FILE. THESE NAMES WILL BE AVAILABLE IN MBUG. USE
        * 'B NAME' TO SET BREAKPOINTS ON ROUTINES, 'S' TO EXAMINE/CHANGE DATA,
        * 'X' OR 'X RAX' (REGISTER NAME) TO EXAMINE/CHANGE REGISTERS. 'G' TO
        * EXECUTE TO BREAKPOINT. 'T' TO TRACE CODE. DISASSEMBLY FROM JIT IS
        * AVAILABLE, ALONG WITH 'NOTE()' COMMENTS IN THE CODE. SEE RUN FOR
        * HOW THIS IS INTERFACED INTO MBUG. NOTE THAT JIT_DISASSEMBLE()
        * ALWAYS SENDS RESULTS TO STANDARD OUT -- RUN FORKS A SUBPROCESS, AND
        * IN THAT SUBPROCESS REDIRECTS STANDARD OUT. THE DISASSEMBLY IS
        * CAPTURED SO IT CAN BE SENT TO MBUG().
        *
        -PUBLIC MBUG(), INT3
        *
3465             DEFINE('MBUG(SYMTAB,SRC)')
        *
                 INT3 = HI('CC') ;* OR CD 03
        *
        -PUBLIC PTRACE_TRACEME, PTRACE_PEEKTEXT, PTRACE_PEEKDATA
        *
3467             PTRACE_TRACEME            = 0
3468             PTRACE_PEEKTEXT           = 1
3469             PTRACE_PEEKDATA           = 2
        *
        -PUBLIC PTRACE_PEEKUSER, PTRACE_POKETEXT, PTRACE_POKEDATA
        *
3470             PTRACE_PEEKUSER           = 3
3471             PTRACE_POKETEXT           = 4
3472             PTRACE_POKEDATA           = 5
        *
        -PUBLIC PTRACE_POKEUSER, PTRACE_CONT, PTRACE_KILL, PTRACE_SINGLESTEP
        *
3473             PTRACE_POKEUSER           = 6
3474             PTRACE_CONT               = 7
3475             PTRACE_KILL               = 8
3476             PTRACE_SINGLESTEP         = 9
        *
        -PUBLIC PTRACE_GETREGS, PTRACE_SETREGS, PTRACE_GETFPREGS
        *
3477             PTRACE_GETREGS            = 12
3478             PTRACE_SETREGS            = 13
3479             PTRACE_GETFPREGS          = 14
        *
        -PUBLIC PTRACE_SETFPREGS, PTRACE_ATTACH, PTRACE_DETACH
        *
3480             PTRACE_SETFPREGS          = 15
3481             PTRACE_ATTACH             = 16
3482             PTRACE_DETACH             = 17
        *
        -PUBLIC PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, PTRACE_SYSCALL
        *
3483             PTRACE_GETFPXREGS         = 18
3484             PTRACE_SETFPXREGS         = 19
3485             PTRACE_SYSCALL            = 24
        *
        -PUBLIC PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG, PTRACE_GETSIGINFO
        *
3486             PTRACE_SETOPTIONS         = HI('4200')
3487             PTRACE_GETEVENTMSG        = HI('4201')
3488             PTRACE_GETSIGINFO         = HI('4202')
        *
        -PUBLIC PTRACE_SETSIGINFO, PTRACE_GETREGSET, PTRACE_SETREGSET
        *
3489             PTRACE_SETSIGINFO         = HI('4203')
3490             PTRACE_GETREGSET          = HI('4204')
3491             PTRACE_SETREGSET          = HI('4205')
        *
        -PUBLIC PTRACE_SEIZE, PTRACE_INTERRUPT, PTRACE_LISTEN
        *
3492             PTRACE_SEIZE              = HI('4206')
3493             PTRACE_INTERRUPT          = HI('4207')
3494             PTRACE_LISTEN             = HI('4208')
        *
        -PUBLIC PTRACE_PEEKSIGINFO, PTRACE_SEIZE_DEVEL, PTRACE_O_TRACESYSGOOD
        *
3495             PTRACE_PEEKSIGINFO        = HI('4209')
3496             PTRACE_SEIZE_DEVEL        = HI('80000000')
3497             PTRACE_O_TRACESYSGOOD     = HI('00000001')
        *
        -PUBLIC PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, PTRACE_O_TRACECLONE
        *
3498             PTRACE_O_TRACEFORK        = HI('00000002')
3499             PTRACE_O_TRACEVFORK       = HI('00000004')
3500             PTRACE_O_TRACECLONE       = HI('00000008')
        *
        -PUBLIC PTRACE_O_TRACEEXEC, PTRACE_O_TRACEVFORKDONE, PTRACE_TRACEEXIT
        *
3501             PTRACE_O_TRACEEXEC        = HI('00000010')
3502             PTRACE_O_TRACEVFORKDONE   = HI('00000020')
3503             PTRACE_O_TRACEEXIT        = HI('00000040')
        *
        -PUBLIC PTRACE_O_TRACESECCOMP, PTRACE_O_EXITKILL, PTRACE_O_MASK
        *
3504             PTRACE_O_TRACESECCOMP     = HI('00000080')
3505             PTRACE_O_EXITKILL         = HI('00100000')
3506             PTRACE_O_MASK             = HI('001000FF')
        *
        -PUBLIC PTRACE_EVENT_FORK, PTRACE_EVENT_VFORK, PTRACE_EVENT_CLONE
        *
3507             PTRACE_EVENT_FORK         = 1
3508             PTRACE_EVENT_VFORK        = 2
3509             PTRACE_EVENT_CLONE        = 3
        *
        -PUBLIC PTRACE_EVENT_EXEC, PTRACE_EVENT_VFORK_DONE, PTRACE_EVENT_EXIT
        *
3510             PTRACE_EVENT_EXEC         = 4
3511             PTRACE_EVENT_VFORK_DONE   = 5
3512             PTRACE_EVENT_EXIT         = 6
        *
        -PUBLIC PTRACE_EVENT_SECCOMP, PTRACE_PEEKSIGINFO_SHARED
        *
3513             PTRACE_EVENT_SECCOMP      = 5
3514             PTRACE_PEEKSIGINFO_SHARED = 1
        *
        * PTRACE_PEEKSIGINFO ARG
        *     UINT64 OFF
        *     UINT32 FLAGS
        *     INT32 NR
        *
        * INDEX INTO ARRAY OF 8 BYTE LONGS RETURNED FROM PTRACE FOR LOCATION
        * OF THE USERS' GENERAL PURPOSE REGISTERS (216 BYTES)
        *
        -PUBLIC REGS_R15, REGS_R14, REGS_R13, REGS_R12, REGS_RBP, REGS_RBX
        *
3515             REGS_R15      = 0
3516             REGS_R14      = 1
3517             REGS_R13      = 2
3518             REGS_R12      = 3
3519             REGS_RBP      = 4
3520             REGS_RBX      = 5
        *
        -PUBLIC REGS_R11, REGS_R10, REGS_R9, REGS_R8, REGS_RAX, REGS_RCX
        *
3521             REGS_R11      = 6
3522             REGS_R10      = 7
3523             REGS_R9       = 8
3524             REGS_R8       = 9
3525             REGS_RAX      = 10
3526             REGS_RCX      = 11
        *
        -PUBLIC REGS_RDX, REGS_RSI, REGS_RDI, REGS_ORIG_RAX, REGS_RIP
        *
3527             REGS_RDX      = 12
3528             REGS_RSI      = 13
3529             REGS_RDI      = 14
3530             REGS_ORIG_RAX = 15
3531             REGS_RIP      = 16
        *
        -PUBLIC REGS_CS, REGS_EFLAGS, REGS_RSP, REGS_SS, REGS_FS_BASE
        *
3532             REGS_CS       = 17
3533             REGS_EFLAGS   = 18
3534             REGS_RSP      = 19
3535             REGS_SS       = 20
3536             REGS_FS_BASE  = 21
        *
        -PUBLIC REGS_GS_BASE, REGS_DS, REGS_ES, REGS_FS, REGS_GS
        *
3537             REGS_GS_BASE  = 22
3538             REGS_DS       = 23
3539             REGS_ES       = 24
3540             REGS_FS       = 25
3541             REGS_GS       = 26
        *
        * FP REGS. THESE ARE BYTE OFFSETS (user.h)
        *
        * FIXME: NOT PUBLISHED YET AS -PUBLIC, WAIT UNTIL TESTED!
        *
3542             FPREGS_CWD       = 0
3543             FPREGS_SWD       = 2
3544             FPREGS_FTW       = 4
3545             FPREGS_FOP       = 6
3546             FPREGS_RIP       = 8
3547             FPREGS_RDP       = 16
3548             FPREGS_MXCSR     = 24
3549             FPREGS_MXCR_MASK = 28
        * 8 * 16 BYTES FOR EACH FP-REG = 128 BYTES
3550             FPREGS_ST_SPACE  = 32
        * 16 * 16 BYTES FOR EACH XMM REG = 256 BYTES
3551             FPREGS_XMM_SPACE = FP_FPREGS_ST_SPACE + 128
        * PADDING = 96 BYTES
3552             FPREGS_PADDING   = FPREGS_XMM_SPACE + 256
        *
        * NEED REGISTER DEFINITIONS FOR 386, OTHER MACHINES AS APPROPRIATE.
        * RIGHT NOW, ALL OF MY WORK IS ON X86_64 PLATFORM, NOT ABLE TO TEST
        * OTHERS.
        *
        * LONG PTRACE(ENUM __PTRACE_REQUEST REQUEST, PID_T PID,
        *             VOID *ADDR, VOID *DATA)
        *
3553             FFI_PTRACE = FFI_NEW('L', 'I,I,P,P')
3554             FFI_SET_CALLP(FFI_PTRACE, DLSYM(0, 'ptrace'))
        *
        -PUBLIC PTRACE()
        *
3555             DEFINE('PTRACE(REQUEST,PID,ADDR,DATA)')
        *
        * NOTE: CSNOBOL4 CALLS OPENING AN ARBITRARY FD BUT DOESN'T ALLOW
        * USING A FILE*, AT LEAST IN A DOCUMENTED WAY. io_getfp(int) ALLOWS
        * RECOVERY OF FILE* FROM A UNIT, AND io_mkfile(int, FILE*, char*)
        * ASSOCIATES A UNIT WITH A FILE*. THE FINAL char* IS THE NAME OF
        * THE FILE (FOR ERRORS).
        *
        * WE DEFINE OPEN_MEMSTREAM TO CREATE A FILE* THAT REFERS TO MEMORY.
        * THIS COULD BE ASSOCIATED WITH A UNIT, BUT WE DON'T HAVE TO, GIVEN
        * THAT THE ONLY USE HERE IS TO PASS THIS FILE* TO LIBOPCODES.
        *
3556             FFI_OPEN_MEMSTREAM = FFI_NEW('P', 'P,P')
3557             FFI_SET_CALLP(FFI_OPEN_MEMSTREAM, DLSYM(0, 'open_memstream'))
        *
        -PUBLIC OPEN_MEMSTREAM()
        *
3558             DEFINE('OPEN_MEMSTREAM(PS,PL)')
        *
3559             FFI_FCLOSE = FFI_NEW('I', 'P')
3560             FFI_SET_CALLP(FFI_FCLOSE, DLSYM(0, 'fclose'))
        *
        -PUBLIC FCLOSE()
        *
3561             DEFINE('FCLOSE(F)')
        *
        * LINK TO DISASSEMBLER
        *
        -PUBLIC DISASSEMBLE_INFO_ENDIAN, BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE
        -PUBLIC BFD_ENDIAN_UNKNOWN, BFD_DISASSEMBLE_INFO_MACH, BFD_MACH_X86_64
        -PUBLIC BFD_MACH_I386_SYNTAX, DISASSEMBLE_INFO_BUFFER
        -PUBLIC DISASSEMBLE_INFO_BUFFER_LENGTH, INIT_DISASSEMBLE_INFO()
        -PUBLIC PRINT_INSN_I386()
        *
                 DISASSEMBLE_INFO_ENDIAN        = 40  ;* 4 BYTES
3563             BFD_ENDIAN_BIG                 = 0
3564             BFD_ENDIAN_LITTLE              = 1
3565             BFD_ENDIAN_UNKNOWN             = 2
                 DISASSEMBLE_INFO_MACH          = 32  ;* 8 BYTES
3567             BFD_MACH_X86_64                = 8
3568             BFD_MACH_I386_INTEL_SYNTAX     = 1
                 DISASSEMBLE_INFO_BUFFER        = 152 ;* 8 BYTES
                 DISASSEMBLE_INFO_BUFFER_VMA    = 160 ;* 8 BYTES
                 DISASSEMBLE_INFO_BUFFER_LENGTH = 168 ;* 4 BYTES
3572             H = DLOPEN('/usr/lib64/libopcodes-2.23.2.so', RTLD_NOW)
3573             FFI_INIT_DISASSEMBLE_INFO = FFI_NEW('V', 'P,P,P')
3574             FFI_SET_CALLP(FFI_INIT_DISASSEMBLE_INFO,
3574    +           DLSYM(H, 'init_disassemble_info'))
3575             DEFINE('INIT_DISASSEMBLE_INFO(DINFO,FILEP,FFUNC)')
3576             FFI_PRINT_INSN_I386 = FFI_NEW('I', 'P,P')
3577             FFI_SET_CALLP(FFI_PRINT_INSN_I386, DLSYM(H, 'print_insn_i386'))
3578             DEFINE('PRINT_INSN_I386(VMADDR,DINFO)')
        *
3579             DEFINE('DISASSEMBLE(ADDR)F,P,N,PTR,SIZ,DINFO,DIS,S,I,S2')
        *
3580             DEFINE('MBUG_ARG(S)')
3581             MBUG_REGS = MALLOC(256)
        * ORIG_RAX=15 - ORIGINAL RAX ON SYSCALL
3582             MBUG_RNAMES = #('R15=0,R14=1,R13=2,R12=3,RBP=4,RBX=5,R11=6,'
3582    +                        'R10=7,R9=8,R8=9,RAX=10,RCX=11,RDX=12,RSI=13,'
3582    +                        'RDI=14,RIP=16,EFLAGS=18,RSP=19')
3583             MBUG_R2 = KEYST(MBUG_RNAMES)                        :(MBUG_END)
        *
        * AN ARGUMENT IS A REGISTER, A SYMBOL NAME, OR A HEX VALUE. IF REGISTER,
        * THE VALUE OF THE REGISTER IS USED. THE ARGUMENT MAY BE EMPTY, IN
        * WHICH CASE THE LAST ARGUMENT IS USED. THE ARGUMENT MAY BE FOLLOWED
        * BY + OR - AND A HEX VALUE. FOR EXAMPLE:
        *
        * D STRINGS, +10
        *
        * WILL DUMP FROM SYMBOL STRINGS TO STRINGS+10 BYTES.  THE RETAINED
        * ARGUMENT IS RETAINED BETWEEN COMMANDS.
        *
3584    MBUG_ARG S = TRIMB(S)
3585             OP =
3586             R = 0
3587             S BRKREM('+-') . S REM . R
3588             R LEN(1) . OP REM . R
3589             LA = VDIFFER(S)
3590             S = IDENT(S) LA
3591             U = REPLACE(S, &LCASE, &UCASE)
3592             MBUG_ARG = PEEK_P(MBUG_REGS + 8 * VDIFFER(MBUG_RNAMES<U>))
3592    +                                                           :S(MBUG_AR2)
3593             MBUG_ARG = VDIFFER(SYMTAB<S>)                      :S(MBUG_AR2)
3594             MBUG_ARG = VDIFFER(SYMTAB<U>)                      :S(MBUG_AR2)
3595             MBUG_ARG = HI(S)                                      :(RETURN)
3596    MBUG_AR2 IDENT(OP)                                            :S(RETURN)
3597             R = HI(VDIFFER(R))
3598             MBUG_ARG = EVAL(MBUG_ARG ' ' OP ' ' R)                :(RETURN)
        *
3599    PTRACE   FFI_PAR_N_INTEGER(FFI_PTRACE, 1, REQUEST)
3600             FFI_PAR_N_INTEGER(FFI_PTRACE, 2, PID)
3601             FFI_PAR_N_PTR(FFI_PTRACE, 3, ADDR)
3602             FFI_PAR_N_PTR(FFI_PTRACE, 4, DATA)
3603             PTRACE = FFI_CALL_PTR(FFI_PTRACE)                     :(RETURN)
        *
3604    FCLOSE   FFI_PAR_N_PTR(FFI_FCLOSE, 1, F)
3605             FCLOSE = FFI_CALL_INTEGER(FFI_FCLOSE)                 :(RETURN)
        *
3606    OPEN_MEMSTREAM
3607             FFI_PAR_N_PTR(FFI_OPEN_MEMSTREAM, 1, PS)
3608             FFI_PAR_N_PTR(FFI_OPEN_MEMSTREAM, 2, PL)
3609             OPEN_MEMSTREAM = FFI_CALL_PTR(FFI_OPEN_MEMSTREAM)     :(RETURN)
        *
3610    INIT_DISASSEMBLE_INFO
3611             FFI_PAR_N_PTR(FFI_INIT_DISASSEMBLE_INFO, 1, DINFO)
3612             FFI_PAR_N_PTR(FFI_INIT_DISASSEMBLE_INFO, 2, FILEP)
3613             FFI_PAR_N_PTR(FFI_INIT_DISASSEMBLE_INFO, 3, FFUNC)
3614             FFI_CALL_VOID(FFI_INIT_DISASSEMBLE_INFO)              :(RETURN)
        *
3615    PRINT_INSN_I386
3616             FFI_PAR_N_PTR(FFI_PRINT_INSN_I386, 1, VMADDR)
3617             FFI_PAR_N_PTR(FFI_PRINT_INSN_I386, 2, DINFO)
3618             PRINT_INSN_I386 = FFI_CALL_INTEGER(FFI_PRINT_INSN_I386)
3618    +                                                              :(RETURN)
        *
3619    DISASSEMBLE
3620             S = LPAD(IH(ADDR), 16, '0') ': '
3621             DIS = MALLOC(16)
3622             DINFO = MALLOC(1024)
3623             PTR = MALLOC(16)
3624             SIZ = MALLOC(16)
3625             N = PTRACE(PTRACE_PEEKTEXT, PID, ADDR + 0, 0)
3626             POKE_P(DIS + 0, N)
3627             N = PTRACE(PTRACE_PEEKTEXT, PID, ADDR + 8, 0)
3628             POKE_P(DIS + 8, N)
3629             POKE_P(PTR, 0)
3630             POKE_P(SIZ, 0)
3631             F = OPEN_MEMSTREAM(PTR, SIZ)
3632             INIT_DISASSEMBLE_INFO(DINFO, F, DLSYM(0, 'fprintf'))
3633             POKE_P(DINFO + DISASSEMBLE_INFO_MACH, BFD_MACH_X86_64)
3634             POKE_I(DINFO + DISASSEMBLE_INFO_ENDIAN, BFD_ENDIAN_LITTLE)
3635             POKE_P(DINFO + DISASSEMBLE_INFO_BUFFER, DIS)
        *
        * FIXME: NOTE THAT DISASSEMBLE OF RELATIVE BRANCHES NEEDS A BASE
        * ADDRESS, CURRENTLY, 0 IS USED, AND THE BRANCH THEN COMPUTES FROM
        * THE IDEA THAT THE INSTRUCTION IS LOCATED AT LOCATION 0. THIS IS
        * WRONG. WE KNOW THAT THAT THE INSTRUCTION IS ACTUALLY BASED AT
        * LOCATION ADDR. BUT, HOW DO WE TELL THE DISASSEMBLER? SETTING
        * BUFFER_VMA TO ADDR DOESN'T DO IT. WE MAY BE FORCED TO ACTUALLY
        * READ THE LIBOPCODES CODE TO DETERMINE HOW BEST TO ACCOMPLISH THIS
        * FEAT.
        *
        *        POKE_P(DINFO + DISASSEMBLE_INFO_BUFFER_VMA, ADDR)
        *        POKE_P(DINFO + DISASSEMBLE_INFO_BUFFER_VMA, 0)
3636             POKE_I(DINFO + DISASSEMBLE_INFO_BUFFER_LENGTH, 16)
3637             INSTRUCTION_BYTES = PRINT_INSN_I386(0, DINFO)
3638             FCLOSE(F)
3639             P = PEEK_P(PTR)
3640             N = PEEK_I(SIZ)
        *        TERMINAL = 'INSTRUCTION BYTES: ' INSTRUCTION_BYTES
3641             I = 0
3642    DIS2     S2 = '  '
3643             S2 = LT(I, INSTRUCTION_BYTES) LPAD(IH(PEEK_C(DIS + I)), 2, '0')
3644             S = S S2 ' '
3645             I = I + 1
3646             LT(I, 4)                                               :S(DIS2)
3647             DISASSEMBLE = S PEEK_BUFFER(P, N)
3648    DIS4     GE(I, INSTRUCTION_BYTES)                               :S(DIS3)
3649             DISASSEMBLE = EQ(REMDR(I, 4))
3649    +           DISASSEMBLE CHAR(10) DUPL(' ', 18)
3650             S2 = LPAD(IH(PEEK_C(DIS + I)), 2, '0')
3651             DISASSEMBLE = DISASSEMBLE S2 ' '
3652             I = I + 1                                               :(DIS4)
3653    DIS3     FREE(DIS)
3654             FREE(DINFO)
3655             FREE(P)
3656             FREE(PTR)
3657             FREE(SIZ)                                             :(RETURN)
        *
        * MBUG ENTRY. THE 'MAIN' PROCESS NEVER RETURNS. MBUG FORK()S AND THE
        * NEW CHILD PROCESS RETURNS, BUT UNDER MBUG CONTROL.
        *
3658    MBUG     TERMINAL = 'MBUG (TUE JUL  8 21:08:00 EDT 2014)'
        *
        * CONVERT SRC TO ARRAY OF LINES. INDEX BY ADDRESS. THE ADDRESSES ARE
        * ABSOLUTE ADDRESSES. ON THE 'L' COMMAND AND ON BREAK, ISSUE SOURCE
        * IF POSSIBLE.
        *
3659             SRC = CRACK(SRC, CHARS_NL)
3660             SRCIDX = TABLE()
3661             I = 1
3662    MBUG5    S = SRC<I>                                            :F(MBUG6)
3663             S SPAN(' ') '0x' SPAN(&DIGITS 'abcdef') . IDX         :F(MBUG7)
3664             IDX = REPLACE(IDX, &LCASE, &UCASE)
3665             IDX = HI(IDX)
3666             SRCIDX<IDX> = I
3667    MBUG7    I = I + 1                                              :(MBUG5)
3668    MBUG6    B = 0
        *
        * TABLE OF BREAKPOINTS (SEE MBUG.B)
        *
3669             BREAKPOINTS = TABLE()
3670             BREAKA = ARRAY0
        *
        * MAP SIGNAL TO SIGNAL NAME
        *
3671             SIGNALS = TABLE(32)
3672             SIGNALS<SIGHUP>    = 'SIGHUP'
3673             SIGNALS<SIGINT>    = 'SIGINT'
3674             SIGNALS<SIGQUIT>   = 'SIGQUIT'
3675             SIGNALS<SIGILL>    = 'SIGILL'
3676             SIGNALS<SIGTRAP>   = 'SIGTRAP'
3677             SIGNALS<SIGABRT>   = 'SIGABRT'
3678             SIGNALS<SIGBUS>    = 'SIGBUS'
3679             SIGNALS<SIGFPE>    = 'SIGFPE'
3680             SIGNALS<SIGKILL>   = 'SIGKILL'
3681             SIGNALS<SIGUSR1>   = 'SIGUSR1'
3682             SIGNALS<SIGSEGV>   = 'SIGSEGV'
3683             SIGNALS<SIGUSR2>   = 'SIGUSR2'
3684             SIGNALS<SIGPIPE>   = 'SIGPIPE'
3685             SIGNALS<SIGALRM>   = 'SIGALRM'
3686             SIGNALS<SIGTERM>   = 'SIGTERM'
3687             SIGNALS<SIGSTKFLT> = 'SIGSTKFLT'
3688             SIGNALS<SIGCHLD>   = 'SIGCHLD'
3689             SIGNALS<SIGCONT>   = 'SIGCONT'
3690             SIGNALS<SIGSTOP>   = 'SIGSTOP'
3691             SIGNALS<SIGTSTP>   = 'SIGTSTP'
3692             SIGNALS<SIGTTIN>   = 'SIGTTIN'
3693             SIGNALS<SIGTTOU>   = 'SIGTTOU'
3694             SIGNALS<SIGURG>    = 'SIGURG'
3695             SIGNALS<SIGXCPU>   = 'SIGXCPU'
3696             SIGNALS<SIGXFSZ>   = 'SIGXFSZ'
3697             SIGNALS<SIGVTALRM> = 'SIGVTALRM'
3698             SIGNALS<SIGPROF>   = 'SIGPROF'
3699             SIGNALS<SIGWINCH>  = 'SIGWINCH'
3700             SIGNALS<SIGIO>     = 'SIGIO'
3701             SIGNALS<SIGPWR>    = 'SIGPWR'
3702             SIGNALS<SIGSYS>    = 'SIGSYS'
        *
        * TABLE OF ORIGINAL CODE BYTES (SEE MBUG.B, MBUG.G)
        *
3703             ORIGINAL = TABLE()
        *
3704             PID = FORK()
3705             LT(PID)                                               :F(MBUG2)
3706             PERROR('FORK')                                           :(END)
3707    MBUG2    EQ(PID)                                               :S(MBUG3)
        *
        * 'MAIN' PROCESS. ESTABLISH COMMAND HISTORY. FIXME: THINGS LIKE
        * BREAKPOINT AND ORIGINAL CAN BE COMPLETELY MOVED HERE, BECAUSE THEY
        * SHOULD NEVER BE NEEDED IN THE CHILD.
        *
3708             RLAPPNAME('MBUG')
3709             READ_HISTORY('.MBUG')
3710             STIFLE_HISTORY(50)
        *
        * WAIT FOR SIGSTOP FIRST (19), SINGLE STEP (5), NORMAL EXIT (0).
        *
3711    MBUG_TOP WAITPID(-1, 0)
3712             STATUS = GET_STATUS()
3713             EC = STATUS / 256
3714             P = 'MBUG EXITED (Q TO QUIT): '
3715             EQ(EC)                                             :S(MBUG_CMD)
3716             MS_DIS = MALLOC(16)
        *
3717             EQ(EC, SIGTRAP)                                     :S(MBUG_RB)
3718             TERMINAL = 'EC: ' EC ' ' SIGNALS<EC>
        *
        * REMOVE BREAKPOINTS, REWIND RIP BY ONE BYTE (INT3 IS A ONE BYTE
        * INSTRUCTION).
        *
3719    MBUG_RB  IDENT(BRKSET)                                       :S(MBUG_PR)
3720             I = 1
3721    MBUG_NB  BREAKA<I>                                           :F(MBUG_PR)
3722             V2 = PTRACE(PTRACE_PEEKDATA, PID, BREAKA<I>, 0)
3723             M = HI('FFFFFFFFFFFFFF00')
3724             V2 = AND(V2, M)
3725             V2 = OR(V2, ORIGINAL<BREAKA<I>>)
3726             N = PTRACE(PTRACE_POKEDATA, PID, BREAKA<I>, V2)
3727             I = I + 1                                            :(MBUG_NB)
        *
3728    MBUG_PR  PTRACE(PTRACE_GETREGS, PID, 0, MBUG_REGS)
3729             RIP = PEEK_P(MBUG_REGS + 8 * MBUG_RNAMES<'RIP'>)
        *
        * IF EC IS 5 AND BRKSET, WE HIT A BREAKPOINT (5 COULD ALSO BE SINGLE
        * STEP, BUT WE DON'T SET BREAKPOINTS IN THAT CASE). BACK UP RIP BY
        * ONE BYTE.
        *
3730             (EQ(EC, SIGTRAP) DIFFER(BRKSET))                    :F(MBUG_P2)
3731             RIP = RIP - 1
3732             POKE_P(MBUG_REGS + 8 * MBUG_RNAMES<'RIP'>, RIP)
3733             PTRACE(PTRACE_SETREGS, PID, 0, MBUG_REGS)
        *
        * PROMPT CONTAINS RIP (INSTRUCTION POINTER). FIXME: SHOULD MOVE TO
        * MBUG_CMD, IN CASE X RIP COMMAND IS USED TO EDIT THE RIP.
        *
3734    MBUG_P2  BRKSET =
3735             P = 'MBUG ' IH(RIP) ': '
3736             L = SRCIDX<RIP>                                    :F(MBUG_INS)
3737             TERMINAL = SRC<L>                                  :S(MBUG_CMD)
        *
3738    MBUG_INS S = DISASSEMBLE(RIP)
3739             TERMINAL = S
        *
3740    MBUG_CMD MBUG_IN = TRIM(HISTORY_EXPAND(READLINE(P)))             :F(END)
3741             IDENT(MBUG_IN)                                     :S(MBUG_CMD)
3742             ADD_HISTORY(MBUG_IN)
3743             CMD = FENCE NSPAN(' ' CHARS_TAB)
3743    +              ANY('TtDdBbXxLlSsGgEeQqYyRrKkHhUu=?') . C
3743    +              NSPAN(' ' CHARS_TAB) REM . ARGS
3744             MBUG_IN CMD                                        :F(MBUG_BAD)
3745             ARGS = TRIM(ARGS)
3746             C = REPLACE(C, '?=', 'HE')                      :($('MBUG.' C))
3747    MBUG_BAD TERMINAL = 'BAD COMAND, TRY H FOR HELP'             :(MBUG_CMD)
        *
        * DUMP SYMBOL TABLE. ARGS IS A PATTERN TO APPLY. FIXME: SHOULD
        * EVAL() TO BUILD THE PATTERN -- AS IT IS THE PATTERN IS TAKEN AS
        * A SIMPLE STRING.
        *
3748    MBUG.Y   A = KEYST(SYMTAB)                                  :F(MBUG_CMD)
3749             A = SORT(A)
3750             I = 1
3751    MBUG.Y2  A<I>                                               :F(MBUG_CMD)
3752             TERMINAL = (A<I> ? ARGS)
3752    +           LPAD(IH(SYMTAB<A<I>>), 16, '0') ' ' A<I>
3753             I = I + 1                                            :(MBUG.Y2)
        *
        * DISPLAY MEMORY
        *
3754    MBUG.D   IDENT(ARGS)                                         :S(MBUG.D5)
3755             ARGS BRKREM(',') . A1 =
3756             ARGS FENCE ',' =
3757             B = MBUG_ARG(A1)
3758             IDENT(ARGS)                                         :S(MBUG.D5)
3759             E = MBUG_ARG(ARGS)
3760             GT(E, B)                                            :S(MBUG.D4)
3761    MBUG.D5  E = B + 256
        *
3762    MBUG.D4  A = LPAD(IH(B), 16, '0') ': '
3763             H =
3764             S =
3765    MBUG.D2  V = AND(PTRACE(PTRACE_PEEKDATA, PID, B, 0), 255)
3766             S = S (LT(V, 32) '.', GT(V, 126) '.', CHAR(V))
3767             V = LPAD(IH(V), 2, '0')
3768             H = H V
3769             H = NE(AND(B, 1)) H ' '
3770             B = B + 1
3771             GE(B, E)                                            :S(MBUG.D3)
3772             EQ(AND(B, 15))                                      :F(MBUG.D2)
3773             TERMINAL = A LPAD(H, 40, ' ') S                      :(MBUG.D4)
3774    MBUG.D3  TERMINAL = A RPAD(H, 40, ' ') S
3775             B = E                                               :(MBUG_CMD)
        *
3776    MBUG.B   CT = 'SET'
3777    MBUG.B2  IDENT(ARGS)                                         :S(MBUG.B4)
3778             ARGS BRKREM(',') . A =
3779             ARGS FENCE ',' =
3780             A = TRIMB(A)
3781             IDENT(A)                                            :S(MBUG.B2)
3782             A2 = MBUG_ARG(A)
3783             IDENT(CT, 'SET')                                    :F(MBUG.B3)
3784             DIFFER(BREAKPOINTS<A2>)                             :S(MBUG.B2)
3785             BREAKPOINTS<A2> = A                                  :(MBUG.B2)
3786    MBUG.B3  IDENT(BREAKPOINTS<A2>)                              :S(MBUG.B2)
3787             BREAKPOINTS<A2> =                                    :(MBUG.B2)
3788    MBUG.B4  BREAKA = (KEYST(BREAKPOINTS), ARRAY0)               :(MBUG_CMD)
        *
3789    MBUG.R   I = 1
3790    MBUG.R2  BREAKA<I>                                          :F(MBUG_CMD)
3791             TERMINAL = LPAD(IH(BREAKA<I>), 16, '0')
3791    +           ' (' BREAKPOINTS<BREAKA<I>> ')'
3792             I = I + 1                                            :(MBUG.R2)
        *
3793    MBUG.K   CT = 'CLEAR'                                         :(MBUG.B2)
        *
3794    MBUG.U   UA = MBUG_ARG(VDIFFER(ARGS))                        :F(MBUG.U3)
3795             UA = IDENT(UA) RIP
3796             TERMINAL = '(' ARGS '):'
3797    MBUG.U3  N = 12
3798    MBUG.U2  TERMINAL = DISASSEMBLE(UA)
3799             UA = UA + INSTRUCTION_BYTES
3800             N = N - 1
3801             GT(N)                                    :S(MBUG.U2)F(MBUG_CMD)
        *
3802    MBUG.L   A = MBUG_ARG(VDIFFER(ARGS))                         :F(MBUG.L3)
3803             L = SRCIDX<A>                                      :F(MBUG_CMD)
3804             TERMINAL = LPAD(IH(A), 16, '0') ' (' ARGS '):'
3805    MBUG.L3  N = 12
3806    MBUG.L2  TERMINAL = SRC<L>                                  :F(MBUG_CMD)
3807             L = L + 1
3808             N = N - 1
3809             GT(N)                                    :S(MBUG.L2)F(MBUG_CMD)
        *
        * FIXME - STRING HAS TWO ISSUES - C STRING VS BUFFER. POSSIBLY 'C
        * FOR BYTE ENTRY
        *
        * NEED REAL EDIT
        *
        * '/' LEAVES EDIT, MAYBE ADVANCE, BACKUP? Nn> Pp<? 'C?
        *
3810    MBUG.S   ARGS BRKREM(',') . ARGS REM . T
3811             T FENCE ',' =
3812             T = REPLACE(TRIMB(T), &LCASE, &UCASE)
3813             TYPEM = TABLE(21)
3814             TYPEM<''>        = 'BYTE'
3815             TYPEM<'BYTE'>    = 'BYTE'
3816             TYPEM<'WORD'>    = 'WORD'
3817             TYPEM<'DWORD'>   = 'DWORD'
3818             TYPEM<'QWORD'>   = 'QWORD'
3819             TYPEM<'INTEGER'> = 'INTEGER'
3820             TYPEM<'SHORT'>   = 'SHORT'
3821             TYPEM<'LONG'>    = 'LONG'
3822             TYPEM<'B'>       = 'BYTE'
3823             TYPEM<'W'>       = 'WORD'
3824             TYPEM<'D'>       = 'DWORD'
3825             TYPEM<'Q'>       = 'QWORD'
3826             TYPEM<'I'>       = 'INTEGER'
3827             TYPEM<'S'>       = 'SHORT'
3828             TYPEM<'L'>       = 'LONG'
3829             TYPEM<'FLOAT'>   = 'FLOAT'
3830             TYPEM<'DOUBLE'>  = 'DOUBLE'
3831             TYPEM<'REAL'>    = 'FLOAT'
3832             TYPEM<'F'>       = 'FLOAT'
3833             TYPEM<'R'>       = 'FLOAT'
3834             TYPEM<'DP'>      = 'DOUBLE'
3835             EDITT = TABLE(7)
3836             EDITT<'BYTE'>    = 'HEX'
3837             EDITT<'WORD'>    = 'HEX'
3838             EDITT<'DWORD'>   = 'HEX'
3839             EDITT<'QWORD'>   = 'HEX'
3840             EDITT<'INTEGER'> = 'INTEGER'
3841             EDITT<'SHORT'>   = 'INTEGER'
3842             EDITT<'LONG'>    = 'INTEGER'
3843             T = TYPEM<T>
3844             IDENT(MASKS<T>)                                    :S(MBUG_BAD)
3845             SA = MBUG_ARG(VDIFFER(ARGS))
3846             MASKS = TABLE(9)
3847             MASKC = TABLE(9)
3848             SIZET = TABLE(9)
3849             SEXM = TABLE(2)
3850             SEXT = TABLE(2)
3851             SEXM<2>          = HI('0000000000008000')
3852             SEXT<2>          = HI('FFFFFFFFFFFF8000')
3853             SEXM<4>          = HI('0000000080000000')
3854             SEXT<4>          = HI('FFFFFFFF80000000')
3855             MASKS<'BYTE'>    = HI('00000000000000FF')
3856             MASKC<'BYTE'>    = HI('FFFFFFFFFFFFFF00')
3857             SIZET<'BYTE'>    = 1
3858             MASKS<'WORD'>    = HI('000000000000FFFF')
3859             MASKS<'SHORT'>   = HI('000000000000FFFF')
3860             MASKC<'WORD'>    = HI('FFFFFFFFFFFF0000')
3861             MASKC<'SHORT'>   = HI('FFFFFFFFFFFF0000')
3862             SIZET<'WORD'>    = 2
3863             SIZET<'SHORT'>   = 2
3864             MASKS<'DWORD'>   = HI('00000000FFFFFFFF')
3865             MASKS<'INTEGER'> = HI('00000000FFFFFFFF')
3866             MASKS<'FLOAT'>   = HI('00000000FFFFFFFF')
3867             MASKC<'DWORD'>   = HI('FFFFFFFF00000000')
3868             MASKC<'INTEGER'> = HI('FFFFFFFF00000000')
3869             MASKC<'FLOAT'>   = HI('FFFFFFFF00000000')
3870             SIZET<'DWORD'>   = 4
3871             SIZET<'INTEGER'> = 4
3872             SIZET<'FLOAT'>   = 4
3873             MASKS<'QWORD'>   = HI('FFFFFFFFFFFFFFFF')
3874             MASKS<'LONG'>    = HI('FFFFFFFFFFFFFFFF')
3875             MASKS<'DOUBLE'>  = HI('FFFFFFFFFFFFFFFF')
3876             MASKC<'QWORD'>   = HI('0000000000000000')
3877             MASKC<'LONG'>    = HI('0000000000000000')
3878             MASKC<'DOUBLE'>  = HI('0000000000000000')
3879             SIZET<'QWORD'>   = 8
3880             SIZET<'LONG'>    = 8
3881             SIZET<'DOUBLE'>  = 8
3882             SBUF = IDENT(SBUF) MALLOC(16)
        *
3883    MBUG.S2  V = AND(PTRACE(PTRACE_PEEKDATA, PID, SA, 0), MASKS<T>)
        *
3884             V = IDENT(EDITT<T>, 'HEX') LPAD(IH(V), SIZET<T> * 2, '0')
3885             V = IDENT(EDITT<T>, 'INTEGER') V
3886             V = (IDENT(EDITT<T>, 'INTEGER') DIFFER(SEXM<SIZET<T>>)
3886    +             NE(AND(V, SEXM<SIZET<T>>))) OR(V, SEXT<SIZET<T>>)
3887             IDENT(T, 'FLOAT') POKE_I(SBUF, V)
3888             V = IDENT(T, 'FLOAT') PEEK_F(SBUF)
3889             IDENT(T, 'DOUBLE') POKE_P(SBUF, V)
3890             V = IDENT(T, 'DOUBLE') PEEK_D(SBUF)
        *
3891             V = EDITLINE(LPAD(IH(SA), 16, '0') ': ', V)
3892             V = TRIMB(V)
3893             IDENT(V)                                           :S(MBUG_CMD)
3894             V ANY('/')                                         :S(MBUG_CMD)
        *
        * FIXME: CAREFUL ABOUT FAILURE HERE
        *
3895             &ERRLIMIT = 1
3896             V = IDENT(EDITT<T>, 'HEX') HI(V)
3897             V = IDENT(EDITT<T>, 'INTEGER') +V
3898             IDENT(T, 'FLOAT') POKE_F(SBUF, V)
3899             V = IDENT(T, 'FLOAT') PEEK_I(SBUF)
3900             IDENT(T, 'DOUBLE') POKE_D(SBUF, V)
3901             V = IDENT(T, 'DOUBLE') PEEK_P(SBUF)
        *
3902             V = AND(V, MASKS<T>)
3903             V2 = PTRACE(PTRACE_PEEKDATA, PID, SA, 0)
3904             V2 = AND(V2, MASKC<T>)
3905             V3 = OR(V2, V)
3906             PTRACE(PTRACE_POKEDATA, PID, SA, V3)
3907             SA = SA + SIZET<T>                                   :(MBUG.S2)
        *
        * G, EXECUTE
        *
        * ESTABLISH BREAKPOINTS - SAVE ORIGINAL VALUES, PUT IN INT3 CODES
        *
3908    MBUG.G   I = 1
3909             BRKSET = 1
3910    MBUG.G3  BREAKA<I>                                           :F(MBUG.G2)
3911             V = AND(PTRACE(PTRACE_PEEKTEXT, PID, BREAKA<I>, 0), 255)
3912             ORIGINAL<BREAKA<I>> = V
3913             V2 = PTRACE(PTRACE_PEEKTEXT, PID, BREAKA<I>, 0)
3914             M = HI('FFFFFFFFFFFFFF00')
3915             V2 = AND(V2, M)
3916             V2 = OR(V2, INT3)
3917             N = PTRACE(PTRACE_POKETEXT, PID, BREAKA<I>, V2)
3918             I = I + 1                                            :(MBUG.G3)
3919    MBUG.G2  PTRACE(PTRACE_CONT, PID, 0, 0)                      :(MBUG_TOP)
        *
3920    MBUG.E   TERMINAL = ARGS ' = ' EVAL(ARGS)                    :(MBUG_CMD)
        *
3921    MBUG.Q   WRITE_HISTORY('.MBUG')
3922             KILL(PID, SIGKILL)                                       :(END)
        *
3923    MBUG.X   DIFFER(ARGS)                                        :S(MBUG.X2)
        *
        * X ALONE DISPLAYS ALL REGISTERS. WE DON'T DO FLOATING POINT REGISTERS
        * YET.
        *
3924             I = 1
3925             S =
3926             TWIDTH = 72
3927    MBUG.X3  R = MBUG_R2<I>
3928             N = PEEK_P(MBUG_REGS + 8 * MBUG_RNAMES<R>)
3929             N = R '=' IH(N)
3930             X = SIZE(S) + SIZE(N) + 2
3931             TERMINAL = GE(X, TWIDTH) S
3932             S = GE(X, TWIDTH)
3933             S = VDIFFER(S) ', '
3934             S = S N
3935             I = I + 1
3936             MBUG_R2<I>                                          :S(MBUG.X3)
3937             TERMINAL = VDIFFER(S)                               :(MBUG_CMD)
        *
        * X REG DISPLAYS SPECIFIC REGISTER, ALLOWS EDIT OF REGISTER VALUE.
        *
3938    MBUG.X2  ARGS = REPLACE(TRIMB(ARGS), &LCASE, &UCASE)
3939             IDENT(MBUG_RNAMES<ARGS>)                           :S(MBUG_CMD)
3940             N = PEEK_P(MBUG_REGS + 8 * MBUG_RNAMES<ARGS>)
3941             N = IH(N)
3942             N = EDITLINE(ARGS ': ', N)
3943             N = HI(N)
3944             POKE_P(MBUG_REGS + 8 * MBUG_RNAMES<ARGS>, N)
3945             N = PTRACE(PTRACE_SETREGS, PID, 0, MBUG_REGS)       :(MBUG_CMD)
        *
        * HELP FOR MBUG
        *
3946    MBUG.H   TERMINAL = 'MBUG COMMANDS:'
3947             TERMINAL = 'T           TRACE, SINGLE STEP'
3948             TERMINAL = 'X [REG]     EXAMINE/CHANGE REGISTERS'
3949             TERMINAL = 'G           GO'
3950             TERMINAL = 'E EXPR      EVALUATE EXPRESSION'
3951             TERMINAL = 'Q           QUIT MBUG - EXIT TO SYSTEM'
3952             TERMINAL = 'H           HELP'
3953             TERMINAL = 'D B,E       DISPLAY MEMORY'
3954             TERMINAL = 'B ADDR      SET BREAKPOINT'
3955             TERMINAL = 'K ADDR      REMOVE BREAKPOINT'
3956             TERMINAL = 'R           REPORT BREAKPOINTS'
3957             TERMINAL = 'L ADDR      LIST CODE'
3958             TERMINAL = 'S ADDR[,T]  SET/EXAMINE MEMORY TYPE T'
3959             TERMINAL = '            BYTE/WORD/DWORD/QWORD FLOAT/DOUBLE'
3960             TERMINAL = '            SHORT/INTEGER/LONG (BWDQFSIL, DP)'
3961             TERMINAL = 'H           HELP'
3962             TERMINAL = 'Y PAT       SYMBOLS, MATCHING PAT'
3963             TERMINAL = 'U ADDR      UNASSEMBLE'
3964                                                                 :(MBUG_CMD)
        *
3965    MBUG.T   PTRACE(PTRACE_SINGLESTEP, PID, 0, 0)                :(MBUG_TOP)
        *
        * IN CHILD. WE CALL PTRACE() TO BECOME A CALLEE. PTRACE_TRACEME
        * WON'T CAUSE THE CHILD TO STOP. THIS IS WHY WE IMMEDIATELY FOLLOW
        * UP WITH RAISE(SIGSTOP). THE WAITPID() IN MBUG WILL NOW RETURN,
        * WITH THE CHILD TRACED.
        *
3966    MBUG3    PTRACE(PTRACE_TRACEME, 0, 0, 0)
3967             RAISE(SIGSTOP)
        *
        * AFTER RETURN, ENTER FFI BASED OR LOAD() CODE IMMEDIATELY. ALL CODE
        * AFTER THE RAISE(SIGSTOP) IS RUN UNDER THE CONTROL OF MBUG.
        *
3968                                                                   :(RETURN)
        *
        * CE: .MSNOBOL4;
        *
3969    MBUG_END
        -INCLUDE 'MD5.INC'
        -MODULE MD5
        -LINE 11 "MD5.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'MKTEMP.INC'
        -MODULE MKTEMP
        -LINE 10 "MKTEMP.lss"
        -INCLUDE 'BQ.INC'
        -IN72
        -LINE 39 "MKTEMP.lss"
        -STITL MKTEMP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #     #  #    #  #######  #######  #     #  ######           *
        *         ##   ##  #   #      #     #        ##   ##  #     #          *
        *         # # # #  #  #       #     #        # # # #  #     #          *
        *         #  #  #  ###        #     #####    #  #  #  ######           *
        *         #     #  #  #       #     #        #     #  #                *
        *         #     #  #   #      #     #        #     #  #                *
        *         #     #  #    #     #     #######  #     #  #                *
        *                                                                      *
        * MKTEMP               CREATE TEMPORARY FILE                           *
        *                                                                      *
        ************************************************************************
        *
        * MKTEMP.lss
        *
        -LINE 14 "MKTEMP.lss"
        -PUBLIC MKTEMP()
        *
3970             DEFINE('MKTEMP()')                                :(MKTEMP_END)
        *
3971    MKTEMP   MKTEMP = BQ('mktemp')                                 :(RETURN)
3972
3973    MKTEMP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'WRTFILE.INC'
        -IN72
        -LINE 46 "MD5.lss"
        -STITL MD5
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       #     #  ######   #####                        *
        *                       ##   ##  #     #  #                            *
        *                       # # # #  #     #  #                            *
        *                       #  #  #  #     #  #####                        *
        *                       #     #  #     #      #                        *
        *                       #     #  #     #      #                        *
        *                       #     #  ######   #####                        *
        *                                                                      *
        * MD5                           MD5 HASH                               *
        *                                                                      *
        ************************************************************************
        *
        * MD5.lss
        *
        -LINE 18 "MD5.lss"
        -PUBLIC MD5()
        *
3974             DEFINE('MD5(S)T')                                    :(MD5_END)
        *
3975    MD5      T = MKTEMP()
3976             WRITEFILE(T, S)
3977             MD5 = BQ('md5sum ' T)
3978             MD5 BREAK(' ') . MD5
3979             DELETE(T)                                             :(RETURN)
        *
3980    MD5_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MDY.INC'
        -MODULE MDY
        -LINE 10 "MDY.lss"
        -IN72
        -LINE 48 "MDY.lss"
        -STITL MDY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #     #  ######   #     #                       *
        *                      ##   ##  #     #   #   #                        *
        *                      # # # #  #     #    # #                         *
        *                      #  #  #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  ######      #                          *
        *                                                                      *
        * MDY                       M/D/Y FROM Y/D                             *
        *                                                                      *
        ************************************************************************
        *
        * MDY.lss
        *
        -LINE 13 "MDY.lss"
        -PUBLIC MDY()
        *
3981             DEFINE('MDY(Y,DY)X,T')
3982             DAY_MONTH = '(334,12)(304,11)(273,10)(243,9)'
3982    +           '(212,8)(181,7)(151,6)(120,5)(90,4)(59,3)(31,2)(0,1)'
3983             LY_DAY_MONTH = '(335,12)(305,11)(274,10)(244,9)'
3983    +           '(213,8)(182,7)(152,6)(121,5)(91,4)(60,3)(31,2)(0,1)'
3984             I = SPAN('0123456789')
3985             SEARCH.X.M = '(' I $ X *GT(DY, X) ',' I $ M          :(MDY_END)
        *
3986    MDY      T = EQ(REMDR(Y, 400), 0) LY_DAY_MONTH                 :S(MDY_1)
3987             T = EQ(REMDR(Y, 100), 0) DAY_MONTH                    :S(MDY_1)
3988             T = EQ(REMDR(Y,   4), 0) LY_DAY_MONTH                 :S(MDY_1)
3989             T = DAY_MONTH
3990    MDY_1    T SEARCH.X.M                                        :F(FRETURN)
3991             D = DY - X
3992             GT(D, 31)                                           :S(FRETURN)
3993             MDY = M '/' D '/' Y                                   :(RETURN)
        *
3994    MDY_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MERGET.INC'
        -INCLUDE 'MKTEMP.INC'
        -INCLUDE 'NDBM.INC'
        -INCLUDE 'NOTIFY.INC'
        -MODULE NOTIFY
        -INCLUDE 'HOST.INC'
        -INCLUDE 'DDT.INC'
        -IN72
        -STITL NOTIFY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *           #     #  #######  #######  ###  #######  #     #           *
        *           ##    #  #     #     #      #   #         #   #            *
        *           # #   #  #     #     #      #   #          # #             *
        *           #  #  #  #     #     #      #   #####       #              *
        *           #   # #  #     #     #      #   #           #              *
        *           #    ##  #     #     #      #   #           #              *
        *           #     #  #######     #     ###  #           #              *
        *                                                                      *
        * NOTIFY                    NOTIFY USER                                *
        *                                                                      *
        ************************************************************************
        *
        * NOTIFICATION FROM A PROCESS. JUST A WRAPPER FOR notify-send. COULD USE
        * DBUS DIRECTLY. TIMEOUT IS IN MILLISECONDS. URGENCY IS LOW, NORMAL,
        * CRITICAL. BODY CAN HAVE <I>, </B>, <U>, <IMG>, <A HREF>
        *
3995             DEFINE('NOTIFY(SUMMARY,BODY,URGENCY,TIMEOUT)')    :(NOTIFY_END)
        *
3996    NOTIFY
3997             HOST(HOST_GETENV, 'DBUS_SESSION_BUS_ADDRESS')        :F(RETURN)
3998             URGENCY = ' -u ' VDIFFER(URGENCY)
3999             TIMEOUT = ' -t ' VDIFFER(TIMEOUT)
4000             SUMMARY = ' "' SUMMARY '"'
4001             BODY = ' "' BODY '"'
4002             NOTIFY = '/usr/bin/notify-send' URGENCY TIMEOUT SUMMARY BODY
4003             HOST(HOST_SYSCMD, NOTIFY)                             :(RETURN)
        *
4004    NOTIFY_END
        *
        * CE: .MSNOBOL4;
4005
        -INCLUDE 'NOTP.INC'
        -MODULE NOTP
        -LINE 11 "NOTP.lss"
        -INCLUDE 'STACK.INC'
        -LINE 11 "STACK.lss"
        -INCLUDE 'LINK.INC'
        -INCLUDE 'REPL.INC'
        -STITL STACK
        -EJECT
        -LINE 53 "STACK.lss"
        *
        ************************************************************************
        *                                                                      *
        *               #####   #######     #      #####   #    #              *
        *              #     #     #       # #    #     #  #   #               *
        *              #           #      #   #   #        #  #                *
        *               #####      #     #     #  #        ###                 *
        *                    #     #     #######  #        #  #                *
        *              #     #     #     #     #  #     #  #   #               *
        *               #####      #     #     #   #####   #    #              *
        *                                                                      *
        * STACK                     CREATE STACK                               *
        *                                                                      *
        ************************************************************************
        *
        * STACK.lss
        *
        -LINE 16 "STACK.lss"
        -MODULE STACK
        -PUBLIC STACK()
4006             DEFINE('STACK(SUF)S')
4007             STACK()
        -PUBLIC PUSH(), POP(), TOP()
4008             OPSYN('PUSH', 'PUSH_')
4009             OPSYN('POP',  'POP_')
4010             OPSYN('TOP',  'TOP_')                              :(STACK_END)
        *
4011    STACK    S = 'PUSH_SUF STACK_SUF = LINK(V, STACK_SUF)         ;'
4011    +            '         PUSH_SUF = .VALUE(STACK_SUF) :(NRETURN);'
4011    +            'POP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
4011    +            '         POP_SUF = VALUE(STACK_SUF)             ;'
4011    +            '         STACK_SUF = NEXT(STACK_SUF)   :(RETURN);'
4011    +            'TOP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
4011    +            '         TOP_SUF = .VALUE(STACK_SUF)  :(NRETURN);'
4012             CODE(REPL(S, 'SUF', SUF))
4013             DEFINE('PUSH_' SUF '(V)')
4014             DEFINE('POP_'  SUF '()' )
4015             DEFINE('TOP_'  SUF '()' )                             :(RETURN)
        *
4016    STACK_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 46 "NOTP.lss"
        -STITL NOTP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                   #     #  #######  #######  ######                  *
        *                   ##    #  #     #     #     #     #                 *
        *                   # #   #  #     #     #     #     #                 *
        *                   #  #  #  #     #     #     ######                  *
        *                   #   # #  #     #     #     #                       *
        *                   #    ##  #     #     #     #                       *
        *                   #     #  #######     #     #                       *
        *                                                                      *
        * NOTP                       INVERT PATTERN                            *
        *                                                                      *
        ************************************************************************
        *
        * NOTP.lss
        *
        -LINE 15 "NOTP.lss"
        -PUBLIC NOTP()
        *
4017             DEFINE('NOTP(P)')                                   :(NOTP_END)
        *
        -LINE 27 "NOTP.lss"
4018    NOTP     NOTP = PUSH() P *?(POP() PUSH(1)) FAIL |
4018    +               *IDENT(POP())                                  :(RETURN)
        *
4019    NOTP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'NSPAN.INC'
        -INCLUDE 'ONCE.INC'
        -MODULE ONCE
        -LINE 13 "ONCE.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 43 "ONCE.lss"
        -STITL ONCE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  #######  #     #   #####   #######                  *
        *                  #     #  ##    #  #     #  #                        *
        *                  #     #  # #   #  #        #                        *
        *                  #     #  #  #  #  #        #####                    *
        *                  #     #  #   # #  #        #                        *
        *                  #     #  #    ##  #     #  #                        *
        *                  #######  #     #   #####   #######                  *
        *                                                                      *
        * ONCE                                                                 *
        *                                                                      *
        ************************************************************************
        *
        * ONCE.lss
        *
        -LINE 17 "ONCE.lss"
        -PUBLIC ONCE()
        *
4020             DEFINE('ONCE(ID)NAME')                              :(ONCE_END)
4021    ONCE     ONCE = IDENT(ID, NULL)
4021    +               CONVERT('ONCE(' 1 ')', 'EXPRESSION')          :S(RETURN)
4022             NAME = UNIQUE()
4023             ONCE = $NAME
4024             $NAME = FAIL                                          :(RETURN)
        *
4025    ONCE_END
        *
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ORDER.INC'
        -MODULE ORDER
        -LINE 9 "ORDER.lss"
        -IN72
        -LINE 37 "ORDER.lss"
        -STITL ORDER
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                #######  ######   ######   #######  ######            *
        *                #     #  #     #  #     #  #        #     #           *
        *                #     #  #     #  #     #  #        #     #           *
        *                #     #  ######   #     #  #####    ######            *
        *                #     #  #   #    #     #  #        #   #             *
        *                #     #  #    #   #     #  #        #    #            *
        *                #######  #     #  ######   #######  #     #           *
        *                                                                      *
        * ORDER                   ORDER CHARACTERS IN STRING                   *
        *                                                                      *
        ************************************************************************
        *
        * ORDER.lss
        *
        -LINE 12 "ORDER.lss"
        -PUBLIC ORDER()
        *
4026             DEFINE('ORDER(S)T,HIGHS,S1')                       :(ORDER_END)
        *
4027    ORDER    S LEN(1) . T =                                       :F(RETURN)
4028             &ALPHABET BREAK(T) REM . HIGHS
4029             ORDER (BREAK(HIGHS) | REM) . S1 = S1 T                 :(ORDER)
        *
4030    ORDER_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'P64.INC'
        -INCLUDE 'PRUNET.INC'
        -MODULE PRUNET
        -LINE 14 "PRUNET.lss"
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 43 "PRUNET.lss"
        -STITL PRUNET
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######   ######   #     #  #     #  #######  #######         *
        *         #     #  #     #  #     #  ##    #  #           #            *
        *         #     #  #     #  #     #  # #   #  #           #            *
        *         ######   ######   #     #  #  #  #  #####       #            *
        *         #        #   #    #     #  #   # #  #           #            *
        *         #        #    #   #     #  #    ##  #           #            *
        *         #        #     #   #####   #     #  #######     #            *
        *                                                                      *
        * PRUNET                       PRUNE TABLE                             *
        *                                                                      *
        ************************************************************************
        *
        * PRUNET.lss
        *
        -LINE 19 "PRUNET.lss"
        -PUBLIC PRUNET()
        *
4031             DEFINE('PRUNET(T)A,I')                            :(PRUNET_END)
        *
4032    PRUNET   PRUNET = TABLE()
4033             A = KEYST(T)                                         :F(RETURN)
4034             SEQ(' PRUNET<A<I>> = VDIFFER(T<A<I>>)', .I)           :(RETURN)
        *
4035    PRUNET_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'PSQL.INC'
        -MODULE PSQL
        -LINE 71 "PSQL.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'COUNT.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'SCOOP.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'TIMER.INC'
        -INCLUDE 'UNIQUE.INC'
        -LINE 396 "PSQL.lss"
        -IN72
        -STITL PSQL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  ######    #####    #####   #                        *
        *                  #     #  #     #  #     #  #                        *
        *                  #     #  #        #     #  #                        *
        *                  ######    #####   #     #  #                        *
        *                  #              #  #   # #  #                        *
        *                  #        #     #  #    #   #                        *
        *                  #         #####    #### #  #######                  *
        *                                                                      *
        * PSQL                 INTERFACE TO POSTGRESQL                         *
        *                                                                      *
        ************************************************************************
        *
        * PSQL.lss
        *
        -LINE 120 "PSQL.lss"
        *
        * THESE THREE ARE FUNCTIONS -- SIMPLY EASIER THAT WAY.
        *
        -PUBLIC PSQL_INSERT(), PSQL_RESULT(), PSQL_ESCAPE()
        *
4036             DEFINE('PSQL_INSERT(T)N,V,I')
4037             DEFINE('PSQL_RESULT(S)I,N,R,T,KEY,DAT')
4038             DEFINE('PSQL_ESCAPE(S)')
        *
        * CREATE CLASS PSQL_CLASS AND POPULATE ITS METHODS
        *
        -PUBLIC CLASS:PSQL_CLASS
        *
4039             PSQL_CLASS = SEND(CLASS, 'NEW_CLASS', 'PSQL_CLASS')
4040             DEFINE('PSQL_OPEN()L')
        *
        -PUBLIC PSQL_CLASS:'OPEN'
        *
4041             SEND(PSQL_CLASS, 'ADD_METHOD', 'OPEN', 'PSQL_OPEN')
4042             DEFINE('PSQL_CLOSE()PID')
        *
        -PUBLIC PSQL_CLASS:'CLOSE'
        *
4043             SEND(PSQL_CLASS, 'ADD_METHOD', 'CLOSE', 'PSQL_CLOSE')
        *
        -PUBLIC PSQL_CLASS:'GET_PIPE'
        *
4044             SEND(PSQL_CLASS, 'ADD_METHOD', 'GET_PIPE', CODE(
4044    +           ' SEND = |.PIPE :(RETURN)'))
4045             DEFINE('PSQL_DISCARD()L')
        *
        -PUBLIC PSQL_CLASS:'DISCARD'
        *
4046             SEND(PSQL_CLASS, 'ADD_METHOD', 'DISCARD', 'PSQL_DISCARD')
4047             DEFINE('PSQL_OUTPUT()L')
        *
        -PUBLIC PSQL_CLASS:'OUTPUT'
        *
4048             SEND(PSQL_CLASS, 'ADD_METHOD', 'OUTPUT', 'PSQL_OUTPUT')
        *
4049                                                                 :(PSQL_END)
        *
        * CONVERT TABLE TO "(NAME, ...) VALUES (DATA, ...)" READY FOR SQL
        * INSERT. USES PSQL_ESCAPE() TO ENSURE THAT VALUES ARE QUOTED CORRECTLY.
        *
4050    PSQL_INSERT
4051             T = CONVERT(T, 'ARRAY')
4052             SEQ(' N = N T<I, 1> ", "; '
4052    +            ' V = V PSQL_ESCAPE(T<I, 2>) ", " ', .I)
4053             IDENT(N)                                            :S(FRETURN)
4054             N ', ' RPOS(0) =
4055             V ', ' RPOS(0) =
4056             PSQL_INSERT = '(' N ') VALUES (' V ')'                :(RETURN)
        *
        * CONVERT PSQL_OUTPUT() INTO ARRAY OF TABLES
        *
4057    PSQL_RESULT
4058             IDENT(S)                                            :S(FRETURN)
4059             S = S CHARS_NL
4060             N = COUNT(S, CHARS_NL CHARS_NL)
4061             EQ(N)                                               :S(FRETURN)
4062             PSQL_RESULT = ARRAY(N)
4063    PSQL5    S POS(0) ARB . T CHARS_NL CHARS_NL REM . S           :F(RETURN)
4064             R = TABLE()
4065    PSQL6    T POS(0) BREAK('|') . KEY '|'
4065    +          BRKREM(CHARS_NL) . DAT (CHARS_NL | RPOS(0)) =       :F(PSQL7)
4066             R<KEY> = DAT                                           :(PSQL6)
4067    PSQL7    I = I + 1
4068             PSQL_RESULT<I> = R                                     :(PSQL5)
        *
        * ESCAPE AND QUOTE AN SQL STRING
        *
4069    PSQL_ESCAPE
4070             PSQL_ESCAPE = "'" REPL(S, "'", "''") "'"              :(RETURN)
        *
        * DISCARD OUTPUT FROM LAST SQL COMMAND.
        *
4071    PSQL_DISCARD
4072             L = $|.PIPE                                         :F(FRETURN)
4073             L POS(0) '*' RPOS(0)                  :S(RETURN)F(PSQL_DISCARD)
        *
        * GATHER AND RETURN OUTPUT FROM SQL COMMAND. DISCARD COMMAND ECHO,
        * RETURNING ONLY RESULTS.
        *
4074    PSQL_OUTPUT
4075    PSQL2    L = $|.PIPE                                         :F(FRETURN)
4076             L POS(0) '*' RPOS(0)                                  :S(PSQL3)
4077             PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
4078    PSQL3    PSQL_OUTPUT CHARS_NL CHARS_NL RPOS(0) = CHARS_NL      :S(PSQL3)
4079    PSQL4    PSQL_OUTPUT BREAK(CHARS_NL) CHARS_NL REM . PSQL_OUTPUT
4079    +                                                            :F(FRETURN)
4080             PSQL_OUTPUT POS(0) '# '                      :S(PSQL4)F(RETURN)
        *
        * OPEN PSQL COMMAND. SEND COMMANDS TO MAKE PSQL_OUTPUT() EASIER,
        * PSQL_RESULT() FOR PARSING SELECT RESULTS AND BUILDING RESULT ARRAYS.
        *
4081    PSQL_OPEN
4082             |.UNIT = IO_FINDUNIT()                              :F(FRETURN)
4083             |.PIPE = UNIQUE()
4084             INPUT(|.PIPE, |.UNIT, 'U', '||/usr/bin/psql -q')    :F(FRETURN)
4085             OUTPUT(|.PIPE, |.UNIT)                              :F(FRETURN)
4086             $|.PIPE = "\set PROMPT1 '\n*\n'"                    :F(FRETURN)
4087             SELF('DISCARD')                                     :F(FRETURN)
4088             $|.PIPE = "\set PROMPT2 '# '"                       :F(FRETURN)
4089             SELF('DISCARD')                                     :F(FRETURN)
4090             $|.PIPE = "\pset pager off"                         :F(FRETURN)
4091             SELF('DISCARD')                                     :F(FRETURN)
4092             $|.PIPE = "\a"                                      :F(FRETURN)
4093             SELF('DISCARD')                                     :F(FRETURN)
4094             $|.PIPE = "\x on"                                   :F(FRETURN)
4095             SELF('DISCARD')                            :F(FRETURN)S(RETURN)
        *
        * CLOSE PSQL
        *
4096    PSQL_CLOSE
4097             $|.PIPE = '\q'                                      :F(FRETURN)
4098             ENDFILE(|.UNIT)                                     :F(FRETURN)
4099             DETACH(|.PIPE)                                      :F(FRETURN)
        *
        * ENDFILE() CLOSES PSQL. INDEED, WE SEND A QUIT COMMAND (\q) FIRST!
        * BUT... THE CLOSE CODE IN THE INTERPRETER DOES NOT REAP THE ZOMBIE.
        * WAIT() IS DEFINED IN CSNOBOL4, USE WAIT() TO REAP. THIS IS WRONG,
        * WE MAY REAP THE WRONG PROCESS! SHOULD FIX THIS IN IO.C - THE CODE
        * IS IN IO.C, BUT ISN'T WORKING (?)
        *
4100             PID = WAIT()                               :S(RETURN)F(FRETURN)
        *
4101    PSQL_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'QUOTE.INC'
        -INCLUDE 'RANDOM.INC'
        -MODULE RANDOM
        -LINE 9 "RANDOM.lss"
        -IN72
        -LINE 42 "RANDOM.lss"
        -STITL RANDOM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######      #     #     #  ######   #######  #     #         *
        *         #     #    # #    ##    #  #     #  #     #  ##   ##         *
        *         #     #   #   #   # #   #  #     #  #     #  # # # #         *
        *         ######   #     #  #  #  #  #     #  #     #  #  #  #         *
        *         #   #    #######  #   # #  #     #  #     #  #     #         *
        *         #    #   #     #  #    ##  #     #  #     #  #     #         *
        *         #     #  #     #  #     #  ######   #######  #     #         *
        *                                                                      *
        * RANDOM                 RANDOM NUMBER FUNCTIONS                       *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * JANUARY 4, 2011                                                      *
        *                                                                      *
        ************************************************************************
        *
        * RANDOM.lss
        *
        -LINE 12 "RANDOM.lss"
        -PUBLIC RANDOM(), SRANDOM(), SRANDOMDEV() RANDOMI()
        *
4102             LOAD('RANDOM()INTEGER')
4103             LOAD('SRANDOM(INTEGER)STRING')
4104             LOAD('SRANDOMDEV()STRING')
4105             DEFINE('RANDOMI(N)')                              :(RANDOM_END)
        *
        * RANDOM() RETURNS INTEGER 0 .. 2 ** 31 - 1
        * RETURN 1 .. N
        *
4106    RANDOMI  RANDOMI = RANDOM()
4107             RANDOMI = RANDOMI / 2147483647.0
4108             RANDOMI = NE(N, 0) CONVERT(RANDOMI * N, 'INTEGER') + 1
4109                                                                   :(RETURN)
4110    RANDOM_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'READL.INC'
        -MODULE READL
        -LINE 14 "READL.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 46 "READL.lss"
        -STITL READL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             ######   #######     #     ######   #                    *
        *             #     #  #          # #    #     #  #                    *
        *             #     #  #         #   #   #     #  #                    *
        *             ######   #####    #     #  #     #  #                    *
        *             #   #    #        #######  #     #  #                    *
        *             #    #   #        #     #  #     #  #                    *
        *             #     #  #######  #     #  ######   #######              *
        *                                                                      *
        * READL                      READ LIST                                 *
        *                                                                      *
        ************************************************************************
        *
        * READL.lss
        *
        -LINE 18 "READL.lss"
        -PUBLIC READL()
        *
4111             DEFINE('READL(P,IN)N,S')                           :(READL_END)
        *
4112    READL    P = IDENT(P) ABORT
4113             IN = IDENT(IN) .INPUT
4114             N = .READL
4115    READL_1  S = $IN                                              :F(RETURN)
4116             S P                                                  :S(RETURN)
4117             $N = LINK(S)
4118             N = .NEXT($N)                                        :(READL_1)
        *
4119    READL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READLINE.INC'
        -INCLUDE 'REAL.INC'
        -MODULE REAL
        -STITL REAL
        *
        ************************************************************************
        *                                                                      *
        *                  ######   #######     #     #                        *
        *                  #     #  #          # #    #                        *
        *                  #     #  #         #   #   #                        *
        *                  ######   #####    #     #  #                        *
        *                  #   #    #        #######  #                        *
        *                  #    #   #        #     #  #                        *
        *                  #     #  #######  #     #  #######                  *
        *                                                                      *
        * REAL                 FASBOL II REAL PREDICATE                        *
        *                                                                      *
        ************************************************************************
        *
        * REAL.INC
        *
        -PUBLIC REAL()
        *
4120             DEFINE('REAL(X)')                                   :(END_REAL)
        *
4121    REAL     IDENT(DATATYPE(X), 'REAL')                            :(RETURN)
4122             INTEGER(X)                                          :S(FRETURN)
4123             (IDENT(DATATYPE(X), 'STRING') CONVERT(X, 'REAL'))
4123    +                                                   :S(RETURN)F(FRETURN)
        *
4124    END_REAL
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'REDEFINE.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'RESOL.INC'
        -INCLUDE 'REVL.INC'
        -INCLUDE 'ROMAN.INC'
        -MODULE ROMAN
        -LINE 12 "ROMAN.lss"
        -IN72
        -LINE 57 "ROMAN.lss"
        -STITL ROMAN
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             ######   #######  #     #     #     #     #              *
        *             #     #  #     #  ##   ##    # #    ##    #              *
        *             #     #  #     #  # # # #   #   #   # #   #              *
        *             ######   #     #  #  #  #  #     #  #  #  #              *
        *             #   #    #     #  #     #  #######  #   # #              *
        *             #    #   #     #  #     #  #     #  #    ##              *
        *             #     #  #######  #     #  #     #  #     #              *
        *                                                                      *
        * ROMAN                      ROMAN NUMERAL                             *
        *                                                                      *
        ************************************************************************
        *
        * ROMAN.lss
        *
        -LINE 15 "ROMAN.lss"
        -PUBLIC ROMAN()
        *
4125             DEFINE('ROMAN(N)T')                                :(ROMAN_END)
        *
4126    ROMAN    N RPOS(1) LEN(1) . T =                               :F(RETURN)
4127             '0,1I,2II,3III,4IV,5V,6VI,7VII,8VIII,9IX,'
4127    +           T BREAK(',') . T                                 :F(FRETURN)
4128             ROMAN = REPLACE(ROMAN(N), 'IVXLCDM', 'XLCDM**') T
4128    +                                                   :S(RETURN)F(FRETURN)
        *
4129    ROMAN_END
        *
        -PUBLIC ARABIC()
4130             DEFINE('ARABIC(R)T,X')                            :(ARABIC_END)
        *
4131    ARABIC   R RPOS(1) LEN(1) . T =                               :F(RETURN)
4132             'M1000,D500,C100,L50,X10,V5,I1,' T BREAK(',') . T   :F(FRETURN)
4133             T = LT(T, X) -T
4134             ARABIC = ARABIC + (X = T)                             :(ARABIC)
        *
4135    ARABIC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ROTATER.INC'
        -MODULE ROTATER
        -LINE 9 "ROTATER.lss"
        -IN72
        -LINE 38 "ROTATER.lss"
        -STITL ROTATER
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    ######   #######  #######     #     #######  #######  ######      *
        *    #     #  #     #     #       # #       #     #        #     #     *
        *    #     #  #     #     #      #   #      #     #        #     #     *
        *    ######   #     #     #     #     #     #     #####    ######      *
        *    #   #    #     #     #     #######     #     #        #   #       *
        *    #    #   #     #     #     #     #     #     #        #    #      *
        *    #     #  #######     #     #     #     #     #######  #     #     *
        *                                                                      *
        * ROTATER                    ROTATE STRING                             *
        *                                                                      *
        ************************************************************************
        *
        * ROTATER.lss
        *
        -LINE 12 "ROTATER.lss"
        -PUBLIC ROTATER()
        *
4136             DEFINE('ROTATER(S,N)S1')                         :(ROTATER_END)
        *
4137    ROTATER  IDENT(S)                                             :S(RETURN)
4138             N = REMDR(N, SIZE(S))
4139             N = LT(N, 0) SIZE(S) + N
4140             S RTAB(N) . S  REM . S1 = S1 S
4141             ROTATER = S                                           :(RETURN)
        *
4142    ROTATER_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ROUTING.INC'
        -MODULE ROUTING
        -LINE 16 "ROUTING.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'SDIFF.INC'
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 121 "ROUTING.lss"
        -STITL ROUTING
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *      ######   #######  #     #  #######  ###  #     #   #####        *
        *      #     #  #     #  #     #     #      #   ##    #  #     #       *
        *      #     #  #     #  #     #     #      #   # #   #  #             *
        *      ######   #     #  #     #     #      #   #  #  #  #  ####       *
        *      #   #    #     #  #     #     #      #   #   # #  #     #       *
        *      #    #   #     #  #     #     #      #   #    ##  #     #       *
        *      #     #  #######   #####      #     ###  #     #   #####        *
        *                                                                      *
        * ROUTING                   ROUTING FOR CGI                            *
        *                                                                      *
        ************************************************************************
        *
        * ROUTING.lss
        *
        -LINE 22 "ROUTING.lss"
        -PUBLIC ROUTING_INIT(), ROUTING_ADD(), ROUTING()
        *
4143             DEFINE('ROUTING_INIT()')
4144             DEFINE('ROUTING_ADD(ROUTE,PATTERN,ACTION_)NAME,P')
4145             DEFINE('ROUTING(METHOD,ROUTE,VARS_)P,S')
        *
4146             ROUTING_VAR = ':'
4147             ROUTING_NAME_C = &UCASE &LCASE '0123456789' '._'
4148             ROUTING_NAME = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789._')
4149             MAKE_UNIQUE('ROUTING')
        *
4150                                                              :(ROUTING_END)
        *
        * INITIALIZE ROUTE. THE INITIAL ROUTE ALWAYS FAILS.
        *
4151    ROUTING_INIT
4152             UNIQUE_ROUTING('CLEAR')
4153             ROUTING_INIT = ABORT                                  :(RETURN)
        *
        * ADD PATTERN TO ROUTE, WITH ACTION. ON MATCH, YIELDS ACTION, AND
        * SUCCESS.
        *
4154    ROUTING_ADD
4155             NAME = UNIQUE_ROUTING()
4156             $NAME = ACTION_
4157             P = EVAL('PATTERN *?(ACTION = ' NAME ')')
4158             ROUTING_ADD = P | ROUTE                               :(RETURN)
        *
        * MAKE A ROUTING PATTERN. METHOD WILL BE SOMETHING LIKE 'GET', 'POST',
        * '', ('GET' | 'POST'). ROUTE WILL BE '/A/B/C', '/A/:VAR/C'
        *
4159    ROUTING  METHOD = IDENT(METHOD) BREAK('\')
4160    ROUTE_3  ROUTE POS(0) BRKREM(ROUTING_VAR) . S =
4161             P = DIFFER(S) P S
4162             IDENT(ROUTE)                                        :S(ROUTE_9)
4163             ROUTE POS(0) LEN(1) BRKREM(ROUTING_NAME) . S =
4164             IDENT(S)                                            :S(ROUTE_3)
4165             ROUTE LEN(1) . B =                                  :F(ROUTE_4)
4166             P = P BREAK(B) . ($VARS_)<S> B                       :(ROUTE_3)
4167    ROUTE_4  P = P REM . ($VARS_)<S>
4168    ROUTE_9  ROUTING = METHOD '\' P                                :(RETURN)
        *
4169    ROUTING_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'SCOOP.INC'
        -INCLUDE 'SDIFF.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'SESSION.INC'
        -INCLUDE 'SIZEA.INC'
        -INCLUDE 'SIZEL.INC'
        -LINE 9 "SIZEL.lss"
        -INCLUDE 'LINK.INC'
        -STITL SIZEL
        -EJECT
        -LINE 38 "SIZEL.lss"
        *
        ************************************************************************
        *                                                                      *
        *                #####   ###  #######  #######  #                      *
        *               #     #   #        #   #        #                      *
        *               #         #       #    #        #                      *
        *                #####    #     #      #####    #                      *
        *                     #   #    #       #        #                      *
        *               #     #   #   #        #        #                      *
        *                #####   ###  #######  #######  #######                *
        *                                                                      *
        * SIZEL                    SIZE OF LIST                                *
        *                                                                      *
        ************************************************************************
        *
        * SIZEL.lss
        *
        -LINE 13 "SIZEL.lss"
        -MODULE SIZEL
        -PUBLIC SIZEL()
        *
4170             DEFINE('SIZEL(L)')                                 :(END_SIZEL)
        *
4171    SIZEL    SIZEL = 0
4172    SIZEL_2  SIZEL = DIFFER(L) SIZEL + 1                          :F(RETURN)
4173             L = NEXT(L)                                          :(SIZEL_2)
        *
4174    END_SIZEL
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SIZET.INC'
        -MODULE SIZEL
        -IN72
        -LINE 10 "SIZET.lss"
        -INCLUDE 'HASH.INC'
        -INCLUDE 'SIZEA.INC'
        -LINE 37 "SIZET.lss"
        -STITL SIZET
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                #####   ###  #######  #######  #######                *
        *               #     #   #        #   #           #                   *
        *               #         #       #    #           #                   *
        *                #####    #     #      #####       #                   *
        *                     #   #    #       #           #                   *
        *               #     #   #   #        #           #                   *
        *                #####   ###  #######  #######     #                   *
        *                                                                      *
        * SIZET                    SIZE OF TABLE                               *
        *                                                                      *
        ************************************************************************
        *
        * SIZET.lss
        *
        -LINE 15 "SIZET.lss"
        -PUBLIC SIZET()
        *
4175             DEFINE('SIZET(T)')                                 :(END_SIZET)
        *
4176    SIZET    SIZET =  SIZEA(KEYST(T))                              :(RETURN)
        *
4177    END_SIZET
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SKIM.INC'
        -LINE 11 "SKIM.lss"
        -INCLUDE 'SDIFF.INC'
        -STITL SKIM
        -EJECT
        -LINE 40 "SKIM.lss"
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                    #####   #    #  ###  #     #                      *
        *                   #     #  #   #    #   ##   ##                      *
        *                   #        #  #     #   # # # #                      *
        *                    #####   ###      #   #  #  #                      *
        *                         #  #  #     #   #     #                      *
        *                   #     #  #   #    #   #     #                      *
        *                    #####   #    #  ###  #     #                      *
        *                                                                      *
        * SKIM                 SKIM UNIQUE CHARACTERS                          *
        *                                                                      *
        ************************************************************************
        *
        * SKIM.lss
        *
        -LINE 15 "SKIM.lss"
        -MODULE SKIM
        -PUBLIC SKIM()
4178             DEFINE('SKIM(S)C')                                  :(SKIM_END)
        *
4179    SKIM     S LEN(1) . C =                                       :F(RETURN)
4180             SKIM C                                               :S(SKIM_D)
4181             SKIM = SKIM C                                           :(SKIM)
4182    SKIM_D   S = SDIFF(S, SKIM)                                      :(SKIM)
        *
4183    SKIM_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SLOAD.INC'
        -INCLUDE 'SOUNDEX.INC'
        -STITL SOUNDEX
        -EJECT
        *
        -LINE 46 "SOUNDEX.lss"
        ************************************************************************
        *                                                                      *
        *     #####   #######  #     #  #     #  ######   #######  #     #     *
        *    #     #  #     #  #     #  ##    #  #     #  #         #   #      *
        *    #        #     #  #     #  # #   #  #     #  #          # #       *
        *     #####   #     #  #     #  #  #  #  #     #  #####       #        *
        *          #  #     #  #     #  #   # #  #     #  #          # #       *
        *    #     #  #     #  #     #  #    ##  #     #  #         #   #      *
        *     #####   #######   #####   #     #  ######   #######  #     #     *
        *                                                                      *
        * SOUNDEX                   NARA SOUNDEX                               *
        *                                                                      *
        ************************************************************************
        *
        * SOUNDEX.lss
        *
        -LINE 11 "SOUNDEX.lss"
        -MODULE SOUNDEX
        -PUBLIC SOUNDEX()
4184             DEFINE('SOUNDEX(STR)SDXMAP,INIT,CH')             :(SOUNDEX_END)
        *
4185    SOUNDEX  SDXMAP = '01230127022455012623017202'
4186             STR = REPLACE(STR, &LCASE, &UCASE)
4187    SDX1     STR NOTANY(&UCASE) =                                   :S(SDX1)
4188             INIT = SUBSTR(STR, 1, 1)
4189             STR = REPLACE(STR, &UCASE, SDXMAP)
4190    SDX2     STR LEN(1) $ CH SPAN(*CH) = CH                         :S(SDX2)
        * OMIT NEXT LINE FOR KNUTH'S SIMPLE SOUNDEX
4191    SDX3     STR LEN(1) $ CH ('7' *CH) = CH                         :S(SDX3)
4192             STR LEN(1) = INIT
4193    SDX4     STR ANY('07') =                                        :S(SDX4)
4194             STR = SUBSTR(STR, 1, 4)
4195             STR = LT(SIZE(STR), 4) STR DUPL('0', 4 - SIZE(STR))
4196             SOUNDEX = STR                                         :(RETURN)
        *
4197    SOUNDEX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SPELL.INC'
        -STITL SPELL
        -EJECT
        *
        -LINE 58 "SPELL.lss"
        ************************************************************************
        *                                                                      *
        *                 #####   ######   #######  #        #                 *
        *                #     #  #     #  #        #        #                 *
        *                #        #     #  #        #        #                 *
        *                 #####   ######   #####    #        #                 *
        *                      #  #        #        #        #                 *
        *                #     #  #        #        #        #                 *
        *                 #####   #        #######  #######  #######           *
        *                                                                      *
        * SPELL                    SPELL OUT A NUMBER                          *
        *                                                                      *
        ************************************************************************
        *
        * SPELL.lss
        *
        -LINE 12 "SPELL.lss"
        -MODULE SPELL
        -PUBLIC SPELL()
4198             DEFINE('SPELL(N)M')                                :(SPELL_END)
        *
4199    SPELL    GE(N, 1000)                                      :S(SPELL_1000)
4200             GE(N, 100)                                        :S(SPELL_100)
4201             GE(N, 20)                                          :S(SPELL_20)
4202             GE(N, 13)                                          :S(SPELL_13)
4203             ('1ONE,2TWO,3THREE,4FOUR,5FIVE,6SIX,7SEVEN,8EIGHT,9NINE,'
4203    +           '10TEN,11ELEVEN,12TWELVE,') N ARB . SPELL ','      :(RETURN)
4204    SPELL_13 N 1 LEN(1) . M
4205             SPELL = SPELL(M 0)
4206             SPELL 'TY' = 'TEEN'
4207             SPELL 'FOR' = 'FOUR'                                  :(RETURN)
4208    SPELL_20 N LEN(1) . M =
4209             '2TWEN,3THIR,4FOR,5FIF,6SIX,7SEVEN,8EIGH,9NINE,'
4209    +           M BREAK(',') . SPELL
4210             SPELL = SPELL 'TY'
4211             SPELL = NE(N,0) SPELL '-' SPELL(N)                    :(RETURN)
4212    SPELL_100
4213             N LEN(1) . M  =
4214             SPELL = SPELL(M) ' HUNDRED'
4215             SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
4216    SPELL_1000
4217             N RTAB(3) . M  =
4218             SPELL = SPELL(M)
4219             SPELL 'THOUSAND' = 'MILLION'
4220             SPELL = SPELL ' THOUSAND'
4221             SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
        *
4222    SPELL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'STACK.INC'
        -INCLUDE 'STCL.INC'
        -INCLUDE 'STROUT.INC'
        -STITL STROUT
        -EJECT
        *
        -LINE 43 "STROUT.lss"
        ************************************************************************
        *                                                                      *
        *            #####   #######  ######   #######  #     #  #######       *
        *           #     #     #     #     #  #     #  #     #     #          *
        *           #           #     #     #  #     #  #     #     #          *
        *            #####      #     ######   #     #  #     #     #          *
        *                 #     #     #   #    #     #  #     #     #          *
        *           #     #     #     #    #   #     #  #     #     #          *
        *            #####      #     #     #  #######   #####      #          *
        *                                                                      *
        * STROUT                    ARRAY TO STRING                            *
        *                                                                      *
        ************************************************************************
        *
        * STROUT.lss
        *
        -LINE 16 "STROUT.lss"
        -MODULE STROUT
        -PUBLIC STRINGOUT()
4223             DEFINE('STRINGOUT(A,SEP)I')                    :(STRINGOUT_END)
        *
4224    STRINGOUT
4225             I = 1
4226             STRINGOUT = A<1>                                     :F(RETURN)
4227    STRINGOUT_1
4228             I = I + 1
4229             STRINGOUT = STRINGOUT SEP A<I>         :S(STRINGOUT_1)F(RETURN)
        *
4230    STRINGOUT_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SWAP.INC'
        -INCLUDE 'SYSLOG.INC'
        -LINE 10 "SYSLOG.lss"
        -INCLUDE 'FFI.INC'
        -INCLUDE 'UNIX.INC'
        -STITL SYSLOG
        -EJECT
        -LINE 108 "SYSLOG.lss"
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *          #####   #     #   #####   #        #######   #####          *
        *         #     #   #   #   #     #  #        #     #  #     #         *
        *         #          # #    #        #        #     #  #               *
        *          #####      #      #####   #        #     #  #  ####         *
        *               #     #           #  #        #     #  #     #         *
        *         #     #     #     #     #  #        #     #  #     #         *
        *          #####      #      #####   #######  #######   #####          *
        *                                                                      *
        * SYSLOG        INTERFACE TO OPENLOG/SYSLOG/CLOSELOG                   *
        *                                                                      *
        ************************************************************************
        *
        * SYSLOG.lss
        *
        -LINE 15 "SYSLOG.lss"
        -MODULE SYSLOG
4231             FFI_OPENLOG = FFI_NEW('V', 'P,I,I')
4232             FFI_SET_CALLP(FFI_OPENLOG, DLSYM(0, 'openlog'))
4233             FFI_SYSLOG = FFI_NEW('V', 'I,P,P')
4234             FFI_SET_CALLP(FFI_SYSLOG, DLSYM(0, 'syslog'))
4235             FFI_CLOSELOG = FFI_NEW('V', 'V')
4236             FFI_SET_CALLP(FFI_CLOSELOG, DLSYM(0, 'closelog'))
        *
        * PRIORITY
        *
        -PUBLIC LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING
        -PUBLIC LOG_NOTICE, LOG_INFO, LOG_DEBUG
4237             LOG_EMERG   = 0
4238             LOG_ALERT   = 1
4239             LOG_CRIT    = 2
4240             LOG_ERR     = 3
4241             LOG_WARNING = 4
4242             LOG_NOTICE  = 5
4243             LOG_INFO    = 6
4244             LOG_DEBUG   = 7
        *
        * FACILITY
        *
        -PUBLIC LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_SYSLOG
        -PUBLIC LOG_LPR, LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_AUTHPRIV, LOG_FTP
        -PUBLIC LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4
        -PUBLIC LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7
4245             LOG_KERN     =  0 * 8
4246             LOG_USER     =  1 * 8
4247             LOG_MAIL     =  2 * 8
4248             LOG_DAEMON   =  3 * 8
4249             LOG_AUTH     =  4 * 8
4250             LOG_SYSLOG   =  5 * 8
4251             LOG_LPR      =  6 * 8
4252             LOG_NEWS     =  7 * 8
4253             LOG_UUCP     =  8 * 8
4254             LOG_CRON     =  9 * 8
4255             LOG_AUTHPRIV = 10 * 8
4256             LOG_FTP      = 11 * 8
4257             LOG_LOCAL0   = 16 * 8
4258             LOG_LOCAL1   = 17 * 8
4259             LOG_LOCAL2   = 18 * 8
4260             LOG_LOCAL3   = 19 * 8
4261             LOG_LOCAL4   = 20 * 8
4262             LOG_LOCAL5   = 21 * 8
4263             LOG_LOCAL6   = 22 * 8
4264             LOG_LOCAL7   = 23 * 8
        *
        * OPTIONS
        *
        -PUBLIC LOG_PID, LOG_CONS, LOG_ODELAY, LOG_NDELAY, LOG_NOWAIT
        -PUBLIC LOG_PERROR
4265             LOG_PID    =  1
4266             LOG_CONS   =  2
4267             LOG_ODELAY =  4
4268             LOG_NDELAY =  8
4269             LOG_NOWAIT = 16
4270             LOG_PERROR = 32
        *
        -PUBLIC OPENLOG(), SYSLOG() CLOSELOG()
4271             DEFINE('OPENLOG(IDENT,OPTION,FACILITY)P')
4272             DEFINE('SYSLOG(PRIORITY,S)')
4273             DEFINE('CLOSELOG()')                           :(SYSLOG_FN_END)
        *
4274    OPENLOG  P = STRDUP(IDENT)
4275             FFI_PAR_N_PTR(FFI_OPENLOG, 1, P)
4276             FFI_PAR_N_INTEGER(FFI_OPENLOG, 2, OPTION)
4277             FFI_PAR_N_INTEGER(FFI_OPENLOG, 3, FACILITY)
4278             FFI_CALL_VOID(FFI_OPENLOG)                            :(RETURN)
        *
4279    SYSLOG   FFI_PAR_N_INTEGER(FFI_SYSLOG, 1, PRIORITY)
4280             FFI_PAR_N_STRING(FFI_SYSLOG, 2, '%s')
4281             FFI_PAR_N_STRING(FFI_SYSLOG, 3, S)
4282             FFI_CALL_VOID(FFI_SYSLOG)                             :(RETURN)
        *
4283    CLOSELOG FFI_CALL_VOID(FFI_CLOSELOG)                           :(RETURN)
        *
4284    SYSLOG_FN_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SYSTEM.INC'
        -INCLUDE 'TEST.INC'
        -LINE 16 "TEST.lss"
        -INCLUDE 'UNIQUE.INC'
        -STITL TEST
        -EJECT
        -LINE 46 "TEST.lss"
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                  #######  #######   #####   #######                  *
        *                     #     #        #     #     #                     *
        *                     #     #        #           #                     *
        *                     #     #####     #####      #                     *
        *                     #     #              #     #                     *
        *                     #     #        #     #     #                     *
        *                     #     #######   #####      #                     *
        *                                                                      *
        * TEST                                                                 *
        *                                                                      *
        ************************************************************************
        *
        * TEST.lss
        *
        -LINE 20 "TEST.lss"
        -MODULE TEST
        -PUBLIC TESTP()
4285             DEFINE('TESTP(ARG)NAME')                            :(TEST_END)
        *
4286    TESTP    IDENT(DATATYPE(ARG), 'EXPRESSION')                   :F(TEST_1)
4287             NAME = UNIQUE()
4288             $NAME = ARG
4289             TEST = EVAL("NULL $ *TEST('" NAME "')")               :(RETURN)
4290    TEST_1   TEST = ?EVAL($ARG) .TEST_                 :S(NRETURN)F(FRETURN)
        *
4291    TEST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TIMEGC.INC'
        -LINE 13 "TIMEGC.lss"
        -INCLUDE 'LINK.INC'
        -INCLUDE 'RESOL.INC'
        -INCLUDE 'SYSTEM.INC'
        -STITL TIMEGC
        -EJECT
        -LINE 70 "TIMEGC.lss"
        *
        ************************************************************************
        *                                                                      *
        *           #######  ###  #     #  #######   #####    #####            *
        *              #      #   ##   ##  #        #     #  #     #           *
        *              #      #   # # # #  #        #        #                 *
        *              #      #   #  #  #  #####    #  ####  #                 *
        *              #      #   #     #  #        #     #  #                 *
        *              #      #   #     #  #        #     #  #     #           *
        *              #     ###  #     #  #######   #####    #####            *
        *                                                                      *
        * TIMEGC                TIME GARBAGE COLLECT                           *
        *                                                                      *
        ************************************************************************
        *
        * TIMEGC.lss
        *
        -LINE 19 "TIMEGC.lss"
        -MODULE TIMEGC
        -PUBLIC TIMEGC()
4292             DEFINE('TIMEGC(N)I,S,A,L,T,K,FREED')              :(TIMEGC_END)
        *
4296    TIMEGC   I = ; S = ; A = ; L =
4297             COLLECT()
4298             N = IDENT(N) 25
4299             A = ARRAY(N)
4300    TIMEGC_1 I = I + 1
4301             $I = DUPL(' ', 78) I
4302             A<I> = DUPL('*', I)
4303             L = LINK(NULL, L)
4304             GE(I, N)                                           :F(TIMEGC_1)
4305             STREM = COLLECT()
4308    TIMEGC_2 $I = ; A<I> = ; L = NEXT(L)
4309             I = I - 2 GT(I, 2)                                 :S(TIMEGC_2)
4310             T = TIME()
4311             FREED = FREED + (COLLECT() - STREM)
4312             TIMEGC = TIMEGC + (TIME() - T)
4313             K = K + 1
4314             M = 50
4315             M = LT(RESOLUTION(), 0.9) 5000
4316             LT(TIMEGC, M * RESOLUTION())                         :S(TIMEGC)
4317             OUTPUT =
4318             OUTPUT = 'IN ' SYSTEM() ' ' K ' GARBAGE COLLECTS'
4318    +           ' REQUIRED A TOTAL OF ' TIMEGC ' MILLISECONDS TO FREE '
4318    +           FREED ' STORAGE UNITS.'
4319             TIMEGC = CONVERT(TIMEGC, 'REAL')
4320             OUTPUT = 'THIS AVERAGES TO ' (TIMEGC / K) ' MILLISECONDS PER'
4320    +           ' GARBAGE COLLECT AND ' (TIMEGC * 1000000 / FREED)
4320    +           ' NANOSECONDS PER STORAGE UNIT.'                   :(RETURN)
        *
4321    TIMEGC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TIME.INC'
        -INCLUDE 'TIMER.INC'
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'TRUNC.INC'
        -LINE 12 "TRUNC.lss"
        -INCLUDE 'SEQ.INC'
        -STITL TRUNC
        -EJECT
        -LINE 40 "TRUNC.lss"
        *
        ************************************************************************
        *                                                                      *
        *             #######  ######   #     #  #     #   #####               *
        *                #     #     #  #     #  ##    #  #     #              *
        *                #     #     #  #     #  # #   #  #                    *
        *                #     ######   #     #  #  #  #  #                    *
        *                #     #   #    #     #  #   # #  #                    *
        *                #     #    #   #     #  #    ##  #     #              *
        *                #     #     #   #####   #     #   #####               *
        *                                                                      *
        * TRUNC                     TRUNCATE ARRAY                             *
        *                                                                      *
        ************************************************************************
        *
        * TRUNC.lss
        *
        -LINE 16 "TRUNC.lss"
        -MODULE TRUNC
        -PUBLIC TRUNC()
4322             DEFINE('TRUNC(A,L,H)')                             :(TRUNC_END)
        *
4323    TRUNC    TRUNC = ARRAY(H - L + 1)
4324             L = L - 1
4325             SEQ(' TRUNC<I> = A<L + I> ',.I)                       :(RETURN)
        *
4326    TRUNC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'UNIQUE.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'UTF8.INC'
        -MODULE UTF8
        -STITL UTF8
        -EJECT
        -LINE 249 "UTF8.lss"
        *
        ************************************************************************
        *                                                                      *
        *                   #     #  #######  #######   ###                    *
        *                   #     #     #     #        #   #                   *
        *                   #     #     #     #        #   #                   *
        *                   #     #     #     #####     ###                    *
        *                   #     #     #     #        #   #                   *
        *                   #     #     #     #        #   #                   *
        *                    #####      #     #         ###                    *
        *                                                                      *
        * UTF8                                                                 *
        *                                                                      *
        ************************************************************************
        *
        * SNOBOL4 FUNCTIONS TO IMPLEMENT UTF-ENCODED UNICODE HANDLING
        * UTF8.lss
        *
        -LINE 12 "UTF8.lss"
        * PHIL BUDNE <PHIL@ULTIMATE.COM>
        * SEPTEMBER 1996
        * UPDATED FOR 4/5/6 BYTE RUNES JUNE 1997
        *
        * MOST OF THIS IS JUST AWFUL, BUT THIS IS JUST A PROOF OF CONCEPT,
        * AND LIKE ALL SNOBOL THERE IS ALWAYS A SMALLER, FASTER AND MORE
        * PERVERSE WAY TO DO ANYTHING.
        *
        * TODO
        *
        * UTFNOTANY
        * UTFSPAN
        * UTFBREAK
        * UTFBREAKX
        *
        * PATTERN TO MATCH ONE UTF ENCODED RUNE
        *
        * SNOBOL4 LACKS CHAR(), SPITBOL CHAR() LOSES ON CHAR(0)!
        *
4327             DEFINE("XCHAR(N)")                                    :(EXCHAR)
        *
4328    XCHAR    &ALPHABET ARB POS(N) LEN(1) . XCHAR        :S(RETURN)F(FRETURN)
        *
4329    EXCHAR
        *
        * HELPER FUNCTION TO PATTERN THAT MATCHES A RANGE OF BYTE VALUES.
        * THE TRUE SNO-HEAD MIGHT IMPLEMENT THIS AS A FUNCTION THAT TAKES
        * STRINGS OF SPAN('01') ARBNO('X') DIRECTLY!!
        *
4330             DEFINE("RANGE(START,END)")                            :(ERANGE)
        *
4331    RANGE
        *
        * SPITBOL COMPILES ANY() INTO A BITMAP;
4332             &ALPHABET ARB (XCHAR(START) ARB XCHAR(END)) . RANGE :F(FRETURN)
        * SPITBOL COMPILES TABLES ONCE
4333             RANGE = ANY(RANGE)                                    :(RETURN)
        * FOR SNOBOL4; CREATE BIG PATTERN
        *        GE(START, END)                                      :S(FRETURN)
        *        RANGE = XCHAR(START)
        *RANGE1  GE(STAT, END)                                        :S(RETURN)
        *        START = START + 1
        *        RANGE = RANGE | XCHAR(START)                          :(RANGE1)
        *
4334    ERANGE
        *
        * SINGLE BYTE:       0XXXXXXX  VALUES 0..0X7F
        *
4335             UTF.T1 = RANGE(0, 127)
        *
        * TWO-BYTE LEADER:   110XXXXX  VALUES 0X80..0X7FF
        *
4336             UTF.T2 = RANGE(192, 223)
        *
        * THREE-BYTE LEADER: 1110XXXX  VALUES 0X800..0XFFFF
        *
4337             UTF.T3 = RANGE(224, 239)
        *
        * FOUR-BYTE LEADER:  11110XXX  VALUES 0X10000..0X1FFFFF
        *
4338             UTF.T4 = RANGE(240, 247)
        *
        * FIVE-BYTE LEADER:  111110XX  VALUES 0X200000..0X3FFFFFF
        *
4339             UTF.T5 = RANGE(248, 251)
        *
        * FIVE-BYTE LEADER:  1111110X  VALUES 0X4000000..0X7FFFFFFF
        *
4340             UTF.T6 = RANGE(252, 253)
        *
        * SUBSEQUENT BYTE:   10XXXXXX
        *
4341             UTF.TX = RANGE(128, 191)
        *
4342             UTF.RUNE = FENCE
4342    +           (UTF.T1 |
4342    +            UTF.T2 UTF.TX |
4342    +            UTF.T3 UTF.TX UTF.TX |
4342    +            UTF.T4 UTF.TX UTF.TX UTF.TX |
4342    +            UTF.T5 UTF.TX UTF.TX UTF.TX UTF.TX |
4342    +            UTF.T6 UTF.TX UTF.TX UTF.TX UTF.TX UTF.TX)
        *
4343             UTF.RUNE0 = POS(0) UTF.RUNE
        *
        * PATTERN TO MOVE TO NEXY SYNC CHAR;
        *
        *        UTF.SYNC = BREAKX(UTF.T1 UTF.T2 UTF.T3 UTF.T4 UTF.T5 UTF.T6)
        *
        * UTF ANALOG OF ARB
        *
4344             UTFARB = ARBNO(UTF.RUNE)
        *
        * UTF ANALOG OF LEN
        *
4345             DEFINE("UTFLEN(N)")                                  :(EUTFLEN)
        *
4346    UTFLEN   LT(N, 0)                                             :(FRETURN)
4347             UTFLEN =
4348    UTFLEN2  EQ(N, 0)                                             :S(RETURN)
4349             UTFLEN = UTFLEN UTF.RUNE
4350             N = N - 1                                            :(UTFLEN2)
        *
4351    EUTFLEN
        *
        * UTF ANALOG FOR ANY(STR)
        *
4352             DEFINE("UTFANY(STR)R")                               :(EUTFANY)
        *
4353    UTFANY   STR UTF.RUNE0 . UTFANY =                            :F(FRETURN)
4354    UTFANY2  IDENT(STR)                                           :S(RETURN)
4355             STR UTF.RUNE0 . R =                                 :F(FRETURN)
4356             UTFANY = UTFANY | R                                  :(UTFANY2)
4357    EUTFANY
        *
        * UTF ANALOG FOR CHAR(N)
        *
4358             DEFINE("RUNE(N)")                                      :(ERUNE)
        *
4359    RUNE     LT(N, 0)                                            :S(FRETURN)
4360             GT(N, 127)                                            :S(RUNE2)
        * SINGLE BYTE RUNE
4361             RUNE = XCHAR(N)                                       :(RETURN)
4362    RUNE2    GT(N, 2047)                                           :S(RUNE3)
        * TWO-BYTE RUNE
4363             RUNE = XCHAR(192 + (N / 64))
4363    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * THREE-BYTE RUNE
4364    RUNE3    GT(N, 65535)                                          :S(RUNE4)
4365             RUNE = XCHAR(224 + N / 4096)
4365    +               XCHAR(128 + REMDR(N / 64, 64))
4365    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * FOUR-BYTE RUNE
4366    RUNE4    GT(N, 2097151)                                        :S(RUNE5)
4367             RUNE = XCHAR(240 + N / 262144)
4367    +               XCHAR(128 + REMDR(N / 65536, 64))
4367    +               XCHAR(128 + REMDR(N / 64, 64))
4367    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * FIVE-BYTE RUNE
4368    RUNE5    GT(N, 67108863)                                       :S(RUNE6)
4369             RUNE = XCHAR(248 + N / 16777216)
4369    +               XCHAR(128 + REMDR(N / 262144, 64))
4369    +               XCHAR(128 + REMDR(N / 4096, 64))
4369    +               XCHAR(128 + REMDR(N / 64, 64))
4369    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * SIX-BYTE RUNE
4370    RUNE6    GT(N, 2147483647)                                   :S(FRETURN)
4371             RUNE = XCHAR(252 + N / 1073741824)
4371    +               XCHAR(128 + REMDR(N / 16777216, 64))
4371    +               XCHAR(128 + REMDR(N / 262144, 64))
4371    +               XCHAR(128 + REMDR(N / 4096, 64))
4371    +               XCHAR(128 + REMDR(N / 64, 64))
4371    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        *
4372    ERUNE
        *
        * UTF ANALOG FOR SIZE(STR)
        *
4373             DEFINE("UTFSIZE(STR)")                              :(EUTFSIZE)
        *
4374    UTFSIZE  STR UTF.RUNE =                                      :F(UTFSIZ2)
4375             UTFSIZE = UTFSIZE + 1                                :(UTFSIZE)
4376    UTFSIZ2  IDENT(STR)                                 :S(RETURN)F(FRETURN)
        *
4377    EUTFSIZE
        *
        * UTF ANALOG FOR REPLACE()
        *
4378             DEFINE("UTFREPLACE(IN,FROM,TO)T,R1,R2")          :(EUTFREPLACE)
        *
4379    UTFREPLACE
4380             T = TABLE()
        * PEEL RUNES OFF INPUT AND OUTPUT LANGUAGES ONE AT A TIME
4381    UTFREP1  FROM UTF.RUNE0 . R1 =                               :F(UTFREP2)
4382             TO UTF.RUNE0 . R2 =                                 :F(UTFREP2)
4383             T<R1> = R2                                           :(UTFREP1)
        * BOTH INPUT AND OUTPUT LANGUAGES SHOULD NOW BE EMPTY
4384    UTFREP2  DIFFER(FROM)                                        :S(FRETURN)
4385             DIFFER(TO)                                          :S(FRETURN)
        * FREEZE TABLE FOR SNOBOL4+?
        * PEEL RUNES INPUT ONE AT A TIME, FEED THRU TABLE
4386             UTFREPLACE =
4387    UTFREP3  IN UTF.RUNE0 . R1 =                                 :F(UTFREP4)
4388             UTFREPLACE = UTFREPLACE (IDENT(T<R1>) R1, T<R1>)     :(UTFREP3)
4389    UTFREP4  IDENT(IN)                                  :S(RETURN)F(FRETURN)
        *
4390    EUTFREPLACE
        *
        ************************************************************************
        *
        * TESTS
        *
        *        &ANCHOR = 1
        *        S = "Hello World!!"
        *
        *        OUTPUT = UTFREPLACE(S,&UCASE "!",&LCASE "?")
        *
        *L       S UTF.RUNE $ OUTPUT =                                     :S(L)
        *
        *        "HELLO WORLD!" UTFARB . OUTPUT RPOS(0)
        *        "Hello World!" UTFARB UTFANY(&LCASE) . OUTPUT
        *        "Hello World!" UTFANY(&UCASE) . OUTPUT
        *
        *        OUTPUT = RUNE(0)
        *        OUTPUT = RUNE(127)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(128)
        *        OUTPUT = RUNE(255)
        *        OUTPUT = RUNE(2047)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(2048)
        *        OUTPUT = RUNE(65535)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(65536)
        *        OUTPUT = RUNE(2097151)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(2097152)
        *        OUTPUT = RUNE(67108863)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(67108864)
        *        OUTPUT = RUNE(2147483647)
        *
        *END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'VDIFFER.INC'
        -INCLUDE 'WRAPPER.INC'
        -MODULE WRAPPER
        -LINE 9 "WRAPPER.lss"
        -STITL WRAPPER
        -LINE 295 "WRAPPER.lss"
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #     #  ######      #     ######   ######   #######  ######      *
        *    #  #  #  #     #    # #    #     #  #     #  #        #     #     *
        *    #  #  #  #     #   #   #   #     #  #     #  #        #     #     *
        *    #  #  #  ######   #     #  ######   ######   #####    ######      *
        *    #  #  #  #   #    #######  #        #        #        #   #       *
        *    #  #  #  #    #   #     #  #        #        #        #    #      *
        *     ## ##   #     #  #     #  #        #        #######  #     #     *
        *                                                                      *
        * WRAPPER   CREATE C CODE TO WRAP A FUNCTION FOR LOAD()'ING            *
        *                                                                      *
        * PHIL BUDNE, DECEMBER, 2001                                           *
        *                                                                      *
        ************************************************************************
        *
        * WRAPPER.lss
        *
        * FMGW
        *
        *     STRING_FREE, FREE RETURNED STRING AFTER COPYING TO SNOBOL4
        *     STRING2, REQUIRES LEN PARAMETER, COPY FIXED LENGTH
        *     REMOVE HANDLE TYPE COMPLETELY
        *
        -LINE 12 "WRAPPER.lss"
4391             WPMAXSTR = 1024
4392             WPSTRTYPE = 'STRING'
4393             WPSTRFREE = 'STRING_FREE'
4394             WPSTRTYP2 = 'STRING2'
4395             WPINTTYPE = 'INTEGER'
4396             WPPTRTYPE = 'POINTER'
4397             WPLONGTYPE = 'LONG'
4398             WPREALTYPE = 'REAL'
4399             WPREDTYPE = 'PREDICATE'
4400             WPSPREDTYPE = 'SYSPRED'
4401             WPTYPES = WPLONGTYPE | WPINTTYPE | WPREALTYPE | WPSTRTYPE |
4401    +                  WPPTRTYPE
4402             WPRTYPES = WPTYPES | WPREDTYPE | WPSPREDTYPE | WPSTRFREE |
4402    +                   WPSTRTYP2 | ''
4403             WPNAME = ANY(&UCASE &LCASE '_')
4403    +                 SPAN(&UCASE &LCASE '0123456789_')
4404             WPEND = ANY(',)')
4405             WP4SP = '    '
4406             WP8SP = '	'
        *
        * WRAPPER_STARTFILE(OUTPUT_NAME)
        *
        * OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VAR FOR C FILE
        *
        -PUBLIC WRAPPER_STARTFILE()
4407             DEFINE('WRAPPER_STARTFILE(FN)')        :(WRAPPER_STARTFILE_END)
        *
4408    WRAPPER_STARTFILE
4409             $FN = '/* Generated by WRAPPER on ' DATE() ' */'
4410             $FN =
4411             $FN = '#include "config.h"'
4412             $FN = '#include "h.h"'
4413             $FN = '#include "snotypes.h"'
4414             $FN = '#include "macros.h"'
4415             $FN = '#include "load.h"'
4416             $FN = '#include "equ.h"'
4417             $FN = '#include <string.h>'
4418             $FN =                                                 :(RETURN)
        *
4419    WRAPPER_STARTFILE_END
        *
        -PUBLIC WRAPPER_COBOL()
4420             DEFINE('WRAPPER_COBOL(FN)')                :(WRAPPER_COBOL_END)
        *
4421    WRAPPER_COBOL
4422             $FN = '#include <libcob.h>'                           :(RETURN)
        *
4423    WRAPPER_COBOL_END
        *
        * WRAPPER_PROTO(PROTOTYPE,OUTPUT_NAME)
        *
        * PROTOTYPE:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
        *              C FUNCTION TO CALL IS THE LOWERCASE VERSION
        *              OF THE FUNCTION NAME.
        * OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
        *
        -PUBLIC WRAPPER_PROTO(), C_WRAPPER_PROTO(), COBOL_WRAPPER_PROTO()
        -PUBLIC SCHEME_WRAPPER_PROTO()
4424             DEFINE('WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
4425             DEFINE('C_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4425    +           'WRAPPER_PROTO')
4426             DEFINE('COBOL_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4426    +           'WRAPPER_PROTO')
4427             DEFINE('SCHEME_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4427    +           'WRAPPER_PROTO')                        :(WRAPPER_PROTO_END)
        *
4428    WRAPPER_PROTO
4429             $FN =
4430             $FN = '/* ' PROTO ' */'
4431             PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
4432             N = 0
4433             WPCOPY = 0
4434             TYPES = ARRAY('0:29')
4435             PROTO POS(0) ')' =                                  :S(WPEPARS)
4436    WPLOOP   PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
4437             TYPES<N> = TYPE                                       :F(WPERR)
4438             N = N + 1
4439             WPCOPY = IDENT(TYPE, WPSTRTYPE) WPCOPY + 1
4440             IDENT(C, ')')                              :S(WPEPARS)F(WPLOOP)
4441    WPERR    TERMINAL = 'ERROR IN PROTOTYPE: >' PROTO '<'         :(FRETURN)
4442    WPEPARS  PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
4443             I = 0
4444             $FN = NAME '( LA_ALIST ) LA_DCL'
4445             $FN = '{'
4446             EQ(WPCOPY, 0)                                      :S(WPNOSTRS)
        *
4447    WPLOOP2  IDENT(TYPES<I>, WPSTRTYPE)                          :F(WPNEXT2)
4448             $FN = WP4SP 'char arg' I '[' WPMAXSTR '];'
4449    WPNEXT2  I = I + 1
4450             LT(I, N)                                            :S(WPLOOP2)
        *
4451             I = 0
4452    WPCOPY                                           :($('WPCPY_' TYPES<I>))
4453    WPCPY_STRING
4454             $FN = WP4SP
4454    +              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
4455                                                                  :(WPNCOPY)
4456    WPCPY_LONG
4457    WPCPY_INTEGER
4458    WPCPY_REAL
4459    WPCPY_POINTER
4460    WPCPY_
4461    WPNCOPY  I = I + 1
4462             LT(I, N)                                             :S(WPCOPY)
        *
4463    WPNOSTRS CALL = REPLACE(NAME, &UCASE, &LCASE) '('
4464             I = 0
4465    WPCALL   GE(I, N)                                            :S(WPECALL)
4466             CALL = GT(I, 0) CALL ','                :($('WPARG_' TYPES<I>))
4467    WPARG_POINTER
4468             CALL = CALL '(void *)(long)LA_INT(' I ')'            :(WPNCALL)
4469    WPARG_LONG
4470             CALL = CALL '(long)LA_INT(' I ')'                    :(WPNCALL)
4471    WPARG_INTEGER
4472             CALL = CALL '(int)LA_INT(' I ')'                     :(WPNCALL)
4473    WPARG_REAL
4474             CALL = CALL '(double)LA_REAL(' I ')'                 :(WPNCALL)
4475    WPARG_STRING
4476             CALL = CALL 'arg' I
4477    WPNCALL  I = I + 1                                             :(WPCALL)
4478    WPECALL  CALL = CALL ')'                            :($('WPRET_' PROTO))
        *
4479    WPRET_STRING
4480             $FN = WP4SP 'RETSTR((char *)' CALL ');'               :(WPDONE)
4481    WPRET_STRING2
4482             $FN = WP4SP 'RETSTR2((char *)' CALL ',' LEN ');'      :(WPDONE)
4483    WPRET_STRING_FREE
4484             $FN = WP4SP 'RETSTR_FREE((char *)' CALL ');'          :(WPDONE)
4485    WPRET_POINTER
4486             $FN = WP4SP 'RETINT((long)' CALL ');'                 :(WPDONE)
4487    WPRET_LONG
4488             $FN = WP4SP 'RETINT((long)' CALL ');'                 :(WPDONE)
4489    WPRET_INTEGER
4490             $FN = WP4SP 'RETINT(' CALL ');'                       :(WPDONE)
4491    WPRET_REAL
4492             $FN = WP4SP 'RETREAL(' CALL ');'                      :(WPDONE)
4493    WPRET_PREDICATE
4494             $FN = WP4SP 'if (' CALL ')'
4495             $FN = WP8SP 'RETNULL;'
4496             $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
        * SYSTEM CALL (< 0 FOR FAILURE)
4497    WPRET_SYSPRED
4498             $FN = WP4SP 'if (' CALL ' >= 0)'
4499             $FN = WP8SP 'RETNULL;'
4500             $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
4501    WPRET_
4502             $FN = WP4SP CALL ';'
4503             $FN = WP4SP 'RETNULL;'
        * END OF FUNCTION
4504    WPDONE   $FN = '}'                                             :(RETURN)
        *
4505    WRAPPER_PROTO_END
        *
        * FWRAPPER
        *
        * MAKE WRAPPER FOR FORTRAN FUNCTION
        *
        * SIMILAR TO C WRAPPER, BUT:
        *
        *     - ALL PARAMETERS NEED TO BE COPIED
        *     - STRINGS ARE PASSED AS TWO PARAMETERS
        *     - STRING RETURN IS AN ADDED PARAMETER ON THE FRONT OF THE ARG
        *       LIST
        *
        * FWRAPPER_PROTO(PROTO,FN,LEN)
        *
        * PROTO:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
        *          FORTRAN FUNCTION TO CALL IS THE LOWERCASE VERSION
        *          OF THE FUNCTION NAME WITH _ APPENDED.
        * FN:      THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
        *
        -PUBLIC FWRAPPER_PROTO(), FORTRAN_WRAPPER_PROTO()
4506             DEFINE('FWRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
4507             DEFINE('FORTRAN_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4507    +           'FWRAPPER_PROTO')                      :(FWRAPPER_PROTO_END)
        *
4508    FWRAPPER_PROTO
4509             $FN =
4510             $FN = '/* FORTRAN ' PROTO ' */'
4511             PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
4512             N = 0
4513             TYPES = ARRAY('0:29')
4514             PROTO POS(0) ')' =                                 :S(FWPEPARS)
4515    FWPLOOP  PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
4516             TYPES<N> = TYPE                                       :F(WPERR)
4517             N = N + 1
4518             IDENT(C, ')')                            :S(FWPEPARS)F(FWPLOOP)
4519    FWPEPARS WPCOPY = N
4520             PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
4521             I = 0
4522             $FN = NAME '( LA_ALIST ) LA_DCL'
4523             $FN = '{'
4524             $FN = IDENT(PROTO, WPREALTYPE)
4524    +           WP4SP 'double ' REPLACE(NAME, &UCASE, &LCASE) '_();'
4525             $FN = IDENT(PROTO, WPSTRTYPE)
4525    +           WP4SP 'char result[' WPMAXSTR '];'
4526             EQ(WPCOPY, 0)                                     :S(FWPNOSTRS)
        *
4527    FWPLOOP2 $FN = IDENT(TYPES<I>, WPSTRTYPE)
4527    +           WP4SP 'char arg' I '[' WPMAXSTR '];'            :S(FWPNEXT2)
4528             $FN = IDENT(TYPES<I>, WPLONGTYPE)
4528    +           WP4SP 'long arg' I ';'                          :S(FWPNEXT2)
4529             $FN = IDENT(TYPES<I>, WPINTTYPE)
4529    +           WP4SP 'int arg' I ';'                           :S(FWPNEXT2)
4530             $FN = IDENT(TYPES<I>, WPREALTYPE)
4530    +           WP4SP 'double arg' I ';'                        :S(FWPNEXT2)
4531    FWPNEXT2 I = I + 1
4532             LT(I, N)                                           :S(FWPLOOP2)
        *
4533             I = 0
4534    FWPCOPY                                         :($('FWPCPY_' TYPES<I>))
4535    FWPCPY_STRING
4536             $FN = WP4SP
4536    +              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
4537                                                                 :(FWPNCOPY)
4538    FWPCPY_LONG
4539             $FN = WP4SP 'arg' I ' = (long)LA_INT(' I ');'       :(FWPNCOPY)
4540    FWPCPY_INTEGER
4541             $FN = WP4SP 'arg' I ' = (int)LA_INT(' I ');'        :(FWPNCOPY)
4542    FWPCPY_REAL
4543             $FN = WP4SP 'arg' I ' = (double)LA_REAL(' I ');'    :(FWPNCOPY)
4544    FWPCPY_
4545    FWPNCOPY I = I + 1
4546             LT(I, N)                                            :S(FWPCOPY)
        *
4547    FWPNOSTRS
4548             CALL = REPLACE(NAME, &UCASE, &LCASE) '_('
4549             I = 0
4550    FWPCALL  GE(I, N)                                           :S(FWPECALL)
4551             CALL = GT(I, 0) CALL ','               :($('FWPARG_' TYPES<I>))
4552    FWPARG_LONG
4553    FWPARG_INTEGER
4554    FWPARG_REAL
4555             CALL = CALL '&arg' I                                :(FWPNCALL)
4556    FWPARG_STRING
4557             CALL = CALL 'arg' I ', strlen(arg' I ')'
4558    FWPNCALL I = I + 1                                            :(FWPCALL)
4559    FWPECALL CALL = CALL ')'                           :($('FWPRET_' PROTO))
        *
4560    FWPRET_STRING
4561             LEN = 1024
4562    FWPRET_STRING2
4563             CALL '()' = '(result, sizeof result)'             :S(FWPRETST2)
4564             CALL '(' = '(result, sizeof result,'
4565    FWPRETST2
4566             CALL = CALL ', result'
4567             $FN = WP4SP 'RETSTR2((' CALL '), ' LEN ');'          :(FWPDONE)
4568    FWPRET_LONG
4569    FWPRET_INTEGER
4570             $FN = WP4SP 'RETINT(' CALL ');'                      :(FWPDONE)
4571    FWPRET_REAL
4572             $FN = WP4SP 'RETREAL(' CALL ');'                     :(FWPDONE)
4573    FWPRET_PREDICATE
4574             $FN = WP4SP 'if (' CALL ')'
4575             $FN = WP8SP 'RETNULL;'
4576             $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
        * SYSTEM CALL (< 0 FOR FAILURE)
4577    FWPRET_SYSPRED
4578             $FN = WP4SP 'if (' CALL ' >= 0)'
4579             $FN = WP8SP 'RETNULL;'
4580             $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
4581    FWPRET_
4582             $FN = WP4SP CALL ';'
4583             $FN = WP4SP 'RETNULL;'
        * END OF FUNCTION
4584    FWPDONE  $FN = '}'                                             :(RETURN)
        *
4585    FWRAPPER_PROTO_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'WRTFILE.INC'
        -INCLUDE 'XTERM.INC'
        -MODULE XTERM
        -INCLUDE 'SCOOP.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'DISPLAY.INC'
        -INCLUDE 'READLINE.INC'
        -INCLUDE 'FFI.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'P64.INC'
        -INCLUDE 'UNIQUE.INC'
        -INCLUDE 'DDT.INC'
        -IN72
        -STITL XTERM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *             #     #  #######  #######  ######   #     #              *
        *              #   #      #     #        #     #  ##   ##              *
        *               # #       #     #        #     #  # # # #              *
        *                #        #     #####    ######   #  #  #              *
        *               # #       #     #        #   #    #     #              *
        *              #   #      #     #        #    #   #     #              *
        *             #     #     #     #######  #     #  #     #              *
        *                                                                      *
        * XTERM                     XTERM TERMINAL                             *
        *                                                                      *
        ************************************************************************
        *
        * LAUNCH XTERM AS AN EXTERNAL TERMINAL FOR APPLICATIONS. THIS CAN
        * PROVIDE TEXT AND TEK 4014 GRAPHICS. AS WELL, THE READLINE LIBRARY
        * CAN USE THE XTERM TERMINAL.
        *
        * -xrm 'XTerm.vt100.initialFont: 6'
        *
        -PUBLIC CLASS:XTERM_CLASS
        *
4586             XTERM_CLASS = SEND(CLASS, 'NEW_CLASS', 'XTERM_CLASS')
4587             DEFINE('XTERM_INIT(OPTIONS)')
        *
        -PUBLIC XTERM_CLASS:'INIT'
        *
4588             SEND(XTERM_CLASS, 'ADD_METHOD', 'INIT', 'XTERM_INIT')
        *
        -PUBLIC FDOPEN()
        *
4589             FFI_FDOPEN = FFI_NEW('P', 'I,P')
4590             FFI_SET_CALLP(FFI_FDOPEN, DLSYM(0, 'fdopen'))
4591             DEFINE('FDOPEN(FD,MODE)')
        *
        -PUBLIC XTERM_CLASS:'CLOSE'
        *
4592             DEFINE('XTERM_CLOSE()E')
4593             SEND(XTERM_CLASS, 'ADD_METHOD', 'CLOSE', 'XTERM_CLOSE')
        *
        -PUBLIC XTERM_CLASS:'GET_XTERM'
        *
4594             SEND(XTERM_CLASS, 'ADD_METHOD', 'GET_XTERM', CODE(
4594    +           ' SEND = |.XTERM :(RETURN)'))
        *
        -PUBLIC XTERM_CLASS:'PREP_READLINE'
        *
4595             DEFINE('XTERM_READLINE()')
4596             SEND(XTERM_CLASS, 'ADD_METHOD',
4596    +           'PREP_READLINE', 'XTERM_READLINE')
        *
        -PUBLIC XTERM_CLASS:'NO_READLINE'
        *
4597             DEFINE('XTERM_NOREADLINE()')
4598             SEND(XTERM_CLASS, 'ADD_METHOD',
4598    +           'NO_READLINE', 'XTERM_NOREADLINE')              :(XTERM_END)
        *
4599    XTERM_INIT
4600             XTERM_INIT = SUPER('INIT')
4601             |.RL_INSTREAM = DLSYM(0, 'rl_instream')
4602             |.RL_OUTSTREAM = DLSYM(0, 'rl_outstream')
4603             |.OLD_RL_INSTREAM = PEEK_P(|.RL_INSTREAM)
4604             |.OLD_RL_OUTSTREAM = PEEK_P(|.RL_OUTSTREAM)
4605             |.UNIT = IO_FINDUNIT()
4606             |.XTERM = UNIQUE()
4607             INPUT(|.XTERM, |.UNIT, 'U',
4607    +           '|/usr/bin/xterm -Sxx0 ' OPTIONS ' 2>/dev/null')
4608             OUTPUT(|.XTERM, |.UNIT, 'W,T')
4609             |.ID = $|.XTERM
4610             TERMINAL = |.ID                                       :(RETURN)
        *
4611    FDOPEN   FFI_PAR_N_INTEGER(FFI_FDOPEN, 1, FD)
4612             FFI_PAR_N_STRING(FFI_FDOPEN, 2, MODE)
4613             FDOPEN = FFI_CALL_PTR(FFI_FDOPEN)                     :(RETURN)
        *
        * PREPARE XTERM FOR READLINE/EDITLINE
        *
4614    XTERM_READLINE
4615             |.FILEH = IDENT(|.FILEH)
4615    +           FDOPEN(FILENO(IO_GETFP(|.UNIT)), 'r+')
4616             POKE_P(|.RL_INSTREAM, |.FILEH)
4617             POKE_P(|.RL_OUTSTREAM, |.FILEH)                       :(RETURN)
        *
4618    XTERM_NOREADLINE
4619             POKE_P(|.RL_INSTREAM, |.OLD_RL_INSTREAM)
4620             POKE_P(|.RL_OUTSTREAM, |.OLD_RL_OUTSTREAM)            :(RETURN)
        *
4621    XTERM_CLOSE
4622             HOST(HOST_SYSCMD, '/usr/bin/xkill -id 0x' |.ID ' >/dev/null')
4623             E = &ERRLIMIT
4624             &ERRLIMIT = 1
4625             ENDFILE(|.UNIT)
4626             DETACH(|.XTERM)
4627             &ERRLIMIT = E                                         :(RETURN)
        *
4628    XTERM_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 189 "ALL.lss"
        -STITL ALL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #     #        #                             *
        *                        # #    #        #                             *
        *                       #   #   #        #                             *
        *                      #     #  #        #                             *
        *                      #######  #        #                             *
        *                      #     #  #        #                             *
        *                      #     #  #######  #######                       *
        *                                                                      *
        *                                                                      *
        * ALL                      INCLUDE ALL                                 *
        *                                                                      *
        ************************************************************************
        *
        * ALL.lss
        *
        * CE: .MSNOBOL4;
        -MODULE ENDCARD
        -LINE 8 "ENDCARD.lss"
        -IN72
        -LINE 26 "ENDCARD.lss"
        -STITL ENDCARD
        -EJECT
        ************************************************************************
        *                                                                      *
        *    #######  #     #  ######    #####      #     ######   ######      *
        *    #        ##    #  #     #  #     #    # #    #     #  #     #     *
        *    #        # #   #  #     #  #         #   #   #     #  #     #     *
        *    #####    #  #  #  #     #  #        #     #  ######   #     #     *
        *    #        #   # #  #     #  #        #######  #   #    #     #     *
        *    #        #    ##  #     #  #     #  #     #  #    #   #     #     *
        *    #######  #     #  ######    #####   #     #  #     #  ######      *
        *                                                                      *
        * ENDCARD      AN END CARD FOR USE WITH -M (MULTI-FILE)                *
        *                                                                      *
        ************************************************************************
        *
        * ENDCARD.lss
        *
        * CE: .MSNOBOL4;
        *
        -LINE 11 "ENDCARD.lss"
4629    END
