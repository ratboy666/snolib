        -MODULE ALL
        -LINE 60 "ALL.lss"
        -INCLUDE 'AGT.INC'
        -MODULE AGT
        -LINE 13 "AGT.lss"
        -IN72
        -LINE 42 "AGT.lss"
        -STITL AGT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #      #####   #######                       *
        *                        # #    #     #     #                          *
        *                       #   #   #           #                          *
        *                      #     #  #  ####     #                          *
        *                      #######  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #   #####      #                          *
        *                                                                      *
        * AGT        ALPHABETIC COMPARISION WITH UPPER AND LOWER EQUAL         *
        *                                                                      *
        ************************************************************************
        *
        * AGT.lss
        *
        -LINE 16 "AGT.lss"
        -PUBLIC AGT()
        *
1                DEFINE('AGT(S1,S2)')
2                AGT_TT = REPLACE(&ALPHABET, &UCASE, &LCASE)          :(AGT_END)
        *
3       AGT      LGT(REPLACE(S1, &ALPHABET, AGT_TT),
3       +            REPLACE(S2, &ALPHABET, AGT_TT))        :S(RETURN)F(FRETURN)
        *
4       AGT_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'AI.INC'
        -MODULE AI
        -LINE 18 "AI.lss"
        -INCLUDE 'SEQ.INC'
        -MODULE SEQ
        -LINE 34 "SEQ.lss"
        -IN72
        -LINE 64 "SEQ.lss"
        -STITL SEQ
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       #####   #######   #####                        *
        *                      #     #  #        #     #                       *
        *                      #        #        #     #                       *
        *                       #####   #####    #     #                       *
        *                            #  #        #   # #                       *
        *                      #     #  #        #    #                        *
        *                       #####   #######   #### #                       *
        *                                                                      *
        * SEQ                SEQUENCE STATEMENT WITH COUNTER                   *
        *                                                                      *
        ************************************************************************
        *
        * SEQ.lss
        *
        -LINE 37 "SEQ.lss"
        -PUBLIC SEQ()
        *
5                DEFINE('SEQ(ARG_S,ARG_NAME,START,END)')              :(SEQ_END)
        *
6       SEQ      START = IDENT(START) 1
7                $ARG_NAME = START - 1
8                ARG_S = CODE(ARG_S  ' :S(SEQ_1)F(SEQ_2)')             :F(ERROR)
9       SEQ_1    DIFFER(END) GE($ARG_NAME, END)                       :S(RETURN)
10               $ARG_NAME = $ARG_NAME + 1                              :<ARG_S>
11      SEQ_2    EQ($ARG_NAME, START)                       :S(FRETURN)F(RETURN)
        *
12      SEQ_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 56 "AI.lss"
        -STITL AI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                #     ###                             *
        *                               # #     #                              *
        *                              #   #    #                              *
        *                             #     #   #                              *
        *                             #######   #                              *
        *                             #     #   #                              *
        *                             #     #  ###                             *
        *                                                                      *
        * AI                          APPLY INDEX                              *
        *                                                                      *
        ************************************************************************
        *
        * AI.lss
        *
        -LINE 22 "AI.lss"
        -PUBLIC AI()
        *
13               DEFINE('AI(A,I)J')                                    :(AI_END)
        *
14      AI       IDENT(DATATYPE(I), 'ARRAY')                            :F(AI_1)
15               AI = ARRAY(PROTOTYPE(I))
16               SEQ(' AI<J> = A<I<J>> ', .J)                          :(RETURN)
17      AI_1     AI = A<I>                                  :S(RETURN)F(FRETURN)
        *
18      AI_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'AOPA.INC'
        -MODULE AOPA
        -LINE 16 "AOPA.lss"
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 72 "AOPA.lss"
        -STITL AOPA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #     #######  ######      #                      *
        *                   # #    #     #  #     #    # #                     *
        *                  #   #   #     #  #     #   #   #                    *
        *                 #     #  #     #  ######   #     #                   *
        *                 #######  #     #  #        #######                   *
        *                 #     #  #     #  #        #     #                   *
        *                 #     #  #######  #        #     #                   *
        *                                                                      *
        * AOPA                 APPLY OPERATOR TO ARRAY                         *
        *                                                                      *
        ************************************************************************
        *
        * AOPA.lss
        *
        -LINE 20 "AOPA.lss"
        -PUBLIC AOPA()
        *
19               DEFINE('AOPA(A1,OP,A2)S1,I,S2,S')                   :(AOPA_END)
        *
20      AOPA     IDENT(DATATYPE(A1), 'ARRAY')                         :S(AOPA_1)
21               IDENT(DATATYPE(A2), 'ARRAY')                         :S(AOPA_2)
22               AOPA = EVAL('A1 ' OP ' A2')                           :(RETURN)
23      AOPA_1   S1 = '<I>'
24               S2 = IDENT(DATATYPE(A2), 'ARRAY')  '<I>'
25               AOPA = ARRAY(PROTOTYPE(A1))                      :(AOPA_COMMON)
26      AOPA_2   S2 = '<I>'
27               AOPA = ARRAY(PROTOTYPE(A2))
28      AOPA_COMMON
29               S = ' AOPA<I> = A1' S1 ' ' OP ' A2' S2
30               SEQ(S, .I)                                            :(RETURN)
        *
31      AOPA_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'APPENDA.INC'
        -MODULE APPENDA
        -LINE 12 "APPENDA.lss"
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'SIZEA.INC'
        -MODULE SIZEA
        -IN72
        -LINE 13 "SIZEA.lss"
        -INCLUDE 'ARRAY0.INC'
        -MODULE ARRAY0
        -LINE 11 "ARRAY0.lss"
        -INCLUDE 'SYSTEM.INC'
        -MODULE SYSTEM
        -IN72
        -LINE 49 "SYSTEM.lss"
        -LINE 129 "SYSTEM.lss"
        -STITL SYSTEM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *          #####   #     #   #####   #######  #######  #     #         *
        *         #     #   #   #   #     #     #     #        ##   ##         *
        *         #          # #    #           #     #        # # # #         *
        *          #####      #      #####      #     #####    #  #  #         *
        *               #     #           #     #     #        #     #         *
        *         #     #     #     #     #     #     #        #     #         *
        *          #####      #      #####      #     #######  #     #         *
        *                                                                      *
        * SYSTEM            DETERMINE KIND OF SNOBOL4                          *
        *                                                                      *
        ************************************************************************
        *
        * SYSTEM.lss
        *
        -LINE 52 "SYSTEM.lss"
        -PUBLIC SYSTEM(), ISSPITBOL(), ISSNOBOL4()
        -PUBLIC ISASCII(), ISEBCDIC(), ISCDC_DISPLAY_CODE()
        *
32               DEFINE('SYSTEM()K,E,T')
33               DEFINE('ISSPITBOL()')
34               DEFINE('ISSNOBOL4()')
35               DEFINE('ISASCII()A')
36               DEFINE('ISEBCDIC()A')
37               DEFINE('ISCDC_DISPLAY_CODE()A')                   :(SYSTEM_END)
        *
38      ISASCII  A = &ANCHOR
39               &ANCHOR = 0
40               &ALPHABET '()'                          :S(ISASCII1)F(ISASCII2)
41      ISASCII1 &ANCHOR = A                                           :(RETURN)
42      ISASCII2 &ANCHOR = A                                          :(FRETURN)
        *
        * OR, TRY LLT('A',1)
43      ISEBCDIC A = &ANCHOR
44               &ANCHOR = 0
45               &ALPHABET '(+'                          :S(ISASCII1)F(ISASCII2)
        *
46      ISCDC_DISPLAY_CODE
47               A = &ANCHOR
48               &ANCHOR = 0
49               &ALPHABET ')*'                          :S(ISASCII1)F(ISASCII2)
        *
50      ISSPITBOL
51               DIFFER(.NAME, 'NAME')                      :S(RETURN)F(FRETURN)
        *
52      ISSNOBOL4
53               IDENT(.NAME, 'NAME')                       :S(RETURN)F(FRETURN)
        *
54      SYSTEM   IDENT(DATATYPE(.X), 'STRING')                      :F(SYSTEM_2)
55               K = SIZE(&ALPHABET)
56               SYSTEM = EQ(K,512) 'HONEYWELL MAINBOL'               :S(RETURN)
57               SYSTEM = EQ(K,256) 'IBM MAINBOL'                   :S(SYSTEM_0)
58               SYSTEM = EQ(K,128) 'PDP-10 MAINBOL'                  :S(RETURN)
59               SYSTEM =           'CDC MAINBOL'
60               ISASCII()                                          :S(SYSTEM_1)
61               SYSTEM =           'UNIVAC MAINBOL'                   :(RETURN)
        *
        * DISTINGUISH IBM MAINBOL AND CSNOBOL, ASSUME ASCII FOR CSNOBOL4.
        * IBM MAINBOL RUNS ON SYSTEM/360, WHICH IS EBCDIC.
        *
        * AFTER 1.5 (VERSION 1.5+), CSNOBOL4 SUPPORTS BLOCKS WITH THE
        * -B COMMAND LINE SWITCH AND -BLOCKS/-NOBLOCKS
        *
62      SYSTEM_0 ISASCII()                                          :F(SYSTEM_1)
63               SYSTEM = 'CSNOBOL4 MAINBOL'
        *
64      SYSTEM_1 E = &ERRLIMIT
65               &ERRLIMIT = 1
66               T = DATATYPE(1 # 1)
67               &ERRLIMIT = E
68               DIFFER(T, 'BLOCK')                                   :S(RETURN)
69               SYSTEM = SYSTEM ' WITH BLOCKS'                        :(RETURN)
        *
70      SYSTEM_2 SYSTEM = DIFFER(SUBSTR('ABC', 2, 1), 'B') 'FASBOL'   :S(RETURN)
71               SYSTEM = EQ(SIZE(&ALPHABET), 128)         'SITBOL'   :S(RETURN)
72               SYSTEM =                                  'SPITBOL'   :(RETURN)
        *
73      SYSTEM_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 35 "ARRAY0.lss"
        -STITL ARRAY0
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *            #     ######   ######      #     #     #   ####           *
        *           # #    #     #  #     #    # #     #   #   #   ##          *
        *          #   #   #     #  #     #   #   #     # #    #  # #          *
        *         #     #  ######   ######   #     #     #     # #  #          *
        *         #######  #   #    #   #    #######     #     ##   #          *
        *         #     #  #    #   #    #   #     #     #     #    #          *
        *         #     #  #     #  #     #  #     #     #      ####           *
        *                                                                      *
        * ARRAY0                      ARRAY OF SIZE 0                          *
        *                                                                      *
        ************************************************************************
        *
        * ARRAY0.lss
        *
        -LINE 15 "ARRAY0.lss"
        -PUBLIC ARRAY0
        *
74               ARRAY0 = ARRAY('-10000:-10000')
75               ARRAY0 = ?(SYSTEM() ? 'CSNOBOL4') ARRAY('0:-1')
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'BRKREM.INC'
        -MODULE BRKREM
        -LINE 11 "BRKREM.lss"
        -INCLUDE 'SDIFF.INC'
        -MODULE SDIFF
        -LINE 10 "SDIFF.lss"
        -IN72
        -LINE 38 "SDIFF.lss"
        -STITL SDIFF
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                #####   ######   ###  #######  #######                *
        *               #     #  #     #   #   #        #                      *
        *               #        #     #   #   #        #                      *
        *                #####   #     #   #   #####    #####                  *
        *                     #  #     #   #   #        #                      *
        *               #     #  #     #   #   #        #                      *
        *                #####   ######   ###  #        #                      *
        *                                                                      *
        * SDIFF                     SET DIFFERENCE                             *
        *                                                                      *
        ************************************************************************
        *
        * SDIFF.lss
        *
        -LINE 13 "SDIFF.lss"
        -PUBLIC SDIFF()
        *
76               DEFINE('SDIFF(S1,S2)')                             :(SDIFF_END)
        *
77      SDIFF    SDIFF = S1
78               IDENT(S2, NULL)                                      :S(RETURN)
79               S2 = SPAN(S2)
80      SDIFF_1  SDIFF S2 =                                 :S(SDIFF_1)F(RETURN)
        *
81      SDIFF_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 41 "BRKREM.lss"
        -STITL BRKREM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *         ######   ######   #    #  ######   #######  #     #          *
        *         #     #  #     #  #   #   #     #  #        ##   ##          *
        *         #     #  #     #  #  #    #     #  #        # # # #          *
        *         ######   ######   ###     ######   #####    #  #  #          *
        *         #     #  #   #    #  #    #   #    #        #     #          *
        *         #     #  #    #   #   #   #    #   #        #     #          *
        *         ######   #     #  #    #  #     #  #######  #     #          *
        *                                                                      *
        * BRKREM                   BREAK(S) OR REM                             *
        *                                                                      *
        ************************************************************************
        *
        * BRKREM.lss
        *
        -LINE 15 "BRKREM.lss"
        -PUBLIC BRKREM()
        *
82               DEFINE('BRKREM(S)CS')                             :(BRKREM_END)
        *
83      BRKREM   BRKREM = IDENT(S) REM                                :S(RETURN)
84               CS = SDIFF(&ALPHABET, S)
85               IDENT(CS)                                            :S(RETURN)
86               BRKREM = RPOS(0) | SPAN(CS) RPOS(0) | BREAK(S)
87                                                                     :(RETURN)
        *
88      BRKREM_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'LOWA.INC'
        -MODULE LOWA
        -IN72
        -LINE 10 "LOWA.lss"
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'BRKREM.INC'
        -LINE 44 "LOWA.lss"
        -STITL LOWA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  #        #######  #     #     #                     *
        *                  #        #     #  #  #  #    # #                    *
        *                  #        #     #  #  #  #   #   #                   *
        *                  #        #     #  #  #  #  #     #                  *
        *                  #        #     #  #  #  #  #######                  *
        *                  #        #     #  #  #  #  #     #                  *
        *                  #######  #######   ## ##   #     #                  *
        *                                                                      *
        * LOWA                       LOW INDEX OF ARRAY                        *
        *                                                                      *
        ************************************************************************
        *
        * LOWA.lss
        *
        -LINE 15 "LOWA.lss"
        -PUBLIC LOWA()
        *
89               DEFINE('LOWA(A)L,U')                                :(LOWA_END)
        *
90      LOWA     LOWA = IDENT(A) 0                                    :S(RETURN)
91               LOWA = IDENT(A, ARRAY0) 0                            :S(RETURN)
92               IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
93               PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
94               IDENT(L)                                            :S(FRETURN)
95               LOWA = L
96               LOWA = IDENT(U) 1                                     :(RETURN)
        *
97      LOWA_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'SWAP.INC'
        -STITL SWAP
        -EJECT
        *
        -LINE 37 "SWAP.lss"
        ************************************************************************
        *                                                                      *
        *                   #####   #     #     #     ######                   *
        *                  #     #  #  #  #    # #    #     #                  *
        *                  #        #  #  #   #   #   #     #                  *
        *                   #####   #  #  #  #     #  ######                   *
        *                        #  #  #  #  #######  #                        *
        *                  #     #  #  #  #  #     #  #                        *
        *                   #####    ## ##   #     #  #                        *
        *                                                                      *
        * SWAP                    SWAP TWO VARIABLES                           *
        *                                                                      *
        ************************************************************************
        *
        * SWAP.lss
        *
        -LINE 12 "SWAP.lss"
        -MODULE SWAP
        -PUBLIC SWAP()
98               DEFINE('SWAP(SWAP_ARG1,SWAP_ARG2)')                 :(SWAP_END)
        *
99      SWAP     SWAP = $SWAP_ARG1
100              $SWAP_ARG1 = $SWAP_ARG2
101              $SWAP_ARG2 = SWAP
102              SWAP =                                                :(RETURN)
        *
103     SWAP_END
        *
        * CE: .MSNOBOL4;
        -LINE 65 "SIZEA.lss"
        -STITL SIZEA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #####   ###  #######  #######     #                  *
        *                #     #   #        #   #          # #                 *
        *                #         #       #    #         #   #                *
        *                 #####    #     #      #####    #     #               *
        *                      #   #    #       #        #######               *
        *                #     #   #   #        #        #     #               *
        *                 #####   ###  #######  #######  #     #               *
        *                                                                      *
        * SIZEA                       SIZE OF ARRAY                            *
        *                                                                      *
        ************************************************************************
        *
        * SIZEA.lss
        *
        -LINE 20 "SIZEA.lss"
        -PUBLIC SIZEA()
        *
104              DEFINE('SIZEA(A)L,U')                              :(SIZEA_END)
        *
105     SIZEA    SIZEA = IDENT(A) 0                                   :S(RETURN)
106              SIZEA = IDENT(A, ARRAY0) 0                           :S(RETURN)
107              IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
108              L =
109              U =
110              PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
111              IDENT(L)                                            :S(FRETURN)
112              U = IDENT(U) 1                                      :F(SIZEA_2)
113              SWAP(.L, .U)
114     SIZEA_2  SIZEA = LT(U, L) 0                                   :S(RETURN)
115              SIZEA = U - L + 1                                     :(RETURN)
        *
116     SIZEA_END
        *
        * CE: .F.MSNOBOL4;
        -IN72
        -LINE 41 "APPENDA.lss"
        -STITL AI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *       #     ######   ######   #######  #     #  ######      #        *
        *      # #    #     #  #     #  #        ##    #  #     #    # #       *
        *     #   #   #     #  #     #  #        # #   #  #     #   #   #      *
        *    #     #  ######   ######   #####    #  #  #  #     #  #     #     *
        *    #######  #        #        #        #   # #  #     #  #######     *
        *    #     #  #        #        #        #    ##  #     #  #     #     *
        *    #     #  #        #        #######  #     #  ######   #     #     *
        *                                                                      *
        * APPENDA              APPEND ELEMENT TO ARRRAY                        *
        *                                                                      *
        ************************************************************************
        *
        * APPENDA.lss
        *
        -LINE 17 "APPENDA.lss"
        -PUBLIC APPENDA()
        *
117              DEFINE('APPENDA(A,V)I')                          :(END_APPENDA)
        *
118     APPENDA  APPENDA = ARRAY(SIZEA(A) + 1)
119              SEQ(' APPENDA<I> = A<I>', .I)
120              APPENDA<I> = V                                        :(RETURN)
        *
121     END_APPENDA
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'ASM.INC'
        -MODULE ASM
        -INCLUDE 'JIT.INC'
        -MODULE JIT
        -LINE 15 "JIT.lss"
        -INCLUDE 'CRACK.INC'
        -MODULE CRACK
        -LINE 16 "CRACK.lss"
        -INCLUDE 'COUNT.INC'
        -MODULE COUNT
        -LINE 8 "COUNT.lss"
        -IN72
        -LINE 38 "COUNT.lss"
        -STITL COUNT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #####   #######  #     #  #     #  #######             *
        *              #     #  #     #  #     #  ##    #     #                *
        *              #        #     #  #     #  # #   #     #                *
        *              #        #     #  #     #  #  #  #     #                *
        *              #        #     #  #     #  #   # #     #                *
        *              #     #  #     #  #     #  #    ##     #                *
        *               #####   #######   #####   #     #     #                *
        *                                                                      *
        * COUNT              COUNT STRING OCCURRENCES                          *
        *                                                                      *
        * COUNT(S1,S2) COUNTS THE NUMBER OF OCCURRENCES OF STRING S2 IN STRING *
        * S1.                                                                  *
        *                                                                      *
        ************************************************************************
        *
        * COUNT.lss
        *
        -LINE 11 "COUNT.lss"
        -PUBLIC COUNT()
        *
122              DEFINE('COUNT(S1,S2)FIRST,REST,P')                 :(COUNT_END)
        *
123     COUNT    COUNT = 0
124              S2 LEN(1) . FIRST REM . REST                         :F(RETURN)
125              P = POS(0) BREAKX(FIRST) S2
126     COUNT_1  S1 P = REST                                          :F(RETURN)
127              COUNT = COUNT + 1                                    :(COUNT_1)
        *
128     COUNT_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 63 "CRACK.lss"
        -STITL CRACK
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #####   ######      #      #####   #    #              *
        *              #     #  #     #    # #    #     #  #   #               *
        *              #        #     #   #   #   #        #  #                *
        *              #        ######   #     #  #        ###                 *
        *              #        #   #    #######  #        #  #                *
        *              #     #  #    #   #     #  #     #  #   #               *
        *               #####   #     #  #     #   #####   #    #              *
        *                                                                      *
        * CRACK                    STRING TO ARRAY                             *
        *                                                                      *
        ************************************************************************
        *
        * CRACK.lss
        *
        -LINE 20 "CRACK.lss"
        -PUBLIC CRACK(), %1
        *
129              DEFINE('CRACK_1(S)P')
130              DEFINE('CRACK(S,B,F)I,PAT,N')
131              DEFINE('CRACK_4(S)')
132              OPSYN('%', 'CRACK_1', 1)                           :(CRACK_END)
        *
133     CRACK_1  P = IDENT(P) ','
134              CRACK_1 = CRACK(S, P)                                 :(RETURN)
        *
135     CRACK    F = IDENT(F) 'CRACK_4'
136              IDENT(B, NULL)                                      :S(CRACK_3)
137              S RTAB(1) B ABORT | REM . S = S B
138              N = COUNT(S, B)
139              EQ(N, 0)                                             :S(RETURN)
140              CRACK = ARRAY(N)
141              PAT = BREAK(B) . *CRACK<I> LEN(1)
142     CRACK_2  I = I + 1
143              S PAT =                                              :F(RETURN)
144              CRACK<I> = APPLY(F, CRACK<I>)             :S(CRACK_2)F(FRETURN)
145     CRACK_3  N = SIZE(S)
146              EQ(N, 0)                                             :S(RETURN)
147              CRACK = ARRAY(N)
148              PAT = LEN(1) . *CRACK<I>                             :(CRACK_2)
        *
149     CRACK_4  CRACK_4 = S                                           :(RETURN)
        *
150     CRACK_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SEQ.INC'
        -IN1024
        -LINE 1309 "JIT.lss"
        -STITL JIT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                              #  ###  #######                         *
        *                              #   #      #                            *
        *                              #   #      #                            *
        *                              #   #      #                            *
        *                        #     #   #      #                            *
        *                        #     #   #      #                            *
        *                         #####   ###     #                            *
        *                                                                      *
        * JIT                JUST-IN-TIME CODE GENERATION                      *
        *                                                                      *
        ************************************************************************
        *
        * QMUL/QDIV NOT YET SUPPORTED
        *
        * JIT.lss
        *
        -LINE 20 "JIT.lss"
        -CASE 1
        -PLUSOPS 1
        -LINE 23 "JIT.lss"
        -LINE 24 "JIT.lss"
        -LINE 25 "JIT.lss"
        -LINE 26 "JIT.lss"
        -LINE 27 "JIT.lss"
        -LINE 30 "JIT.lss"
151              JIT = 'jit.c'
        -LINE 577 "JIT.lss"
        -LINE 578 "JIT.lss"
        -LINE 579 "JIT.lss"
        -LINE 580 "JIT.lss"
        -LINE 581 "JIT.lss"
        -LINE 582 "JIT.lss"
        -LINE 585 "JIT.lss"
        *
        -PUBLIC INIT_JIT(), FINISH_JIT(), JIT_GET_STATE(), JIT_SET_STATE()
        *
152              LOAD('INIT_JIT(STRING)', 'jit.so')
153              LOAD('FINISH_JIT()', 'jit.so')
154              LOAD('JIT_GET_STATE()INTEGER', 'jit.so')
155              LOAD('JIT_SET_STATE(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_NEW_STATE(), JIT_DESTROY_STATE(), JIT_CLEAR_STATE()
        *
156              LOAD('JIT_NEW_STATE()INTEGER', 'jit.so')
157              LOAD('JIT_DESTROY_STATE()', 'jit.so')
158              LOAD('JIT_CLEAR_STATE()', 'jit.so')
        *
        -PUBLIC JIT_PROLOG(), JIT_EPILOG(), JIT_NOTE(), JIT_NAME()
        *
159              LOAD('JIT_PROLOG()', 'jit.so')
160              LOAD('JIT_EPILOG()', 'jit.so')
161              LOAD('JIT_NOTE(STRING,INTEGER)INTEGER', 'jit.so')
162              LOAD('JIT_NAME(STRING)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDRESS(), JIT_DISASSEMBLE(), JIT_EMIT(), JIT_LABEL()
        *
163              LOAD('JIT_ADDRESS(INTEGER)INTEGER', 'jit.so')
164              LOAD('JIT_DISASSEMBLE()', 'jit.so')
165              LOAD('JIT_EMIT()INTEGER', 'jit.so')
166              LOAD('JIT_PRINT()', 'jit.so')
167              LOAD('JIT_LABEL()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ELLIPSIS(), JIT_INTEGER_P(), JIT_CALLEE_SAVE_P()
        *
168              LOAD('JIT_ELLIPSIS()', 'jit.so')
169              LOAD('GET_NOTE_I()INTEGER', 'jit.so')
170              LOAD('GET_NOTE_S1()STRING', 'jit.so')
171              LOAD('GET_NOTE_S2()STRING', 'jit.so')
172              LOAD('GET_NOTE_JIT(INTEGER)PREDICATE', 'jit.so')
173              LOAD('JIT_INTEGER_P(INTEGER)PREDICATE', 'jit.so')
174              LOAD('JIT_CALLEE_SAVE_P(INTEGER)PREDICATE', 'jit.so')
        *
        -PUBLIC JIT_PATCH_AT(), JIT_PATCH_ABS(), JIT_PATCH(), JIT_PREPARE()
        *
175              LOAD('JIT_PATCH_AT(INTEGER,INTEGER)', 'jit.so')
176              LOAD('JIT_PATCH_ABS(INTEGER,INTEGER)', 'jit.so')
177              LOAD('JIT_PATCH(INTEGER)', 'jit.so')
178              LOAD('JIT_PREPARE()', 'jit.so')
        *
        -PUBLIC JIT_ALLOCAI(), JIT_DATA() JIT_FORWARD(), JIT_INDIRECT()
        *
179              LOAD('JIT_ALLOCAI(INTEGER)INTEGER', 'jit.so')
180              LOAD('JIT_DATA(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
181              LOAD('JIT_FORWARD()INTEGER', 'jit.so')
182              LOAD('JIT_INDIRECT()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LIVE(), JIT_LINK, JIT_R_NUM_(), JIT_V_NUM_(), JIT_F_NUM()
        *
183              LOAD('JIT_LIVE(INTEGER)INTEGER', 'jit.so')
184              LOAD('JIT_LINK(INTEGER)', 'jit.so')
185              LOAD('JIT_R_NUM_()INTEGER', 'jit.so')
186              LOAD('JIT_V_NUM_()INTEGER', 'jit.so')
187              LOAD('JIT_F_NUM_()INTEGER', 'jit.so')
        *
        -PUBLIC R0_(), R1_(), R2_(), R3_(), V0_(), V1_(), V2()_, V3_()
        *
188              LOAD('R0_()INTEGER', 'jit.so')
189              LOAD('R1_()INTEGER', 'jit.so')
190              LOAD('R2_()INTEGER', 'jit.so')
191              LOAD('R3_()INTEGER', 'jit.so')
192              LOAD('V0_()INTEGER', 'jit.so')
193              LOAD('V1_()INTEGER', 'jit.so')
194              LOAD('V2_()INTEGER', 'jit.so')
195              LOAD('V3_()INTEGER', 'jit.so')
        *
        -PUBLIC F0_(), F1_(), F2_(), F3_(), F4_(), F5_(), F6_(), F7_(), FP_()
        *
196              LOAD('F0_()INTEGER', 'jit.so')
197              LOAD('F1_()INTEGER', 'jit.so')
198              LOAD('F2_()INTEGER', 'jit.so')
199              LOAD('F3_()INTEGER', 'jit.so')
200              LOAD('F4_()INTEGER', 'jit.so')
201              LOAD('F5_()INTEGER', 'jit.so')
202              LOAD('F6_()INTEGER', 'jit.so')
203              LOAD('F7_()INTEGER', 'jit.so')
204              LOAD('FP_()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDR(), JIT_ADDR_F(), JIT_ADDR_D()
        *
205              LOAD('JIT_ADDR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
206              LOAD('JIT_ADDR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
207              LOAD('JIT_ADDR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDI(), JIT_ADDI_F(), JIT_ADDI_D()
        *
208              LOAD('JIT_ADDI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
209              LOAD('JIT_ADDI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
210              LOAD('JIT_ADDI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ADDXR(), JIT_ADDXI(), JIT_ADDCR(), JIT_ADDCI()
        *
211              LOAD('JIT_ADDXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
212              LOAD('JIT_ADDXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
213              LOAD('JIT_ADDCR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
214              LOAD('JIT_ADDCI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SUBR(), JIT_SUBR_F(), JIT_SUBR_D()
        *
215              LOAD('JIT_SUBR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
216              LOAD('JIT_SUBR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
217              LOAD('JIT_SUBR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SUBI(), JIT_SUBI_F(), JIT_SUBI_D()
        *
218              LOAD('JIT_SUBI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
219              LOAD('JIT_SUBI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
220              LOAD('JIT_SUBI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SUBXR(), JIT_SUBXI(), JIT_SUBCR(), JIT_SUBCI()
        *
221              LOAD('JIT_SUBXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
222              LOAD('JIT_SUBXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
223              LOAD('JIT_SUBCR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
224              LOAD('JIT_SUBCI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MULR(), JIT_MULR_F(), JIT_MULR_D()
        *
225              LOAD('JIT_MULR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
226              LOAD('JIT_MULR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
227              LOAD('JIT_MULR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MULTI(), JIT_MULI_F(), JIT_MULI_D()
        *
228              LOAD('JIT_MULI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
229              LOAD('JIT_MULI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
230              LOAD('JIT_MULI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_DIVR(), JIT_DIVR_U(), JIT_DIVR_F(), JI_DIVR_D()
        *
231              LOAD('JIT_DIVR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
232              LOAD('JIT_DIVR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
233              LOAD('JIT_DIVR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
234              LOAD('JIT_DIVR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_DIVI(), JIT_DIVI_U(), JIT_DIVI_F(), JIT_DIVI_D()
        *
235              LOAD('JIT_DIVI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
236              LOAD('JIT_DIVI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
237              LOAD('JIT_DIVI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
238              LOAD('JIT_DIVI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_REMR(), JIT_REMR_U(), JIT_REMI(), JIT_REMI_U()
        *
239              LOAD('JIT_REMR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
240              LOAD('JIT_REMR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
241              LOAD('JIT_REMI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
242              LOAD('JIT_REMI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ANDR(), JIT_ANDI(), JIT_ORR(), JIT_ORI()
        *
243              LOAD('JIT_ANDR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
244              LOAD('JIT_ANDI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
245              LOAD('JIT_ORR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
246              LOAD('JIT_ORI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_XORR(), JIT_XORI()
        *
247              LOAD('JIT_XORR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
248              LOAD('JIT_XORI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LSHR(), JIT_LSHI()
        *
249              LOAD('JIT_LSHR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
250              LOAD('JIT_LSHI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_RSHR(), JIT_RSHR_U(), JIT_RSHI(), JIT_RSHI_U()
        *
251              LOAD('JIT_RSHR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
252              LOAD('JIT_RSHR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
253              LOAD('JIT_RSHI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
254              LOAD('JIT_RSHI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_NEGR(), JIT_NEGR_F(), JIT_NEGR_D()
        *
255              LOAD('JIT_NEGR(INTEGER,INTEGER)INTEGER', 'jit.so')
256              LOAD('JIT_NEGR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
257              LOAD('JIT_NEGR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_COMR()
        *
258              LOAD('JIT_COMR(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ABSR_F(), JIT_ABSR_D()
        *
259              LOAD('JIT_ABSR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
260              LOAD('JIT_ABSR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_SQRTR_F(), JIT_SQRTR_D()
        *
261              LOAD('JIT_SQRTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
262              LOAD('JIT_SQRTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LTR(), JIT_LTR_U(), JIT_LTR_F(), JIT_LTR_D()
        *
263              LOAD('JIT_LTR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
264              LOAD('JIT_LTR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
265              LOAD('JIT_LTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
266              LOAD('JIT_LTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LTI(), JIT_LTI_U(), JIT_LTI_F(), JIT_LTI_D()
        *
267              LOAD('JIT_LTI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
268              LOAD('JIT_LTI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
269              LOAD('JIT_LTI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
270              LOAD('JIT_LTI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LER(), JIT_LER_U(), JIT_LER_F(), JIT_LER_D()
        *
271              LOAD('JIT_LER(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
272              LOAD('JIT_LER_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
273              LOAD('JIT_LER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
274              LOAD('JIT_LER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LEI(), JIT_LEI_U(), JIT_LEI_F(), JIT_LEI_D()
        *
275              LOAD('JIT_LEI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
276              LOAD('JIT_LEI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
277              LOAD('JIT_LEI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
278              LOAD('JIT_LEI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GTR(), JIT_GTR_U(), JIT_GTR_F(), GIT_GTR_D()
        *
279              LOAD('JIT_GTR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
280              LOAD('JIT_GTR_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
281              LOAD('JIT_GTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
282              LOAD('JIT_GTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GTI(), JIT_GTI_U(), JIT_GTI_F(), JIT_GTI_D()
        *
283              LOAD('JIT_GTI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
284              LOAD('JIT_GTI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
285              LOAD('JIT_GTI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
286              LOAD('JIT_GTI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GER(), JIT_GER_U(), JIT_GER_F(), JIT_GER_D()
        *
287              LOAD('JIT_GER(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
288              LOAD('JIT_GER_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
289              LOAD('JIT_GER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
290              LOAD('JIT_GER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GEI(), JIT_GEI_U(), JIT_GEI_F(), JIT_GEI_D()
        *
291              LOAD('JIT_GEI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
292              LOAD('JIT_GEI_U(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
293              LOAD('JIT_GEI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
294              LOAD('JIT_GEI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EQR(), JIT_EQR_F(), JIT_EQR_D()
        *
295              LOAD('JIT_EQR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
296              LOAD('JIT_EQR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
297              LOAD('JIT_EQR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EQI(), JIT_EQI_F(), JIT_EQI_D()
        *
298              LOAD('JIT_EQI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
299              LOAD('JIT_EQI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
300              LOAD('JIT_EQI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_NER(), JIT_NER_F(), JIT_NER_D()
        *
301              LOAD('JIT_NER(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
302              LOAD('JIT_NER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
303              LOAD('JIT_NER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_NEI(), JIT_NEI_F(), JIT_NEI_D()
        *
304              LOAD('JIT_NEI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
305              LOAD('JIT_NEI_F(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
306              LOAD('JIT_NEI_D(INTEGER,INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNLTR_F(), JIT_UNLTR_D()
        *
307              LOAD('JIT_UNLTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
308              LOAD('JIT_UNLTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNLER_F(), JIT_UNLER_D()
        *
309              LOAD('JIT_UNLER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
310              LOAD('JIT_UNLER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNGTR_F(), JIT_UNGTR_D()
        *
311              LOAD('JIT_UNGTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
312              LOAD('JIT_UNGTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNGER_F(), JIT_UNGER_D()
        *
313              LOAD('JIT_UNGER_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
314              LOAD('JIT_UNGER_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNEQR_D(), JIT_UNEQR_D()
        *
315              LOAD('JIT_UNEQR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
316              LOAD('JIT_UNEQR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LTGTR_F(), JIT_LTGTR_D()
        *
317              LOAD('JIT_LTGTR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
318              LOAD('JIT_LTGTR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ORDR_F(), JIT_ORDR_D()
        *
319              LOAD('JIT_ORDR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
320              LOAD('JIT_ORDR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_UNORDR_F(), JIT_UNORDR_D()
        *
321              LOAD('JIT_UNORDR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
322              LOAD('JIT_UNORDR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MOVR(), JIT_MOVR_F, JIT_MOVR_D()
        *
323              LOAD('JIT_MOVR(INTEGER,INTEGER)INTEGER', 'jit.so')
324              LOAD('JIT_MOVR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
325              LOAD('JIT_MOVR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_MOVI(), JIT_MOVI_F(), JIT_MOVI_D()
        *
326              LOAD('JIT_MOVI(INTEGER,INTEGER)INTEGER', 'jit.so')
327              LOAD('JIT_MOVI_F(INTEGER,REAL)INTEGER', 'jit.so')
328              LOAD('JIT_MOVI_D(INTEGER,REAL)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EXTR_C(), JIT_EXTR_UC(), JIT_EXTR_S(), JIT_EXTR_US()
        *
329              LOAD('JIT_EXTR_C(INTEGER,INTEGER)INTEGER', 'jit.so')
330              LOAD('JIT_EXTR_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
331              LOAD('JIT_EXTR_S(INTEGER,INTEGER)INTEGER', 'jit.so')
332              LOAD('JIT_EXTR_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EXTR_I(), JIT_EXTR_UI(), JIT_EXTR_F(), JIT_EXTR_D_F()
        *
333              LOAD('JIT_EXTR_I(INTEGER,INTEGER)INTEGER', 'jit.so')
334              LOAD('JIT_EXTR_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
335              LOAD('JIT_EXTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
336              LOAD('JIT_EXTR_D_F(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_EXTR_D(), JIT_EXTR_F_D()
        *
337              LOAD('JIT_EXTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
338              LOAD('JIT_EXTR_F_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_TRUNCR_F_I(), JIT_TRUNCR_F(), JIT_TRUNCR_F_L()
        *
339              LOAD('JIT_TRUNCR_F_I(INTEGER,INTEGER)INTEGER', 'jit.so')
340              LOAD('JIT_TRUNCR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
341              LOAD('JIT_TRUNCR_F_L(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_TRUNCR_D_I(), JIT_TRUNCR_D(), JIT_TRUNCR_D_L()
        *
342              LOAD('JIT_TRUNCR_D_I(INTEGER,INTEGER)INTEGER', 'jit.so')
343              LOAD('JIT_TRUNCR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
344              LOAD('JIT_TRUNCR_D_L(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_HTONR(), JIT_NTOHR()
        *
345              LOAD('JIT_HTONR(INTEGER,INTEGER)INTEGER', 'jit.so')
346              LOAD('JIT_NTOHR(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDR(), JIT_LDR_C(), JIT_LDR_UC(), JIT_LDR_S(), JIT_LDR_US()
        *
347              LOAD('JIT_LDR(INTEGER,INTEGER)INTEGER', 'jit.so')
348              LOAD('JIT_LDR_C(INTEGER,INTEGER)INTEGER', 'jit.so')
349              LOAD('JIT_LDR_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
350              LOAD('JIT_LDR_S(INTEGER,INTEGER)INTEGER', 'jit.so')
351              LOAD('JIT_LDR_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDR_I(), JIT_LDR_UI(), JIT_LDR_L(), JIT_LDR_F(), JIT_LDR_D()
        *
352              LOAD('JIT_LDR_I(INTEGER,INTEGER)INTEGER', 'jit.so')
353              LOAD('JIT_LDR_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
354              LOAD('JIT_LDR_L(INTEGER,INTEGER)INTEGER', 'jit.so')
355              LOAD('JIT_LDR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
356              LOAD('JIT_LDR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDI(), JIT_LDI_C(), JIT_LDI_UC(), JIT_LDI_S(), JIT_LDI_US()
        *
357              LOAD('JIT_LDI(INTEGER,INTEGER)INTEGER', 'jit.so')
358              LOAD('JIT_LDI_C(INTEGER,INTEGER)INTEGER', 'jit.so')
359              LOAD('JIT_LDI_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
360              LOAD('JIT_LDI_S(INTEGER,INTEGER)INTEGER', 'jit.so')
361              LOAD('JIT_LDI_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDI_I(), JIT_LDI_UI(), JIT_LDI_L(), JIT_LDI_F(), JIT_LDI_D()
        *
362              LOAD('JIT_LDI_I(INTEGER,INTEGER)INTEGER', 'jit.so')
363              LOAD('JIT_LDI_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
364              LOAD('JIT_LDI_L(INTEGER,INTEGER)INTEGER', 'jit.so')
365              LOAD('JIT_LDI_F(INTEGER,INTEGER)INTEGER', 'jit.so')
366              LOAD('JIT_LDI_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXR(), JIT_LDXR_C(), JIT_LDXR_UC(), JIT_LDXR_S()
        *
367              LOAD('JIT_LDXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
368              LOAD('JIT_LDXR_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
369              LOAD('JIT_LDXR_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
370              LOAD('JIT_LDXR_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXR_US(), JIT_LDXR_I(), JIT_LDXR_UI(), JIT_LDXR_L()
        *
371              LOAD('JIT_LDXR_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
372              LOAD('JIT_LDXR_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
373              LOAD('JIT_LDXR_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
374              LOAD('JIT_LDXR_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXR_F(), JIT_LDXR_D()
        *
375              LOAD('JIT_LDXR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
376              LOAD('JIT_LDXR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXI(), JIT_LDXI_C(), JIT_LDXI_UC(), JIT_LDXI_S()
        *
377              LOAD('JIT_LDXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
378              LOAD('JIT_LDXI_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
379              LOAD('JIT_LDXI_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
380              LOAD('JIT_LDXI_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXI_US(), JIT_LDXI_I(), JIT_LDXI_UI(), JIT_LDXI_L()
        *
381              LOAD('JIT_LDXI_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
382              LOAD('JIT_LDXI_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
383              LOAD('JIT_LDXI_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
384              LOAD('JIT_LDXI_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_LDXI_F(), JIT_LDXI_D()
        *
385              LOAD('JIT_LDXI_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
386              LOAD('JIT_LDXI_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STR(), JIT_STR_C(), JIT_STR_UC(), JIT_STR_S(), JIT_STR_US()
        *
387              LOAD('JIT_STR(INTEGER,INTEGER)INTEGER', 'jit.so')
388              LOAD('JIT_STR_C(INTEGER,INTEGER)INTEGER', 'jit.so')
389              LOAD('JIT_STR_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
390              LOAD('JIT_STR_S(INTEGER,INTEGER)INTEGER', 'jit.so')
391              LOAD('JIT_STR_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STR_I(), JIT_STR_UI(), JIT_STR_L(), JIT_STR_F(), JIT_STR_D()
        *
392              LOAD('JIT_STR_I(INTEGER,INTEGER)INTEGER', 'jit.so')
393              LOAD('JIT_STR_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
394              LOAD('JIT_STR_L(INTEGER,INTEGER)INTEGER', 'jit.so')
395              LOAD('JIT_STR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
396              LOAD('JIT_STR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STI(), JI_STI_C(), JIT_STI_UC(), JI_STI_S(), JIT_STI_US()
        *
397              LOAD('JIT_STI(INTEGER,INTEGER)INTEGER', 'jit.so')
398              LOAD('JIT_STI_C(INTEGER,INTEGER)INTEGER', 'jit.so')
399              LOAD('JIT_STI_UC(INTEGER,INTEGER)INTEGER', 'jit.so')
400              LOAD('JIT_STI_S(INTEGER,INTEGER)INTEGER', 'jit.so')
401              LOAD('JIT_STI_US(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STI_I(), JIT_STI_UI(), JIT_STI_L(), JIT_STI_F(), JIT_STI_D()
        *
402              LOAD('JIT_STI_I(INTEGER,INTEGER)INTEGER', 'jit.so')
403              LOAD('JIT_STI_UI(INTEGER,INTEGER)INTEGER', 'jit.so')
404              LOAD('JIT_STI_L(INTEGER,INTEGER)INTEGER', 'jit.so')
405              LOAD('JIT_STI_F(INTEGER,INTEGER)INTEGER', 'jit.so')
406              LOAD('JIT_STI_D(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXR(), JIT_STXR_C(), JIT_STXR_UC(), JIT_STXR_S()
        *
407              LOAD('JIT_STXR(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
408              LOAD('JIT_STXR_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
409              LOAD('JIT_STXR_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
410              LOAD('JIT_STXR_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXR_US(), JIT_STXR_I(), JIT_STXR_UI(), JIT_STXR_L()
        *
411              LOAD('JIT_STXR_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
412              LOAD('JIT_STXR_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
413              LOAD('JIT_STXR_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
414              LOAD('JIT_STXR_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXR_F(), JIT_STXR_D()
        *
415              LOAD('JIT_STXR_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
416              LOAD('JIT_STXR_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXI(), JIT_STXI_C(), JIT_STXI_S(), JIT_STXI_I()
        *
417              LOAD('JIT_STXI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
418              LOAD('JIT_STXI_C(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *        LOAD('JIT_STXI_UC(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
419              LOAD('JIT_STXI_S(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *        LOAD('JIT_STXI_US(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
420              LOAD('JIT_STXI_I(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *        LOAD('JIT_STXI_UI(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_STXI_L(), JIT_STXI_F(), JIT_STXI_D()
        *
421              LOAD('JIT_STXI_L(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
422              LOAD('JIT_STXI_F(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
423              LOAD('JIT_STXI_D(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_PUSHARGR(), JIT_PUSHARGR_F(), JIT_PUSHARGR_D()
        *
424              LOAD('JIT_PUSHARGR(INTEGER)', 'jit.so')
        *         LOAD('JIT_PUSHARGR_C(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_UC(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_S(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_US(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_I(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_UI(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGR_L(INTEGER)INTEGER', 'jit.so')
425              LOAD('JIT_PUSHARGR_F(INTEGER)', 'jit.so')
426              LOAD('JIT_PUSHARGR_D(INTEGER)', 'jit.so')
        *
        -PUBLIC JIT_PUSHARGI(), JIT_PUSHARGI_F(), JIT_PUSHARGI_D()
        *
427              LOAD('JIT_PUSHARGI(INTEGER)', 'jit.so')
        *         LOAD('JIT_PUSHARGI_C(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_UC(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_S(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_US(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_I(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_UI(INTEGER)INTEGER', 'jit.so')
        *         LOAD('JIT_PUSHARGI_L(INTEGER)INTEGER', 'jit.so')
428              LOAD('JIT_PUSHARGI_F(REAL)', 'jit.so')
429              LOAD('JIT_PUSHARGI_D(REAL)', 'jit.so')
        *
        -PUBLIC JIT_ARG(), JIT_ARG_C(), JIT_ARG_UC(), JIT_ARG_S(), JIT_ARG_US()
        *
430              LOAD('JIT_ARG()INTEGER', 'jit.so')
431              LOAD('JIT_ARG_C(INTEGER)INTEGER', 'jit.so')
432              LOAD('JIT_ARG_UC(INTEGER)INTEGER', 'jit.so')
433              LOAD('JIT_ARG_S(INTEGER)INTEGER', 'jit.so')
434              LOAD('JIT_ARG_US(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_ARG_I(), JIT_ARG_UI(), JIT_ARG_L(), JIT_ARG_F(), JIT_ARG_D()
        *
435              LOAD('JIT_ARG_I(INTEGER)INTEGER', 'jit.so')
436              LOAD('JIT_ARG_UI(INTEGER)INTEGER', 'jit.so')
437              LOAD('JIT_ARG_L(INTEGER)INTEGER', 'jit.so')
438              LOAD('JIT_ARG_F()INTEGER', 'jit.so')
439              LOAD('JIT_ARG_D()INTEGER', 'jit.so')
        *
        * ===
        *
440              LOAD('JIT_GETARG(INTEGER,INTEGER)', 'jit.so')
441              LOAD('JIT_GETARG_C(INTEGER,INTEGER)', 'jit.so')
442              LOAD('JIT_GETARG_UC(INTEGER,INTEGER)', 'jit.so')
443              LOAD('JIT_GETARG_S(INTEGER,INTEGER)', 'jit.so')
444              LOAD('JIT_GETARG_US(INTEGER,INTEGER)', 'jit.so')
445              LOAD('JIT_GETARG_I(INTEGER,INTEGER)', 'jit.so')
446              LOAD('JIT_GETARG_UI(INTEGER,INTEGER)', 'jit.so')
447              LOAD('JIT_GETARG_L(INTEGER,INTEGER)', 'jit.so')
448              LOAD('JIT_GETARG_F(INTEGER,INTEGER)', 'jit.so')
449              LOAD('JIT_GETARG_D(INTEGER,INTEGER)', 'jit.so')
        *
        *
450              LOAD('JIT_RET()', 'jit.so')
451              LOAD('JIT_RETR(INTEGER)', 'jit.so')
452              LOAD('JIT_RETR_C(INTEGER)INTEGER', 'jit.so')
453              LOAD('JIT_RETR_UC(INTEGER)INTEGER', 'jit.so')
454              LOAD('JIT_RETR_S(INTEGER)INTEGER', 'jit.so')
455              LOAD('JIT_RETR_US(INTEGER)INTEGER', 'jit.so')
456              LOAD('JIT_RETR_I(INTEGER)INTEGER', 'jit.so')
457              LOAD('JIT_RETR_UI(INTEGER)INTEGER', 'jit.so')
458              LOAD('JIT_RETR_L(INTEGER)INTEGER', 'jit.so')
459              LOAD('JIT_RETR_F(INTEGER)', 'jit.so')
460              LOAD('JIT_RETR_D(INTEGER)', 'jit.so')
461              LOAD('JIT_RETI(INTEGER)', 'jit.so')
462              LOAD('JIT_RETI_C(INTEGER)INTEGER', 'jit.so')
463              LOAD('JIT_RETI_UC(INTEGER)INTEGER', 'jit.so')
464              LOAD('JIT_RETI_S(INTEGER)INTEGER', 'jit.so')
465              LOAD('JIT_RETI_US(INTEGER)INTEGER', 'jit.so')
466              LOAD('JIT_RETI_I(INTEGER)INTEGER', 'jit.so')
467              LOAD('JIT_RETI_UI(INTEGER)INTEGER', 'jit.so')
468              LOAD('JIT_RETI_L(INTEGER)INTEGER', 'jit.so')
469              LOAD('JIT_RETI_F(REAL)', 'jit.so')
470              LOAD('JIT_RETI_D(REAL)', 'jit.so')
        *
        *
471              LOAD('JIT_RETVAL(INTEGER)', 'jit.so')
472              LOAD('JIT_RETVAL_C(INTEGER)', 'jit.so')
473              LOAD('JIT_RETVAL_UC(INTEGER)', 'jit.so')
474              LOAD('JIT_RETVAL_S(INTEGER)', 'jit.so')
475              LOAD('JIT_RETVAL_US(INTEGER)', 'jit.so')
476              LOAD('JIT_RETVAL_I(INTEGER)', 'jit.so')
477              LOAD('JIT_RETVAL_UI(INTEGER)', 'jit.so')
478              LOAD('JIT_RETVAL_L(INTEGER)', 'jit.so')
479              LOAD('JIT_RETVAL_F(INTEGER)', 'jit.so')
480              LOAD('JIT_RETVAL_D(INTEGER)', 'jit.so')
        *
        *
481              LOAD('JIT_BLTR(INTEGER,INTEGER)INTEGER', 'jit.so')
482              LOAD('JIT_BLTR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
483              LOAD('JIT_BLTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
484              LOAD('JIT_BLTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
485              LOAD('JIT_BLTI(INTEGER,INTEGER)INTEGER', 'jit.so')
486              LOAD('JIT_BLTI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
487              LOAD('JIT_BLTI_F(INTEGER,REAL)INTEGER', 'jit.so')
488              LOAD('JIT_BLTI_D(INTEGER,REAL)INTEGER', 'jit.so')
489              LOAD('JIT_BLER(INTEGER,INTEGER)INTEGER', 'jit.so')
490              LOAD('JIT_BLER_U(INTEGER,INTEGER)INTEGER', 'jit.so')
491              LOAD('JIT_BLER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
492              LOAD('JIT_BLER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
493              LOAD('JIT_BLEI(INTEGER,INTEGER)INTEGER', 'jit.so')
494              LOAD('JIT_BLEI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
495              LOAD('JIT_BLEI_F(INTEGER,REAL)INTEGER', 'jit.so')
496              LOAD('JIT_BLEI_D(INTEGER,REAL)INTEGER', 'jit.so')
497              LOAD('JIT_BGTR(INTEGER,INTEGER)INTEGER', 'jit.so')
498              LOAD('JIT_BGTR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
499              LOAD('JIT_BGTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
500              LOAD('JIT_BGTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
501              LOAD('JIT_BGTI(INTEGER,INTEGER)INTEGER', 'jit.so')
502              LOAD('JIT_BGTI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
503              LOAD('JIT_BGTI_F(INTEGER,REAL)INTEGER', 'jit.so')
504              LOAD('JIT_BGTI_D(INTEGER,REAL)INTEGER', 'jit.so')
505              LOAD('JIT_BGER(INTEGER,INTEGER)INTEGER', 'jit.so')
506              LOAD('JIT_BGER_U(INTEGER,INTEGER)INTEGER', 'jit.so')
507              LOAD('JIT_BGER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
508              LOAD('JIT_BGER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
509              LOAD('JIT_BGEI(INTEGER,INTEGER)INTEGER', 'jit.so')
510              LOAD('JIT_BGEI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
511              LOAD('JIT_BGEI_F(INTEGER,REAL)INTEGER', 'jit.so')
512              LOAD('JIT_BGEI_D(INTEGER,REAL)INTEGER', 'jit.so')
513              LOAD('JIT_BEQR(INTEGER,INTEGER)INTEGER', 'jit.so')
514              LOAD('JIT_BEQR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
515              LOAD('JIT_BEQR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
516              LOAD('JIT_BEQI(INTEGER,INTEGER)INTEGER', 'jit.so')
517              LOAD('JIT_BEQI_F(INTEGER,REAL)INTEGER', 'jit.so')
518              LOAD('JIT_BEQI_D(INTEGER,REAL)INTEGER', 'jit.so')
519              LOAD('JIT_BNER(INTEGER,INTEGER)INTEGER', 'jit.so')
520              LOAD('JIT_BNER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
521              LOAD('JIT_BNER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
522              LOAD('JIT_BNEI(INTEGER,INTEGER)INTEGER', 'jit.so')
523              LOAD('JIT_BNEI_F(INTEGER,REAL)INTEGER', 'jit.so')
524              LOAD('JIT_BNEI_D(INTEGER,REAL)INTEGER', 'jit.so')
525              LOAD('JIT_BUNLTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
526              LOAD('JIT_BUNLTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
527              LOAD('JIT_BUNLER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
528              LOAD('JIT_BUNLER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
529              LOAD('JIT_BUNGTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
530              LOAD('JIT_BUNGTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
531              LOAD('JIT_BUNGER_F(INTEGER,INTEGER)INTEGER', 'jit.so')
532              LOAD('JIT_BUNGER_D(INTEGER,INTEGER)INTEGER', 'jit.so')
533              LOAD('JIT_BUNEQR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
534              LOAD('JIT_BUNEQR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
535              LOAD('JIT_BLTGTR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
536              LOAD('JIT_BLTGTR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
537              LOAD('JIT_BORDR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
538              LOAD('JIT_BORDR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
539              LOAD('JIT_BUNORDR_F(INTEGER,INTEGER)INTEGER', 'jit.so')
540              LOAD('JIT_BUNORDR_D(INTEGER,INTEGER)INTEGER', 'jit.so')
541              LOAD('JIT_BMSR(INTEGER,INTEGER)INTEGER', 'jit.so')
542              LOAD('JIT_BMSI(INTEGER,INTEGER)INTEGER', 'jit.so')
543              LOAD('JIT_BMCR(INTEGER,INTEGER)INTEGER', 'jit.so')
544              LOAD('JIT_BMCI(INTEGER,INTEGER)INTEGER', 'jit.so')
545              LOAD('JIT_BOADDR(INTEGER,INTEGER)INTEGER', 'jit.so')
546              LOAD('JIT_BOADDR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
547              LOAD('JIT_BOADDI(INTEGER,INTEGER)INTEGER', 'jit.so')
548              LOAD('JIT_BOADDI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
549              LOAD('JIT_BXADDR(INTEGER,INTEGER)INTEGER', 'jit.so')
550              LOAD('JIT_BXADDR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
551              LOAD('JIT_BXADDI(INTEGER,INTEGER)INTEGER', 'jit.so')
552              LOAD('JIT_BXADDI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BOSUBR(), JIT_BOSUBR_U(), JIT_BOSUBI(), JIT_BOSUBI_U()
        *
553              LOAD('JIT_BOSUBR(INTEGER,INTEGER)INTEGER', 'jit.so')
554              LOAD('JIT_BOSUBR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
555              LOAD('JIT_BOSUBI(INTEGER,INTEGER)INTEGER', 'jit.so')
556              LOAD('JIT_BOSUBI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_BXSUBR(), JIT_BXSUBR_U(), JIT_BXSUBI(), JIT_BXSUBI_U()
        *
557              LOAD('JIT_BXSUBR(INTEGER,INTEGER)INTEGER', 'jit.so')
558              LOAD('JIT_BXSUBR_U(INTEGER,INTEGER)INTEGER', 'jit.so')
559              LOAD('JIT_BXSUBI(INTEGER,INTEGER)INTEGER', 'jit.so')
560              LOAD('JIT_BXSUBI_U(INTEGER,INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_CALLR(), JIT_CALLI()
        *
561              LOAD('JIT_CALLR(INTEGER)INTEGER', 'jit.so')
562              LOAD('JIT_CALLI(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_FINISHR(), JIT_FINISHI()
        *
563              LOAD('JIT_FINISHR(INTEGER)', 'jit.so')
564              LOAD('JIT_FINISHI(INTEGER)INTEGER', 'jit.so')
        *
        -PUBLIC JIT_JMPR(), JIT_JMPI()
        *
565              LOAD('JIT_JMPR(INTEGER)', 'jit.so')
566              LOAD('JIT_JMPI()INTEGER', 'jit.so')
        *
        -PUBLIC JIT_GET_NOTE()
        *
567              DEFINE('JIT_GET_NOTE(P)')                            :(END_JIT)
        *
568     JIT_GET_NOTE
569              GET_NOTE_JIT(P)                                     :F(FRETURN)
570              JIT_GET_NOTE = ARRAY(3)
571              JIT_GET_NOTE<1> = GET_NOTE_S1()
572              JIT_GET_NOTE<2> = GET_NOTE_S2()
573              JIT_GET_NOTE<3> = GET_NOTE_I                          :(RETURN)
        *
574     END_JIT
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CHARS.INC'
        -MODULE CHARS
        -LINE 12 "CHARS.lss"
        -IN72
        -LINE 100 "CHARS.lss"
        -STITL CHARS
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #####   #     #     #     ######    #####               *
        *             #     #  #     #    # #    #     #  #     #              *
        *             #        #     #   #   #   #     #  #                    *
        *             #        #######  #     #  ######    #####               *
        *             #        #     #  #######  #   #          #              *
        *             #     #  #     #  #     #  #    #   #     #              *
        *              #####   #     #  #     #  #     #   #####               *
        *                                                                      *
        * CHARS             SYMBOLIC NAMES FOR CHARACTERS                      *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * DECEMBER 2001                                                        *
        *                                                                      *
        ************************************************************************
        *
        * CHARS.lss
        *
        -LINE 15 "CHARS.lss"
        -PUBLIC CHARS_NUL, CHARS_SOH, CHARS_STX, CHARS_ETX, CHARS_EOT, CHARS_ENQ
        -PUBLIC CHARS_ACK, CHARS_BEL, CHARS_HT, CHARS_BS, CHARS_NL, CHARS_VT
        -PUBLIC CHARS_NP, CHARS_CR, CHARS_SO, CHARS_SI, CHARS_DLE, CHARS_DC1
        -PUBLIC CHARS_DC2, CHARS_DC3, CHARS_DC4, CHARS_NAK, CHARS_SYN, CHARS_ETB
        -PUBLIC CHARS_CAN, CHARS_EM, CHARS_SUB, CHARS_ESC, CHARS_FS, CHARS_GS
        -PUBLIC CHARS_RS, CHARS_US, CHARS_SP, CHARS_DEL, CHARS_TAB, CHARS_SPACE
        -PUBLIC CHARS_FF, CHARS_LF, CHARS_CONTROL, CHARS_PRINTABLE, CHARS_HIGH
        *
575     CHARS    CHARS_NUL = CHAR( 0)
576              CHARS_SOH = CHAR( 1)
577              CHARS_STX = CHAR( 2)
578              CHARS_ETX = CHAR( 3)
579              CHARS_EOT = CHAR( 4)
580              CHARS_ENQ = CHAR( 5)
581              CHARS_ACK = CHAR( 6)
582              CHARS_BEL = CHAR( 7)
583              CHARS_BS  = CHAR( 8)
584              CHARS_HT  = CHAR( 9)
585              CHARS_NL  = CHAR(10)
586              CHARS_VT  = CHAR(11)
587              CHARS_NP  = CHAR(12)
588              CHARS_CR  = CHAR(13)
589              CHARS_SO  = CHAR(14)
590              CHARS_SI  = CHAR(15)
591              CHARS_DLE = CHAR(16)
592              CHARS_DC1 = CHAR(17)
593              CHARS_DC2 = CHAR(18)
594              CHARS_DC3 = CHAR(19)
595              CHARS_DC4 = CHAR(20)
596              CHARS_NAK = CHAR(21)
597              CHARS_SYN = CHAR(22)
598              CHARS_ETB = CHAR(23)
599              CHARS_CAN = CHAR(24)
600              CHARS_EM  = CHAR(25)
601              CHARS_SUB = CHAR(26)
602              CHARS_ESC = CHAR(27)
603              CHARS_FS  = CHAR(28)
604              CHARS_GS  = CHAR(29)
605              CHARS_RS  = CHAR(30)
606              CHARS_US  = CHAR(31)
607              CHARS_SP  = CHAR(32)
608              CHARS_DEL = CHAR(127)
        -LINE 68 "CHARS.lss"
        *
609              CHARS_TAB   = CHARS_HT
610              CHARS_SPACE = CHARS_SP
611              CHARS_FF    = CHARS_NP
612              CHARS_LF    = CHARS_NL
        -LINE 78 "CHARS.lss"
        *
613              &ALPHABET LEN(32) .  CHARS_CONTROL
613     +                  LEN(95) .  CHARS_PRINTABLE
613     +                  LEN(129) . CHARS_HIGH
        *
614              CODE('CHARS')
        *
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'KEYST.INC'
        -MODULE KEYST
        -LINE 10 "KEYST.lss"
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 40 "KEYST.lss"
        -STITL KEYST
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #    #  #######  #     #   #####   #######              *
        *              #   #   #         #   #   #     #     #                 *
        *              #  #    #          # #    #           #                 *
        *              ###     #####       #      #####      #                 *
        *              #  #    #           #           #     #                 *
        *              #   #   #           #     #     #     #                 *
        *              #    #  #######     #      #####      #                 *
        *                                                                      *
        * KEYST                      KEYS IN TABLE                             *
        *                                                                      *
        ************************************************************************
        *
        * KEYST.lss
        *
        -LINE 15 "KEYST.lss"
        -PUBLIC KEYST()
        *
615              DEFINE('KEYST(T)A,N,I')                            :(KEYST_END)
        *
616     KEYST    A = (CONVERT(T, 'ARRAY'), ARRAY0)
617              PROTOTYPE(A) BREAK(',') . N                         :F(FRETURN)
618              KEYST = (NE(N) ARRAY(N), ARRAY0)
619              SEQ(' KEYST<I> = A<I,1> ', .I)                        :(RETURN)
        *
620     KEYST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BREAKQ.INC'
        -MODULE BREAKQ
        -INCLUDE 'UNIQUE.INC'
        -LINE 24 "UNIQUE.lss"
        -INCLUDE 'REPL.INC'
        -MODULE REPL
        -LINE 13 "REPL.lss"
        -IN72
        -LINE 45 "REPL.lss"
        -STITL REPL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                   ######   #######  ######   #                       *
        *                   #     #  #        #     #  #                       *
        *                   #     #  #        #     #  #                       *
        *                   ######   #####    ######   #                       *
        *                   #   #    #        #        #                       *
        *                   #    #   #        #        #                       *
        *                   #     #  #######  #        #######                 *
        *                                                                      *
        * REPL                   REPLACE STRINGS                               *
        *                                                                      *
        ************************************************************************
        *
        * REPL.lss
        *
        -LINE 16 "REPL.lss"
        -PUBLIC REPL()
        *
621              DEFINE('REPL(S1,S2,S3)C,T,FINDC')                   :(REPL_END)
        *
622     REPL     S2 LEN(1) . C =                                     :F(FRETURN)
623              FINDC = BREAK(C) . T LEN(1)
624              S2 = POS(0) S2
625     REPL_1   S1 FINDC =                                           :F(REPL_2)
626              S1 S2 =                                              :F(REPL_3)
627              REPL = REPL T S3                                      :(REPL_1)
628     REPL_3   REPL = REPL T C                                       :(REPL_1)
629     REPL_2   REPL = REPL S1                                        :(RETURN)
        *
630     REPL_END
        *
        * CE: .MSNOBOL4;
        -STITL UNIQUE
        -EJECT
        -LINE 73 "UNIQUE.lss"
        *
        ************************************************************************
        *                                                                      *
        *           #     #  #     #  ###   #####   #     #  #######           *
        *           #     #  ##    #   #   #     #  #     #  #                 *
        *           #     #  # #   #   #   #     #  #     #  #                 *
        *           #     #  #  #  #   #   #     #  #     #  #####             *
        *           #     #  #   # #   #   #   # #  #     #  #                 *
        *           #     #  #    ##   #   #    #   #     #  #                 *
        *            #####   #     #  ###   #### #   #####   #######           *
        *                                                                      *
        * UNIQUE                 GENERATE UNIQUE NAME                          *
        *                                                                      *
        ************************************************************************
        *
        * UNIQUE.lss
        *
        -LINE 28 "UNIQUE.lss"
        -MODULE UNIQUE
        -PUBLIC MAKE_UNIQUE(), UNIQUE()
631              DEFINE('MAKE_UNIQUE(SUF)S')
632              MAKE_UNIQUE()
633              OPSYN('UNIQUE', 'UNIQUE_')                        :(UNIQUE_END)
        *
634     MAKE_UNIQUE
635              S =
635     + 'UNIQUE_SUF  UNIQUE_SUF_ = IDENT(I) UNIQUE_SUF_ + 1  :F(UNIQUECSUF);'
635     + '            UNIQUE_SUF = "USUF" UNIQUE_SUF_ "_"          :(RETURN);'
635     + 'UNIQUECSUF $("USUF" UNIQUE_SUF_ "_") = '
635     + '           ?(UNIQUE_SUF_ = GT(UNIQUE_SUF_,0) UNIQUE_SUF_ - 1)'
635     + '                                           :S(UNIQUECSUF)F(RETURN);'
636              CODE(REPL(S, 'SUF', SUF))
637              DEFINE('UNIQUE_' SUF '(I)')                           :(RETURN)
        *
638     UNIQUE_END
        *
        * CE: .MSNOBOL4;
        -STITL BREAKQ
        *
        ************************************************************************
        *                                                                      *
        *         ######   ######   #######     #     #    #   #####           *
        *         #     #  #     #  #          # #    #   #   #     #          *
        *         #     #  #     #  #         #   #   #  #    #     #          *
        *         ######   ######   #####    #     #  ###     #     #          *
        *         #     #  #   #    #        #######  #  #    #   # #          *
        *         #     #  #    #   #        #     #  #   #   #    #           *
        *         ######   #     #  #######  #     #  #    #   #### #          *
        *                                                                      *
        *                                                                      *
        * BREAKQ           FASBOL II BREAKQ PATTERN                            *
        *                                                                      *
        ************************************************************************
        *
        * BREAKQ.INC
        *
        -PUBLIC BREAKQ()
        *
639              DEFINE('BREAKQ(S)NAME,R,P1,P2,P3')                :(END_BREAKQ)
        *
640     BREAKQ   NAME = UNIQUE()
641              R = CONVERT(NAME, 'EXPRESSION')
642              P1 = BREAK('"' "'" S)
643              P2 = "'" BREAK("'") "'" R
644              P3 = '"' BREAK('"') '"' R
645              BREAKQ = P1 (P2 | P3 | BREAK(S))
646              $NAME = BREAKQ                                        :(RETURN)
        *
647     END_BREAKQ
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'NSPAN.INC'
        -MODULE NSPAN
        -STITL NSPAN
        *
        ************************************************************************
        *                                                                      *
        *             #     #   #####   ######      #     #     #              *
        *             ##    #  #     #  #     #    # #    ##    #              *
        *             # #   #  #        #     #   #   #   # #   #              *
        *             #  #  #   #####   ######   #     #  #  #  #              *
        *             #   # #        #  #        #######  #   # #              *
        *             #    ##  #     #  #        #     #  #    ##              *
        *             #     #   #####   #        #     #  #     #              *
        *                                                                      *
        * NSPAN               FASBOL II NSPAN PATTERN                          *
        *                                                                      *
        ************************************************************************
        *
        * NSPAN.INC
        *
        -PUBLIC NSPAN()
        *
648              DEFINE('NSPAN(P)')                                 :(END_NSPAN)
        *
649     NSPAN    NSPAN = SPAN(P) | ''                                  :(RETURN)
        *
650     END_NSPAN
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'LINK.INC'
        -MODULE LINK
        -LINE 10 "LINK.lss"
        -IN72
        -LINE 73 "LINK.lss"
        -STITL LINK
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #        ###  #     #  #    #                     *
        *                    #         #   ##    #  #   #                      *
        *                    #         #   # #   #  #  #                       *
        *                    #         #   #  #  #  ###                        *
        *                    #         #   #   # #  #  #                       *
        *                    #         #   #    ##  #   #                      *
        *                    #######  ###  #     #  #    #                     *
        *                                                                      *
        * LINK                        LINK TYPE                                *
        *                                                                      *
        ************************************************************************
        *
        * LINK.lss
        *
        -LINE 13 "LINK.lss"
        -PUBLIC LINK(), NEXT()
        *
651              DATA('LINK(VALUE,NEXT)')
        *
        -PUBLIC CONS(), CAR(), CDR()
        *
652              OPSYN('CONS', 'LINK')
653              OPSYN('CAR', 'VALUE')
654              OPSYN('CDR', 'NEXT')
        *
        -PUBLIC CAAR(), CDAR(), CADR(), CDDR()
        *
655              DEFINE('CAAR(L)')
656              DEFINE('CDAR(l)')
657              DEFINE('CADR(L)')
658              DEFINE('CDDR(L)')
        *
        -PUBLIC CAAAR(), CAADR(), CADAR(), CADDR()
        -PUBLIC CDAAR(), CDADR(), CDDAR(), CDDDR()
        *
659              DEFINE('CAAAR(L)')
660              DEFINE('CAADR(L)')
661              DEFINE('CADAR(L)')
662              DEFINE('CADDR(L)')
663              DEFINE('CDAAR(L)')
664              DEFINE('CDADR(L)')
665              DEFINE('CDDAR(L)')
666              DEFINE('CDDDR(L)')
667                                                                  :(LINK_END)
        *
668     CAAAR    CAAAR = CAR(CAAR(L))                                  :(RETURN)
669     CAADR    CAADR = CAR(CADR(L))                                  :(RETURN)
670     CADAR    CADAR = CAR(CDAR(L))                                  :(RETURN)
671     CADDR    CADDR = CAR(CDDR(L))                                  :(RETURN)
672     CDAAR    CDAAR = CDR(CAAR(L))                                  :(RETURN)
673     CDADR    CDADR = CDR(CADR(L))                                  :(RETURN)
674     CDDAR    CDDAR = CDR(CDAR(L))                                  :(RETURN)
675     CDDDR    CDDDR = CDR(CDDR(L))                                  :(RETURN)
        *
676     CAAR     CAAR = CAR(CAR(L))                                    :(RETURN)
677     CDAR     CDAR = CDR(CAR(L))                                    :(RETURN)
678     CADR     CADR = CAR(CDR(L))                                    :(RETURN)
679     CDDR     CDDR = CDR(CDR(L))                                    :(RETURN)
        *
680     LINK_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'UNIX.INC'
        -MODULE UNIX
        -INCLUDE 'FFI.INC'
        -MODULE FFI
        -CASE 1
        -PLUSOPS 1
        -LINE 651 "FFI.lss"
        -LINE 17 "FFI.lss"
        -IN72
        -STITL FFI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #######  #######  ###                        *
        *                         #        #         #                         *
        *                         #        #         #                         *
        *                         #####    #####     #                         *
        *                         #        #         #                         *
        *                         #        #         #                         *
        *                         #        #        ###                        *
        *                                                                      *
        * FFI                  FOREIGN FUNCTION INTERFACE                      *
        *                                                                      *
        ************************************************************************
        *
        * FFI.lss
        *
        -LINE 22 "FFI.lss"
        -LINE 23 "FFI.lss"
        -LINE 24 "FFI.lss"
        -LINE 25 "FFI.lss"
        -LINE 26 "FFI.lss"
        -LINE 27 "FFI.lss"
        -LINE 28 "FFI.lss"
        -LINE 31 "FFI.lss"
681              FFI = 'ffi.c'
        -LINE 538 "FFI.lss"
        -LINE 539 "FFI.lss"
        -LINE 540 "FFI.lss"
        -LINE 541 "FFI.lss"
        -LINE 542 "FFI.lss"
        -LINE 543 "FFI.lss"
        -LINE 553 "FFI.lss"
682              LOAD('FFI_FREE(INTEGER)', 'ffi.so')
683              LOAD('FFI_CLEAR(INTEGER)', 'ffi.so')
684              LOAD('FFI_NEW(STRING,STRING)INTEGER', 'ffi.so')
685              LOAD('FFI_PAR_N_NEEDFREE(INTEGER,INTEGER)', 'ffi.so')
686              LOAD('FFI_PAR_N_INTEGER(INTEGER,INTEGER,INTEGER)', 'ffi.so')
687              LOAD('FFI_PAR_N_PTR(INTEGER,INTEGER,INTEGER)', 'ffi.so')
688              LOAD('FFI_PAR_N_REAL(INTEGER,INTEGER,REAL)', 'ffi.so')
689              LOAD('FFI_PAR_N_STRING(INTEGER,INTEGER,STRING)', 'ffi.so')
690              LOAD('FFI_PAR_N_P(INTEGER,INTEGER,INTEGER)', 'ffi.so')
691              LOAD('FFI_PAR_N_F(INTEGER,INTEGER,REAL)', 'ffi.so')
692              LOAD('FFI_PAR_N_D(INTEGER,INTEGER,REAL)', 'ffi.so')
693              LOAD('FFI_PAR_N_LD(INTEGER,INTEGER,REAL)', 'ffi.so')
694              LOAD('FFI_SET_CALLP(INTEGER,INTEGER)', 'ffi.so')
695              LOAD('FFI_RESULTP(INTEGER)INTEGER', 'ffi.so')
696              LOAD('CALL_FFI(INTEGER)', 'ffi.so')
697              LOAD('CALL_INTEGER_FFI(INTEGER)INTEGER', 'ffi.so')
698              LOAD('CALL_PTR_FFI(INTEGER)INTEGER', 'ffi.so')
699              LOAD('CALL_REAL_FFI(INTEGER)REAL', 'ffi.so')
700              LOAD('CALL_STRING_FFI(INTEGER)STRING', 'ffi.so')
        *
701              RTLD_LAZY   = 1
702              RTLD_NOW    = 2
703              RTLD_GLOBAL = 256
704              RTLD_LOCAL  = 0
        *
705              LOAD('DLOPEN_(STRING,INTEGER)INTEGER', 'ffi.so')
706              LOAD('DLERROR_()STRING', 'ffi.so')
707              LOAD('DLSYM_(INTEGER,STRING)', 'ffi.so')
708              LOAD('DLCLOSE_(INTEGER)INTEGER', 'ffi.so')
        *
        -LINE 588 "FFI.lss"
        -PUBLIC DLOPEN(), DLERROR(), DLSYM(), DLCLOSE()
        *
709              DEFINE('DLOPEN(S,I)')
710              DEFINE('DLERROR()')
711              DEFINE('DLSYM(H,S)')
712              DEFINE('DLCLOSE(H)')
        *
        -PUBLIC FFI_NEW(), FFI_FREE(), FFI_CLEAR(), FFI_PAR_N_NEEDFREE()
        -PUBLIC FFI_PAR_N_INTEGER(), FFI_PAR_N_PTR(), FFI_PAR_N_REAL()
        -PUBLIC FFI_PAR_N_STRING(),  FFI_SET_CALLP()
        -PUBLIC FFI_CALL_VOID(), FFI_CALL_INTEGER(), FFI_CALL_REAL()
        -PUBLIC FFI_CALL_STRING(), FFI_CALL_PTR(), CALL_FFI(), FFI_RESULTP()
        *
713              DEFINE('FFI_CALL_INTEGER(FFI)')
714              DEFINE('FFI_CALL_REAL(FFI)')
715              DEFINE('FFI_CALL_STRING(FFI)')
716              DEFINE('FFI_CALL_PTR(FFI)')
717              DEFINE('FFI_CALL_VOID(FFI)')                         :(FFI_END)
        *
718     DLOPEN   DLOPEN = DLOPEN_(S, I)                                :(RETURN)
        *
719     DLERROR  DLERROR = DLERROR_()                                  :(RETURN)
        *
720     DLSYM    DLSYM = DLSYM_(H, S)                                  :(RETURN)
        *
721     DLCLOSE  DLCLOSE = DLCLOSE_(H)                                 :(RETURN)
        *
722     FFI_CALL_VOID
723              CALL_FFI(FFI)
724              FFI_CLEAR(FFI)                                        :(RETURN)
        *
725     FFI_CALL_INTEGER
726              FFI_CALL_INTEGER = CALL_INTEGER_FFI(FFI)
727              FFI_CLEAR(FFI)                                        :(RETURN)
        *
728     FFI_CALL_REAL
729              FFI_CALL_REAL = CALL_REAL_FFI(FFI)
730              FFI_CLEAR(FFI)                                        :(RETURN)
        *
731     FFI_CALL_STRING
732              FFI_CALL_STRING = CALL_STRING_FFI(FFI)
733              FFI_CLEAR(FFI)                                        :(RETURN)
        *
734     FFI_CALL_PTR
735              FFI_CALL_PTR = CALL_PTR_FFI(FFI)
736              FFI_CLEAR(FFI)                                        :(RETURN)
        *
737     FFI_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'P64.INC'
        -MODULE P64
        -LINE 37 "P64.lss"
        -IN72
        -LINE 217 "P64.lss"
        -CASE 1
        -STITL P64
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       ######    ###   #   #                          *
        *                       #     #  #   #  #   #                          *
        *                       #     #  #      #   #                          *
        *                       ######   ####   #####                          *
        *                       #        #   #      #                          *
        *                       #        #   #      #                          *
        *                       #         ###       #                          *
        *                                                                      *
        * P64                    POINTER UTILITIES                             *
        *                                                                      *
        ************************************************************************
        *
        * P64.lss
        *
        -LINE 40 "P64.lss"
        -LINE 41 "P64.lss"
        -LINE 42 "P64.lss"
        -LINE 43 "P64.lss"
        -LINE 44 "P64.lss"
        -LINE 45 "P64.lss"
        -LINE 50 "P64.lss"
738              P64 = 'p64.c'
        -LINE 164 "P64.lss"
        -LINE 165 "P64.lss"
        -LINE 166 "P64.lss"
        -LINE 167 "P64.lss"
        -LINE 168 "P64.lss"
        -LINE 176 "P64.lss"
        -PUBLIC PEEK_STRING(), POKE_STRING(), PEEK_BUFFER(), POKE_BUFFER()
        *
739              LOAD('PEEK_STRING(INTEGER)STRING', 'p64.so')
740              LOAD('POKE_STRING(INTEGER,STRING)', 'p64.so')
741              LOAD('PEEK_BUFFER(INTEGER,INTEGER)STRING', 'p64.so')
742              LOAD('POKE_BUFFER(INTEGER,STRING)', 'p64.so')
        *
        -PUBLIC PEEK_P(), PEEK_C(), PEEK_S(), PEEK_I(), PEEK_D(), PEEK_F()
        -PUBLIC PEEK_LD()
        -PUBLIC POKE_P(), POKE_C(), POKE_S(), POKE_I(), POKE_D(), POKE_F()
        -PUBLIC POKE_LD()
        *
743              LOAD('PEEK_P(INTEGER)INTEGER', 'p64.so')
744              LOAD('PEEK_C(INTEGER)INTEGER', 'p64.so')
745              LOAD('PEEK_S(INTEGER)INTEGER', 'p64.so')
746              LOAD('PEEK_I(INTEGER)INTEGER', 'p64.so')
747              LOAD('PEEK_D(INTEGER)REAL', 'p64.so')
748              LOAD('PEEK_F(INTEGER)REAL', 'p64.so')
749              LOAD('PEEK_LD(INTEGER)REAL', 'p64.so')
750              LOAD('POKE_P(INTEGER,INTEGER)', 'p64.so')
751              LOAD('POKE_C(INTEGER,INTEGER)', 'p64.so')
752              LOAD('POKE_S(INTEGER,INTEGER)', 'p64.so')
753              LOAD('POKE_I(INTEGER,INTEGER)', 'p64.so')
754              LOAD('POKE_D(INTEGER,REAL)', 'p64.so')
755              LOAD('POKE_F(INTEGER,REAL)', 'p64.so')
756              LOAD('POKE_LD(INTEGER,REAL)', 'p64.so')
        *
        * CE: .F.MSNOBOL4;
        -IN72
        -STITL UNIX
        *
        ************************************************************************
        *                                                                      *
        *                    #     #  #     #  ###  #     #                    *
        *                    #     #  ##    #   #    #   #                     *
        *                    #     #  # #   #   #     # #                      *
        *                    #     #  #  #  #   #      #                       *
        *                    #     #  #   # #   #     # #                      *
        *                    #     #  #    ##   #    #   #                     *
        *                     #####   #     #  ###  #     #                    *
        *                                                                      *
        * UNIX                       UNIX SUPPORT                              *
        *                                                                      *
        ************************************************************************
        *
        * UNIX.INC
        *
        * AFTER CSNOBOL4 FUNCTIONS REFACTORED TO UNIX, ADD PEEK_STRING()
        * AND REFACTOR TEMPORARY FILE TO HERE AS WELL.
        * ADD SPRINTF() TO unix.so
        *
        -PUBLIC SIZEOF_INT(), SIZEOF_LONG(), SIZEOF_TIMEVAL(), SIZEOF_FD_SET()
        *
757              LOAD('SIZEOF_INT()INTEGER', 'unix.so')
758              LOAD('SIZEOF_LONG()INTEGER', 'unix.so')
759              LOAD('SIZEOF_TIMEVAL()INTEGER', 'unix.so')
760              LOAD('SIZEOF_FD_SET()INTEGER', 'unix.so')
        *
        -PUBLIC GET_ERRNO(), CLEAR_ERRNO()
        *
761              LOAD('GET_ERRNO()INTEGER', 'unix.so')
762              LOAD('CLEAR_ERRNO()INTEGER', 'unix.so')
        *
        -PUBLIC SET_TIMEVAL()
        *
763              LOAD('SET_TIMEVAL(INTEGER,INTEGER)', 'unix.so')
        *
        -PUBLIC FD_ISSET(), FD_ZERO(), FD_SET(), FD_CLR()
        *
764              LOAD('FD_ISSET_(INTEGER,INTEGER)INTEGER', 'unix.so')
765              LOAD('FD_ZERO_(INTEGER)', 'unix.so')
766              LOAD('FD_CLR_(INTEGER,INTEGER)', 'unix.so')
767              LOAD('FD_SET_(INTEGER,INTEGER)', 'unix.so')
        *
        -PUBLIC FORK(), WAIT(), WAITPID(), GET_STATUS(), PERROR()
        *
768              LOAD('WAITPID(INTEGER,INTEGER)', 'unix.so')
769              LOAD('GET_STATUS()INTEGER', 'unix.so')
        *
770              FFI_PERROR = FFI_NEW('V', 'P')
771              FFI_SET_CALLP(FFI_PERROR, DLSYM(0, 'perror'))
772              FFI_MALLOC = FFI_NEW('P', 'I')
773              FFI_SET_CALLP(FFI_MALLOC, DLSYM(0, 'malloc'))
774              FFI_FREE = FFI_NEW('V', 'I')
775              FFI_SET_CALLP(FFI_FREE, DLSYM(0, 'free'))
776              FFI_STRDUP = FFI_NEW('P', 'P')
777              FFI_SET_CALLP(FFI_STRDUP, DLSYM(0, 'strdup'))
778              FFI_STRLEN = FFI_NEW('I', 'P')
779              FFI_SET_CALLP(FFI_STRLEN, DLSYM(0, 'strlen'))
        *
780              FFI_PIPE = FFI_NEW('I', 'P')
781              FFI_SET_CALLP(FFI_PIPE, DLSYM(0, 'pipe'))
782              FFI_FORK = FFI_NEW('I', '')
783              FFI_SET_CALLP(FFI_FORK, DLSYM(0, 'fork'))
784              FFI_WAIT = FFI_NEW('I', '')
785              FFI_SET_CALLP(FFI_WAIT, DLSYM(0, 'wait'))
786              FFI_FILENO = FFI_NEW('I', 'P')
787              FFI_SET_CALLP(FFI_FILENO, DLSYM(0, 'fileno'))
788              FFI_CLOSE = FFI_NEW('I', 'I')
789              FFI_SET_CALLP(FFI_CLOSE, DLSYM(0, 'close'))
790              FFI_SELECT = FFI_NEW('I', 'I,P,P,P,P')
791              FFI_SET_CALLP(FFI_SELECT, DLSYM(0, 'select'))
792              FFI_READ = FFI_NEW('I', 'I,P,I')
793              FFI_SET_CALLP(FFI_READ, DLSYM(0, 'read'))
794              FFI_WRITE = FFI_NEW('I', 'I,P,I')
795              FFI_SET_CALLP(FFI_WRITE, DLSYM(0, 'write'))
796              FFI_GETPID = FFI_NEW('I', '')
797              FFI_SET_CALLP(FFI_GETPID, DLSYM(0, 'getpid'))
798              FFI_GETPPID = FFI_NEW('I', '')
799              FFI_SET_CALLP(FFI_GETPPID, DLSYM(0, 'getppid'))
800              FFI_KILL = FFI_NEW('I', 'I,I')
801              FFI_SET_CALLP(FFI_KILL, DLSYM(0, 'kill'))
802              FFI_RAISE = FFI_NEW('I', 'I')
803              FFI_SET_CALLP(FFI_RAISE, DLSYM(0, 'raise'))
804              FFI_OPEN = FFI_NEW('I', 'P,I')
805              FFI_SET_CALLP(FFI_OPEN, DLSYM(0, 'open'))
806              FFI_CREAT = FFI_NEW('I', 'P,I')
807              FFI_SET_CALLP(FFI_CREAT, DLSYM(0, 'creat'))
808              FFI_DUP = FFI_NEW('I', 'I')
809              FFI_SET_CALLP(FFI_DUP, DLSYM(0, 'dup'))
        *
        -PUBLIC O_RDONLY, O_WRONLY, O_RDWR
        *
810              O_RDONLY = 0
811              O_WRONLY = 1
812              O_RDWR   = 2
        *
        * SIGNAL DEFINITIONS
        *
        -PUBLIC SIGHUP, SIGINT, SIGQUIT, SIGILL, SIGTRAP, SIGABRT, SIGBUS
        *
813              SIGHUP    = 1
814              SIGINT    = 2
815              SIGQUIT   = 3
816              SIGILL    = 4
817              SIGTRAP   = 5
818              SIGABRT   = 6
819              SIGBUS    = 7
        *
        -PUBLIC SIGFPE, SIGKILL, SIGUSR1, SIGSEGV, SIGUSR2, SIGALRM, SIGTERM
        *
820              SIGFPE    = 8
821              SIGKILL   = 9
822              SIGUSR1   = 10
823              SIGSEGV   = 11
824              SIGUSR2   = 12
825              SIGPIPE   = 13
826              SIGALRM   = 14
827              SIGTERM   = 15
        *
        -PUBLIC SIGSTKFLT, SIGCHLD, SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU
        *
828              SIGSTKFLT = 16
829              SIGCHLD   = 17
830              SIGCONT   = 18
831              SIGSTOP   = 19
832              SIGTSTP   = 20
833              SIGTTIN   = 21
834              SIGTTOU   = 22
        *
        -PUBLIC SIGURG, SIGXCPU, SIGXFSZ, SIGVTALRM, SIGPROF, SIGWINCH
        *
835              SIGURG    = 23
836              SIGXCPU   = 24
837              SIGXFSZ   = 25
838              SIGVTALRM = 26
839              SIGPROF   = 27
840              SIGWINCH  = 28
        *
        -PUBLIC SIGIO, SIGPWR, SIGSYS
        *
841              SIGIO     = 29
842              SIGPWR    = 30
843              SIGSYS    = 31
        *
        -PUBLIC FILENO(), READ(), WRITE(), GETPID(), GETPPID(), KILL(), RAISE()
        -PUBLIC OPEN(), CREAT(), DUP()
        *
844              DEFINE('KILL(PID,SIG)')
845              DEFINE('RAISE(SIG)')
846              DEFINE('GETPID()')
847              DEFINE('GETPPID()')
848              DEFINE('READ(FD,BUF,NBYTES)')
849              DEFINE('CLOSE(FD)')
850              DEFINE('OPEN(FN,F)')
851              DEFINE('CREAT(FN,M)')
852              DEFINE('DUP(FD)')
853              DEFINE('SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)')
854              DEFINE('FILENO(FP)')
855              DEFINE('FORK()')
856              DEFINE('WAIT()')
857              DEFINE('FD_ZERO(FDS)')
858              DEFINE('FD_ISSET(FD,FDS)')
859              DEFINE('FD_CLR(FD,FDS)')
860              DEFINE('FD_SET(FD,FDS)')
861              DEFINE('NEW_FD_SET()')
862              DEFINE('NEW_TIMEVAL()')
        *
        -PUBLIC PIPE(), MALLOC(), FREE(), STRDUP(), STRLEN(), CLOSE()
        -PUBLIC SELECT()
        *
863              DEFINE('PIPE()R,P')
864              DEFINE('PERROR(S)')
865              DEFINE('MALLOC(N)')
866              DEFINE('FREE(P)')
867              DEFINE('STRDUP(S)')
868              DEFINE('STRLEN(S)')                                 :(UNIX_END)
        *
869     PERROR   FFI_PAR_N_STRING(FFI_PERROR, 1, S)
870              FFI_CALL_VOID(FFI_PERROR)                             :(RETURN)
        *
871     KILL     FFI_PAR_N_INTEGER(FFI_KILL, 1, PID)
872              FFI_PAR_N_INTEGER(FFI_KILL, 2, SIG)
873              KILL = FFI_CALL_INTEGER(FFI_KILL)                     :(RETURN)
        *
874     RAISE    FFI_PAR_N_INTEGER(FFI_RAISE, 1, SIG)
875              RAISE = FFI_CALL_INTEGER(FFI_RAISE)                   :(RETURN)
        *
876     GETPID   GETPID = FFI_CALL_INTEGER(FFI_GETPID)                 :(RETURN)
        *
877     GETPPID  GETPPID = FFI_CALL_INTEGER(FFI_GETPPID)               :(RETURN)
        *
878     WRITE    FFI_PAR_N_INTEGER(FFI_WRITE, 1, FD)
879              FFI_PAR_N_PTR(FFI_WRITE, 2, BUF)
880              FFI_PAR_N_PTR(FFI_WRITE, 3, NBYTES)
881              WRITE = FFI_CALL_INTEGER(FFI_WRITE)                   :(RETURN)
        *
882     READ     FFI_PAR_N_INTEGER(FFI_READ, 1, FD)
883              FFI_PAR_N_PTR(FFI_READ, 2, BUF)
884              FFI_PAR_N_PTR(FFI_READ, 3, NBYTES)
885              READ = FFI_CALL_INTEGER(FFI_READ)                     :(RETURN)
        *
886     OPEN     FFI_PAR_N_STRING(FFI_OPEN, 1, FN)
887              FFI_PAR_N_INTEGER(FFI_OPEN, 2, F)
888              OPEN = FFI_CALL_INTEGER(FFI_OPEN)                     :(RETURN)
        *
889     CREAT    FFI_PAR_N_STRING(FFI_CREAT, 1, FN)
890              FFI_PAR_N_INTEGER(FFI_CREAT, 2, M)
891              CREAT = FFI_CALL_INTEGER(FFI_CREAT)                   :(RETURN)
        *
892     DUP      FFI_PAR_N_INTEGER(FFI_DUP, 1, FD)
893              DUP = FFI_CALL_INTEGER(FFI_DUP)                       :(RETURN)
        *
894     CLOSE    FFI_PAR_N_INTEGER(FFI_CLOSE, 1, FD)
895              CLOSE = FFI_CALL_INTEGER(FFI_CLOSE)                   :(RETURN)
        *
896     SELECT   FFI_PAR_N_INTEGER(FFI_SELECT, 1, NFDS)
897              FFI_PAR_N_PTR(FFI_SELECT, 2, READFDS)
898              FFI_PAR_N_PTR(FFI_SELECT, 3, WRITEFDS)
899              FFI_PAR_N_PTR(FFI_SELECT, 4, EXCEPTFDS)
900              FFI_PAR_N_PTR(FFI_SELECT, 5, TIMEOUT)
901              SELECT = FFI_CALL_INTEGER(FFI_SELECT)                 :(RETURN)
        *
902     FILENO   FFI_PAR_N_PTR(FFI_FILENO, 1, FP)
903              FILENO = FFI_CALL_INTEGER(FFI_FILENO)                 :(RETURN)
        *
904     FORK     FORK = FFI_CALL_INTEGER(FFI_FORK)                     :(RETURN)
        *
905     WAIT     WAIT = FFI_CALL_INTEGER(FFI_WAIT)                     :(RETURN)
        *
906     FD_ZERO  FD_ZERO_(FDS)                                         :(RETURN)
        *
907     FD_ISSET FD_ISSET = FD_ISSET_(FD, FDS)                         :(RETURN)
        *
908     FD_CLR   FD_CLR_(FD, FDS)                                      :(RETURN)
        *
909     FD_SET   FD_SET_(FD, FDS)                                      :(RETURN)
        *
910     NEW_FD_SET
911              NEW_FD_SET = MALLOC(SIZEOF_FD_SET())                  :(RETURN)
        *
912     NEW_TIMEVAL
913              NEW_TIMEVAL = MALLOC(SIZEOF_TIMEVAL())                :(RETURN)
        *
914     MALLOC   FFI_PAR_N_INTEGER(FFI_MALLOC, 1, N)
915              MALLOC = FFI_CALL_PTR(FFI_MALLOC)                     :(RETURN)
        *
916     FREE     FFI_PAR_N_PTR(FFI_FREE, 1, P)
917              FFI_CALL_VOID(FFI_FREE)                               :(RETURN)
        *
918     STRDUP   FFI_PAR_N_STRING(FFI_STRDUP, 1, S)
919              STRDUP = FFI_CALL_PTR(FFI_STRDUP)                     :(RETURN)
        *
920     STRLEN   FFI_PAR_N_PTR(FFI_STRLEN, 1, S)
921              STRLEN = FFI_CALL_INTEGER(FFI_STRLEN)                 :(RETURN)
        *
922     PIPE     P = MALLOC(2 * SIZEOF_INT())
923              FFI_PAR_N_PTR(FFI_PIPE, 1, P)
924              R = FFI_CALL_INTEGER(FFI_PIPE)
925              NE(R) FREE(P)                                       :S(FRETURN)
926              PIPE = ARRAY(2)
927              PIPE<1> = PEEK_I(P)
928              PIPE<2> = PEEK_I(P + SIZEOF_INT())
929              FREE(P)                                               :(RETURN)
        *
930     UNIX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'P64.INC'
        -INCLUDE 'LOGIC.INC'
        -MODULE LOGIC
        -LINE 8 "LOGIC.lss"
        -IN72
        -LINE 85 "LOGIC.lss"
        -STITL LOGIC
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             #        #######   #####   ###   #####                   *
        *             #        #     #  #     #   #   #     #                  *
        *             #        #     #  #         #   #                        *
        *             #        #     #  #  ####   #   #                        *
        *             #        #     #  #     #   #   #                        *
        *             #        #     #  #     #   #   #     #                  *
        *             #######  #######   #####   ###   #####                   *
        *                                                                      *
        * LOGIC       CATSPAW SPITBOL COMPATIBLE LOGIC() FUNCTIONS             *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * JANUARY 21, 2002                                                     *
        *                                                                      *
        ************************************************************************
        *
        * LOGIC.lss
        *
        -LINE 11 "LOGIC.lss"
        *
        * NOTE! BASE ARGUMENT MUST BE PASSED A EXPLICIT NULL STRING FOR DEFAULT
        *
        * INTEGER/INTEGER, STRING/INTEGER, STRING/STRING
        *
        -PUBLIC LOGIC()
        *
931              LOAD('LOGIC(INTEGER,,)')
        *
        -PUBLIC NOT(), AND(), OR(), XOR(), NAND(), NOR(), UPLUS(), UMINUS()
        -PUBLIC  UMUL(), UDIV(), SHL(), SHR(), SAR(), ROL(), ROR()
        -PUBLIC HI(), IH(), DIB(), IDB()
        *
932              DEFINE('NOT(ARG)')
933              DEFINE('AND(ARG1,ARG2)')
934              DEFINE('OR(ARG1,ARG2)')
935              DEFINE('XOR(ARG1,ARG2)')
936              DEFINE('NAND(ARG1,ARG2)')
937              DEFINE('NOR(ARG1,ARG2)')
938              DEFINE('UPLUS(ARG1,ARG2)')
939              DEFINE('UMINUS(ARG1,ARG2)')
940              DEFINE('UMUL(ARG1,ARG2)')
941              DEFINE('UDIV(ARG1,ARG2)')
942              DEFINE('SHL(ARG1,ARG2)')
943              DEFINE('SHR(ARG1,ARG2)')
944              DEFINE('SAR(ARG1,ARG2)')
945              DEFINE('ROL(ARG1,ARG2)')
946              DEFINE('ROR(ARG1,ARG2)')
947              DEFINE('HI(ARG)')
948              DEFINE('IH(ARG)')
949              DEFINE('DIB(ARG,BASE)')
950              DEFINE('IDB(ARG,BASE)')                            :(LOGIC_END)
        *
951     NOT      NOT    = LOGIC( 1, ARG)                    :S(RETURN)F(FRETURN)
952     AND      AND    = LOGIC( 2, ARG1, ARG2)             :S(RETURN)F(FRETURN)
953     OR       OR     = LOGIC( 3, ARG1, ARG2)             :S(RETURN)F(FRETURN)
954     XOR      XOR    = LOGIC( 4, ARG1, ARG2)             :S(RETURN)F(FRETURN)
955     NAND     NAND   = LOGIC( 5, ARG1, ARG2)             :S(RETURN)F(FRETURN)
956     NOR      NOR    = LOGIC( 6, ARG1, ARG2)             :S(RETURN)F(FRETURN)
957     UPLUS    UPLUS  = LOGIC( 7, ARG1, ARG2)             :S(RETURN)F(FRETURN)
958     UMINUS   UMINUS = LOGIC( 8, ARG1, ARG2)             :S(RETURN)F(FRETURN)
959     UMUL     UMUL   = LOGIC( 9, ARG1, ARG2)             :S(RETURN)F(FRETURN)
960     UDIV     UDIV   = LOGIC(10, ARG1, ARG2)             :S(RETURN)F(FRETURN)
961     SHL      SHL    = LOGIC(11, ARG1, ARG2)             :S(RETURN)F(FRETURN)
962     SHR      SHR    = LOGIC(12, ARG1, ARG2)             :S(RETURN)F(FRETURN)
963     SAR      SAR    = LOGIC(13, ARG1, ARG2)             :S(RETURN)F(FRETURN)
964     ROL      ROL    = LOGIC(14, ARG1, ARG2)             :S(RETURN)F(FRETURN)
965     ROR      ROR    = LOGIC(15, ARG1, ARG2)             :S(RETURN)F(FRETURN)
966     HI       HI     = LOGIC(16, CONVERT(ARG, 'STRING'), '')
966     +                                                   :S(RETURN)F(FRETURN)
967     IH       IH     = LOGIC(17, CONVERT(ARG, 'INTEGER'), '')
967     +                                                   :S(RETURN)F(FRETURN)
968     DIB      DIB    = LOGIC(16, CONVERT(ARG, 'STRING'), BASE)
968     +                                                   :S(RETURN)F(FRETURN)
969     IDB      IDB    = LOGIC(17, CONVERT(ARG, 'INTEGER'), BASE)
969     +                                                   :S(RETURN)F(FRETURN)
        *
970     LOGIC_END
971              CODE('LOGIC')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COPYT.INC'
        -MODULE COPYT
        -LINE 8 "COPYT.lss"
        -IN72
        -LINE 34 "COPYT.lss"
        -STITL COPYT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #####   #######  ######   #     #  #######              *
        *             #     #  #     #  #     #   #   #      #                 *
        *             #        #     #  #     #    # #       #                 *
        *             #        #     #  ######      #        #                 *
        *             #        #     #  #           #        #                 *
        *             #     #  #     #  #           #        #                 *
        *              #####   #######  #           #        #                 *
        *                                                                      *
        * COPYT                      COPY A TABLE                              *
        *                                                                      *
        ************************************************************************
        *
        * COPYT.lss
        *
        -LINE 11 "COPYT.lss"
        -PUBLIC COPYT()
        *
972              DEFINE('COPYT(T)')                                 :(COPYT_END)
        *
973     COPYT    COPYT = TABLE()
974              COPYT = CONVERT(CONVERT(T, 'ARRAY'), 'TABLE')         :(RETURN)
        *
975     COPYT_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -STITL TRIMB
        -EJECT
        *
        -LINE 35 "TRIMB.lss"
        ************************************************************************
        *                                                                      *
        *               #######  ######   ###  #     #  ######                 *
        *                  #     #     #   #   ##   ##  #     #                *
        *                  #     #     #   #   # # # #  #     #                *
        *                  #     ######    #   #  #  #  ######                 *
        *                  #     #   #     #   #     #  #     #                *
        *                  #     #    #    #   #     #  #     #                *
        *                  #     #     #  ###  #     #  ######                 *
        *                                                                      *
        * TRIMB            TRIM BOTH LEFT AND RIGHT OF STRING                  *
        *                                                                      *
        ************************************************************************
        *
        * TRIMB.lss
        *
        -LINE 11 "TRIMB.lss"
        -MODULE TRIMB
        -PUBLIC TRIMB()
976              DEFINE('TRIMB(S)')                                 :(TRIMB_END)
        *
977     TRIMB    TRIMB = REVERSE(TRIM(REVERSE(TRIM(S))))               :(RETURN)
        *
978     TRIMB_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FFI.INC'
        -IN72
        -STITL ASM
        -CASE 1
        -PLUSOPS 1
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #      #####   #     #                       *
        *                        # #    #     #  ##   ##                       *
        *                       #   #   #        # # # #                       *
        *                      #     #   #####   #  #  #                       *
        *                      #######        #  #     #                       *
        *                      #     #  #     #  #     #                       *
        *                      #     #   #####   #     #                       *
        *                                                                      *
        * ASM                  ASSEMBLER/LOADER FOR JIT                        *
        *                                                                      *
        ************************************************************************
        *
        * ASM.INC
        *
        * A SIMPLE ASSEMBLER/LOADER FOR JIT CODE. THIS IS A BIT BRITTLE.
        *
        * THE BASIC IDEA IS THAT EACH ASSEMBLER LINE IS EXAMINED, AND LABEL,
        * OPCODE AND UP TO THREE PARAMETERS EXTRACTED. THE OPCODE MAY MATCH
        * A FUNCTION IN THE ASSEMBLER (WITH '__' APPENDED), OR, WITH JIT_
        * PREPENDED, A JIT GENERATION INSTRUCTION. THE FUNCTION IS THEN CALLED
        * WITH UP TO THREE PARAMETERS. EACH PARAMETER IS A STRING, A NUMBER, A
        * SYMBOL REFERENCE OR A REGISTER. EACH LABEL ON A JIT_ OPCODE IS ENTERED
        * INTO A LOCAL SYMBOL TABLE.
        *
        * ASM() WORKS IN TWO PHASES - THE FIRST PHASE CREATES SYMBOLS IN
        * THE SYMBOLS1 TABLE. AFTER PHASE1, WE PREPARE THE DSS AND BSS AREAS
        * (THIS COULD BE CONSIDERED PHASE1A - BUT WE ONLY COUNT SOURCE SCANS
        * AS PHASES). THE SECOND PHASE ACTUALLY GENERATES CODE, USING THE
        * SYMBOLS CREATED IN PHASE1. ON COMPLETIION OF PHASE2, WE RESOLVE
        * INTERNAL LOCAL SYMBOLS (BRANCHES IN THE CODE -- THIS IS PHASE 2A).
        * NOTE THAT 'EXTERN' SYMBOLS ARE PUT INTO THE EXPORTS TABLE. THESE
        * CAN BE DSS, BSS OR ADDRESS SYMBOLS. THIS TABLE CAN BE MERGED WITH
        * OTHER EXPORT TABLES (USING MERGET), AND PASSED TO ASM_CREATE TO
        * ESTABLISH THE IMPORTS NEEDED. EXPORTS(ASM) ACCESSES THIS TABLE
        * FOR A MODULE.
        *
        * A = ASM_CREATE()
        * S = ASM(A, SRC) :F(ERROR)
        * ASM_DESTROY(A)
        *
        * THIS IS A PART OF A "MACHINE CODE LOADER", AND ENTRY AND USAGE ISSUES
        * ARE MEANT TO BE COVERED ELSEWHERE. THIS MODULE HANDLES INTEPRETING THE
        * FORMAT, AND RESOLVING (MOST) SYMBOLS, PREPARING THE OBJECT FOR
        * EVENTUAL EXECUTION.
        *
        * THE ASM_TYPE() OBJECT IS CREATED AND IS SOMEWHAT INDEPENDENT OF THE
        * ASM SOURCE AND ASM() CALL. THIS ALLOWS THE ACTUAL ASM RESULTS TO BE
        * USED INDEPENDENTLY WITH (MOST) USING CODE BEING UNAWARE OF THE
        * IMPLEMENTATION USING JIT. AS FAR AS THE USING CODE IS CONCERNED,
        * ASM MAY HAVE BEEN IMPLEMENTED USING AN INTERPRETER.
        *
        * FOR FINAL USE OF THE ASM JIT CODE, JIT(A) WILL RETRIEVE THE JIT STATE,
        * WHICH CAN BE USED WITH JIT FUNCTIONS FOR DEBUG, AND TO EMIT CODE WHICH
        * CAN BE PASSED TO OTHER FUNCTIONS LIKE FFI TO PREPARE FOR FINAL
        * EXECUTION.
        *
        * CE: .MSNOBOL4;
        *
        -PUBLIC JIT(), EXPORTS(), OBJ(), ASM_CREATE(), ASM_DESTROY(), ASM()
        -PUBLIC DSSBASE(), BSSBASE()
        *
979              DATA('ASM_TYPE(JIT,SYMBOLS1,SYMBOLS,REFERENCES,DSS,BSS,SZBSS,'
979     +                      'DINIT,DSSBASE,BSSBASE,ENTRIES,SRC,OBJ,DAREFS,'
979     +                      'DPREFS,EXPORTS)')
        *
980              DEFINE('ASM_CREATE(SYMBOLS1)')
981              DEFINE('ASM_DESTROY(ASM)')
982              DEFINE('ASM(ASM,SRC)')
        *
983              DEFINE('ASM_EMIT()')
984              DEFINE('ASM_BSS()A,I')
985              DEFINE('ASM_DA()A,I,P')
986              DEFINE('ASM_DSS()A,I,S')
987              DEFINE('ASM_LINK()SYMBOLS,A,I,P,R,S')
988              DEFINE('ASM_PHASE(ASM_PHASE)'
988     +               'SRC,LINE,ELINE,R,SYMBOL,LAB,OP,P1,P2,P3,S,OP1')
        *
989              ASET = &UCASE &LCASE &DIGITS '_.$'
990              AWHT = NSPAN(' ' CHARS_TAB)
991              ASM_PAT = FENCE NSPAN(ASET) . LAB
991     +                  AWHT NSPAN(ASET) . OP
991     +                  AWHT ((BREAKQ(',') . P1 ',') | NULL)
991     +                  AWHT ((BREAK(',') . P2 ',') | NULL)
991     +                  AWHT ((BREAK(',') . P3 ',') | NULL)
        *
992              DEFINE('ASM_PARM(X)OFFSET,S,SIGN')
993              DEFINE('ALIGN_BSS(A),N')
        *
994              DEFINE('PHASE1__(P1)')
995              DEFINE('PHASE2__(P2)')
996              DEFINE('EXTERN__(P1,P2,P3)H')
997              DEFINE('DEFINE__(P1,P2,P3)H')
998              DEFINE('USES__(P1)A')
999              DEFINE('EQU__(P1)')
1000             DEFINE('ADDRESS__()')
1001             DEFINE('EXPORT__()')
        *
1002             DEFINE('COMMON__(P1)')
1003             DEFINE('RESB__(P1)')
1004             DEFINE('RESW__(P1)')
1005             DEFINE('RESD__(P1)')
1006             DEFINE('RESQ__(P1)')
1007             DEFINE('RES(P1,P2)')
        *
1008             DEFINE('DB__(P1)')
1009             DEFINE('DW__(P1)')
1010             DEFINE('DD__(P1)')
1011             DEFINE('DQ__(P1)')
1012             DEFINE('DA__(P1)')
1013             DEFINE('DP__(P1)')
1014             DEFINE('DS__(P1)')
        *
        * SET TO NON-NULL TO HAVE ASM GIVE DEBUG OUTPUT
        *
1015             ASM_DEBUG =
        *
        * FOR REGISTER LOOKUP - OPTIMIZATION
        *
1016             AS_REGS = TABLE()
        *
        * SIZES OF TYPES. THESE ARE DEFINE TO ALLOW THEM TO BE USED IN ASM
        * FILES. THEY AREN'T ACTUALLY USED IN THIS FILE.
        *
1017             BYTE = 1
1018             WORD = 2
1019             DWORD = 4
1020             QWORD = 8
1021             FLOAT = 4
1022             DOUBLE = 8
        *
        * STORAGE USED FOR DATA CONVERSIONS.
        *
1023             ASM_P = MALLOC(128)
        *
        * TABLE FOR OPEN SHARED OBJECTS.
        *
1024             DL_TABLE = TABLE()
1025             DL_TABLE<0> = 0
        *
        * NOT USED AS TABLES, THESE ARE SIMPLY UNIQUE NON-STRINGS USED TO
        * IDENTIFY EMPTY AND SYMBOL REFERENCE PARAMETERS.
        *
1026             ASM_PEMPTY = TABLE(1, 1)
1027             ASM_PSYMBOL = TABLE(1, 1)                            :(END_ASM)
        *
        * STANDARD EXTRA OPERATIONS FOR ASM CODE. OF COURSE, ANY APPLICATION
        * SPECIFICS CAN BE DEFINED IN THE USING CODE AND ARE FREELY AVAILABLE
        * THIS ALLOWS THE CODE GENERATOR TO BE EASILY TAILORED FOR SPECIFIC
        * NEEDS. FOR EXAMPLE, MACROS COULD BE DEFINED. ALL THREE OF THE
        * PARAMETERS CAN BE STRINGS OR NUMBERS. THE LABEL IS AVAILABLE AS LAB.
        *
        * BE WARNED THOUGH, THAT THIS IS NOT ONLY AN "ASSEMBLER" FORMAT, IT IS
        * ALSO MEANT TO BE USED AS THE RELOCATING LOADER. SO, KEEP AN EYE
        * ON PERFORMANCE!
        *
        * USES - DECLARES OBJECT CODE USES GIVEN LIST OF REGISTERS. IF A NEEDED
        * REGISTER IS NOT AVAIABLE, GIVES A MESSAGES, AND FAILS. IF ALL
        * REGISTERS ARE AVAILABLE, RETURNS SUCCESS.
        *
        * (FIXME - THERE ARE SOME MINOR DIFFERENCES BETWEEN 32 BIT AND 64 BIT
        * CODE GENERATION THAT SHOULD ALSO BE "HIDDEN").
        *
1028    USES__   NE(ASM_PHASE, 1)                                     :S(RETURN)
1029    USES2    P1 ANY('%') =                                         :S(USES2)
1030             P1 = CRACK(P1, ',')
1031             I = 1
1032    USES3    P1<I>                                                :F(RETURN)
1033             FUNCTION(P1<I> '_')                                   :F(USES4)
1034             EQ(APPLY(P1<I> '_',), -1)                             :S(USES4)
1035             I = I + 1                                              :(USES3)
1036    USES4    TERMINAL = 'REGISTER ' P1<I> ' NOT AVAILABLE'        :(FRETURN)
        *
        * ADDRESS - ADDS SYMBOL(ASM) ENTRY ON PHASE2 THAT CAN BE EVALUATED
        * TO AN ADDRESS WITH JIT_ADDRESS(). USEFUL FOR ENTRY POINTS AND
        * CONSTRUCTING JUMP TABLES. COULD USE NOTE(NULL, 0) HERE AS WELL.
        *
1037    ADDRESS__
1038             NE(ASM_PHASE, 2)                                     :S(RETURN)
1039             ENTRIES(ASM)<LAB> = SYMBOLS(ASM)<LAB> = JIT_INDIRECT()
1039    +                                                              :(RETURN)
        *
        * SYMBOL TO BE EXPORTED. BSS, DSS OR ADDRESS. JUST MAKE THE TABLE
        * ENTRY NON-NULL.
        *
1040    EXPORT__ SYMBOL = NE(ASM_PHASE, 1)                            :S(RETURN)
1041             EXPORTS(ASM)<SYMBOL> = ' '
1042             EXPORTS(ASM)<SYMBOL> = VDIFFER(SYMBOLS1(ASM)<SYMBOL>)
1043             SYMBOL =                                              :(RETURN)
        *
        * PHASE1 EVALUATION ONLY. EVAL P1 DURING PHASE1.
        *
1044    PHASE1__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1045             PHASE1 = EVAL(P1)                          :S(RETURN)F(FRETURN)
        *
        * PHASE2 EVALUATION ONLY. EVAL P1 DURING PHASE2.
        *
1046    PHASE2__ NE(ASM_PHASE, 2)                                     :S(RETURN)
1047             PHASE2 = EVAL(P1)                          :S(RETURN)F(FRETURN)
        *
        * ENTER VALUE INTO SYMBOLS1 TABLE. THIS MAY BE INTEGER OR REAL.
        * ALSO NOTE THAT VALUE WILL BE ENTERED INTO THE EXPORTS TABLE IF NEEDED.
        *
        * NOTE THAT EXTERN ADDS TO EXPORTS ON THE DA RESOLUTION PASS, SO IT
        * ISN'T DONE HERE.
        *
1048    DEFINE__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1049             SYMBOLS1(ASM)<LAB> = INTEGER(P1) +P1               :S(DEFINE_2)
1050             SYMBOLS1(ASM)<LAB> = REAL(P1) +P1                   :F(FRETURN)
1051    DEFINE_2 EXPORTS(ASM)<LAB> = DIFFER(EXPORTS(ASM)<LAB>)
1051    +           SYMBOLS1(ASM)<LAB>                                 :(RETURN)
        *
        * ENTER EXTERNAL LINK INTO SYMBOLS1 TABLE. THERE ARE THREE FORMS FOR
        * THIS DIRECTIVE:
        *
        * LABEL EXTERN 'NAME' ; DEFINE LABEL AS DLSYM(, 'NAME')
        * LABEL EXTERN 'NAME','SO' ; 'NAME' IN 'SO'
        * LABEL EXTERN 'NAME','SO',FLAGS ; IN 'SO' OPEN WITH FLAGS
        *
        * P1 = ENTRY NAME, P2 = MODULE NAME, P3 = OPEN FLAGS
        *
1052    EXTERN__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1053             P2 = IDENT(P2) 0
1054             P3 = IDENT(P3) RTLD_NOW
1055             H = DL_TABLE<P2>
1056             DIFFER(H)                                           :S(EXTERN2)
1057             H = DIFFER(P2) DLOPEN(P2, P3)
1058             NE(+H, 0)                                           :S(EXTERN3)
1059             TERMINAL = 'DLOPEN FAILED: ' DLERROR()               :(FRETURN)
1060    EXTERN3  DL_TABLE<P2> = H
1061    EXTERN2  SYMBOLS1(ASM)<LAB> = DLSYM(H, P1)
        *
        * WE CAN AMORTIZE DLOPEN/DLSYM. INSTEAD OF EXTERN IN EACH MODULE,
        * THESE CAN BE EXPORT, AND THEN WE CAN IMPORT IN ANOTHER ASSEMBLY
        *
1062             EXPORTS(ASM)<LAB> = DIFFER(EXPORTS(ASM)<LAB>)
1062    +           SYMBOLS1(ASM)<LAB>                                 :(RETURN)
        *
        * ENTER VALUE AS GLOBAL VARIABLE IN PHASE1. CAN BE USED BY
        * '(EXPRESSION)' AS PARAMETER.
        *
1063    EQU__    NE(ASM_PHASE, 1)                                     :S(RETURN)
1064             $LAB = P1                                             :(RETURN)
        *
        * FOR DATA DEFINITION, WE USE POKE AND THEN PEEK BYTES BACK TO ADD
        * TO THE DINIT STRING. THIS IS DONE TO TAKE CARE OF ENDIAN ISSUES
        * WITH DATA VALUES. EG. POKE_S WILL DEPOSIT THE BYTES IN EITHER
        * BIG OR LITTLE ENDIAN, DEPENDING ON THE ARCHITURE. PEEK WITH THEN
        * RETRIEVE THE BYTES IN THE CORRECT ORDER FOR THAT MACHINE. WHEN THE
        * DSS BLOCK IS POPULATED, DINIT WILL BE READ SIMPLY AS A STREAM OF
        * BYTES, WHICH WILL BE TRANSFERRED INTO MEMORY LINEARLY.
        *
        * FROM NASM - DB/DW/DD/DQ
        * DS IS DEFINE STRING
        *
        * ENTER VALUES INTO DSS
        *
1065    DB__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1066             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
        *
        * A SINGLE BYTE IS NOT CHANGED BY ENDIAN CHARACTERISTICS. JUST APPEND
        * THE BYTE TO THE DINIT STRING.
        *
1067             DINIT(ASM) = INTEGER(P1) DINIT(ASM) CHAR(P1)          :(RETURN)
        *
1068    DW__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1069             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1070             POKE_S(ASM_P, P1)
1071             DINIT(ASM) = DINIT(ASM) PEEK_BUFFER(ASM_P, 2)         :(RETURN)
        *
1072    DD__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1073             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1074             (INTEGER(P1) POKE_I(ASM_P, P1), POKE_F(ASM_P, P1))
1075             DINIT(ASM) = DINIT(ASM) PEEK_BUFFER(ASM_P, 4)         :(RETURN)
        *
1076    DQ__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1077             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1078             (INTEGER(P1) POKE_P(ASM_P, P1), POKE_D(ASM_P, P1))
1079             DINIT(ASM) = DINIT(ASM) PEEK_BUFFER(ASM_P, 8)         :(RETURN)
        *
        * DP IS DEFINE POINTER - ADD TO DPREFS TABLE TO BE RESOLVED (FIXED)
        * FROM SYMBOLS1 ON COMPLETION.
        *
1080    DP__     SYMBOL = NE(ASM_PHASE, 1)                            :S(RETURN)
1081             SYMBOL =
1082             OP1 = TRIM(OP1)
1083             TERMINAL = DIFFER(ASM_DEBUG)
1083    +           'ADDING DP REF ' OP1 ' ' SIZE(DINIT(ASM))
1084             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1085             DPREFS(ASM)<OP1> = LINK(SIZE(DINIT(ASM)), DPREFS(ASM)<OP1>)
        *
        * ACTUAL DATA IS UNKNOWN -- ALL WE KNOW NOW IS THAT IT IS 8 BYTES IN
        * LENGTH
        *
1086             DINIT(ASM) = DINIT(ASM) DUPL(' ', 8)                  :(RETURN)
        *
        * DA IS DEFINE ADDRESS - ADD TO DAREFS TABLE TO BE RESOLVED FROM
        * ENTRIES ON COMPLETION.
        *
1087    DA__     SYMBOL = NE(ASM_PHASE, 1)                            :S(RETURN)
1088             TERMINAL = DIFFER(ASM_DEBUG) 'ADDING DA REF '
1088    +           SYMBOL ' DSS OFFSET ' SIZE(DINIT(ASM))
1089             DAREFS(ASM)<SYMBOL> =
1089    +           LINK(SIZE(DINIT(ASM)), DAREFS(ASM)<SYMBOL>)
1090             SYMBOL =
1091             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
        *
        * ACTUAL DATA IS UNKNOWN -- ALL WE KNOW NOW IS THAT IT IS 8 BYTES IN
        * LENGTH
        *
1092             DINIT(ASM) = DINIT(ASM) DUPL(' ', 8)                  :(RETURN)
        *
1093    DS__     NE(ASM_PHASE, 1)                                     :S(RETURN)
1094             DSS(ASM)<LAB> = DIFFER(LAB) SIZE(DINIT(ASM))
1095             DINIT(ASM) = DINIT(ASM) P1                            :(RETURN)
        *
        * ALIGN BSS DATA ITEM TO ITS NATURAL SIZE. THIS IS NEEDED ON SOME
        * ARCHITECTURES, OR MAY GREATLY INCREASE PERFORMANCE ON OTHERS. WE
        * ONLY DO THIS FOR BSS ITEMS, AND NOT FOR DSS. FOR DSS, EITHER ORDER
        * THE DECLARATIONS, OR PAD MANUALLY.
        *
        * IF IT BECOMES IMPORTANT FOR DSS, WE CAN INTRODUCE AN ALIGN OP THAT
        * CAN DO IT (ALIGN 1,2,4,8). FIXME - AGAIN, DON'T OVER-IMPLEMENT UNTIL
        * IT IS ACTUALLY NEEDED.
        *
1096    ALIGN_BSS
1097             N = REMDR(SZBSS(ASM), A)
1098             EQ(N)                                                :S(RETURN)
1099             SZBSS(ASM) = SZBSS(ASM) + A - N                       :(RETURN)
        *
        * COMMON N - IF LAB IS NOT DEFINED, DEFINE IT IN BSS WITH LENGTH
        * N. MAKE IT EXPORT. IF SYMBOL DOES EXIST, IGNORE, WE ARE JUST LINKING
        * TO THE SAME THING AGAIN.
        *
        * WITHIN COMMON, VARIABLES HAVE OFFSETS FROM THE COMMON BASE. USE
        * DEFINE TO CREATE THESE. COMMON MAKES NO SENSE UNLESS IT IS EXPORTED.
        * (SINCE COMMON SHARES DATA BETWEEN MODULES). SO, AUTOMATICALLY
        * EXPORT THE COMMON DECLARATION. THE COMMON DECLARATION ONLY WORKS
        * IN BSS SPACE. HOWEVER, THE SYMBOL CAN BE RESOLVED TO DSS SPACE.
        *
        *        EXPORT COMMON
        * COMMON DS ''
        * ... OTHER COMMON DSS ITEMS ...
        *
        * WOULD SUFFICE TO DECLARE A COMMON AREA THAT IS INITIALIZED. NOTE
        * THAT, AS USUAL, DSS AND BSS ARE COMPLETELY SEPARATE AREAS, SO ONCE
        * A COMMON IS ESTABLISHED IN DSS SPACE, IT MUST BE *COMPLETELY*
        * INITIALIZED.
        *
1100    COMMON__ NE(ASM_PHASE, 1)                                     :S(RETURN)
1101             IDENT(LAB)                                           :S(RETURN)
1102             DIFFER(SYMBOLS1(ASM)<LAB>)                           :S(RETURN)
1103             ALIGN_BSS(16)
1104             BSS(ASM)<LAB> =
1105             BSS(ASM)<LAB> = SZBSS(ASM)
1106             SZBSS(ASM) = SZBSS(ASM) + P1
1107             SYMBOL = LAB                                        :(EXPORT__)
        *
        * FROM NASM: RESB/RESW/RESD/RESQ (ADDITIONALLY, RES) TO RESERVE SPACE
        * IN BSS.
        *
1108    RESB__   RES(P1, 1)                                            :(RETURN)
1109    RESW__   RES(P1, 2)                                            :(RETURN)
1110    RESD__   RES(P1, 4)                                            :(RETURN)
1111    RESQ__   RES(P1, 8)                                            :(RETURN)
1112    RES      NE(ASM_PHASE, 1)                                     :S(RETURN)
1113             P1 = IDENT(P1) 1
1114             P2 = IDENT(P2) 1
1115             ALIGN_BSS(P2)
1116             BSS(ASM)<LAB> = DIFFER(LAB) SZBSS(ASM)
1117             SZBSS(ASM) = SZBSS(ASM) + (P1 * P2)                   :(RETURN)
        *
        * PARSE PARAMETER. THE PARAMETER MAY BE %REGISTER (EG. %R0, %V1, %F2)
        * %R0-2, %V0-2 AND %F0-5 ARE ALWAYS AVAILABLE. %R3, %V3, %F6-7 MAY
        * BE AVAILABLE. %FP IS THE FRAME POINTER (IF ONE AVAILABLE).
        *
        * 'STRING' OR "STRING". 1234, -1234, +1234 (INTEGER), OR REAL.
        *
        * SYMBOL (A SYMBOL OR LABEL NAME). IF THIS CAN BE RESOLVED FROM
        * THE SYMBOLS1 TABLE IT WILL BE RETURNED AS A SIMPLE NUMBER. HOWEVER,
        * THIS MAY BE A LOCAL LABEL THAT REQUIRES PATCHING.
        *
        * (EXPRESSION). THE EXPRESSION IS RUN THROUGH EVAL(). IT MAY REFERENCE
        * EQU GENERATED SYMBOLS, OR ANY VARIABLES IN THE SNOBOL4 ENVIRONMENT.
        *
1118    ASM_PARM ASM_PARM = ASM_PEMPTY
1119             IDENT(X)                                             :S(RETURN)
1120             X FENCE '%' REM . X                                   :S(ASREG)
1121             X FENCE ('0x' | '0X')  REM . X                        :S(ASHEX)
1122             X FENCE ANY('"' "'" '(')                              :S(ASTRG)
1123             &ERRLIMIT = 1
        *
        * SIMPLE INTEGER OR REAL VALUE
        *
1124             ASM_PARM = +X                                        :S(RETURN)
        *
        * VALUE FROM SYMBOLS1
        *
1125             ASM_PARM = VDIFFER(SYMBOLS1(ASM)<X>)                 :S(RETURN)
        *
        * SYMBOLS1 SYMBOL + OR - OFFSET
        *
1126             X BREAK('+-') . X (ANY('+-') REM) . OFFSET            :F(ASSYM)
1127             X = TRIM(X)
1128             OFFSET FENCE ANY('+-') . SIGN REM . S
1129             S = TRIMB(S)
1130             T = ASM_PARM(S)
1131             S = INTEGER(T) EVAL(SIGN T)                         :F(FRETURN)
1132             ASM_PARM = SYMBOLS1(ASM)<X> + T                       :(RETURN)
        *
        * NOT IN SYMBOLS1, THIS SYMBOL REQUIRES PATCHING DURING THE LINK
        * PROCESS
        *
1133    ASSYM    ASM_PARM = ASM_PSYMBOL
1134             SYMBOL = X                                            :(RETURN)
        *
        * PARAMETER IS A STRING DELIMITED BY SINGLE OR DOUBLE QUOTES. MAY
        * ALSO BE '(EXPRESSION)' WHICH WILL ALSO BE EVAL'D AND GIVES A
        * WAY TO GET SNOBOL ENVIRONMENT EASILY INTO THE ASSEMBLY.
        *
1135    ASTRG    ASM_PARM = EVAL(X)                         :S(RETURN)F(FRETURN)
        *
        * PARAMETER IS A REGISTER. SEE IF ITS CACHED. IF NOT, EVALUATE THE
        * JIT PROCEDURE TO DETERMINE THE REGISTER NUMBER. MAY YIELD -1, WHICH
        * WOULD MEANS THE REGISTER DOESN'T EXIST. 'USES' MUST BE USED TO
        * ELIMINATE THAT CASE. NOTE THAT THE CACHEING IS DONE ONLY TO PREVENT
        * CALLING THE REGISTER FUNCTION IN THE JIT LAYER.
        *
1136    ASREG    ASM_PARM = VDIFFER(AS_REGS<X>)                       :S(RETURN)
1137             FUNCTION(X '_')                                     :F(FRETURN)
1138             AS_REGS<X> = ASM_PARM = APPLY(X '_',)                :S(RETURN)
        *
        * 0XHEX. 0xHEX.
        *
1139    ASHEX    ASM_PARM = +HI(X)                                     :(RETURN)
        *
        * THE DRIVER ASM() FUNCTION. PHASE1 EXTRACTS D?, RES?, EXTERN,
        * EXPORT, DEFINE, AND OTHER NEEDED PHASE1 INFORMATION. THEN, THE
        * BSS AND DSS SECTIONS ARE CREATED. PHASE2 THEN GENERATES THE CODE.
        * LINK RESOLVES INTERNAL BRANCH TARGETS. EMIT ACTUALLY GENERATES THE
        * MACHINE CODE. DA THEN FIXES UP DA (ADDRESS TO CODE OBJECTS), AND
        * FINAL CODE EXPORTS.
        *
1140    ASM      SRC(ASM) = SRC
1141             JIT_SET_STATE(JIT(ASM))
1142             ASM_PHASE(1)                                        :F(FRETURN)
1143             ASM_BSS()                                           :F(FRETURN)
1144             ASM_DSS()                                           :F(FRETURN)
1145             ASM_PHASE(2)                                        :F(FRETURN)
1146             ASM_LINK()                                          :F(FRETURN)
1147             ASM_EMIT()                                          :F(FRETURN)
1148             ASM_DA()                                            :F(FRETURN)
        *
        * CLEAN UP ASM_TYPE STRUCTURE. KEEP JIT, OBJ, EXPORTS, DSSBASE, BSSBASE
        *
1149             SYMBOLS1(ASM) =
1150             SYMBOLS(ASM) =
1151             REFERENCES(ASM) =
1152             DSS(ASM) =
1153             BSS(ASM) =
1154             SZBSS(ASM) =
1155             DINIT(ASM) =
1156             ENTRIES(ASM) =
1157             SRC(ASM) =
1158             DAREFS(ASM) =
1159             DPREFS(ASM) =                                         :(RETURN)
        *
        * ENTRIES ADJUST. FIXUP DA REFERENCES (JUMP TABLES, CODE REFERENCES
        * IN DSS)
        *
1160    ASM_DA   TERMINAL = DIFFER(ASM_DEBUG) '*** DA ***'
1161             A = KEYST(ENTRIES(ASM))
1162             I = 1
1163    ASM_L_13 ENTRIES(ASM)<A<I>> = JIT_ADDRESS(ENTRIES(ASM)<A<I>>)
1163    +                                                             :F(RETURN)
1164             EXPORTS(ASM)<A<I>> = DIFFER(EXPORTS(ASM)<A<I>>)
1164    +           ENTRIES(ASM)<A<I>>
1165             P = DAREFS(ASM)<A<I>>
1166    ASM_L_16 IDENT(P)                                           :S(ASM_L_15)
1167             TERMINAL = DIFFER(ASM_DEBUG)
1167    +           'DA ' VALUE(P) ' TO ' ENTRIES(ASM)<A<I>>
1168             POKE_P(DSSBASE(ASM) + VALUE(P), ENTRIES(ASM)<A<I>>)
1169             P = NEXT(P)                                         :(ASM_L_16)
1170    ASM_L_15 I = I + 1                                           :(ASM_L_13)
        *
        * ASM_EMIT: PRODUCE OBJECT CODE
        *
1171    ASM_EMIT TERMINAL = DIFFER(ASM_DEBUG) '*** EMIT ***'
1172             OBJ(ASM) = JIT_EMIT()                                 :(RETURN)
        *
        * ASM_DSS: ALLOCATE AND INITIALIZE DSS SECTION
        *
1173    ASM_DSS  TERMINAL = DIFFER(ASM_DEBUG) '*** DSS ALLOCATE ***'
1174             DSSBASE(ASM) = MALLOC(SIZE(VDIFFER(DINIT(ASM))))
        *
        * COPY DINIT(ASM) TO MEMORY DSSBASE(ASM)
        *
1175             POKE_BUFFER(DSSBASE(ASM), DINIT(ASM))
        *
1176    ASM_L_12 A = KEYST(DSS(ASM))                                 :F(ASM_DS1)
1177             I = 1
1178    ASM_L_9  SYMBOLS1(ASM)<A<I>> = DSS(ASM)<A<I>> + DSSBASE(ASM)
1178    +                                                            :F(ASM_DS1)
1179             EXPORTS(ASM)<A<I>> = DIFFER(EXPORTS(ASM)<A<I>>)
1179    +           SYMBOLS1(ASM)<A<I>>
        *
1180             TERMINAL = DIFFER(ASM_DEBUG)
1180    +           'PHASE 1 DSS SYMBOL ' A<I> ' = ' IH(SYMBOLS1(ASM)<A<I>>)
        *
1181             I = I + 1                                            :(ASM_L_9)
        *
        * PATCH DSS SECTION POINTERS TO OTHER DSS (OR BSS) VARIABLES.
1182    ASM_DS1  A = KEYST(DPREFS(ASM))                               :F(RETURN)
1183             I = 1
1184    ASM_DS4  P = DPREFS(ASM)<A<I>>                                :F(RETURN)
1185    ASM_DS2  IDENT(P)                                            :S(ASM_DS3)
1186             POKE_P(DSSBASE(ASM) + VALUE(P), SYMBOLS1(ASM)<A<I>>)
1187             P = NEXT(P)                                          :(ASM_DS2)
1188    ASM_DS3  I = I + 1                                            :(ASM_DS4)
        *
        *
        * ALLOCATE BSS SECTION
        *
1189    ASM_BSS  TERMINAL = DIFFER(ASM_DEBUG) '*** BSS ALLOCATE ***'
1190             BSSBASE(ASM) = NE(SZBSS(ASM)) MALLOC(SZBSS(ASM))
1191             A = KEYST(BSS(ASM))
1192             I = 1
1193    ASM_L_7  SYMBOLS1(ASM)<A<I>> = BSS(ASM)<A<I>> + BSSBASE(ASM)  :F(RETURN)
1194             EXPORTS(ASM)<A<I>> = DIFFER(EXPORTS(ASM)<A<I>>)
1194    +           SYMBOLS1(ASM)<A<I>>
        *
1195             TERMINAL = DIFFER(ASM_DEBUG)
1195    +           'PHASE 1 BSS SYMBOL ' A<I> ' = ' IH(SYMBOLS1(ASM)<A<I>>)
        *
1196             I = I + 1                                            :(ASM_L_7)
        *
        * ASM PHASE 1 OR 2.
        *
        * INTERPOLATE A FILE OR A VARIABLE. IF ITS A VARIABLE, ADD A NEWLINE
        * FOR CONVENIENCE.
        *
1197    ASM_INTERPOLATE
1198             TERMINAL = DIFFER(ASM_DEBUG) 'INTERPOLATE ' P1
1199             IDENT(P1)                                            :S(RETURN)
1200             S = (
1200    +              (?(P1 ? FENCE ANY("'" '"')) READFILE(EVAL(P1))),
1200    +              ($P1 CHARS_NL)
1200    +            )
1201             SRC POS(BL) LEN(0) = S                                 :(ASM_2)
        *
1202    ASM_PHASE
1203             TERMINAL = DIFFER(ASM_DEBUG) '*** PHASE ' ASM_PHASE '***'
1204             SRC = SRC(ASM)
1205             BL = 0
1206             EL = 0
        *
        * SPEED OPTIMIZATION. DON'T REMOVE EACH LINE FROM SRC AS IT IS
        * PROCESSED. ALSO, DON'T DO EVER LONGER 'TAB()' (OR POS) TO EACH LINE.
        * INSTEAD, PROCESS EACH LINE, RECORDING THE BEGINNING OF THE NEXT
        * LINE. AFTER WE ARE 4096 CHARACTERS (OR MORE) IN THE STRING,
        * REMOVE THE LEADING BLOCK. THIS REDUCES GC, AND PERFORMS ABOUT
        * TWICE AS WELL AS THE NAIVE CODE. TESTED WITH 10,000 LINES OF
        * ASM INPUT.
        *
        *        SRC FENCE BREAK(CHARS_NL) . LINE CHARS_NL =          :F(RETURN)
1207    ASM_2    SRC FENCE TAB(BL) BREAK(CHARS_NL) CHARS_NL @EL       :F(RETURN)
1208             LINE = SUBSTR(SRC, BL + 1, EL - BL)
1209             BL = EL
1210             LT(BL, 4096)                                         :S(ASM_X1)
1211             SRC FENCE LEN(BL - 1) =
1212             BL = 0
        *
1213    ASM_X1   TERMINAL = DIFFER(ASM_DEBUG) LINE
        *
1214             LINE FENCE NSPAN(' ' CHARS_TAB) ANY(';*')             :S(ASM_2)
1215             LINE = TRIM(LINE)
1216             IDENT(LINE)                                           :S(ASM_2)
1217             ELINE = LINE
1218             LINE FENCE BREAKQ(';') . LINE
1219             LINE = TRIM(LINE) ',,,'
1220             LAB = OP = P1 = P2 = P3 = SYMBOL =
1221             LINE ASM_PAT                                          :S(ASM_4)
1222    ASM_3    TERMINAL = 'ASM: ERROR IN: ' ELINE                   :(FRETURN)
1223    ASM_4    IDENT(OP, 'END')                                     :S(RETURN)
1224             IDENT(OP, 'end')                                     :S(RETURN)
        *
        * INTERPOLATE A FILE OR STRING INTO THE ASSEMBLY
        * INCLUDE 'NAME', OR INCLUDE SYM
        *
1225             IDENT(OP, 'INCLUDE')                        :S(ASM_INTERPOLATE)
1226             IDENT(OP, 'include')                        :S(ASM_INTERPOLATE)
1227             OP = FUNCTION(OP '__') OP '__'                        :S(ASM_5)
1228             OP = EQ(ASM_PHASE, 1)                                 :S(ASM_2)
1229             OP = (IDENT(OP), FUNCTION('JIT_' OP) 'JIT_' OP)       :F(ASM_3)
1230             TERMINAL = VDIFFER(SYMBOLS(ASM)<LAB>) 'REDEFINED'     :S(ASM_3)
1231             SYMBOLS(ASM)<LAB> = DIFFER(LAB) JIT_LABEL()
1232             IDENT(OP)                                             :S(ASM_2)
1233    ASM_5    OP1 = P1
1234             P1 = ASM_PARM(P1)                                     :F(ASM_3)
1235             P1 = IDENT(P1, ASM_PSYMBOL) 0
1236             P2 = ASM_PARM(P2)                                     :F(ASM_3)
1237             P2 = IDENT(P2, ASM_PSYMBOL) 0
1238             P3 = ASM_PARM(P3)                                     :F(ASM_3)
1239             P3 = IDENT(P3, ASM_PSYMBOL) ASM_PEMPTY
1240             &ERRLIMIT = 1
1241             DIFFER(P1, ASM_PEMPTY)                                :S(ASM_6)
1242             R = APPLY(OP,)                                :S(ASM_9)F(ASM_3)
1243    ASM_6    DIFFER(P2, ASM_PEMPTY)                                :S(ASM_7)
1244             R = APPLY(OP, P1,)                            :S(ASM_9)F(ASM_3)
1245    ASM_7    DIFFER(P3, ASM_PEMPTY)                                :S(ASM_8)
1246             R = APPLY(OP, P1, P2,)                        :S(ASM_9)F(ASM_3)
1247    ASM_8    R = APPLY(OP, P1, P2, P3)                     :S(ASM_9)F(ASM_3)
1248    ASM_9
        * JIT_ARG IS SPECIAL, DON'T PATCH THIS SYMBOL. THE LABEL IS RECORDED
        * IN SYMBOLS1 BECAUSE THIS WILL BE THE "BASE" FOR ARGUMENT RETRIEVAL.
        * JIT_ARG IS THE ONLY INSTRUCTION THAT BEHAVES THIS WAY (EVEN NOTE
        * DOESN'T).
1249             IDENT(OP, 'JIT_ARG')                                 :S(ASM_X3)
1250             IDENT(OP, 'jit_arg')                                 :F(ASM_X2)
1251    ASM_X3   SYMBOLS1(ASM)<LAB> = R
1252             SYMBOLS(ASM)<LAB> =                                   :S(ASM_2)
1253    ASM_X2   IDENT(SYMBOL)                                         :S(ASM_2)
1254             EQ(ASM_PHASE, 1)                                      :S(ASM_2)
1255             TERMINAL = IDENT(R) 'INSTRUCTION NOT PATCHABLE'       :S(ASM_3)
        *
1256             TERMINAL =
1256    +           DIFFER(ASM_DEBUG) 'REFERENCE: AT : ' IH(R) ' TO: ' SYMBOL
        *
1257             REFERENCES(ASM)<SYMBOL> = LINK(R, REFERENCES(ASM)<SYMBOL>)
1257    +                                                               :(ASM_2)
        *
1258    ASM_LINK TERMINAL = DIFFER(ASM_DEBUG) '*** LINK ***'
1259             SYMBOLS = SYMBOLS(ASM)
1260             A = KEYST(REFERENCES(ASM))                           :F(RETURN)
1261             I = 1
1262    ASM_L_2  P = REFERENCES(ASM)<A<I>>                           :F(ASM_L_5)
1263             R = SYMBOLS<A<I>>
1264             IDENT(R)                                            :S(ASM_L_4)
        *
1265             TERMINAL = DIFFER(ASM_DEBUG)
1265    +           'ASM_LINK: RESOLVING ' A<I> ' TO ' IH(R)
        *
1266             REFERENCES(ASM)<A<I>> =
1267    ASM_L_3  IDENT(P)                                            :S(ASM_L_4)
        *
1268             TERMINAL =
1268    +      DIFFER(ASM_DEBUG) 'ASM_LINK: PATCHING ' IH(VALUE(P)) ' TO ' IH(R)
1269             JIT_PATCH_AT(VALUE(P), R)
1270             P = NEXT(P)                                          :(ASM_L_3)
1271    ASM_L_4  I = I + 1                                            :(ASM_L_2)
1272    ASM_L_5  A = KEYST(REFERENCES(ASM))                           :F(RETURN)
1273             I = 1
1274    ASM_L_U  TERMINAL = 'UNRESOLVED: ' A<I>                      :F(FRETURN)
1275             I = I + 1                                            :(ASM_L_U)
        *
1276    ASM_CREATE
1277             ASM_CREATE = ASM_TYPE()
        *
        * WE COPY THE INCOMING SYMBOL TABLE. NOTE THAT TEMPORARY SYMBOLS WILL
        * ADDED TO THIS TABLE (EG. FROM JIT_ARG), THAT WE DON'T WANT TO KEEP.
        * IT IS UP TO THE CALLER TO MANAGE GLOBAL SYMBOLS AS APPROPRIATE. THE
        * INCOMING TABLE IS COPIED TO LESSEN THE MANAGEMENT BURDEN ON THE
        * CALLING CODE, AND ISOLATE ANY CHANGES ASM() ITSELF MAKES.
        *
1278             SYMBOLS1(ASM_CREATE) =
1278    +           (DIFFER(SYMBOLS1) COPYT(SYMBOLS1), TABLE())
1279             EXPORTS(ASM_CREATE) = TABLE()
1280             SYMBOLS(ASM_CREATE) = TABLE()
1281             ENTRIES(ASM_CREATE) = TABLE()
1282             DAREFS(ASM_CREATE) = TABLE()
1283             DPREFS(ASM_CREATE) = TABLE()
1284             REFERENCES(ASM_CREATE) = TABLE()
1285             DSS(ASM_CREATE) = TABLE()
1286             BSS(ASM_CREATE) = TABLE()
1287             SZBSS(ASM_CREATE) = 0
1288             DINIT(ASM_CREATE) =
1289             DSSBASE(ASM_CREATE) = 0
1290             BSSBASE(ASM_CREATE) = 0
1291             JIT(ASM_CREATE) = JIT_NEW_STATE()                     :(RETURN)
        *
1292    ASM_DESTROY
1293             FREE(DSSBASE(ASM))
1294             FREE(BSSBASE(ASM))
1295             JIT_SET_STATE(JIT(ASM))
1296             JIT_DESTROY_STATE()                                   :(RETURN)
        *
1297    END_ASM
        -INCLUDE 'ATOL.INC'
        -MODULE ATOL
        -USES LINK()
        -LINE 11 "ATOL.lss"
        -INCLUDE 'LINK.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'REVL.INC'
        -MODULE REVL
        -LINE 11 "REVL.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 45 "REVL.lss"
        -STITL REVL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    ######   #######  #     #  #                      *
        *                    #     #  #        #     #  #                      *
        *                    #     #  #        #     #  #                      *
        *                    ######   #####    #     #  #                      *
        *                    #   #    #         #   #   #                      *
        *                    #    #   #          # #    #                      *
        *                    #     #  #######     #     #######                *
        *                                                                      *
        * REVL                      REVERSE LIST                               *
        *                                                                      *
        ************************************************************************
        *
        * REVL.lss
        *
        -LINE 15 "REVL.lss"
        -PUBLIC REVL()
        *
1298             DEFINE('REVL(L)T')                                  :(REVL_END)
        *
1299    REVL     REVL = L
1300             IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
1301             L = NEXT(REVL)
1302             NEXT(REVL) =
1303    REVL_1   IDENT(L)                                             :S(RETURN)
1304             T = NEXT(L)
1305             NEXT(L) = REVL
1306             REVL = L
1307             L = T                                                 :(REVL_1)
        *
1308    REVL_END
        *
        * CE: .MSNOBOL4;
        -LINE 40 "ATOL.lss"
        -IN72
        -STITL ATOL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                     #     #######  #######  #                        *
        *                    # #       #     #     #  #                        *
        *                   #   #      #     #     #  #                        *
        *                  #     #     #     #     #  #                        *
        *                  #######     #     #     #  #                        *
        *                  #     #     #     #     #  #                        *
        *                  #     #     #     #######  #######                  *
        *                                                                      *
        * ATOL                      ARRAY TO LIST                              *
        *                                                                      *
        ************************************************************************
        *
        * ATOL.lss
        *
        -LINE 17 "ATOL.lss"
        -PUBLIC ATOL()
        *
1309             DEFINE('ATOL(A)I')                                  :(END_ATOL)
        *
1310    ATOL     SEQ(' ATOL = LINK(A<I>, ATOL)', .I)
1311             ATOL = REVL(ATOL)                                     :(RETURN)
        *
1312    END_ATOL
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BALREV.INC'
        -MODULE BALREV
        -LINE 11 "BALREV.lss"
        -IN72
        -LINE 37 "BALREV.lss"
        -STITL BALREV
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *           ######      #     #        ######   #######  #     #       *
        *           #     #    # #    #        #     #  #        #     #       *
        *           #     #   #   #   #        #     #  #        #     #       *
        *           ######   #     #  #        ######   #####    #     #       *
        *           #     #  #######  #        #   #    #         #   #        *
        *           #     #  #     #  #        #    #   #          # #         *
        *           ######   #     #  #######  #     #  #######     #          *
        *                                                                      *
        * BALREV                   BALANCED REVERSE                            *
        *                                                                      *
        ************************************************************************
        *
        * BALREV.lss
        *
        -LINE 14 "BALREV.lss"
        -PUBLIC BALREV()
        *
1313             DEFINE('BALREV(S)')                               :(BALREV_END)
        *
1314    BALREV   BALREV = REPLACE(REVERSE(S), ')(', '()')              :(RETURN)
        *
1315    BALREV_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BALX.INC'
        -MODULE BALX
        -LINE 19 "BALX.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 53 "BALX.lss"
        -STITL BALX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  ######      #     #        #     #                  *
        *                  #     #    # #    #         #   #                   *
        *                  #     #   #   #   #          # #                    *
        *                  ######   #     #  #           #                     *
        *                  #     #  #######  #          # #                    *
        *                  #     #  #     #  #         #   #                   *
        *                  ######   #     #  #######  #     #                  *
        *                                                                      *
        * BALX                      BAL EXTENDED                               *
        *                                                                      *
        ************************************************************************
        *
        * BALX.lss
        *
        -LINE 23 "BALX.lss"
        -PUBLIC BALX()
        *
1316             DEFINE('BALX(PARENS,QTS)Q,GBAL,NAME,STAR,LP,RP')    :(BALX_END)
        *
1317    BALX     NAME = UNIQUE()
1318             STAR = CONVERT(NAME, 'EXPRESSION')
1319             GBAL = NOTANY(PARENS QTS)
1320    BALX_1   QTS LEN(1) . Q =                                     :F(BALX_2)
1321             GBAL = Q BREAK(Q) Q | GBAL                            :(BALX_1)
1322    BALX_2   PARENS LEN(1) . LP  RTAB(1) . PARENS  LEN(1) . RP    :F(BALX_3)
1323             GBAL = LP  (STAR | NULL) RP  |  GBAL                  :(BALX_2)
1324    BALX_3   BALX = GBAL ARBNO(GBAL)
1325             $NAME = BALX                                          :(RETURN)
        *
1326    BALX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BLEND.INC'
        -MODULE BLEND
        -LINE 10 "BLEND.lss"
        -IN72
        -LINE 50 "BLEND.lss"
        -STITL BLEND
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              ######   #        #######  #     #  ######              *
        *              #     #  #        #        ##    #  #     #             *
        *              #     #  #        #        # #   #  #     #             *
        *              ######   #        #####    #  #  #  #     #             *
        *              #     #  #        #        #   # #  #     #             *
        *              #     #  #        #        #    ##  #     #             *
        *              ######   #######  #######  #     #  ######              *
        *                                                                      *
        * BLEND                      BLEND STRINGS                             *
        *                                                                      *
        ************************************************************************
        *
        * BLEND.lss
        *
        -LINE 13 "BLEND.lss"
        -PUBLIC BLEND()
        *
1327             DEFINE('BLEND(S1,S2)T1,T2,ABC,XYZ,L1,L2')
1328             &ALPHABET LEN(128) . ABC LEN(128) . XYZ
1329    BLE_1    ABC LEN(1) . T1 =                                 :F(BLEND_END)
1330             XYZ LEN(1) . T2 =
1331             BLENDED_ALPHABET = BLENDED_ALPHABET T1 T2              :(BLE_1)
        *
1332    BLEND    L1 = SIZE(S1)
1333             GT(L1, 128)                                         :F(BLEND_1)
1334             EQ(L1, 0)                                            :S(RETURN)
1335             S1 LEN(128) . S1 REM . T1
1336             S2 LEN(128) . S2 REM . T2
1337             BLEND = REPLACE(BLENDED_ALPHABET, &ALPHABET, S1 S2)
1338             BLEND(T1, T2)                                         :(RETURN)
1339    BLEND_1  L2 = SIZE(S2)
1340             &ALPHABET LEN(*L1) . ABC TAB(128) LEN(*L2) . XYZ
1341             BLENDED_ALPHABET LEN(*(L1 + L2)) . AXBYCZ
1342             BLEND = REPLACE(AXBYCZ, ABC XYZ, S1 S2)               :(RETURN)
        *
1343    BLEND_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BQ.INC'
        -MODULE BQ
        -LINE 17 "BQ.lss"
        -IN72
        -LINE 75 "BQ.lss"
        -STITL BQ
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                          ######    #####                             *
        *                          #     #  #     #                            *
        *                          #     #  #     #                            *
        *                          ######   #     #                            *
        *                          #     #  #   # #                            *
        *                          #     #  #    #                             *
        *                          ######    #### #                            *
        *                                                                      *
        * BQ          EXECUTE A SHELL COMMAND LINE AND CAPTURE STDOUT          *
        *                                                                      *
        * P BUDNE, JUNE 20, 1994                                               *
        *                                                                      *
        ************************************************************************
        *
        * BQ.lss
        *
        -LINE 20 "BQ.lss"
        -WEAK DDT_ACTIVE, DDT_SUSPEND(), DDT_RESUME()
        -PUBLIC BQ()
        *
1344             DEFINE('BQ(COMMAND,OFS)DDTF')
1345             DEFINE('BQ2(COMMAND,OFS)X,UNIT')                      :(BQ_END)
        *
        -LINE 37 "BQ.lss"
1346    BQ       DDTF = DDT_ACTIVE
1347             NE(DDTF) DDT_SUSPEND()
1348             BQ = BQ2(COMMAND, OFS)                                  :F(BQ3)
1349             NE(DDTF) DDT_RESUME()                                 :(RETURN)
1350    BQ3      NE(DDTF) DDT_RESUME()                                :(FRETURN)
        -LINE 49 "BQ.lss"
1351    BQ2      UNIT = IO_FINDUNIT()                                :F(FRETURN)
1352             INPUT(.X, UNIT,, '|' COMMAND)                       :F(FRETURN)
1353             OFS = IDENT(OFS) ' '
1354             BQ2 = X                                                 :S(BQ4)
1355             ENDFILE(UNIT)
1356             DETACH(.X)                                           :(FRETURN)
1357    BQ4      BQ2 = BQ2 OFS X                                         :S(BQ4)
1358             ENDFILE(UNIT)
1359             DETACH(.X)                                            :(RETURN)
        *
1360    BQ_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'BREAKQ.INC'
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CATA.INC'
        -MODULE CATA
        -LINE 11 "CATA.lss"
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 50 "CATA.lss"
        -STITL CATA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #####      #     #######     #                    *
        *                   #     #    # #       #       # #                   *
        *                   #         #   #      #      #   #                  *
        *                   #        #     #     #     #     #                 *
        *                   #        #######     #     #######                 *
        *                   #     #  #     #     #     #     #                 *
        *                    #####   #     #     #     #     #                 *
        *                                                                      *
        * CATA                     CONCATENATE ARRAYS                          *
        *                                                                      *
        ************************************************************************
        *
        * CATA.lss
        *
        -LINE 15 "CATA.lss"
        -PUBLIC CATA()
        *
1361             DEFINE('CATA(A1,A2)I,N1')                           :(CATA_END)
        *
1362    CATA     N1 = PROTOTYPE(A1)
1363             CATA = ARRAY(N1 + PROTOTYPE(A2))
1364             SEQ(' CATA<I> = A1<I> ', .I)
1365             SEQ(' CATA<N1 + I> = A2<I> ', .I)                     :(RETURN)
        *
1366    CATA_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CGI.INC'
        -MODULE CGI
        -USES CRACK(), HOST(), URL_DECODE(), COOKIE_FIX_NAME()
        -WEAK USE_FCGI, FCGI_ENV, FCGI_IN, FCGI_REQUEST_COMPLETE
        -LINE 606 "CGI.lss"
        -WEAK FCGI_SEND(), FCGI_END()
        -LINE 58 "CGI.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'COOKIE.INC'
        -MODULE COOKIE
        -LINE 49 "COOKIE.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'DEXP.INC'
        -MODULE DEXP
        -LINE 13 "DEXP.lss"
        -IN72
        -LINE 41 "DEXP.lss"
        -STITL DEXP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                   ######   #######  #     #  ######                  *
        *                   #     #  #         #   #   #     #                 *
        *                   #     #  #          # #    #     #                 *
        *                   #     #  #####       #     ######                  *
        *                   #     #  #          # #    #                       *
        *                   #     #  #         #   #   #                       *
        *                   ######   #######  #     #  #                       *
        *                                                                      *
        * DEXP                 SIMPLE FUNCTION DEFINTION                       *
        *                                                                      *
        ************************************************************************
        *
        * DEXP.lss
        *
        -LINE 16 "DEXP.lss"
        -PUBLIC DEXP()
        *
1367             DEFINE('DEXP(PROTO)NAME,ARGS')                      :(DEXP_END)
        *
1368    DEXP     PROTO POS(0) SPAN(' ') =
1369             PROTO BREAK('(') . NAME BAL . ARGS = NAME
1370             CODE(NAME ' ' PROTO ' :S(RETURN)F(FRETURN)')
1371             DEFINE(NAME ARGS)                                     :(RETURN)
        *
1372    DEXP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'TIME.INC'
        -STITL TIME
        -EJECT
        *
        -LINE 78 "TIME.lss"
        ************************************************************************
        *                                                                      *
        *                    #######  ###  #     #  #######                    *
        *                       #      #   ##   ##  #                          *
        *                       #      #   # # # #  #                          *
        *                       #      #   #  #  #  #####                      *
        *                       #      #   #     #  #                          *
        *                       #      #   #     #  #                          *
        *                       #     ###  #     #  #######                    *
        *                                                                      *
        * TIME                    DATE/TIME FUNCTIONS                          *
        *                                                                      *
        * PHILE BUDNE <PHIL@ULTIMATE.COM>                                      *
        * DECEMBER 15, 2010                                                    *
        *                                                                      *
        ************************************************************************
        *
        * TIME.lss
        *
        -LINE 11 "TIME.lss"
        -MODULE TIME
        -PUBLIC TIMEVAL(), TV_SEC(), TV_USEC()
1373             DATA('TIMEVAL(TV_SEC,TV_USEC)')
        -PUBLIC TM(), TM_SEC(), TM_MIN(), TM_HOUR(), TM_MDAY(), TM_MON()
        -PUBLIC TM_YEAR(), TM_WDAY(), TM_YDAY(), TM_ISDST(), TM_GMTOFF()
1374             DATA('TM(TM_SEC,TM_MIN,TM_HOUR,TM_MDAY,TM_MON,'
1374    +                'TM_YEAR,TM_WDAY,TM_YDAY,TM_ISDST,TM_GMTOFF)')
        *
1375             LOAD('GETTIMEOFDAY_(TIMEVAL)')
1376             LOAD('LOCALTIME_(INTEGER,TM)')
1377             LOAD('GMTIME_(INTEGER,TM)')
        -PUBLIC STRFTIME()
1378             LOAD('STRFTIME(STRING,TM)STRING')
        -PUBLIC MKTIME()
1379             LOAD('MKTIME(TM)INTEGER')
        -PUBLIC SLEEP()
1380             LOAD('SLEEP(REAL)')
1381             LOAD('STRPTIME_(STRING,STRING,TM)')
        *
        -PUBLIC GETTIMEOFDAY()
1382             DEFINE('GETTIMEOFDAY()TIMEVAL')             :(GETTIMEOFDAY_END)
        *
1383    GETTIMEOFDAY
1384             GETTIMEOFDAY = TIMEVAL()
1385             GETTIMEOFDAY_(GETTIMEOFDAY)                :S(RETURN)F(FRETURN)
        *
1386    GETTIMEOFDAY_END
        *
        -PUBLIC LOCALTIME()
1387             DEFINE('LOCALTIME(T)TM')                       :(LOCALTIME_END)
        *
1388    LOCALTIME
1389             LOCALTIME = TM()
1390             LOCALTIME_(T, LOCALTIME)                   :S(RETURN)F(FRETURN)
        *
1391    LOCALTIME_END
        *
        -PUBLIC GMTIME()
1392             DEFINE('GMTIME(T)TM')                             :(GMTIME_END)
        *
1393    GMTIME   GMTIME = TM()
1394             GMTIME_(T, GMTIME)                         :S(RETURN)F(FRETURN)
        *
1395    GMTIME_END
        *
        -PUBLIC STRPTIME()
1396             DEFINE('STRPTIME(S,F)TM')                       :(STRPTIME_END)
        *
1397    STRPTIME STRPTIME = TM()
1398             STRPTIME_(S, F, STRPTIME)                  :S(RETURN)F(FRETURN)
        *
1399    STRPTIME_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'VDIFFER.INC'
        -LINE 10 "VDIFFER.lss"
        -INCLUDE 'SYSTEM.INC'
        -STITL VDIFFER
        -EJECT
        -LINE 37 "VDIFFER.lss"
        *
        ************************************************************************
        *                                                                      *
        *      #     #  ######   ###  #######  #######  #######  ######        *
        *      #     #  #     #   #   #        #        #        #     #       *
        *      #     #  #     #   #   #        #        #        #     #       *
        *      #     #  #     #   #   #####    #####    #####    ######        *
        *       #   #   #     #   #   #        #        #        #   #         *
        *        # #    #     #   #   #        #        #        #    #        *
        *         #     ######   ###  #        #        #######  #     #       *
        *                                                                      *
        * VDIFFER            RETURN FIRST ARG IF DIFFER                        *
        *                                                                      *
        ************************************************************************
        *
        * VDIFFER.lss
        *
        -LINE 14 "VDIFFER.lss"
        -MODULE VDIFFER
1400             SYSTEM() 'CSNOBOL4'                             :S(VDIFFER_END)
        -PUBLIC VDIFFER()
1401             DEFINE('VDIFFER(P1,P2)')                         :(VDIFFER_END)
        *
1402    VDIFFER  VDIFFER = DIFFER(P1, P2) P1                :F(FRETURN)S(RETURN)
        *
1403    VDIFFER_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 212 "COOKIE.lss"
        -STITL COOKIE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *            #####   #######  #######  #    #  ###  #######            *
        *           #     #  #     #  #     #  #   #    #   #                  *
        *           #        #     #  #     #  #  #     #   #                  *
        *           #        #     #  #     #  ###      #   #####              *
        *           #        #     #  #     #  #  #     #   #                  *
        *           #     #  #     #  #     #  #   #    #   #                  *
        *            #####   #######  #######  #    #  ###  #######            *
        *                                                                      *
        * COOKIE                    HANDLE COOKIES                             *
        *                                                                      *
        ************************************************************************
        *
        * COOKIE.lss
        *
        -LINE 58 "COOKIE.lss"
        -PUBLIC NEW_COOKIE_JAR(), NEW_COOKIE(), COOKIE_SET_VALUE()
        -PUBLIC COOKIE_VALUE(), COOKIE_SET_CRUMB(), COOKIE_GET_CRUMB()
        -PUBLIC PUT_COOKIE_IN_JAR(), GET_COOKIE_FROM_JAR(), COOKIES_IN_JAR()
        -PUBLIC CRUMBS_IN_COOKIE(), COOKIE_EXPIRY(), COOKIE_STRING()
        -PUBLIC COOKIE_FIX_NAME()
        *
1404             DEFINE('NEW_COOKIE_JAR()')
1405             DEFINE('NEW_COOKIE(VALUE)')
1406             DEFINE('COOKIE_SET_VALUE(COOKIE,VALUE)')
1407             DEFINE('COOKIE_VALUE(COOKIE)')
1408             DEFINE('COOKIE_SET_CRUMB(COOKIE,CRUMB_NAME,VALUE)')
1409             DEFINE('COOKIE_GET_CRUMB(COOKIE,CRUMB_NAME)')
1410             DEFINE('PUT_COOKIE_IN_JAR(COOKIE_JAR,COOKIE_NAME,COOKIE)')
1411             DEFINE('GET_COOKIE_FROM_JAR(COOKIE_JAR,COOKIE_NAME)')
1412             DEFINE('COOKIES_IN_JAR(COOKIE_JAR)')
1413             DEFINE('CRUMBS_IN_COOKIE(COOKIE)')
1414             DEFINE('COOKIE_EXPIRY(N)T,D,M,S')
1415             DEXP('L20_(S) = LPAD(S, 2, "0")')
1416             DEFINE('COOKIE_STRING(COOKIE_JAR)A,B,C,I,J,S,V')
1417             DEFINE('COOKIE_FIX_NAME(S)')
1418                                                               :(COOKIE_END)
        *
        * RETURN COOKIE STRING
        *
1419    COOKIE_STRING
1420             A = COOKIES_IN_JAR(COOKIE_JAR)                       :F(RETURN)
1421    COOKIE_STRING_2
1422             I = I + 1
1423             C = GET_COOKIE_FROM_JAR(COOKIE_JAR, A<I>)   :F(COOKIE_STRING_5)
1424             B = CRUMBS_IN_COOKIE(C)                     :F(COOKIE_STRING_2)
1425             S = S 'Set-Cookie: ' A<I> '=' COOKIE_VALUE(C)
1426             J = 1
1427    COOKIE_STRING_3
1428             J = J + 1
1429             V = COOKIE_GET_CRUMB(C, B<J>)               :F(COOKIE_STRING_4)
1430             S = S '; ' B<J>
1431             S = S '=' VDIFFER(V)                         :(COOKIE_STRING_3)
1432    COOKIE_STRING_4
1433             S = S CHARS_CR CHARS_NL                      :(COOKIE_STRING_2)
1434    COOKIE_STRING_5
1435             COOKIE_STRING = S                                     :(RETURN)
        *
        * RETURN EXPIRES STRING FOR N SECONDS IN THE FUTURE. THIS STRING IS
        * IN THE FORMAT:
        * Wed, 09 Jun 2021 10:18:14 GMT
        * ALL COOKIE EXPIRY IS IN GMT.
        *
1436    COOKIE_EXPIRY
1437             T = TV_SEC(GETTIMEOFDAY()) + N
1438             T = GMTIME(T)
1439             '0Sun1Mon2Tue3Wed4Thu5Fri6Sat' TM_WDAY(T) LEN(3) . D
1440             '0Jan1Feb2Mar3Apr4May5Jun6Jul7Aug8Sep9Oct10Nov11Dec'
1440    +           TM_MON(T) LEN(3) . M
1441             S = D ', ' L20_(TM_MDAY(T)) ' ' M ' ' (TM_YEAR(T) + 1900)
1441    +        ' ' L20_(TM_HOUR(T)) ':' L20_(TM_MIN(T)) ':' L20_(TM_SEC(T))
1441    +        ' GMT'
1442             COOKIE_EXPIRY = S                                     :(RETURN)
        *
        * MAKE A NEW COOKIE JAR
        *
1443    NEW_COOKIE_JAR
1444             NEW_COOKIE_JAR = TABLE()                              :(RETURN)
        *
        * MAKE A NEW COOKIE
        *
1445    NEW_COOKIE
1446             NEW_COOKIE = TABLE()
1447             NEW_COOKIE<''> = VDIFFER(VALUE)                       :(RETURN)
        *
        * SET THE VALUE OF THE COOKIE (ATRIBUTE '')
        *
1448    COOKIE_SET_VALUE
1449             COOKIE<''> = VALUE                                    :(RETURN)
        *
        * RETURN THE VALUE OF THE COOKIE (ATTRIBUTE '')
        *
1450    COOKIE_VALUE
1451             COOKIE_VALUE = COOKIE<''>                             :(RETURN)
        *
1452    COOKIE_FIX_NAME
1453             S = TRIMB(S)
1454             S POS(0) '$' REM . S
1455             COOKIE_FIX_NAME = S                                   :(RETURN)
        *
        * SET AN ATTRIBUTE ON THE COOKIE
        *
1456    COOKIE_SET_CRUMB
1457             CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
1458             COOKIE<CRUMB_NAME> = VALUE                            :(RETURN)
        *
        * GET VALUE OF AN ATTRIBUTE FROM THE COOKIE
        *
1459    COOKIE_GET_CRUMB
1460             CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
1461             COOKIE_GET_CRUMB = COOKIE<CRUMB_NAME>                 :(RETURN)
        *
        * PUT THE COOKIE INTO THE COOKIE JAR, WITH NAME COOKIE_NAME
        *
1462    PUT_COOKIE_IN_JAR
1463             COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
1464             COOKIE_JAR<COOKIE_NAME> = COOKIE                      :(RETURN)
        *
        * GET COOKIE NAMED COOKIE_NAME FROM THE COOKIE JAR
        *
1465    GET_COOKIE_FROM_JAR
1466             COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
1467             GET_COOKIE_FROM_JAR = COOKIE_JAR<COOKIE_NAME>         :(RETURN)
        *
        * RETURN ARRAY OF COOKIE NAMES IN THE COOKIE JAR, SORTED.
        *
1468    COOKIES_IN_JAR
1469             COOKIES_IN_JAR = KEYST(COOKIE_JAR)                  :F(FRETURN)
1470             COOKIES_IN_JAR = SORT(COOKIES_IN_JAR)                 :(RETURN)
        *
        * RETURN ARRAY OF CRUMBS IN THE COOKIE, SORTED. THE FIRST CRUMB WILL
        * BE THE UNAMED VALUE OF THE COOKIE.
        *
1471    CRUMBS_IN_COOKIE
1472             CRUMBS_IN_COOKIE = KEYST(COOKIE)                    :F(FRETURN)
1473             CRUMBS_IN_COOKIE = SORT(CRUMBS_IN_COOKIE)             :(RETURN)
        *
1474    COOKIE_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'DSERVE.INC'
        -MODULE DSERVE
        -LINE 48 "DSERVE.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -MODULE CSNOBOL4
        -LINE 15 "CSNOBOL4.lss"
        -INCLUDE 'FFI.INC'
        -IN72
        -LINE 81 "CSNOBOL4.lss"
        -STITL CSNOBOL4
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  #####    #####   #     #  #######  ######   #######  #        #   # *
        * #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *
        * #        #        # #   #  #     #  #     #  #     #  #        #   # *
        * #         #####   #  #  #  #     #  ######   #     #  #        ##### *
        * #              #  #   # #  #     #  #     #  #     #  #            # *
        * #     #  #     #  #    ##  #     #  #     #  #     #  #            # *
        *  #####    #####   #     #  #######  ######   #######  #######      # *
        *                                                                      *
        * CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *
        *                                                                      *
        ************************************************************************
        *
        * CSNOBOL4.lss
        *
        -LINE 27 "CSNOBOL4.lss"
        -PUBLIC SPRINTF()
        *
1475             LOAD('SPRINTF(STRING,)STRING')
        -LINE 42 "CSNOBOL4.lss"
        *
        -PUBLIC IO_GETFP()
        *
1476             IO_GETFP_FFI = FFI_NEW('P', 'I')
1477             FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, 'io_getfp'))
1478             DEFINE('IO_GETFP(UNIT)')                        :(CSNOBOL4_END)
        *
1479    IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
1480             IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 :(RETURN)
        *
1481    CSNOBOL4_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'P64.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'DDT.INC'
        -MODULE DDT
        -WEAK DSERVE_APPNAME
        -USES SLOAD()
        -LINE 706 "DDT.lss"
        -LINE 65 "DDT.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'FREEZE.INC'
        -MODULE FREEZE
        -LINE 7 "FREEZE.lss"
        -INCLUDE 'SYSTEM.INC'
        -IN72
        -LINE 36 "FREEZE.lss"
        -STITL FREEZE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #######  ######   #######  #######  #######  #######         *
        *         #        #     #  #        #             #   #               *
        *         #        #     #  #        #            #    #               *
        *         #####    ######   #####    #####      #      #####           *
        *         #        #   #    #        #         #       #               *
        *         #        #    #   #        #        #        #               *
        *         #        #     #  #######  #######  #######  #######         *
        *                                                                      *
        * FREEZE            FREEZE AND THAW FOR SPITBOL                        *
        *                                                                      *
        ************************************************************************
        *
        * FREEZE.lss
        *
        -LINE 11 "FREEZE.lss"
        -MODULE FREEZE
1482             SYSTEM() 'CSNOBOL4'                              :S(FREEZE_END)
        -PUBLIC FREEZE(), THAW()
1483             DEFINE('FREEZE(X)')
1484             DEFINE('THAW(X)')                                 :(FREEZE_END)
        *
1485    FREEZE
1486    THAW                                                           :(RETURN)
        *
1487    FREEZE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HOST.INC'
        -MODULE HOST
        -LINE 8 "HOST.lss"
        -IN72
        -LINE 162 "HOST.lss"
        -STITL HOST
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #     #  #######   #####   #######                   *
        *                 #     #  #     #  #     #     #                      *
        *                 #     #  #     #  #           #                      *
        *                 #######  #     #   #####      #                      *
        *                 #     #  #     #        #     #                      *
        *                 #     #  #     #  #     #     #                      *
        *                 #     #  #######   #####      #                      *
        *                                                                      *
        * HOST               HOST() FUNCTION CODES                             *
        *                                                                      *
        ************************************************************************
        *
        * HOST.lss
        *
        -LINE 11 "HOST.lss"
1488    HOST
        *
        *
        * MACRO SPITBOL
        *
        -PUBLIC HOST_SYSINFO, HOST_PARAMS
        *
        * ARCH:OS:SNOBOL_VERSION
1489             HOST_SYSINFO = ''
        * ARGUMENT FROM -u OR ENTIRE COMMAND LINE
1490             HOST_PARAMS = 0
        *
        * CATSPAW SPITBOL
        *
        -PUBLIC HOST_SYSCMD, HOST_ARGN, HOST_FIRSTARG, HOST_GETENV
        *
        * EXEC ARG AS SHELL COMMAND, RETURN STATUS
1491             HOST_SYSCMD = 1
        * N'TH TOKEN ON COMMAND LINE (INTEGER)
1492             HOST_ARGN = 2
        * INDEX OF 1ST USER COMMAND LINE ARG TOKEN
1493             HOST_FIRSTARG = 3
        * RETURNS ENVIRONMENT VARIABLE, OR FAILS
1494             HOST_GETENV = 4
        *
        -PUBLIC HOST_SNOLIB_DIR
        *
        * DEFAULT SNOLIB DIR (-INCLUDE, LOAD())
1495             HOST_SNOLIB_DIR = 2200
        *
        -PUBLIC HOST_CC, HOST_COPT
        *
        * C COMPILER USED TO BUILD CSNOBOL4
1496             HOST_CC = 2202
        * C OPTIMIZER FLAGS USED TO BUILD CSNOBOL4
1497             HOST_COPT = 2203
        *
        -PUBLIC HOST_DL_EXT, HOST_DL_CFLAGS, HOST_DL_LD,HOST_DL_LDFLAGS
        *
        * DYNAMIC LOADABLE LIBRARY EXTENSION
1498             HOST_DL_EXT = 2208
        * C COMPILER FLAGS FOR DYNAMIC LOADABLES
1499             HOST_DL_CFLAGS = 2209
        * DYNAMIC LOADABLE FILE LOAD COMMAND
1500             HOST_DL_LD = 2210
        * DYNAMIC LOADABLE FILE LOAD SWITCHES
1501             HOST_DL_LDFLAGS = 2211
        *
        -PUBLIC HOST_DIR_SEP, HOST_PATH_SEP
        *
        * DIRECTORY SEPARATOR CHAR (MAY BE EMPTY)
1502             HOST_DIR_SEP = 2212
        * PATH SEPARATOR CHARACTER
1503             HOST_PATH_SEP = 2213
        *
        * CSNOBOL4 1.5
        *
        -PUBLIC HOST_DEF_SNOPATH, HOST_INCUDE_DIR
        *
        * DEFAULT LIBRARY SEARCH PATH
1504             HOST_DEF_SNOPATH = 2214
        * PATH FOR C HEADERS
1505             HOST_INCLUDE_DIR = 2215
        *
        -PUBLIC HOST_INTEGER_BITS, HOST_REAL_BITS, HOST_POINTER_BITS
        -PUBLIC HOST_LONG_BITS, HOST_DESCR_BITS, HOST_SPEC_BITS, HOST_CHAR_BITS
        *
        * NUMBER OF BITS FOR SNOBOL4 INTEGER TYPE
1506             HOST_INTEGER_BITS = 2300
        * NUMBER OF BITS FOR SNOBOL4 REAL TYPE
1507             HOST_REAL_BITS = 2301
        * NUMBER OF BITS FOR C POINTER TYPE
1508             HOST_POINTER_BITS = 2302
        * NUMBER OF BITS FOR C LONG TYPE
1509             HOST_LONG_BITS = 2303
        * NUMBER OF BITS FOR SIL 'DESCRIPTOR' TYPE
1510             HOST_DESCR_BITS = 2304
        * NUMBER OF BITS FOR SIL 'SPECIFIER' TYPE
1511             HOST_SPEC_BITS = 2305
        * NUMBER OF BITS FOR C CHAR TYPE
1512             HOST_CHAR_BITS = 2306
        *
        -PUBLIC HOST_DYNAMIC_SIZE, HOST_PMSTACK_SIZE, HOST_ISTACK_SIZE
        *
        * SIZE OF 'DYNAMIC' STORAGE IN DESCRIPTORS
1513             HOST_DYNAMIC_SIZE = 2400
        * SIZE OF PATTERN MATCH STACK IN DESCRS
1514             HOST_PMSTACK_SIZE = 2401
        * SIZE OF INTERPRETER STACK IN DESCRIPTORS
1515             HOST_ISTACK_SIZE = 2402
        *
1516        CODE('HOST')
        *
1517    HOST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'QUOTE.INC'
        -MODULE QUOTE
        -LINE 11 "QUOTE.lss"
        -INCLUDE 'REPL.INC'
        -IN72
        -LINE 38 "QUOTE.lss"
        -STITL QUOTE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #####   #     #  #######  #######  #######             *
        *              #     #  #     #  #     #     #     #                   *
        *              #     #  #     #  #     #     #     #                   *
        *              #     #  #     #  #     #     #     #####               *
        *              #   # #  #     #  #     #     #     #                   *
        *              #    #   #     #  #     #     #     #                   *
        *               #### #   #####   #######     #     #######             *
        *                                                                      *
        * QUOTE                      QUOTE A STRING                            *
        *                                                                      *
        ************************************************************************
        *
        * QUOTE.lss
        *
        -LINE 15 "QUOTE.lss"
        -PUBLIC QUOTE()
        *
1518             DEFINE('QUOTE(S)Q,QQ')                             :(QUOTE_END)
        *
1520    QUOTE    Q = "'"; QQ = '"'
1521             QUOTE = Q REPL(S, Q, Q ' ' QQ Q QQ ' ' Q) Q           :(RETURN)
        *
1522    QUOTE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READLINE.INC'
        -MODULE READLINE
        -LINE 9 "READLINE.lss"
        -IN72
        -LINE 34 "READLINE.lss"
        -STITL READLINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  ######   #######     #     ######   #        ###  #     #  #######  *
        *  #     #  #          # #    #     #  #         #   ##    #  #        *
        *  #     #  #         #   #   #     #  #         #   # #   #  #        *
        *  ######   #####    #     #  #     #  #         #   #  #  #  #####    *
        *  #   #    #        #######  #     #  #         #   #   # #  #        *
        *  #    #   #        #     #  #     #  #         #   #    ##  #        *
        *  #     #  #######  #     #  ######   #######  ###  #     #  #######  *
        *                                                                      *
        * READLINE                 READLINE FUNCTIONS                          *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * JANUARY 3, 2011                                                      *
        *                                                                      *
        ************************************************************************
        *
        * READLINE.lss
        *
        -LINE 12 "READLINE.lss"
        -PUBLIC READLINE(), ADD_HISTORY(), HISTORY_EXPAND()
        *
1523    READLINE LOAD('READLINE(STRING)STRING')
1524             LOAD('ADD_HISTORY(STRING)STRING')
1525             LOAD('HISTORY_EXPAND(STRING)STRING')
        *
1526             CODE('READLINE')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SLOAD.INC'
        -LINE 12 "SLOAD.lss"
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'TRIMB.INC'
        -STITL SLOAD
        -EJECT
        -LINE 112 "SLOAD.lss"
        *
        ************************************************************************
        *                                                                      *
        *              #####   #        #######     #     ######               *
        *             #     #  #        #     #    # #    #     #              *
        *             #        #        #     #   #   #   #     #              *
        *              #####   #        #     #  #     #  #     #              *
        *                   #  #        #     #  #######  #     #              *
        *             #     #  #        #     #  #     #  #     #              *
        *              #####   #######  #######  #     #  ######               *
        *                                                                      *
        * SLOAD                LOAD SNOBOL4 SOURCE                             *
        *                                                                      *
        * (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *
        *                                                                      *
        * MODIFIED TO SUPPORT /DEV FILES, SEARCH CSNOBOL4 PATHS                *
        *                                                                      *
        ************************************************************************
        *
        * SLOAD.lss
        *
        -LINE 18 "SLOAD.lss"
        -MODULE SLOAD
        -PUBLIC SLOAD()
1527             DEFINE('SLOAD(FILENAME)'
1527    +               'LIB,CODE,PATH,X,A,I,P,PS,DS,TRIM_SAV,POSITION,UNIT')
1528             Q_ = "'"
1529             QQ_ = '"'
1530             SLOAD_STMT = ARBNO(Q_ BREAK(Q_) Q_ | QQ_ BREAK(QQ_) QQ_ |
1530    +                     NOTANY(Q_ QQ_) BREAK(Q_ QQ_ ';')) ';'
1531             SLOAD_STMTS = FENCE (';' ARBNO(SLOAD_STMT)) . X '*' REM
        * NOTE THAT ; FOLLOWED BY ANYTHING OTHER THAN . OR + IS ALSO A COMMENT
1532             SLOAD_CCPAT = FENCE ('*' | '-' | '#' | '!' | '|' | RPOS(0))
1533             SLOAD_CNPAT = FENCE (';.' | ';+')
1534             SLOAD_INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
1534    +                                (ANY('Cc') ('OPY' | 'opy')))
1534    +                      BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
1535             SLOAD_TAB = TABLE()                                :(SLOAD_END)
        *
        * FUNCTION TO READ AND COMPILE SNOBOL4 FUNCTIONS FROM A DISK FILE.
        * THE FILENAME IS SPECIFIED AS THE ARGUMENT TO FUNCTION SLOAD.
        *
1536    SLOAD    UNIT = IO_FINDUNIT()
1537             PATH = FILENAME
1538             INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
1539             DS = HOST(HOST_DIR_SEP)
1540             PS = HOST(HOST_PATH_SEP)
1541             X = HOST(HOST_GETENV, 'SNOPATH')                    :S(SLOAD_8)
1542             X = HOST(HOST_GETENV, 'SNOLIB')                     :S(SLOAD_8)
1543             X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
1544    SLOAD_8  A = CRACK(X, PS)
1545             I = 1
1546    SLOAD_10 P = TRIMB(A<I>)                                     :F(FRETURN)
1547             PATH = P DS FILENAME
1548             INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
1549             I = I + 1                                           :(SLOAD_10)
        *
1550    SLOAD_0  TRIM_SAV = &TRIM
1551             &TRIM = 1
        *
1552    SLOAD_1  X = LIB                                             :F(SLOAD_2)
1553             X SLOAD_CCPAT                                       :S(SLOAD_4)
1554             X = ';' X
1555             X SLOAD_CNPAT = ' '
1556             X SLOAD_STMTS
1557             CODE = CODE X                                        :(SLOAD_1)
        *
1558    SLOAD_4  X SLOAD_INPAT                                       :F(SLOAD_1)
1559             DIFFER(SLOAD_TAB<X>)                                :S(SLOAD_1)
        *
1560             POSITION = SET(UNIT, 0, 1)
1561             ENDFILE(UNIT)
1562             DETACH(.LIB)
        *
1563             SLOAD(X)                                            :F(FRETURN)
        *
1564             INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
        *
1565             SLOAD_TAB<X> = 1
1566             FILENAME FENCE '/dev/'                              :S(SLOAD_1)
1567             EQ(SET(UNIT, POSITION, 0), POSITION)      :S(SLOAD_1)F(FRETURN)
        *
1568    SLOAD_2  ENDFILE(UNIT)
1569             DETACH(.LIB)
1570             CODE = CODE(CODE '; :(SLOAD_3)')                       :S<CODE>
1571             TERMINAL = 'COMPILATION ERROR, FILE: ' FILENAME
        *
        * ERROR. TAKE CODE APART STATEMENT BY STATEMENT TO FIND THE PROBLEM.
        * FIRST REMOVE FROM INCLUDE FILE TABLE, THEN REMOVE INITIAL ';'
        *
1572             SLOAD_TAB<X> =
1573             CODE = SUBSTR(CODE, 2)
1574    SLOAD_6  CODE FENCE SLOAD_STMT . X =                         :F(SLOAD_7)
1575             CODE(X)                                             :S(SLOAD_6)
1576             X RTAB(1) . TERMINAL
1577    SLOAD_7  &TRIM = TRIM_SAV
1578             TERMINAL = &ERRTEXT                                  :(FRETURN)
        *
1579    SLOAD_3  &TRIM = TRIM_SAV                                      :(RETURN)
        *
1580    SLOAD_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'VDIFFER.INC'
        -INCLUDE 'EDITLINE.INC'
        -MODULE EDITLINE
        -LINE 10 "EDITLINE.lss"
        -IN72
        -LINE 163 "EDITLINE.lss"
        -STITL EDITLINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #######  ######   ###  #######  #        ###  #     #  #######    *
        *    #        #     #   #      #     #         #   ##    #  #          *
        *    #        #     #   #      #     #         #   # #   #  #          *
        *    #####    #     #   #      #     #         #   #  #  #  #####      *
        *    #        #     #   #      #     #         #   #   # #  #          *
        *    #        #     #   #      #     #         #   #    ##  #          *
        *    #######  ######   ###     #     #######  ###  #     #  #######    *
        *                                                                      *
        * EDITLINE                 EDIT LINE FUNCTIONS                         *
        *                                                                      *
        ************************************************************************
        *
        * EDITLINE.lss
        *
        -LINE 13 "EDITLINE.lss"
        -LINE 14 "EDITLINE.lss"
        -LINE 15 "EDITLINE.lss"
        -LINE 16 "EDITLINE.lss"
        -LINE 17 "EDITLINE.lss"
        -LINE 18 "EDITLINE.lss"
        -LINE 19 "EDITLINE.lss"
        -LINE 22 "EDITLINE.lss"
1581             EDITLINE = 'editline.c'
        -LINE 122 "EDITLINE.lss"
        -LINE 123 "EDITLINE.lss"
        -LINE 124 "EDITLINE.lss"
        -LINE 125 "EDITLINE.lss"
        -LINE 126 "EDITLINE.lss"
        -LINE 127 "EDITLINE.lss"
        -LINE 136 "EDITLINE.lss"
        *
        -PUBLIC EDITLINE(), RLAPPNAME(), CLEAR_HISTORY(), STIFLE_HISTORY()
        -PUBLIC READ_HISTORY(), WRITE_HISTORY()
        *
1582    EDITLINE LOAD('EDITLINE(STRING,STRING)STRING', 'editline.so')
1583             LOAD('RLAPPNAME(STRING)', 'editline.so')
1584             LOAD('CLEAR_HISTORY()', 'editline.so')
1585             LOAD('STIFLE_HISTORY(INTEGER)', 'editline.so')
1586             LOAD('READ_HISTORY(STRING)INTEGER', 'editline.so')
1587             LOAD('WRITE_HISTORY(STRING)INTEGER', 'editline.so')
        *
1588             CODE('EDITLINE')
        *
        * CE: .MSNOBOL4;
        -IN72
        -STITL DDT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      ######   ######   #######                       *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      ######   ######      #                          *
        *                                                                      *
        * DDT             AN INTERACTIVE SNOBOL4 DEBUGGER                      *
        *                                                                      *
        ************************************************************************
        *
        * DDT.lss
        *
        -LINE 77 "DDT.lss"
        -PUBLIC DDT(), DEBUG(), DDT_LOADED, DDT_ACTIVE
        *
1589             DEFINE('DDT(S)')
1590             DEFINE('DEBUG(S)', 'DDT')
        *
1591             DDT_LOADED = 1
1592             DDT_ACTIVE = 0
        *
        * REMOTE DEBUG, DDT_USE_R IS FLAG TO GET INPUT FROM REMOTE (= 1).
        * IF 2, WE ARE IN GUI.
        * DDT_T IS OUTPUT (ALWAYS) AND DDT_R IN READ CHANNEL. IF DDT_USE_R
        * IS NULL, READLINE() WILL BE USED. IF IT IS NOT NULL, DDT_R WILL
        * BE USED FOR COMMANDS AND INPUT.
        *
        -PUBLIC DDT_T, DDT_USE_R, DDT_R
        *
1593             DDT_T_UNIT = IO_FINDUNIT()
1594             OUTPUT(.DDT_T, DDT_T_UNIT, 'W', '/dev/stderr')
1595             DDT_USE_R =
        *        DDT_R_UNIT = IO_FINDUNIT()
        *        INPUT(.DDT_R, DDT_R_UNIT,, '/dev/stdin')
1596                                                                  :(DDT_END)
        *
1597    DDT      DDT_ACTIVE = 1
1598             DDT_COUNT = 0
1599             DDT_IGNORE =
1600             DDT_UNIT2 =
1601             RLAPPNAME('DDT')
1602             READ_HISTORY('.DDT')
1603             STIFLE_HISTORY(50)
1604             DEFINE('DDT(S)', 'DDT_')
1605             DEFINE('DEBUG(S)', 'DDT_')
1606             DEFINE('DDT_SOURCE()')
        -LINE 120 "DDT.lss"
        -PUBLIC DDT_SUSPEND(), DDT_RESUME(), DDT_TOUT()
1607             DEFINE('DDT_SUSPEND()', 'DDT.O')
1608             DEFINE('DDT_RESUME()')
1609             DEFINE('DDT_TOUT(S)')
        *
1610             DDT_TOUT('DDT (FRI MAY 23 15:30:53 EDT 2014)')
1611             DDT_TOUT('TRY H FOR HELP')
1612             DDT_SOURCE =
1613             DDT_LIST_F =
1614             DDT_LIST_L =
1615             DDT_FINAL_STMT =
1616             DDT_CURR_STMT =
1617             DDT_BREAK_TAB = TABLE()
1618             DDT_BREAK_TEMP = TABLE()
1619             DDT_STEP_COUNT = 1
1620             DDT_FNCLEVEL = 50000
1621             DDT_WHITE = CHARS_HT ' '
1622             DDT_G_PAT = FENCE '=' (BREAK(DDT_WHITE ',') | REM)
1622    +           . DDT_CMD (SPAN(DDT_WHITE ',') | RPOS(0))
1623             DDT_CHARU = CHARS_HT ' CBE=GHKLPQRTI+-?!XOSMV*.'
1624             DDT_CHARL = CHARS_HT ' cbe=ghklpqrti+-?!xosmv*.'
1625             DDT_CHARR =      'C' 'CCBEEGHKLPQRTI+-HXXOSMV*.'
1626             DDT_CHARS = FENCE ANY(DDT_CHARU DDT_CHARL) . DDT_C
1626    +           (SPAN(DDT_WHITE) | '')
1627             DDT_DL_PAT = FENCE LEN(8) (NOTANY(DDT_WHITE)
1627    +           (BREAK(DDT_WHITE CHARS_NL) | REM)) . DDT_LABEL
1628             DDT_GET_PAT1 = FENCE SPAN(&DIGITS) . DDT_GET_STMT
1628    +           (SPAN(DDT_WHITE ',') | RPOS(0))
1629             DDT_GET_PAT2 = FENCE (BREAK(',') | REM) . LABEL
1629    +           (SPAN(DDT_WHITE ',') | RPOS(0))
1630             DDT_GET_PAT3 = FENCE BREAK('+-' DDT_WHITE) . LABEL
1630    +           BREAK('+-') LEN(1) . SIGN BREAK(&DIGITS)
1630    +           SPAN(&DIGITS) . OFFSET
1630    +           (SPAN(DDT_WHITE ',') | RPOS(0))
1631             DEFINE('DDT_LABEL(STNO)OFFSET')
1632             DEFINE('DDT_GET_STMT(S)LABEL,SIGN,OFFSET')
1633             DEFINE('DDT_FNC()')
1634             DEFINE('DDT_CASE(DDT_CASE)')
1635             DEFINE('DDT_CMD()'
1635    +           'DDT_A,DDT_B,DDT_C,DDT_IN,DDT_I,DDT_FIELD,DDT_RESULT,DDT_V')
1636             DEFINE('DDT_READLIST(LABTAB,LAST)'
1636    +           'STNO,STMT,LINE,LABEL,PAT1,PAT2,PAT3,PAT4,PAT5')
1637             DDT_STMTS = TABLE()
1638             DDT_LBLS = TABLE(50, 50)
1639             FREEZE(DDT_STMTS)
1640             FREEZE(DDT_LBLS)
1641             FREEZE(DDT_BREAK_TAB)
1642             FREEZE(DDT_BREAK_TEMP)
1643             HOST(HOST_GETENV, 'LIST')                              :F(DDT_)
1644             DDT_SOURCE()
        *
        -LINE 181 "DDT.lss"
1645    DDT_     S DDT_IGNORE                                          :F(DDT2_)
1646             DDT_COUNT = GT(DDT_COUNT) DDT_COUNT - 1              :S(RETURN)
1647    DDT2_    DDT_STEP_COUNT = 1
1648             DDT_FNCLEVEL = 50000
1649             DDT_TOUT('DDT(' S ')')
1650    DDT_RESUME
1651             &STLIMIT = 999999999
1652             &TRACE = 999999999
1653             TRACE('STCOUNT', 'KEYWORD',, 'DDT_FNC')               :(RETURN)
        *
        * CURRENT STATEMENT
        *
1654    DDT_FNC  DDT_CURR_STMT = &LASTNO
        *
        * IF NOT SINGLE-STEPPING AND DID NOT HIT A BREAKPOINT, JUST RETURN.
        *
1655             (LE(DDT_STEP_COUNT)
1655    +           IDENT(DDT_BREAK_TAB<DDT_CURR_STMT>)
1655    +           IDENT(DDT_BREAK_TEMP<DDT_CURR_STMT>))             :S(RETURN)
        *
        * IF IT WAS A BREAKPOINT, TURN OFF ANY SINGLE-STEPPING.
        *
1656             DDT_STEP_COUNT = DIFFER(DDT_BREAK_TAB<DDT_CURR_STMT>)
1656    +                                                        :S(DDT_DISPLAY)
1657             DDT_STEP_COUNT = DIFFER(DDT_BREAK_TEMP<DDT_CURR_STMT>)
1657    +                                                        :S(DDT_DISPLAY)
        *
        * IF DOING A P TRACE, DON'T STOP IF DOWN IN A FUNCTION.
        *
1658             GT(&FNCLEVEL, DDT_FNCLEVEL)                          :S(RETURN)
        *
        * MUST HAVE BEEN SINGLE-STEPPING. DECREMENT COUNT.
        *
1659             DDT_STEP_COUNT = DDT_STEP_COUNT - 1
        *
        * DISPLAY CURRENT STATEMENT.
        *
1660    DDT_DISPLAY
1661             DIFFER(DDT_HOOK)                              :S(DDT_DISPLAY_2)
1662             DDT_FNC = DDT_LABEL(DDT_CURR_STMT)
1663             DDT_TOUT(VDIFFER(DDT_FNC))
1664             DDT_TOUT(DIFFER(DDT_FINAL_STMT) DDT_STMTS<DDT_CURR_STMT>)
1665             DDT_TOUT(IDENT(DDT_FINAL_STMT) DDT_CURR_STMT)
        *
        * CALL EXTERNAL ROUTINE IF DEFINED TO REGISTER BREAK. THIS CAN
        * REPLICATE SOME OF THE ABOVE IF NEEDED.
        *
        -PUBLIC DDT_HOOK
1666    DDT_DISPLAY_2
1667             DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'BREAK', DDT_CURR_STMT)
        *
        * LISTING BEGINS HERE
        *
1668             DDT_LIST_F = DDT_CURR_STMT
1669             DDT_LIST_L = DDT_CURR_STMT
        *
        * IF MORE SINGLE-STEPPING TO DO, JUST EXIT
        *
1670             GT(DDT_STEP_COUNT)                                   :S(RETURN)
        *
        -LINE 251 "DDT.lss"
1671             THAW(DDT_BREAK_TAB)
1672             THAW(DDT_BREAK_TEMP)
1673             DDT_BREAK_TEMP = TABLE()
1674             DDT_ACTIVE = 1
1675             DDT_CURR_STMT = DDT_CMD()                            :F(RETURN)
        *
        * JUMP TO USER'S LABEL WITHOUT CLEARING INTERRUPT
        *
1676             &TRACE = 999999999                            :($DDT_CURR_STMT)
        *
        * CONVERT TO UPPERCASE IF SOURCE IS NOT CASE SENSITIVE
        *
1677    DDT_CASE DDT_CASE = NE(&CASE)
1677    +           REPLACE(DDT_CASE, &LCASE, &UCASE)                  :(RETURN)
        *
        -LINE 273 "DDT.lss"
1678    DDT_LABEL
1679             IDENT(DDT_FINAL_STMT)                                :S(RETURN)
1680    DDT_LAB2 DDT_STMTS<STNO> DDT_DL_PAT                         :S(DDT_LAB1)
1681             STNO = GT(STNO, 1) STNO - 1                        :F(DDT_LAB1)
1682             OFFSET = OFFSET + 1                                 :(DDT_LAB2)
1683    DDT_LAB1 DDT_LABEL = IDENT(OFFSET) '(' DDT_LABEL ')'          :S(RETURN)
1684             DDT_LABEL = '(' DDT_LABEL ' + ' OFFSET ')'            :(RETURN)
        *
        -LINE 293 "DDT.lss"
1685    DDT_GET_STMT
1686             IDENT($S)                                            :S(RETURN)
        * CHECK FOR SIMPLE NUMBER
1687             $S DDT_GET_PAT1 =                                    :S(RETURN)
        * CHECK FOR TEXT LABEL
1688             $S DDT_GET_PAT2 =                                  :F(DDT_GET1)
        * CHECK FOR OPTIONAL +N OR -N AFTER LABEL
1689             LABEL DDT_GET_PAT3
1690             OFFSET = IDENT(SIGN, '-') -OFFSET
        * MAP CASE-CONVERTED LABEL TO STATEMENT NUMBER
1691             DDT_GET_STMT = DDT_LBLS<DDT_CASE(LABEL)>
        * CHECK IF LABEL UNKNOWN TO US, AND ADD OFFSET.
1692             DDT_GET_STMT = VDIFFER(DDT_GET_STMT)
1692    +           + OFFSET                                          :S(RETURN)
1693    DDT_GET1 DDT_TOUT('BAD LABEL OR STATEMENT NUMBER')            :(FRETURN)
        *
        -LINE 318 "DDT.lss"
1694    DDT_READLIST
1695             PAT1 = FENCE (LEN(4) | SPAN(&DIGITS)) . STNO
1695    +           (LEN(4) | '') REM . STMT
1696             PAT2 = FENCE (NOTANY('-+.*;|#! ' CHARS_NP CHARS_HT)
1696    +           BREAK(CHARS_HT ' ') ) . LABEL
1697             PAT3 = FENCE NOTANY(&DIGITS ' ' CHARS_HT)
1698             PAT4 = FENCE ANY('+.')
1699             PAT5 = FENCE ANY('*;|#!')
1700             DDT_READLIST = TABLE(151)
1701    DDT_RL1  LINE = TRIM(DDT_SOURCE)                              :F(RETURN)
1702             IDENT(LINE)                                         :S(DDT_RL1)
1703             LINE PAT1                                           :F(DDT_RL1)
        * IGNORE PAGE THROW, ERROR MESSAGE, FORM FEED, AND TITLES IN LISTING
        * FILE.
1704             STNO PAT3                                           :S(DDT_RL1)
1705             STNO = TRIM(STNO)
1706             INTEGER(STNO)                                       :F(DDT_RL4)
        * IGNORE COMMENTS
1707             STMT PAT5                                           :S(DDT_RL1)
        * CONTINUATION LINES
1708             STMT PAT4                                           :S(DDT_RL2)
        * ADJUST $LAST IF NEW STATEMENT NUMBER
1709             $LAST = +VDIFFER(STNO)                    :S(DDT_RL3)F(DDT_RL1)
        * APPEND LF TO EXISTING TEXT IF CONTINUED STATEMENT
1710    DDT_RL2  DDT_READLIST<$LAST> = VDIFFER(DDT_READLIST<$LAST>) CHARS_NL
        * PLACE STATEMENT IN TABLE
1711    DDT_RL3  DDT_READLIST<$LAST> = DDT_READLIST<$LAST> LINE
        * EXTRACT LABEL
1712             (STMT ' ') PAT2                                     :F(DDT_RL1)
        * RECORD CASE-CONVERTED LABEL TO STATEMENT NUMBER MAPPING
1713             ITEM(LABTAB, DDT_CASE(LABEL)) = $LAST                :(DDT_RL1)
1714    DDT_RL4  DDT_TOUT('INCORRECT PROGRAM LIST FILE, LINE IN ERROR:')
1715             DDT_TOUT(LINE)                                       :(FRETURN)
        *
        -LINE 363 "DDT.lss"
1716    DDT_CMD  IDENT(DDT_UNIT2)                                   :S(DDT_CMD2)
1717             DDT_IN = DDT_INPUT                                 :F(DDT_CMD4)
1718             DDT_TOUT('DDT: ' DDT_IN)                            :(DDT_CMD3)
1719    DDT_CMD4 ENDFILE(DDT_UNIT2)
1720             DETACH(.DDT_INPUT)
1721             DDT_UNIT2 =
1722    DDT_CMD2 DDT_LL2 = DDT_LL
1723             IDENT(DDT_USE_R)                                   :S(DDT_CMD5)
1724             DDT_TOUT(EQ(DDT_USE_R, 1) 'DDT REMOTE (' DSERVE_APPNAME ')')
        *
        * NOTE: THIS IS THE ONLY READ FROM DDT_R.
        *
        * IF DDT_HOOK IS DEFINED, WE WILL CALL WITH THAT WITH 'READ'. SEE
        * DDT_HOOK CALL WITH 'DISPLAY' ABOVE. IF THIS FAILS, WE ASSUME NORMAL
        * READ IS NEEDED. IF USE_DDT_R, AND DDT_HOOK IS NOT SET, WE READ
        * FROM DDT_R.
        *
1725             IDENT(DDT_HOOK)                                    :S(DDT_CMD7)
1726             DDT_IN = TRIM(APPLY(DDT_HOOK, 'READ'))  :F(DDT_CMD5)S(DDT_CMD3)
1727    DDT_CMD7 DDT_IN = TRIM(DDT_R)                       :S(DDT_CMD3)F(DDT.O)
1728    DDT_CMD5 DDT_IN = TRIM(HISTORY_EXPAND(READLINE('DDT: ')))      :F(DDT.O)
        *
        * ONLY ADD NON-NULL COMMANDS THAT DIFFER FROM LAST COMMAND TO HISTORY
        *
1729    DDT_CMD6 IDENT(DDT_IN)                                       :S(DDT_CMD)
1730             DDT_LL = DDT_IN
1731             ADD_HISTORY(VDIFFER(DDT_IN, DDT_LL2))
1732    DDT_CMD3 IDENT(DDT_IN)                                       :S(DDT_CMD)
        *
        * TEST FOR VALID COMMAND AND BRANCH TO APPROPRIATE PROCESSOR (DDT.?).
        * LOWER-CASE COMMANDS ARE EQUIVALENT TO UPPER-CASE, AND BLANK AND
        * TAB ARE CONVERTED TO THE COMMAND 'C'.
        *
1733             DDT_IN DDT_CHARS =                              :F(DDT_CMD_ERR)
1734             DDT_STEP_COUNT = 0
1735                           :($('DDT.' REPLACE(DDT_C, DDT_CHARL, DDT_CHARR)))
        *
        *** INVALID COMMAND
        *
1736    DDT_CMD_ERR
1737             DDT_TOUT('?')                                        :(DDT_CMD)
        *
        *** TURN OFF DEBUGGER
        *
1738    DDT.O    DDT_ACTIVE = 0
1739             WRITE_HISTORY('.DDT')
1740             &STLIMIT = -1
1741             STOPTR('STCOUNT', 'KEYWORD')                         :(FRETURN)
        *
        *** V - VIEW FILE
        *
1742    DDT.V    DDT_IN = IDENT(DDT_IN) DDT_FNAME
1743             (IDENT(DDT_IN) DIFFER(DDT_USE_R))                    :S(DDT.V2)
1744             DDT_IN = IDENT(DDT_IN) READLINE('FILE: ')
1745             DDT_FNAME = VDIFFER(DDT_IN)                         :F(DDT_CMD)
        *
        * FIXME: NEED SOMETHING BETTER. LIST FOR LOCAL, BUT DUMP TO DDT_T FOR
        * REMOTE.
        *
1746             HOST(HOST_SYSCMD, 'LIST ' DDT_IN)                    :(DDT_CMD)
1747    DDT.V2   DDT_TOUT('USE V FILENAME')                           :(DDT_CMD)
        *
        *** M - MODIFY VARIABLE
        *
1748    DDT.M    IDENT(DDT_IN)                                       :S(DDT_CMD)
1749             DDT_TOUT(DIFFER(DDT_USE_R) 'SORRY, NEED EDITLINE')  :S(DDT_CMD)
1750             DATATYPE($DDT_IN) 'STRING' | 'NAME' | 'INTEGER' | 'REAL'
1750    +                                                             :S(DDT.M2)
1751             DDT_TOUT("SORRY, CAN'T MODIFY " DATATYPE($DDT_IN))   :(DDT_CMD)
1752    DDT.M2   $DDT_IN = EDITLINE('EDIT<' DDT_IN '>: ', $DDT_IN)    :(DDT_CMD)
        *
        *** . - SOURCE FILE
        *
1753    DDT..    IDENT(DDT_UNIT2)                                     :S(DDT..1)
1754             DDT_TOUT('. COMMANDS CANNOT BE NESTED')               :(DDT..2)
1755    DDT..1   IDENT(DDT_IN)                                       :S(DDT_CMD)
1756             DDT_TOUT('SOURCING ' DDT_IN)
1757             DDT_UNIT2 = IO_FINDUNIT()
1758             INPUT(.DDT_INPUT, DDT_UNIT2,, DDT_IN)               :S(DDT_CMD)
1759             DDT_TOUT('CANNOT OPEN ' DDT_IN)
1760    DDT..2   ENDFILE(DDT_UNIT2)
1761             DETACH(.DDT_INPUT)
1762             DDT_UNIT2 =                                          :(DDT_CMD)
        *
        *** * - COMMENT
        *
1763    DDT.*                                                         :(DDT_CMD)
        *
        *** H OR ? - HELP
        *
        -LINE 611 "DDT.lss"
1764    DDT.H
1765     DDT_TOUT('STNO - STATEMENT NUMBERS SPECIFIED AS INTEGERS, OR LABEL+-N')
1766     DDT_TOUT('          BRACKETED ITEMS ARE OPTIONAL')
1767     DDT_TOUT('H            (OR ?)     HELP (THIS LIST)')
1768     DDT_TOUT('C STATEMENT  (OR TAB)   IMMEDIATE EXECUTION OF STATEMENT')
1769     DDT_TOUT('E EXPRESSION (OR =EXP)  EVALUATE EXPRESSION')
1770     DDT_TOUT('X COMMAND    (OR !)     EXECUTE SHELL COMMAND')
1771     DDT_TOUT('T [N]                   TRACE N STATEMENTS (INTO PROCS)')
1772     DDT_TOUT('P [N]                   TRACE N STATEMENTS (NO PROCEDURES)')
1773     DDT_TOUT('B STNO [,STNO,...]      SET BREAKPOINT(S)')
1774     DDT_TOUT('K BKPT [,BKPT,...]      KILL BREAKPOINT(S)')
1775     DDT_TOUT('R                       REPORT BREAKPOINTS SET')
1776     DDT_TOUT('G [=LABEL,](STNO1,...]  GO (FROM SPECIFIED LABEL),')
1777     DDT_TOUT('                          SET TEMPORARY BREAKPOINT(S)')
1778     DDT_TOUT('L [STNO1 [,STNO2]]      LIST STATEMENT OR RANGE')
1779     DDT_TOUT('+ [N]  OR  -[N]         LIST NEXT/PREVIOUS N STATEMENTS')
1780     DDT_TOUT('++ OR --                LIST 12 STATEMENTS FORWARD OR BACK')
1781     DDT_TOUT('Q                       QUIT')
1782     DDT_TOUT('O (OR ^D)               OFF - RESUME PROGRAM, STOP DEBUG')
1783     DDT_TOUT('S [FILE]                LOAD SOURCE')
1784     DDT_TOUT('M NAME                  MODIFY VARIABLE')
1785     DDT_TOUT("I 'MSG' N               IGNORE NEXT N CALLS TO DDT(MSG)")
1786     DDT_TOUT('* COMMENT               COMMENT (NO ACTION)')
1787     DDT_TOUT('. FILE                  SOURCE FILE (DO NOT NEST)')
1788     DDT_TOUT('V (FILE)                VIEW FILE (DEFAULT TO LIST FILE)')
1789                                                                  :(DDT_CMD)
        *
        *** I - IGNORE
        *
        *       CALLS TO DDT() OR DEBUG() MAY HAVE A STRING. THE I COMMAND
        *       IGNORES THE NEXT N CALLS TO DDT() WITH A MATCHING STRING.
        *       NORMALLY, I IS FOLLOWED BY O TO EXECUTE AT FULL SPEED.
        *
1790    DDT.I    DDT_IGNORE =
1791             DDT_IN (("'" ARB . DDT_IGNORE "'") | '') SPAN(DDT_WHITE ',')
1791    +           SPAN(&DIGITS) . DDT_COUNT RPOS(0)                :S(DDT_CMD)
1792             DDT_TOUT('BAD I SYNTAX')                             :(DDT_CMD)
        *
        *** Q - QUIT
        *
1793    DDT.Q    WRITE_HISTORY('.DDT')                                    :(END)
        *
        *** X - EXECUTE SHELL COMMAND
        *
1794    DDT.X    HOST(HOST_SYSCMD, DDT_IN)
1795             DDT_TOUT()                                           :(DDT_CMD)
        *
        *** C - IMMEDIATE EXECUTION OF AN UNLABELED CODE STATEMENT.
        *       APPEND OUR OWN GOTOS TO REGAIN CONTROL AFTER EXECUTION.
        *
1796    DDT.C    DDT_C = CODE(' ' DDT_IN ' :S(DDT_SS)F(DDT_FF)')       :S<DDT_C>
1797             DDT_TOUT('COMPILATION ERROR: ' &ERRTEXT)             :(DDT_CMD)
1798    DDT_SS   DDT_TOUT('SUCCESS')                                  :(DDT_CMD)
1799    DDT_FF   DDT_TOUT('FAILURE')                                  :(DDT_CMD)
        *
        *** E - EXAMINE VARIABLE OR EVALUATE EXPRESSION. WE DISPLAY STRINGS,
        *       NUMBERS AS SCALARS, ARRAYS AND TABLES AS PROTOTYPES, CODE,
        *       EXPRESSION, PATTERN AS TYPE NAME, USER TYPES ARE DISPLAYED AS
        *       MEMBERS
        *
        * FIXME - DATATYPE 'NAME' MAY BE AN ISSUE, SEE READL.INC AND FIX HERE
        *         AND IN MODIFY DDT.M
        *
1800    DDT.E    DDT_RESULT = EVAL(DDT_IN)                            :F(DDT.E2)
1801             DDT_V = DATATYPE(DDT_RESULT)
1802             IDENT(DDT_RESULT)                                    :S(DDT.E3)
1803             DDT_RESULT = ?(DDT_V ? 'STRING' | 'NAME') QUOTE(DDT_RESULT)
1803    +                                                             :S(DDT.E3)
1804             DDT_V 'INTEGER' | 'REAL'                             :S(DDT.E3)
1805             DDT_RESULT = ?(DDT_V ? 'CODE' | 'EXPRESSION' | 'PATTERN' |
1805    +           'TABLE' | 'ARRAY') CONVERT(DDT_RESULT, 'STRING')  :S(DDT.E3)
        *
        * USER DEFINED DATATYPE - FIELD('TYPE',1..N)
        *
1806             DDT_TOUT(DATATYPE(DDT_RESULT))
1807             DDT_I =
1808    DDT.E4   DDT_I = DDT_I + 1
1809             DDT_FIELD = FIELD(DATATYPE(DDT_RESULT), DDT_I)      :F(DDT_CMD)
1810             DDT_V = DATATYPE(APPLY(DDT_FIELD, DDT_RESULT))
1811             DDT_V = IDENT(APPLY(DDT_FIELD, DDT_RESULT))          :S(DDT.E5)
1812             DDT_V = ?(DDT_V ? 'STRING' | 'NAME')
1812    +           QUOTE(APPLY(DDT_FIELD, DDT_RESULT))               :S(DDT.E5)
1813             DDT_V = ?(DDT_V ? 'INTEGER' | 'REAL')
1813    +           APPLY(DDT_FIELD, DDT_RESULT)                      :S(DDT.E5)
1814             DDT_V = CONVERT(APPLY(DDT_FIELD, DDT_RESULT), 'STRING')
1815    DDT.E5   DDT_TOUT('    ' RPAD(DDT_FIELD, 10) ': ' DDT_V)       :(DDT.E4)
1816    DDT.E3   DDT_TOUT(DDT_RESULT)                                 :(DDT_CMD)
1817    DDT.E2   DDT_TOUT('EVALUATION ERROR: ' &ERRTEXT)              :(DDT_CMD)
        *
        *** T - STEP N STATEMENTS, DESCENDING INTO PROCEDURES
        *
1818    DDT.T    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
1819             FREEZE(DDT_BREAK_TAB)
1820             FREEZE(DDT_BREAK_TEMP)
1821             DDT_FNCLEVEL = 50000
1822             DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
        *
        *** P - STEP N STATEMENTS, TREAT PROCEDURES AS INTACT ENTITIES
        *
1823    DDT.P    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
1824             FREEZE(DDT_BREAK_TAB)
1825             FREEZE(DDT_BREAK_TEMP)
1826             DDT_FNCLEVEL = &FNCLEVEL - 1
1827             DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
        *
        *** R - REPORT BREAKPOINTS
        *
1828    DDT.R    DDT_A = SORT(DDT_BREAK_TAB)                          :F(DDT_R2)
1829             DDT_C = 0
1830    DDT_R1   DDT_C = DDT_C + 1
1831             DDT_TOUT(DDT_A<DDT_C, 1> ' '
1831    +           DDT_LABEL(DDT_A<DDT_C, 1>))             :S(DDT_R1)F(DDT_CMD)
1832    DDT_R2   DDT_TOUT('NONE')                                     :(DDT_CMD)
        *
        *** K - KILL BREAKPOINT(S)
        *
1833    DDT.K    IDENT(DDT_IN)                                       :S(DDT_CMD)
1834             DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> =     :S(DDT.K)F(DDT_CMD)
        *
        *** B - SET BREAKPOINT(S)
        *
1835    DDT.B    IDENT(DDT_IN)                                       :S(DDT_CMD)
1836             DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> = 1   :S(DDT.B)F(DDT_CMD)
        *
        *** G - GO <=OPTIONAL DIRECT TRANSFER LABEL> <OPTIONAL BREAKPOINTS(S)>
        *
        * FIRST TEST FOR SIMPLE G BY ITSELF
1837    DDT.G    DDT_STEP_COUNT = 0
1838             IDENT(DDT_IN)                                       :S(FRETURN)
        * CHECK FOR =LABEL, ASSIGN LABEL TO DDT_CMD
1839             DDT_IN DDT_G_PAT =                                   :F(DDT_G1)
1840             DDT_CMD = DDT_CASE(DDT_CMD)
        * ERROR IF LABEL UNKNOWN
1841             DDT_TOUT(IDENT(DDT_LBLS<DDT_CMD>) 'UNKNOWN LABEL ='
1841    +           DDT_CMD)                                         :S(DDT_CMD)
        * PROCESS ANY BREAKPOINTS
1842    DDT_G1   DIFFER(DDT_IN)                                       :F(DDT_G2)
1843             DDT_BREAK_TEMP<+DDT_GET_STMT(.DDT_IN)> = 1 :S(DDT_G1)F(DDT_CMD)
        * CHOOSE FRETURN TO RESUME EXECUTION WHERE INTERRUPTED, RETURN TO
        * TRANSFER TO THE LABEL IN DDT_CMD.
1844    DDT_G2   FREEZE(DDT_BREAK_TEMP)
1845             FREEZE(DDT_BREAK_TAB)
1846             DIFFER(DDT_CMD)                            :S(RETURN)F(FRETURN)
        -LINE 648 "DDT.lss"
        *
        *** L - LIST STATEMENT(S)
        *
        * DISPATCH IF L BY ITSELF
1847    DDT.L    DDT_A = IDENT(DDT_IN) DDT_CURR_STMT                  :S(DDT_L1)
        * GET FIRST LINE NUMBER
1848             DDT_A = +DDT_GET_STMT(.DDT_IN)                      :F(DDT_CMD)
        * IF JUST ONE, DISPLAY IT BY ITSELF
1849             IDENT(DDT_IN)                                        :S(DDT_L1)
        * IF ANOTHER, GET IT AS THE ENDING LINE NUMBER
1850             DDT_C = +DDT_GET_STMT(.DDT_IN)             :S(DDT_L2)F(DDT_CMD)
        * DISPLAY ONE LINE AT DDT_A
1851    DDT_L1   DDT_C = DDT_A
        * USE DDT_C AS THE REFERENCE FOR SUBSEQUENT DISPLAY
1852    DDT_L2   DDT_B = .DDT_C
        * CHECK RANGE OF VALUES SPECIFIED
1853             IDENT(DDT_FINAL_STMT)                               :S(DDT_CMD)
1854             DDT_A = LT(DDT_A, 1) 1
1855             DDT_A = GT(DDT_A, DDT_FINAL_STMT) DDT_FINAL_STMT
1856             DDT_C = LT(DDT_C, DDT_A) DDT_A
1857             DDT_C = GT(DDT_C, DDT_FINAL_STMT) DDT_FINAL_STMT
1858             DDT_LIST_F = DDT_A
1859             DDT_LIST_L = DDT_C
        * DISPLAY LOOP
1860    DDT_L3   DDT_TOUT(VDIFFER(DDT_STMTS<DDT_A>))
1861             DDT_A = LT(DDT_A, DDT_C) DDT_A + 1         :S(DDT_L3)F(DDT_CMD)
        *
        *** +<N> - LIST NEXT STATEMENT(S), ++ LISTS THE NEXT 12 LINES.
        *
1862    DDT.+    DDT_A = DDT_LIST_L + 1
1863             DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L4)
1864             DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
1865             DDT_C = LE(DDT_C) 1
1866    DDT_L4   DDT_C = DDT_A + DDT_C - 1                             :(DDT_L2)
        *
        *** -<N> - LIST PREVIOUS STATEMENT(S), -- LISTS THE PREVIOUS 12 LINES.
        *
1867    DDT.-    DDT_B = DDT_LIST_F - 1
1868             DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L5)
1869             DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
1870             DDT_C = LE(DDT_C) 1
1871    DDT_L5   DDT_A = DDT_B - DDT_C + 1
1872             DDT_C = DDT_B                                         :(DDT_L2)
1873    DDT_TOUT DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'DISPLAY', S)
1874             DDT_T = S                                             :(RETURN)
        *
        *** S(FILE) - LOAD SOURCE LISTING
        *
1875    DDT.S    DDT_SOURCE()                                         :(DDT_CMD)
        *
1876    DDT_SOURCE
1877             THAW(DDT_STMTS)
1878             THAW(DDT_LBLS)
1879             DDT_LBLS = TABLE(50, 50)
1880             DDT_FINAL_STMT =
1881             DDT_UNIT = IO_FINDUNIT()
1882             DDT_FNAME = TRIMB(DDT_IN)
1883             DIFFER(DDT_FNAME)                                    :S(DDT_S3)
1884             INPUT('DDT_SOURCE', DDT_UNIT,,
1884    +              DDT_FNAME = HOST(HOST_GETENV, 'LIST'))         :S(DDT_S1)
1885             DDT_TOUT(DIFFER(DDT_USE_R) 'USE S FILE')             :S(DDT_S2)
1886             DDT_FNAME = TRIM(HISTORY_EXPAND(READLINE('LISTING: ')))
1887    DDT_S3   INPUT('DDT_SOURCE', DDT_UNIT,, DDT_FNAME)            :S(DDT_S1)
1888             DDT_FNAME =
1889             DDT_TOUT('NO LISTING FILE PROVIDED')                  :(DDT_S2)
1890    DDT_S1   DDT_STMTS = DDT_READLIST(DDT_LBLS, .DDT_FINAL_STMT)
1891             ENDFILE(DDT_UNIT)
1892             DETACH(.DDT_SOURCE)
1893             DDT_TOUT(DIFFER(DDT_FINAL_STMT) 'SOURCE LISTING LOADED')
1894    DDT_S2   FREEZE(DDT_STMTS)
1895             FREEZE(DDT_LBLS)                                      :(RETURN)
        *
1896    DDT_END
        *
        *
        * CE: .F.MSNOBOL4;
        -IN72
        -LINE 252 "DSERVE.lss"
        -STITL DSERVE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######    #####   #######  ######   #     #  #######         *
        *         #     #  #     #  #        #     #  #     #  #               *
        *         #     #  #        #        #     #  #     #  #               *
        *         #     #   #####   #####    ######   #     #  #####           *
        *         #     #        #  #        #   #     #   #   #               *
        *         #     #  #     #  #        #    #     # #    #               *
        *         ######    #####   #######  #     #     #     #######         *
        *                                                                      *
        * DSERVE                  DDT TELNET SERVER                            *
        *                                                                      *
        ************************************************************************
        *
        * DSERVE.lss
        *
        -LINE 58 "DSERVE.lss"
        -PUBLIC DSERVE_INIT(), DSERVE()
        -PUBLIC DSERVE_PORT, DSERVE_APPNAME
        *
1897             DEFINE('DSERVE_INIT(APPNAME,PORT,KEY,INTR)') :(DSERVE_INIT_END)
        *
1898    DSERVE_INIT
1899             DSERVE_KEY = KEY
1900             DSERVE_PORT = PORT
1901             DSERVE_APPNAME = APPNAME
1902             DSERVE_INTR = INTR
        *
1903             DSERVE_PID = GETPID()
1904             P1 = PIPE()                                         :F(DSERVE9)
1905             DSERVE_P1_RFD = P1<1>
1906             DSERVE_P1_WFD = P1<2>
1907             P2 = PIPE()                                         :F(DSERVE9)
1908             DSERVE_P2_RFD = P2<1>
1909             DSERVE_P2_WFD = P2<2>
1910             PID = FORK()                                        :F(DSERVE9)
1911             LT(PID)                                             :S(DSERVE9)
1912             EQ(PID)                                             :S(DSERVE2)
        *
        * PRIMORDIAL PROCESS - POLLS WITH DSERVE() WAITING FOR CONNECTION AND
        * DEBUGGER ENTRY
        *
        * NEEDS FD SET AND TIMEVAL FOR SELECT
        *
1913             DSERVE_FDS = NEW_FD_SET()
1914             DSERVE_TV = NEW_TIMEVAL()
1915             IDENT(DSERVE_INTR)                                   :S(RETURN)
        *
1916             &ERRLIMIT = 1
1917             SETEXIT('DSERVE_TRAP')                                :(RETURN)
        *
1918    DSERVE_INIT_END
        *
1919             DEFINE('DSERVE()N,S')                             :(DSERVE_END)
        *
        * IF DDT IS ALREADY ACTIVE, WE ARE DEBUGGING THROUGH A DSERVE() POLL,
        * JUST RETURN. IF DSERVE_APPNAME IS NULL, RETURN, DSERVE HAS NOT
        * BEEN SET UP CORRECTLY YET.
        *
1920    DSERVE   NE(DDT_ACTIVE)                                       :S(RETURN)
1921             IDENT(DSERVE_APPNAME)                                :S(RETURN)
        *
        * SEE IF THERE IS INPUT AVAILABLE FROM THE NET. USE SELECT() TO POLL
        * THE READ FILE DESCRIPTOR, WITH A TIMEOUT OF 0 (NO WAIT)
        *
1922             SET_TIMEVAL(DSERVE_TV, 0, 0)
1923             FD_ZERO(DSERVE_FDS)
1924             FD_SET(DSERVE_P2_RFD, DSERVE_FDS)
1925             N = SELECT(DSERVE_P2_RFD + 1, DSERVE_FDS, 0, 0, DSERVE_TV)
1926             EQ(N)                                                :S(RETURN)
        *
        * WE HAVE DATA ON THE READ FD. CREATE I/O CHANNELS TO TELNET I/O
        * PROCESSES.
        *
1927             OUTPUT(.DDT_T, 10, 'W', '/dev/fd/' DSERVE_P1_WFD)   :F(DSERVE9)
1928             INPUT(.DDT_R, 11,, '/dev/fd/' DSERVE_P2_RFD)        :F(DSERVE9)
        *
        * READ MESSAGE FROM NET PROCESS. WE HAVE A MESSAGE TO BE READ
        * (BUT IT MAY NOT BE COMPLETE YET). WE RELY ON NORMAL I/O MECHANISM
        * TO DELIVER COMPLETE MESSAGE LINE.
        *
1929             S = DDT_R
1930             IDENT(S, 'DDT')                                     :S(DSERVE7)
1931             DSERVE = S                                            :(RETURN)
1932    DSERVE7  DDT_T = NE(DDT_ACTIVE) 'APP ALREADY IN DDT'          :S(RETURN)
1933             DDT_USE_R = 1
1934             DSERVE = 'DDT'
        *
        * THE MESSAGE IS 'DDT' WHICH MEANS ENTER DEBUGGER. THE DEBUGGER IS
        * NOT YET ACTIVE. WHEN DSERVE() RETURNS, IT WILL BE UNDER DDT CONTROL.
        * WE SET DDT_USE_R TO 1 TO INFORM DDT OF THE I/O NEEDED (READLINE
        * CANNOT BE USED).
        *
1935             DDT(DSERVE_APPNAME)
1936                                                                   :(RETURN)
        *
        * SETEXIT() TRAP TO ENTER DDT -- NEED DDT() ENTRY THAT DOES ONE STEP
        * COMMAND.
        *
1937    DSERVE_TRAP
1938             OUTPUT(.DDT_T, 10, 'W', '/dev/fd/' DSERVE_P1_WFD)   :F(DSERVE9)
1939             INPUT(.DDT_R, 11,, '/dev/fd/' DSERVE_P2_RFD)        :F(DSERVE9)
1940             S = DDT_R
1941             IDENT(S, 'DDT')                                    :S(DSERVET2)
1942             DSERVE = S                                          :(DSERVET3)
1943    DSERVET2 DDT_T = NE(DDT_ACTIVE) 'APP ALREADY IN DDT'        :S(DSERVET3)
1944             DDT_USE_R = 1
1945             DSERVE = 'DDT'
1946             DDT(DSERVE_APPNAME)
1947                                                                :(SCONTINUE)
1948    DSERVET3 SETEXIT('DSERVE_TRAP')
1949             &ERRLIMIT = 1                                      :(SCONTINUE)
        *
        * CONNECTION LISTENER PROCESS
        *
        * CREATE I/O CHANNELS TO PRIMORDIAL PROCESS. THE PRIMORDIAL PROCESS
        * WILL POLL WAITING FOR A MESSAGE TO BE WRITTEN TO TO_PRIMORDIAL.
        *
1950    DSERVE2  INPUT(.FROM_PRIMORDIAL, 12,, '/dev/fd/' DSERVE_P1_RFD)
1950    +                                                            :F(DSERVE9)
1951             OUTPUT(.TO_PRIMORDIAL, 13, 'W', '/dev/fd/' DSERVE_P2_WFD)
1951    +                                                            :F(DSERVE9)
        *
        * WAIT FOR A CONNECTION ON DSERVE_PORT
        *
1952    DSERVE3  FDN = SERV_LISTEN('inet', 'stream', DSERVE_PORT)    :F(DSERVE9)
1953             INPUT(.NET, 9, 'UWT', '/dev/fd/' FDN)               :F(DSERVE9)
1954             OUTPUT(.NET, 9)                                     :F(DSERVE9)
1955             CRLF = CHARS_CR CHARS_LF
        *
        * WE HAVE A CONNECTION. DISPLAY SIGNON, AND REQUEST LOGIN. THE LOGIN
        * IS A SIMPLE STRING PASSED AS DSERVE_KEY
        *
1956             NET = 'DSERVE ' DSERVE_APPNAME CRLF
1957             NET = CRLF
1958             NET = 'LOGIN REQUIRED: ' CRLF
1959             S = NET
1960             S = REPL(S, CRLF)
1961             S = TRIMB(S)
        *
        * LOGIN IS PLAINTEXT. THIS SHOULD ONLY BE USED OVER TELNET RUNNING ON
        * THE SAME HOST AS THE APPLICATION BEING DEBUGGED. THERE IS NO USER
        * NAME/PASSWORD -- JUST A SINGLE MAGIC WORD.
        *
1962             IDENT(S, DSERVE_KEY)                                :S(DSERVE8)
1963             NET = 'BAD LOGIN' CRLF                                   :(END)
1964    DSERVE8  NET = 'LOGIN CONFIRMED' CRLF
1965             NET = 'REDIRECT TO /dev/fd/' DSERVE_P1_WFD ' TO SEND OUTPUT '
1965    +              'TO TELNET USING X (EG ls)' CRLF
        *
        * THE CORRECT KEY WAS SUPPLIED. SEND MESSAGE TO PRIMORDIAL.
        *
1966             TO_PRIMORDIAL = 'DDT'
        *
        * SIGNAL TO ENTER DDT
        *
1967             KILL(DIFFER(DSERVE_INTR) DSERVE_PID, 2)
        *
        * FORK TO TWO COPY LOOPS: PRIMORDIAL -> NET AND NET -> PRIMORDIAL
        *
1968             PID = FORK()
1969             LT(PID)                                             :S(DSERVE9)
1970             EQ(PID)                                            :S(DSERVE12)
        *
        * PRIMORDIAL -> NET COPY PROCESS
        *
1971    DSERVE11 S = FROM_PRIMORDIAL                                     :F(END)
1972             NET = S CRLF                                        :(DSERVE11)
        *
        * NET -> PRIMORDIAL COPY PROCESS
        *
1973    DSERVE12 S = NET                                                 :F(END)
1974             S = REPL(S, CHARS_CR)
1975             S = REPL(S, CHARS_LF)
1976             TO_PRIMORDIAL = S                                   :(DSERVE12)
        *
1977    DSERVE9  TERMINAL = 'DSERVE: INTERNAL FAILURE'                    :(END)
        *
1978    DSERVE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FCGI.INC'
        -MODULE FCGI
        -LINE 28 "FCGI.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'FFI.INC'
        -INCLUDE 'JSON.INC'
        -MODULE JSON
        -LINE 40 "JSON.lss"
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'CH.INC'
        -MODULE CH
        -LINE 10 "CH.lss"
        -INCLUDE 'HEX.INC'
        -MODULE HEX
        -LINE 13 "HEX.lss"
        -INCLUDE 'BLEND.INC'
        -IN72
        -LINE 51 "HEX.lss"
        -STITL HEX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #     #  #######  #     #                       *
        *                      #     #  #         #   #                        *
        *                      #     #  #          # #                         *
        *                      #######  #####       #                          *
        *                      #     #  #          # #                         *
        *                      #     #  #         #   #                        *
        *                      #     #  #######  #     #                       *
        *                                                                      *
        * HEX                    RETURN HEX FOR STRING                         *
        *                                                                      *
        ************************************************************************
        *
        * HEX.lss
        *
        -LINE 17 "HEX.lss"
        -PUBLIC HEX()
        *
1979             DEFINE('HEX(S)S2')
        *
1980             H = '0123456789ABCDEF'
1981             HEX_2ND = DUPL(H, 16)
1982    HEX_1    H LEN(1) . T =                                      :F(HEX_END)
1983             HEX_1ST = HEX_1ST DUPL(T, 16)                          :(HEX_1)
        *
1984    HEX      IDENT(S)                                             :S(RETURN)
1985             LE(SIZE(S), 128)                                      :S(HEX_2)
1986             S LEN(128) . S REM . S2
1987             HEX = HEX(S) HEX(S2)                                  :(RETURN)
1988    HEX_2    HEX = BLEND(REPLACE(S, &ALPHABET, HEX_1ST),
1988    +           REPLACE(S, &ALPHABET, HEX_2ND))                    :(RETURN)
        *
1989    HEX_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 47 "CH.lss"
        -STITL CH
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                            #####   #     #                           *
        *                           #     #  #     #                           *
        *                           #        #     #                           *
        *                           #        #######                           *
        *                           #        #     #                           *
        *                           #     #  #     #                           *
        *                            #####   #     #                           *
        *                                                                      *
        * CH                         HEX TO STRING                             *
        *                                                                      *
        ************************************************************************
        *
        * CH.lss
        *
        -LINE 14 "CH.lss"
        -PUBLIC CH()
        *
1990             DEFINE('CH(H)C,P')
        *
1991             CH_H_ = ' ' HEX(&ALPHABET)
1992    CH_2     CH_H_ ' ' LEN(2) . C1
1992    +          (ANY('0123456789ABCDEF') LEN(1)) . C2 = ' ' C1 ' ' C2
1992    +                                                      :S(CH_2)F(CH_END)
        *
1993    CH       H = REPLACE(H, &LCASE, &UCASE)
1994    CH_3     H LEN(2) . C =                                       :F(RETURN)
1995             CH_H_ ' ' C @P                                      :F(FRETURN)
1996             P = (P - 1) / 3
1997             &ALPHABET LEN(P) LEN(1) . C
1998             CH = CH C                                               :(CH_3)
        *
1999    CH_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HEX.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'LOG.INC'
        -MODULE LOG
        -LINE 13 "LOG.lss"
        -INCLUDE 'DEXP.INC'
        -INCLUDE 'FLOOR.INC'
        -MODULE FLOOR
        -LINE 11 "FLOOR.lss"
        -INCLUDE 'DEXP.INC'
        -IN72
        -LINE 40 "FLOOR.lss"
        -STITL FLOOR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #######  #        #######  #######  ######              *
        *              #        #        #     #  #     #  #     #             *
        *              #        #        #     #  #     #  #     #             *
        *              #####    #        #     #  #     #  ######              *
        *              #        #        #     #  #     #  #   #               *
        *              #        #        #     #  #     #  #    #              *
        *              #        #######  #######  #######  #     #             *
        *                                                                      *
        * FLOOR              FLOOR AND CEIL FUNCTIONS                          *
        *                                                                      *
        ************************************************************************
        *
        * FLOOR.lss
        *
        -LINE 15 "FLOOR.lss"
        -PUBLIC FLOOR(), CEIL()
        *
2000             DEFINE('FLOOR(X)')
2001             DEXP('CEIL(X) = -FLOOR(-X)')                       :(FLOOR_END)
        *
2002    FLOOR    FLOOR = CONVERT(X, 'INTEGER')
2003             GE(X, 0)                                             :S(RETURN)
2004             FLOOR = NE(X, FLOOR) FLOOR - 1                        :(RETURN)
        *
2005    FLOOR_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 34 "LOG.lss"
        -STITL LOG
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #        #######   #####                        *
        *                      #        #     #  #     #                       *
        *                      #        #     #  #                             *
        *                      #        #     #  #  ####                       *
        *                      #        #     #  #     #                       *
        *                      #        #     #  #     #                       *
        *                      #######  #######   #####                        *
        *                                                                      *
        * LOG                       LOG FUNCTIONS                              *
        *                                                                      *
        ************************************************************************
        *
        * LOG.lss
        *
        * CONSTANTS TO 50 PLACES
        *
        * SEE
        * http://numbers.computation.free.fr/Constants/Miscellaneous/digits.html
        *
        -PUBLIC LN_10, EULERS_NUMBER, PI
2006             LN_10    =
2006    +                   2.30258509299404568401799145468436420760110148862877
2007             EULERS_NUMBER =
2007    +                   2.71828182845904523536028747135266249775724709369995
2008             PI =
2008    +                   3.14159265358979323846264338327950288419716939937510
        *
        -PUBLIC CLOG(), LOGB()
        *
2009             DEXP('CLOG(X) = LN(X) / LN_10')
2010             DEXP('LOGB(X,B) = NE(B, 0) LN(X) / LN(B) ;'
2010    +             'LOGB      = EQ(B, 0) LN(X)         ;')
        *
2011    LOG_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SDIFF.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 386 "JSON.lss"
        -STITL JSON
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                        #   #####   #######  #     #                  *
        *                        #  #     #  #     #  ##    #                  *
        *                        #  #        #     #  # #   #                  *
        *                        #   #####   #     #  #  #  #                  *
        *                  #     #        #  #     #  #   # #                  *
        *                  #     #  #     #  #     #  #    ##                  *
        *                   #####    #####   #######  #     #                  *
        *                                                                      *
        * JSON                  CONVERT TO AND FROM JSON                       *
        *                                                                      *
        ************************************************************************
        *
        * JSON.lss
        *
        -LINE 51 "JSON.lss"
        -PUBLIC JSON_ENCODE(), JSON_DECODE()
        *
2012             DEFINE('JSON_ENCODE(X)L')
2013             DEFINE('JSON_DECODE(X)')
        *
2014             DEFINE('JSON_DECODE_STRING()S')
2015             DEFINE('JSON_DECODE_VALUE()')
2016             DEFINE('JSON_DECODE_OBJECT()T,T2')
2017             DEFINE('JSON_DECODE_ARRAY()T,I')
2018             DEFINE('JSON_ESCAPE(C)')
2019             DEFINE('JSON_INDENT()')
2020             DEFINE('JSON_ENCODE_OBJECT(X)K,I')
2021             DEFINE('JSON_ENCODE_ARRAY(X)I')
2022             DEFINE('JSON_ENCODE_STRING(S)L,C')
2023             DEFINE('JSON_ENCODE_VALUE(X)')
        *
        * JSON WHITESPACE. THIS CAN BE BETWEEN TOKENS, AND WILL BE IGNORED
        *
        * ALSO EATS 'COMMENTS' DEFINED AS # TO END OF LINE, // TO END OF
        * LINE AND /* TO */
        *
2024             JSON_WS2 = SPAN(CHARS_TAB CHARS_SPACE CHARS_FF CHARS_LF
2024    +                        CHARS_CR) |
2024    +                   ('#' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
2024    +                   ('//' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
2024    +                   ('/*' BREAK('*') '*/')
2025             JSON_WS = (JSON_WS2 *JSON_WS) |
2025    +                  NULL
        *
        * A JSON NUMBER. PATTERN JSON_NUMBER IS ONLY USED TO DECODE JSON.
        * ENCODING USES THE NORMAL OUTPUT FORMATTING, WITH THE RULE THAT
        * A TRAILING '0' IS ADDED IF THE NUMBER OUTPUT ENDS IN '.'
        *
2026             JSON_DIGIT19 = ANY("123456789")
2027             JSON_DIGIT = ANY("0123456789")
2028             JSON_DIGITS = JSON_DIGIT (*JSON_DIGITS | NULL)
2029             JSON_E = 'e+' | 'e-' | 'E+' | 'E-' | 'e' | 'E'
2030             JSON_EXP = JSON_E JSON_DIGITS
2031             JSON_FRAC = "." JSON_DIGITS
2032             JSON_INT = ("-" | NULL)
2032    +                   ((JSON_DIGIT19 JSON_DIGITS) | JSON_DIGIT)
2033             JSON_NUMBER = JSON_INT (JSON_FRAC | NULL) (JSON_EXP | NULL)
        *
        * JSON CONSTANTS. THESE ARE NOT IN THE SNOBOL4 LEXICON, SO WE
        * CREATE A TYPE THAT REPRESENT THESE VALUES UNIQUELY.
        *
        -PUBLIC JSON_NULL, JSON_TRUE, JSON_FALSE
        *
2034             DATA('JSON_CONSTANT(VALUE)')
2035             JSON_NULL = JSON_CONSTANT('null')
2036             JSON_TRUE = JSON_CONSTANT('true')
2037             JSON_FALSE = JSON_CONSTANT('false')
        *
        * JSON_NL AND JSON_IN ARE PRODUCED FOR NEWLINE AND INDENT SEPARATION.
        * DEFAULT IS A NEWLINE AND TWO SPACES. TO PRODUCE COMPACT JSON, REPLACE
        * WITH NULL.
        *
        -PUBLIC JSON_NL, JSON_IN
        *
2038             JSON_NL = CHARS_NL
2039             JSON_IN = '  '
        *
        * JSON_REST IS THE REST OF THE INPUT AFTER PARSING A JSON DOCUMENT
        * FROM THE FRONT. THIS IS MEANT TO ALLOW CONCATENATION OF JSON
        * DOCUMENTS.
        *
        -PUBLIC JSON_REST
        *
2040             JSON_REST =
        *
        * JSON_HEX IS A HEX DIGIT USED BY THE \u CHARACTER IS A JSON STRING.
        * JSON_NSET IS THE SET OF CHARACTERS WHICH CAN BE SIMPLY ACCEPTED IN
        * A STRING. ANY CHARACTER NOT IN JSON_NSET (NORMAL SET) IS ESCAPED.
        *
2041             JSON_HEX = ANY('0123456789abcdefABCDEF')
2042             JSON_NSET = SDIFF(CHARS_PRINTABLE, '"\/')           :(JSON_END)
        *
2043    JSON_ESCAPE
2044             JSON_ESCAPE = IDENT(C, '"') '\"'                     :S(RETURN)
2045             JSON_ESCAPE = IDENT(C, '\') '\\'                     :S(RETURN)
2046             JSON_ESCAPE = IDENT(C, '/') '\/'                     :S(RETURN)
2047             JSON_ESCAPE = IDENT(C, CHARS_BS) '\b'                :S(RETURN)
2048             JSON_ESCAPE = IDENT(C, CHARS_FF) '\f'                :S(RETURN)
2049             JSON_ESCAPE = IDENT(C, CHARS_NL) '\n'                :S(RETURN)
2050             JSON_ESCAPE = IDENT(C, CHARS_HT) '\t'                :S(RETURN)
2051             JSON_ESCAPE = IDENT(C, CHARS_CR) '\r'                :S(RETURN)
        *
        * FIXME: NOT RIGHT. SHOULD PASS THROUGH UTF-8, AND ONLY CONVERT CONTROL
        *        WE ARE CHEATING BY JUST USING THIS TO CONVERT BYTES.
        *
2052             JSON_ESCAPE = '\u00' HEX(C)                           :(RETURN)
        *
2053    JSON_ENCODE_STRING
2054             L =
2055             S (SPAN(JSON_NSET) | NULL) . L REM . S
2056             JSON_ENCODE_STRING = JSON_ENCODE_STRING L
2057             IDENT(S)                               :S(JSON_ENCODE_STRING_2)
2058             S LEN(1) . C REM . S
2059             JSON_ENCODE_STRING = JSON_ENCODE_STRING JSON_ESCAPE(C)
2059    +                                                  :(JSON_ENCODE_STRING)
2060    JSON_ENCODE_STRING_2
2061             JSON_ENCODE_STRING = '"' JSON_ENCODE_STRING '"'       :(RETURN)
        *
        * CAREFUL WITH REAL VALUES. CSNOBOL4 WILL PRINT '4.' (FOR EXAMPLE).
        * BY THE SYNTAX SPECIFIED, THIS IS NOT LEGAL. '4.0' IS THE LEGAL
        * FORM. FIX THIS BY APPENDING A '0' IF THE FINAL CHARACTER OF A REAL
        * CONVERSION IS '.'.
        *
        * BOTH TABLE AND ARRAY TYPES CAUSE A RECURSION. DATA() TYPES CANNOT
        * BE SERIALIZED.
        *
2062    JSON_ENCODE_VALUE
2063             JSON_ENCODE_VALUE = IDENT(X, JSON_NULL) 'null'       :S(RETURN)
2064             JSON_ENCODE_VALUE = IDENT(X, JSON_TRUE) 'true'       :S(RETURN)
2065             JSON_ENCODE_VALUE = IDENT(X, JSON_FALSE) 'false'     :S(RETURN)
2066             JSON_ENCODE_VALUE = IDENT(X) '""'                    :S(RETURN)
2067             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'INTEGER') X  :S(RETURN)
2068             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'REAL') X
2068    +                                                :F(JSON_ENCODE_VALUE_2)
        *
        * THE FOLLOWING CONDITION WILL NOT HAPPEN WITH SPITBOL.EXE
        *
2069             JSON_ENCODE_VALUE 'nan' | 'inf'         :S(JSON_ENCODE_VALUE_3)
2070             JSON_ENCODE_VALUE RTAB(1) '.'                        :F(RETURN)
2071             JSON_ENCODE_VALUE = JSON_ENCODE_VALUE '0'             :(RETURN)
2072    JSON_ENCODE_VALUE_2
2073             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'STRING')
2073    +                            JSON_ENCODE_STRING(X)            :S(RETURN)
2074             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'TABLE')
2074    +                            JSON_ENCODE_OBJECT(X)            :S(RETURN)
2075             JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'ARRAY')
2075    +                            JSON_ENCODE_ARRAY(X)             :S(RETURN)
2076    JSON_ENCODE_VALUE_3
2077             TERMINAL = 'JSON_ENCODE_VALUE: CANNOT ENCODE: '
2077    +                   DATATYPE(X) ' ' X
2078                                                                      :(END)
        *
2079    JSON_INDENT
2080             JSON_INDENT = DUPL(JSON_IN, L)                        :(RETURN)
        *
2081    JSON_ENCODE_ARRAY
2082             JSON_ENCODE_ARRAY = '['
2083             L = L + 1
2084             DIFFER(DATATYPE(X), 'ARRAY')            :S(JSON_ENCODE_ARRAY_2)
2085             I = 1
2086             X<I>                                    :F(JSON_ENCODE_ARRAY_2)
2087    JSON_ENCODE_ARRAY_1
2088             JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
2088    +                            JSON_INDENT()
2088    +                            JSON_ENCODE_VALUE(X<I>)
2089             I = I + 1
2090             X<I>                                    :F(JSON_ENCODE_ARRAY_2)
2091             JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY ','
2091    +                                                 :(JSON_ENCODE_ARRAY_1)
2092    JSON_ENCODE_ARRAY_2
2093             L = L - 1
2094             JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
2094    +                            JSON_INDENT() ']'                 :(RETURN)
        *
2095    JSON_ENCODE_OBJECT
2096             JSON_ENCODE_OBJECT = '{'
2097             L = L + 1
2098             DIFFER(DATATYPE(X), 'TABLE')           :S(JSON_ENCODE_OBJECT_2)
2099             K = KEYST(X)                           :F(JSON_ENCODE_OBJECT_2)
2100             I = 1
2101    JSON_ENCODE_OBJECT_1
2102             JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
2102    +                             JSON_INDENT()
2102    +                             JSON_ENCODE_STRING(K<I>) ': '
2102    +                             JSON_ENCODE_VALUE(X<K<I>>)
2103             I = I + 1
2104             K<I>                                   :F(JSON_ENCODE_OBJECT_2)
2105             JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT ','
2105    +                                                :(JSON_ENCODE_OBJECT_1)
2106    JSON_ENCODE_OBJECT_2
2107             L = L - 1
2108             JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
2108    +                             JSON_INDENT() '}'                :(RETURN)
        *
2109    JSON_ENCODE
2110             L = 0
2111             JSON_ENCODE = JSON_ENCODE_VALUE(X)                    :(RETURN)
        *
2112    JSON_DECODE_STRING
2113             X BREAK('\"') . S =                                 :F(FRETURN)
2114             JSON_DECODE_STRING = JSON_DECODE_STRING S
2115             X POS(0) '"' =                                       :S(RETURN)
2116             JSON_DECODE_STRING = ?(X ? POS(0) '\b' =)
2116    +                     JSON_DECODE_STRING CHARS_BS :S(JSON_DECODE_STRING)
2117             JSON_DECODE_STRING = ?(X ? POS(0) '\f' =)
2117    +                     JSON_DECODE_STRING CHARS_FF :S(JSON_DECODE_STRING)
2118             JSON_DECODE_STRING = ?(X ? POS(0) '\n' =)
2118    +                     JSON_DECODE_STRING CHARS_NL :S(JSON_DECODE_STRING)
2119             JSON_DECODE_STRING = ?(X ? POS(0) '\t' =)
2119    +                     JSON_DECODE_STRING CHARS_HT :S(JSON_DECODE_STRING)
2120             JSON_DECODE_STRING = ?(X ? POS(0) '\r' =)
2120    +                     JSON_DECODE_STRING CHARS_CR :S(JSON_DECODE_STRING)
2121             JSON_DECODE_STRING = ?(X ? POS(0) '\"' =)
2121    +                     JSON_DECODE_STRING '"'      :S(JSON_DECODE_STRING)
2122             JSON_DECODE_STRING = ?(X ? POS(0) '\\' =)
2122    +                     JSON_DECODE_STRING '\'      :S(JSON_DECODE_STRING)
2123             JSON_DECODE_STRING = ?(X ? POS(0) '\/' =)
2123    +                     JSON_DECODE_STRING '/'      :S(JSON_DECODE_STRING)
        * FIXME: HANDLE UTF SEQUENCES PROPERLY
2124             X POS(0) '\u00' (JSON_HEX JSON_HEX) . C =
2124    +                                               :F(JSON_DECODE_STRING_2)
2125             JSON_DECODE_STRING = JSON_DECODE_STRING CH(C)
2125    +                                                  :(JSON_DECODE_STRING)
2126    JSON_DECODE_STRING_2
2127             TERMINAL = 'JSON_DECODE_STRING: ' X                      :(END)
        *
2128    JSON_DECODE_VALUE
2129             X POS(0) JSON_WS =
2130             IDENT(X)                                            :S(FRETURN)
2131             JSON_DECODE_VALUE = ?(X ? POS(0) 'null' =) JSON_NULL
2131    +                                                             :S(RETURN)
2132             JSON_DECODE_VALUE = ?(X ? POS(0) 'true' =) JSON_TRUE
2132    +                                                             :S(RETURN)
2133             JSON_DECODE_VALUE = ?(X ? POS(0) 'false' =) JSON_FALSE
2133    +                                                             :S(RETURN)
2134             X POS(0) '"' =                          :F(JSON_DECODE_VALUE_2)
2135             JSON_DECODE_VALUE =  JSON_DECODE_STRING()  :S(RETURN)F(FRETURN)
2136    JSON_DECODE_VALUE_2
2137             X POS(0) '{' =                          :F(JSON_DECODE_VALUE_3)
2138             JSON_DECODE_VALUE = JSON_DECODE_OBJECT()   :S(RETURN)F(FRETURN)
2139    JSON_DECODE_VALUE_3
2140             X POS(0) '[' =                          :F(JSON_DECODE_VALUE_4)
2141             JSON_DECODE_VALUE = JSON_DECODE_ARRAY()    :S(RETURN)F(FRETURN)
2142    JSON_DECODE_VALUE_4
2143             X JSON_NUMBER . JSON_DECODE_VALUE =                 :F(FRETURN)
2144             JSON_DECODE_VALUE = +JSON_DECODE_VALUE                :(RETURN)
        *
2145    JSON_DECODE_ARRAY
2146             T = TABLE()
2147             I = 0
2148    JSON_DECODE_ARRAY_1
2149             X POS(0) JSON_WS =
2150             IDENT(X)                                            :S(FRETURN)
2151             X POS(0) ']' =                          :S(JSON_DECODE_ARRAY_2)
2152             I = I + 1
2153             T<I> = JSON_DECODE_VALUE()                          :F(FRETURN)
2154             X POS(0) JSON_WS ',' =                   :(JSON_DECODE_ARRAY_1)
2155    JSON_DECODE_ARRAY_2
2156             JSON_DECODE_ARRAY = EQ(I) ARRAY0                     :S(RETURN)
2157             JSON_DECODE_ARRAY = ARRAY(I)
2158             SEQ(' JSON_DECODE_ARRAY<I> = T<I> ', .I)              :(RETURN)
        *
2159    JSON_DECODE_OBJECT
2160             JSON_DECODE_OBJECT = TABLE()
2161    JSON_DECODE_OBJECT_1
2162             X POS(0) JSON_WS =
2163             IDENT(X)                                            :S(FRETURN)
2164             X POS(0) '}' =                                       :S(RETURN)
2165             X POS(0) '"' =                                      :F(FRETURN)
2166             T = JSON_DECODE_STRING()                            :F(FRETURN)
2167             X POS(0) JSON_WS ':' =                              :F(FRETURN)
2168             T2 = JSON_DECODE_VALUE()                            :F(FRETURN)
2169             JSON_DECODE_OBJECT<T> = T2
2170             X POS(0) JSON_WS ',' =                  :(JSON_DECODE_OBJECT_1)
        *
2171    JSON_DECODE
2172             X = X CHARS_NL
2173             JSON_DECODE = JSON_DECODE_VALUE()                   :F(FRETURN)
2174             JSON_REST = X                                         :(RETURN)
        *
2175    JSON_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'TIME.INC'
        -IN72
        -LINE 305 "FCGI.lss"
        -STITL FCGI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #######   #####    #####   ###                    *
        *                    #        #     #  #     #   #                     *
        *                    #        #        #         #                     *
        *                    #####    #        #  ####   #                     *
        *                    #        #        #     #   #                     *
        *                    #        #     #  #     #   #                     *
        *                    #         #####    #####   ###                    *
        *                                                                      *
        * FCGI                   FCGI SUPPORT FUNCTIONS                        *
        *                                                                      *
        ************************************************************************
        *
        * FCGI.lss
        *
        -LINE 37 "FCGI.lss"
2176             FCGI_LOGUNIT = IO_FINDUNIT()
2177             OUTPUT(.FCGI_LOG, FCGI_LOGUNIT, 'W',
2177    +               '|/usr/bin/logger -n localhost -t FCGI')
2178             STDIN_FILENO = 0
2179             FCGI_LISTENSOCK_FILENO = STDIN_FILENO
        *
2180             FCGI_BEGIN_REQUEST     =  1
2181             FCGI_ABORT_REQUEST     =  2
2182             FCGI_END_REQUEST       =  3
2183             FCGI_PARAMS            =  4
2184             FCGI_STDIN             =  5
2185             FCGI_STDOUT            =  6
2186             FCGI_STDERR            =  7
2187             FCGI_DATA              =  8
2188             FCGI_GET_VALUES        =  9
2189             FCGI_GET_VALUES_RESULT = 10
2190             FCGI_UNKNOWN_TYPE      = 11
        *
2191             FCGI_RESPONDER  = 1
2192             FCGI_AUTHORIZER = 2
2193             FCGI_FILTER     = 3
        *
        -PUBLIC FCGI_REQUEST_COMPLETE, FCGI_CANT_MPX_CONN, FCGI_OVERLOADED
        -PUBLIC FCGI_UNKNOWN_ROLE
2194             FCGI_REQUEST_COMPLETE = 0
2195             FCGI_CANT_MPX_CONN    = 1
2196             FCGI_OVERLOADED       = 2
2197             FCGI_UNKNOWN_ROLE     = 3
        *
        * getpeername RETURNS PEER NAME FOR STDIN IF RUNNING UNDER FCGI. IT
        * ACTUALLY RETURNS TRANSPORT END-POINT NOT CONNECTED. IF IT ISN'T A
        * SOCKET AT ALL, DEFINITELY CGI CASE.
        *
2198             PEER = BQ('/usr/bin/getpeername 2>&1')             :F(NOT_FCGI)
2199             PEER 'Socket operation on non-socket'              :S(NOT_FCGI)
        *
2200             FCGI_LOG = 'FCGI'
        *
        * INFORM CGI THAT FAST CGI IS IN USE. DEFINE THE ACCEPT() FUNCTION.
        * LISTEN() HAS ALREADY BEEN DONE IN THE WEB SERVER.
        *
2201             USE_FCGI = 1
2202    NOT_FCGI FCGI_LOG = IDENT(USER_FCGI) 'NORMAL CGI'
2203             FFI_ACCEPT = FFI_NEW('I', 'I,P,P')
2204             FFI_SET_CALLP(FFI_ACCEPT, DLSYM(0, 'accept'))
        -PUBLIC FCGI_ACCEPT(), ACCEPT(), FCGI_SEND(), FCGI_SEND_ERR(),
        -PUBLIC FCGI_END()
2205             DEFINE('FCGI_ACCEPT()')
2206             DEFINE('ACCEPT(SOCKET,P1,P2)')
2207             DEFINE('FCGI_NAMES(T,A)')
2208             DEFINE('FCGI_SEND(S)')
2209             DEFINE('FCGI_SEND_ERR(S)')
2210             DEFINE('FCGI_SEND_(D,S)B')
2211             DEFINE('FCGI_END(APP_STATUS,PROT_STATUS)S,B0,B1,B2,B3')
2212             DEFINE('FCGI_GET()')                               :(FCGI_END_)
        *
2213    ACCEPT   CLEAR_ERRNO()
2214             FFI_PAR_N_INTEGER(FFI_ACCEPT, 1, SOCKET)
2215             FFI_PAR_N_PTR(FFI_ACCEPT, 2, P1)
2216             FFI_PAR_N_PTR(FFI_ACCEPT, 3, P2)
2217             ACCEPT = FFI_CALL_INTEGER(FFI_ACCEPT)                 :(RETURN)
        *
        * IF THE DATA TO SEND IS 0...65535 BYTES, SEND IT. IF GREATER,
        * SEND THE FIRST 65535, AND LOOP FOR THE REST
        *
2218    FCGI_SEND_
2219             LT(SIZE(S), 65536)                              :S(FCGI_SEND_2)
2220             S LEN(65535) . B REM . S
2221             FCGI_SEND_(D, B)                                  :(FCGI_SEND_)
2222    FCGI_SEND_2
2223             FCGI_LOG = 'FCGI_SEND: '  D ' ' SIZE(S)
2224             S = CHAR(1) CHAR(D)
2224    +            CHAR(FCGI_REQUESTID / 256) CHAR(REMDR(FCGI_REQUESTID, 256))
2224    +            CHAR(SIZE(S) / 256) CHAR(REMDR(SIZE(S), 256))
2224    +            CHAR(0) CHAR(0) S
2225             FCGI_OUT = S                                          :(RETURN)
        *
2226    FCGI_SEND
2227             FCGI_SEND_(FCGI_STDOUT, S)                            :(RETURN)
        *
2228    FCGI_SEND_ERR
2229             FCGI_SEND_(FCGI_STDERR, S)                            :(RETURN)
        *
2230    FCGI_END FCGI_LOG = 'FCGI_END: ' APP_STATUS ' ' PROT_STATUS
2231             B3 = APP_STATUS / 16777216
2232             APP_STATUS = REMDR(APP_STATUS, 16777216)
2233             B2 = APP_STATUS / 65536
2234             APP_STATUS = REMDR(APP_STATUS, 65536)
2235             B1 = APP_STATUS / 256
2236             B0 = REMDR(APP_STATUS, 256)
2237             S = CHAR(B3) CHAR(B2) CHAR(B1) CHAR(B0) CHAR(PROT_STATUS)
2237    +            CHAR(0) CHAR(0) CHAR(0)
2238             B1 = FCGI_REQUESTID / 256
2239             B0 = REMDR(FCGI_REQUESTID, 256)
2240             S = CHAR(1) CHAR(FCGI_END_REQUEST) CHAR(B1) CHAR(B0)
2240    +            CHAR(0) CHAR(8) CHAR(0) CHAR(0) S
2241             FCGI_OUT = S                                          :(RETURN)
        *
2242    FCGI_GET VERSION = ORD(FCGI)
2243             FCGI_LOG = DIFFER(VERSION, 1) 'VERSION <> 1'            :S(END)
2244             TYPE = ORD(FCGI)
2245             REQUESTID = ORD(FCGI) * 256
2246             REQUESTID = REQUESTID + ORD(FCGI)
2247             CONTENTLENGTH = ORD(FCGI) * 256
2248             CONTENTLENGTH = CONTENTLENGTH + ORD(FCGI)
2249             PADDINGLENGTH = ORD(FCGI)
2250             RESERVED = ORD(FCGI)
        *
        * WE COULD READ THIS IN ONE GULP, AND AVOID CONVERTING TO ARRAY AND
        * THEN BACK INTO STRING.
        *
2251             FCGI_GET = NE(CONTENTLENGTH) ARRAY(CONTENTLENGTH)
2252             I = 1
2253    FCGI_4   GT(I, CONTENTLENGTH)                                 :S(FCGI_5)
2254             FCGI_GET<I> = ORD(FCGI)
2255             I = I + 1                                             :(FCGI_4)
2256    FCGI_5   I = 1
2257    FCGI_6   GT(I, PADDINGLENGTH)                                 :S(RETURN)
2258             S = FCGI
2259             I = I + 1                                             :(FCGI_6)
        *
        * EXTRACT NAMES FROM ARRAY. TWO LENGTH FIELDS, EITHER 1 OR 4 BYTES,
        * THEN THE ACTUAL NAME AND DATA.
        *
2260    FCGI_NAMES
2261             I = 1
2262    FCGI_NAMES_7
2263             NL = A<I>
2264             EQ(AND(NL, 128))                               :S(FCGI_NAMES_2)
2265             NL = AND(A<I>, 127) * 16777216 +
2265    +             A<I + 1> * 65536 +
2265    +             A<I + 2> * 256 +
2265    +             A<I + 3>
2266             I = I + 3
2267    FCGI_NAMES_2
2268             I = I + 1
2269             DL = A<I>
2270             EQ(AND(NL, 128))                               :S(FCGI_NAMES_3)
2271             DL = AND(A<I>, 127) * 16777216 +
2271    +             A<I + 1> * 65536 +
2271    +             A<I + 2> * 256 +
2271    +             A<I + 3>
2272             I = I + 3
2273    FCGI_NAMES_3
2274             I = I + 1
2275             NM =
2276             DA =
2277    FCGI_NAMES_4
2278             EQ(NL)                                         :S(FCGI_NAMES_5)
2279             NM = NM CHAR(A<I>)
2280             I = I + 1
2281             NL = NL - 1                                     :(FCGI_NAMES_4)
2282    FCGI_NAMES_5
2283             EQ(DL)                                         :S(FCGI_NAMES_6)
2284             DA = DA CHAR(A<I>)
2285             I = I + 1
2286             DL = DL - 1                                     :(FCGI_NAMES_5)
2287    FCGI_NAMES_6
2288             T<NM> = DA
2289             A<I>                                  :F(RETURN)S(FCGI_NAMES_7)
        *
        * MAIN FCGI FUNCTION
        *
2290    FCGI_ACCEPT
2291             IDENT(USE_FCGI)                                      :S(RETURN)
2292             FCGI_LOG = 'FCGI_ACCEPT: WAITING'
2293             SOCKET = ACCEPT(FCGI_LISTENSOCK_FILENO, 0, 0)
2294             FCGI_LOG = 'AFTER ACCEPT'
2295             GE(SOCKET)                                           :S(FCGI_2)
        *
        * ON ERROR IN ACCEPT, WE DISPLAY ERRNO AND EXIT THE PROCESS
        *
2296             ERRNO = GET_ERRNO()
2297             FCGI_LOG = 'ACCEPT: ERRNO = ' ERRNO                      :(END)
        *
        * READ AND DIGEST PACKETS FROM SOCKET. CLEAN UP OLD INSTANCE I/O
        * (FCGI IS GOING TO STAY AROUND EXECUTING REQUESTS). THEN
        * OPEN THE SOCKET PASSED TO US BY ACCEPT().
        *
2298    FCGI_2   IDENT(FCGI_INSTANCE_UNIT)                            :S(FCGI_8)
2299             DETACH(.FCGI)
2300             DETACH(.FCGI_OUT)
2301             ENDFILE(FCGI_INSTANCE_UNIT)
2302    FCGI_8   FCGI_LOG = 'SOCKET = ' SOCKET
2303             FCGI_INSTANCE_UNIT = IO_FINDUNIT()
2304             FCGI_LOG = 'UNIT = ' FCGI_INSTANCE_UNIT
2305             INPUT(.FCGI, FCGI_INSTANCE_UNIT, 'U,B,1', '/dev/fd/' SOCKET)
2306             OUTPUT(.FCGI_OUT, FCGI_INSTANCE_UNIT, 'W,B,1')
        *
2307             FCGI_ENV = TABLE()
2308             FCGI_IN =
2309             FCGI_REQUESTID =
        *
        * PACKET LOOP
        *
2310    FCGI_PLOOP
2311             CONTENT = FCGI_GET()
2312             FCGI_REQUESTID = IDENT(FCGI_REQUESTID) REQUESTID
2313             EQ(REQUESTID, FCGI_REQUESTID)                  :S(FCGI_PLOOP_2)
2314             FCGI_LOG = 'ONLY SINGLE REQUESTID SUPPORTED'             :(END)
        *
        * WE DO NOT MULTIPLEX REQUESTID, NEED TO SET INDICATION OF THAT
        * IN FCGI_GET().
        *
2315    FCGI_PLOOP_2
2316             EQ(TYPE, FCGI_BEGIN_REQUEST)                        :F(FCGI_10)
2317             FCGI_LOG = 'FCGI_BEGIN_REQUEST'
2318             FCGI_ROLE = CONTENT<1> * 256 + CONTENT<2>
2319             FCGI_LOG = NE(FCGI_ROLE, FCGI_RESPONDER)
2319    +           'ROLE NOT RESPONDER'                                 :S(END)
2320             FCGI_FLAGS = CONTENT<3>
2321             FCGI_REQUESTID = REQUESTID                        :(FCGI_PLOOP)
        *
2322    FCGI_10  EQ(TYPE, FCGI_PARAMS)                               :F(FCGI_11)
2323             FCGI_LOG = 'FCGI_PARAMS'
2324             IDENT(CONTENT)                                   :S(FCGI_PLOOP)
2325             FCGI_NAMES(FCGI_ENV, CONTENT)                     :(FCGI_PLOOP)
        *
2326    FCGI_11  EQ(TYPE, FCGI_STDIN)                                :F(FCGI_12)
2327             FCGI_LOG = 'FCGI_STDIN'
2328             IDENT(CONTENT)                                      :S(FCGI_GO)
2329             I = 1
        * FIXME: WE READ IT AS A STRING, CONVERT TO ARRAY OF SMALL INTEGERS,
        * AND THEN MAKE IT A STRING AGAIN. THIS IS DONE BECAUSE WE ARE GOING
        * TO DO PACKET DISASSEMBLY, AND THAT IS ARGUABLY EASIER IN THE SMALL
        * INTEGER SPACE. STILL, IT SHOULD BE FIXED.
2330    FCGI_13  FCGI_IN = FCGI_IN CHAR(CONTENT<I>)               :F(FCGI_PLOOP)
2331             I = I + 1                                            :(FCGI_13)
        *
2332    FCGI_12
2333             FCGI_LOG = 'BAD TYPE: ' TYPE                             :(END)
        *
2334    FCGI_GO
2335             FCGI_LOG = 'FCGI_GO'
        *
        * HERE WE ILLUSTRATE AN INTERESTING TECHNIQUE. SINCE JSON_ENCODE WILL
        * TRAVERSE TABLES AND ARRAYS, WE CAN USE IT TO EXAMINE VARIABLES BY
        * SENDING THE JSON ENCODING TO A LOG FILE.
        *
2336             FCGI_LOG = 'FCGI_ENV: '
2337             FCGI_LOG = JSON_ENCODE(FCGI_ENV)
        *
        * BUG ALERT: IF THIS IS NOT DONE, GETTIMEOFDAY(), GMTIME() ETC.
        * FAULT ON THE SECOND PASS THROUGH FCGI. HAPPENS WITH CSNOBOL4 1.5
        *
        * TRY TO ISOLATE THIS FURTHER.
        *
2338             T = GETTIMEOFDAY()
2339                                                                   :(RETURN)
        *
2340    FCGI_END_
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'HASH.INC'
        -MODULE HASH
        -LINE 54 "HASH.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'COPYT.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'MERGET.INC'
        -MODULE MERGET
        -LINE 13 "MERGET.lss"
        -INCLUDE 'COPYT.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 42 "MERGET.lss"
        -STITL MERGET
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #     #  #######  ######    #####   #######  #######         *
        *         ##   ##  #        #     #  #     #  #           #            *
        *         # # # #  #        #     #  #        #           #            *
        *         #  #  #  #####    ######   #  ####  #####       #            *
        *         #     #  #        #   #    #     #  #           #            *
        *         #     #  #        #    #   #     #  #           #            *
        *         #     #  #######  #     #   #####   #######     #            *
        *                                                                      *
        * MERGET                     MERGE TABLES                              *
        *                                                                      *
        ************************************************************************
        *
        * MERGET.lss
        *
        -LINE 18 "MERGET.lss"
        -PUBLIC MERGET()
        *
2341             DEFINE('MERGET(T1,T2)A,I')                        :(MERGET_END)
        *
2342    MERGET   MERGET = COPYT(T1)
2343             A = CONVERT(T2, 'ARRAY')
2344             SEQ(' MERGET<A<I, 1>> = A<I, 2> ', .I)                :(RETURN)
        *
2345    MERGET_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -LINE 126 "HASH.lss"
        -STITL HASH
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                  #     #     #      #####   #     #                  *
        *                  #     #    # #    #     #  #     #                  *
        *                  #     #   #   #   #        #     #                  *
        *                  #######  #     #   #####   #######                  *
        *                  #     #  #######        #  #     #                  *
        *                  #     #  #     #  #     #  #     #                  *
        *                  #     #  #     #   #####   #     #                  *
        *                                                                      *
        * HASH                   INITIALIZE A TABLE                            *
        *                                                                      *
        ************************************************************************
        *
        * HASH.lss
        *
        -LINE 63 "HASH.lss"
        -PUBLIC HASH(), #1
        *
2346             DEFINE('HASH(S,E,P,TS,TI,FK,FV,SP)K,V,C')
2347             DEFINE('HASH_3(S)')
2348             OPSYN('#', 'HASH', 1)                               :(HASH_END)
        *
2349    HASH     HASH = TABLE(TS, TI)
2350             E = IDENT(E) '='
2351             P = IDENT(P) ','
2352             FK = IDENT(FK) 'HASH_3'
2353             FV = IDENT(FV) 'HASH_3'
2354    HASH_2   IDENT(S)                                             :S(RETURN)
2355             S POS(0) BREAK(E P) LEN(1) . C                       :F(HASH_5)
2356             C E                                                  :F(HASH_5)
2357             S POS(0) BREAK(E) . K E =                            :S(HASH_4)
2358    HASH_5   K =
2359    HASH_4   S POS(0) BRKREM(P) . V (P | RPOS(0)) =               :F(RETURN)
2360             K = APPLY(FK, K)
2361             V = APPLY(FV, V)
2362             HASH<K> = VDIFFER(HASH<K>) VDIFFER(SP) V             :S(HASH_2)
2363             HASH<K> = V                                           :(HASH_2)
        *
2364    HASH_3   HASH_3 = S                                            :(RETURN)
        *
2365    HASH_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HTMLESC.INC'
        -MODULE HTMLESC
        -LINE 14 "HTMLESC.lss"
        -INCLUDE 'CH.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HEX.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'SDIFF.INC'
        -IN72
        -LINE 110 "HTMLESC.lss"
        -STITL HTMLESC
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #     #  #######  #     #  #        #######   #####    #####      *
        *    #     #     #     ##   ##  #        #        #     #  #     #     *
        *    #     #     #     # # # #  #        #        #        #           *
        *    #######     #     #  #  #  #        #####     #####   #           *
        *    #     #     #     #     #  #        #              #  #           *
        *    #     #     #     #     #  #        #        #     #  #     #     *
        *    #     #     #     #     #  #######  #######   #####    #####      *
        *                                                                      *
        * HTMLESC             HTML (JS, URL) ESCAPING                          *
        *                                                                      *
        ************************************************************************
        *
        * HTMLESC.lss
        *
        -LINE 40 "HTMLESC.lss"
        -PUBLIC HTML_ESCAPE()
2366             DEFINE('HTML_ESCAPE(S)')                     :(END_HTML_ESCAPE)
        *
2367    HTML_ESCAPE
2368             S = REPL(S, '&', '&amp;')
2369             S = REPL(S, '<', '&lt;',)
2370             S = REPL(S, '>', '&gt;',)
2371             S = REPL(S, '"', '&quot;')
2372             S = REPL(S, "'", '&#39;')
2373             HTML_ESCAPE = S                                       :(RETURN)
        *
2374    END_HTML_ESCAPE
        *
        -LINE 57 "HTMLESC.lss"
        -PUBLIC JS_ESCAPE()
2375             DEFINE('JS_ESCAPE(S)')                         :(END_JS_ESCAPE)
        *
2376    JS_ESCAPE
2377             S = REPL(S, '\', '\\')
2378             S = REPL(S, "'", "\'")
2379             S = REPL(S, '"', '\"')
2380             S = REPL(S, CHARS_NL, '\n')
2381             S = REPL(S, CHARS_CR, '\r')
2382             JS_ESCAPE = S                                         :(RETURN)
        *
2383    END_JS_ESCAPE
        *
        -LINE 78 "HTMLESC.lss"
        -PUBLIC URL_ESCAPE(), URL_DECODE()
2384             DEFINE('URL_ESCAPE(S)L,C,R')
2385             DEFINE('URL_DECODE(S)L,C,R')
2386             URL_BAD = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789' '_-~.')
2387             URL_HEX = ANY('0123456789abcdefABCDEF')
2387    +                                                      :(END_URL_ESCAPE)
        *
2388    URL_DECODE_2
2389             S = R
2390    URL_DECODE
2391             C =
2392             S BREAK("+%") . L LEN(1) . C REM . R
2393             URL_DECODE = IDENT(C) URL_DECODE S                   :S(RETURN)
2394             URL_DECODE = IDENT(C, '+') URL_DECODE L ' '    :S(URL_DECODE_2)
2395             URL_DECODE = URL_DECODE L
2396             R (URL_HEX URL_HEX) . C =                      :F(URL_DECODE_2)
2397             URL_DECODE = URL_DECODE CH(C)                   :(URL_DECODE_2)
        *
2398    URL_ESCAPE
2399             S BREAK(URL_BAD) . L LEN(1) . C REM . R             :F(URLESC2)
2400             URL_ESCAPE = IDENT(C, ' ') URL_ESCAPE L '+'
2401             URL_ESCAPE = DIFFER(C, ' ') URL_ESCAPE L '%' HEX(C)
2402             S = R                                             :(URL_ESCAPE)
2403    URLESC2  URL_ESCAPE = URL_ESCAPE S                             :(RETURN)
        *
2404    END_URL_ESCAPE
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HTMLTMPL.INC'
        -PLUSOPS 1
2405      :(HTMLTMPL.1)
        -MODULE HTMLTMPL
        -SNOCONE
        -LINE 28 "HTMLTMPL.lss"
        -LINE 293 "HTMLTMPL.lss"
        -IN1024
        -LINE 72 "HTMLTMPL.lss"
        -LINE 84 "HTMLTMPL.lss"
2406      :(TMPL_INIT.END)
        -LINE 88
2407    TMPL_INIT TMPL_DIR = "./"
        -LINE 92
2408     TMPL_WS = SPAN(" " CHARS_TAB) | ""
        -LINE 93
2409     TMPL = ("/" | "") . H ANY("Tt") ANY("Mm") ANY("Pp") ANY("Ll") "_"
        -LINE 95
2410     TMPL_TAG = TMPL SPAN(&UCASE &LCASE) . TAG
        -LINE 96
2411     TMPL_C = "<!-- " TMPL_WS TMPL_TAG ARB . ARG " -->"
        -LINE 97
2412     TMPL_T = "<" TMPL_TAG BREAK(">") . ARG ">"
        -LINE 98
2413     TMPL_PIECE = POS(0) BREAKX("<") . L (TMPL_T | TMPL_C) . P REM . R
        -LINE 100
2414     TMPL_KEYS = "var if unless else loop include "
        -LINE 104
2415     TMPL_ARG_VAR = TMPL_WS (ANY(&LCASE &UCASE) SPAN(&LCASE
2415    +&UCASE '0123456789' "_")) . N TMPL_WS
        -LINE 106
2416     TMPL_QVAL = '"' BREAK('"') . V '"'
        -LINE 107
2417     TMPL_SVAL = BREAK(" " CHARS_TAB) . V
        -LINE 108
2418     TMPL_ARG_P = (TMPL_ARG_VAR "=" | "") TMPL_WS (TMPL_QVAL
2418    +| TMPL_SVAL | REM . V) :(RETURN)
        -LINE 115
2419    TMPL_INIT.END  :(TMPL_COMPILE.END)
        -LINE 116
2420    TMPL_COMPILE L = TMPL_TOKENIZE(S) :S(HTMLTMPL.2)F(FRETURN)
        -LINE 118
2421    HTMLTMPL.2 L = TMPL_PARSE(L) :S(HTMLTMPL.3)F(FRETURN)
        -LINE 120
2422    HTMLTMPL.3 TMPL_COMPILE = L :(RETURN)
        -LINE 127
2423    TMPL_COMPILE.END  :(TMPL_INTERPRET.END)
        -LINE 128
2424    TMPL_INTERPRET INTERPRET_TMPL(P,A) :(RETURN)
        -LINE 133
2425    TMPL_INTERPRET.END  :(NONE_ESCAPE.END)
        -LINE 134
2426    NONE_ESCAPE NONE_ESCAPE = S :(RETURN)
        -LINE 139
2427    NONE_ESCAPE.END  :(INTERPRET_TMPL.END)
        -LINE 140
2428    INTERPRET_TMPL P
2429    HTMLTMPL.4 DIFFER(P,"") :F(HTMLTMPL.5)
        -LINE 141
2430     V = VALUE(VALUE(P))
        -LINE 142
2431     IDENT(TOKEN_TYPE(V),"text") :F(HTMLTMPL.6)
        -LINE 144
2432     TMPL_INTERPRET = TMPL_INTERPRET TOKEN_ARGS(V) :(HTMLTMPL.7)
        -LINE 146
2433    HTMLTMPL.6 T = TOKEN_ARGS(V)
        -LINE 147
2434     N = A<T<"name">>
        -LINE 148
2435     IDENT(TOKEN_TYPE(V),"var") :F(HTMLTMPL.8)
        -LINE 150
2436     IDENT(N,"") :F(HTMLTMPL.9)
        -LINE 151
2437     N = T<"default">
        -LINE 152
2438    HTMLTMPL.9 E = T<"escape">
        -LINE 154
2439     E = E "_escape"
        -LINE 155
2440     V = &ERRLIMIT
2441     &ERRLIMIT = 1
2442     N = APPLY(E,N)
2443     &ERRLIMIT = V
        -LINE 156
2444     TMPL_INTERPRET = TMPL_INTERPRET N :(HTMLTMPL.10)
        -LINE 157
2445    HTMLTMPL.8 "if unless" ? TOKEN_TYPE(V) :F(HTMLTMPL.11)
        -LINE 159
2446     P1 = VALUE(NEXT(VALUE(P)))
        -LINE 160
2447     P2 = NEXT(NEXT(VALUE(P)))
        -LINE 161
2448     IDENT(TOKEN_TYPE(V),"unless") :F(HTMLTMPL.12)
        -LINE 162
2449     SWAP(.P1,.P2)
        -LINE 163
2450    HTMLTMPL.12 (DIFFER(N,""),NE(+N,0)) :F(HTMLTMPL.13)
        -LINE 164
2451     INTERPRET_TMPL(P1,A) :(HTMLTMPL.14)
        -LINE 166
2452    HTMLTMPL.13 INTERPRET_TMPL(P2,A)
        -LINE 167
2453    HTMLTMPL.14  :(HTMLTMPL.15)
2454    HTMLTMPL.11 IDENT(TOKEN_TYPE(V),"loop") :F(HTMLTMPL.16)
        -LINE 169
2455     IDENT(DATATYPE(N),"ARRAY") :F(HTMLTMPL.17)
        -LINE 170
2456     P1 = VALUE(NEXT(VALUE(P)))
        -LINE 171
2457     I = 1
2458    HTMLTMPL.18 N<I> :F(HTMLTMPL.19)
        -LINE 172
2459     INTERPRET_TMPL(P1,N<I>)
2460     I = I + 1 :(HTMLTMPL.18)
2461    HTMLTMPL.19
2462    HTMLTMPL.17
2463    HTMLTMPL.16
2464    HTMLTMPL.15
2465    HTMLTMPL.10
        -LINE 176
2466    HTMLTMPL.7 P = NEXT(P) :(HTMLTMPL.4)
        -LINE 177
2467    HTMLTMPL.5  :(RETURN)
        -LINE 182
2468    INTERPRET_TMPL.END  :(TMPL_PARSE.END)
        -LINE 183
2469    TMPL_PARSE IDENT(L,"") :S(RETURN)F(HTMLTMPL.20)
        -LINE 185
2470    HTMLTMPL.20 R = TMPL_SEQ() :S(HTMLTMPL.21)F(FRETURN)
        -LINE 187
2471    HTMLTMPL.21 DIFFER(L,"") :S(FRETURN)F(HTMLTMPL.22)
        -LINE 189
2472    HTMLTMPL.22 TMPL_PARSE = R :(RETURN)
        -LINE 195
2473    TMPL_PARSE.END  :(TMPL_SEQ.END)
        -LINE 196
2474    TMPL_SEQ DIFFER(L,"") :F(HTMLTMPL.23)
        -LINE 197
2475     V = VALUE(L)
        -LINE 198
2476     "text var" ? TOKEN_TYPE(V) :F(HTMLTMPL.24)
        -LINE 199
2477     R = LINK(LINK(V),R)
        -LINE 200
2478     L = NEXT(L) :(HTMLTMPL.25)
        -LINE 201
2479    HTMLTMPL.24 "if unless loop" ? TOKEN_TYPE(V) :F(HTMLTMPL.26)
        -LINE 202
2480     DIFFER(TOKEN_END(V),"") :F(HTMLTMPL.27)
        -LINE 203
2481     TMPL_SEQ = REVL(R) :(RETURN)
        -LINE 204
2482    HTMLTMPL.27 L = NEXT(L)
        -LINE 205
2483     P1 = TMPL_SEQ() :S(HTMLTMPL.28)F(FRETURN)
        -LINE 207
2484    HTMLTMPL.28 IDENT(L,"") :S(FRETURN)F(HTMLTMPL.29)
        -LINE 209
2485    HTMLTMPL.29 P2 = ""
        -LINE 210
2486     V2 = VALUE(L)
        -LINE 211
2487     "if unless loop" ? TOKEN_TYPE(V2) :F(HTMLTMPL.30)
        -LINE 212
2488     L = NEXT(L) :(HTMLTMPL.31)
        -LINE 213
2489    HTMLTMPL.30 IDENT(TOKEN_TYPE(V2),"else") :F(HTMLTMPL.32)
        -LINE 214
2490     L = NEXT(L)
        -LINE 215
2491     P2 = TMPL_SEQ() :S(HTMLTMPL.33)F(FRETURN)
        -LINE 217
2492    HTMLTMPL.33 IDENT(L,"") :S(FRETURN)F(HTMLTMPL.34)
        -LINE 219
2493    HTMLTMPL.34 L = NEXT(L) :(HTMLTMPL.35)
        -LINE 221
2494    HTMLTMPL.32  :(FRETURN)
2495    HTMLTMPL.35
        -LINE 222
2496    HTMLTMPL.31 R = LINK(LINK(V,LINK(P1,P2)),R) :(HTMLTMPL.36)
        -LINE 223
2497    HTMLTMPL.26 IDENT(TOKEN_TYPE(V),"else") :F(HTMLTMPL.37)
        -LINE 224
2498     TMPL_SEQ = REVL(R) :(RETURN)
        -LINE 226
2499    HTMLTMPL.37  :(FRETURN)
2500    HTMLTMPL.38
2501    HTMLTMPL.36
        -LINE 227
2502    HTMLTMPL.25  :(TMPL_SEQ)
        -LINE 228
2503    HTMLTMPL.23 TMPL_SEQ = REVL(R) :(RETURN)
        -LINE 233
2504    TMPL_SEQ.END  :(TMPL_TOKENIZE.END)
        -LINE 234
2505    TMPL_TOKENIZE N = .TMPL_TOKENIZE
        -LINE 235
2506    HTMLTMPL.39 DIFFER(S,"") :F(HTMLTMPL.40)
        -LINE 236
2507     S ? TMPL_PIECE :F(HTMLTMPL.41)
        -LINE 237
2508     TAG = REPLACE(TAG,&UCASE,&LCASE)
        -LINE 238
2509     TMPL_KEYS ? TAG " " :F(HTMLTMPL.42)
        -LINE 239
2510     DIFFER(L,"") :F(HTMLTMPL.43)
        -LINE 240
2511     $N = LINK(TMPL_TOKEN("text","",L))
2512     N = .NEXT($N)
        -LINE 242
2513    HTMLTMPL.43 IDENT(TAG,"include") :F(HTMLTMPL.44)
        -LINE 247
2514     T = TMPL_PARSE_ARGS(ARG) :S(HTMLTMPL.45)F(FRETURN)
        -LINE 249
2515    HTMLTMPL.45 S = READFILE(TMPL_DIR T<'name'>) :F(HTMLTMPL.46)
        -LINE 250
2516     $N = TMPL_TOKENIZE(S) :S(HTMLTMPL.47)F(FRETURN)
        -LINE 252
2517    HTMLTMPL.47 N = .LAST(TMPL_TOKENIZE)
        -LINE 254
2518    HTMLTMPL.46  :(HTMLTMPL.48)
        -LINE 255
2519    HTMLTMPL.44 T = TMPL_TOKEN(TAG,H,TMPL_PARSE_ARGS(ARG))
        -LINE 256
2520     $N = LINK(T)
2521     N = .NEXT($N)
        -LINE 258
2522    HTMLTMPL.48  :(HTMLTMPL.49)
        -LINE 259
2523    HTMLTMPL.42 $N = LINK(TMPL_TOKEN("text","",L P))
2524     N = .NEXT($N)
        -LINE 261
2525    HTMLTMPL.49 S = R :(HTMLTMPL.50)
        -LINE 263
2526    HTMLTMPL.41 $N = LINK(TMPL_TOKEN("text","",S))
2527     N = .NEXT($N)
        -LINE 264
2528     S = ""
        -LINE 266
2529    HTMLTMPL.50  :(HTMLTMPL.39)
        -LINE 267
2530    HTMLTMPL.40  :(RETURN)
        -LINE 272
2531    TMPL_TOKENIZE.END  :(TMPL_PARSE_ARGS.END)
        -LINE 273
2532    TMPL_PARSE_ARGS TMPL_PARSE_ARGS = TABLE()
        -LINE 274
2533    HTMLTMPL.51 DIFFER(S,"") :F(HTMLTMPL.52)
        -LINE 275
2534     N = ""
        -LINE 276
2535     V = ""
        -LINE 277
2536     S ? TMPL_ARG_P = "" :F(HTMLTMPL.53)
        -LINE 278
2537     N = REPLACE(N,&UCASE,&LCASE)
        -LINE 279
2538     N = IDENT(N) "name"
        -LINE 280
2539     TMPL_PARSE_ARGS<N> = V :(HTMLTMPL.54)
        -LINE 282
2540    HTMLTMPL.53  :(FRETURN)
        -LINE 283
2541    HTMLTMPL.54  :(HTMLTMPL.51)
        -LINE 284
2542    HTMLTMPL.52  :(RETURN)
2543    TMPL_PARSE_ARGS.END
2544    HTMLTMPL.1
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'LAST.INC'
        -MODULE LAST
        -LINE 11 "LAST.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 39 "LAST.lss"
        -STITL LAST
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  #           #      #####   #######                  *
        *                  #          # #    #     #     #                     *
        *                  #         #   #   #           #                     *
        *                  #        #     #   #####      #                     *
        *                  #        #######        #     #                     *
        *                  #        #     #  #     #     #                     *
        *                  #######  #     #   #####      #                     *
        *                                                                      *
        * LAST                 RETURN LAST LIST ELEMENT                        *
        *                                                                      *
        ************************************************************************
        *
        * LAST.lss
        *
        -LINE 15 "LAST.lss"
        -PUBLIC LAST()
        *
2545             DEFINE('LAST(L)')                                   :(LAST_END)
        *
2546    LAST     IDENT(L)                                            :S(FRETURN)
2547    LAST_1   L = DIFFER(NEXT(L)) NEXT(L)                          :S(LAST_1)
2548             LAST = .NEXT(L)                                      :(NRETURN)
        *
2549    LAST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'LINK.INC'
        -INCLUDE 'READFILE.INC'
        -MODULE READFILE
        -LINE 15 "READFILE.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'SYSTEM.INC'
        -IN72
        -LINE 55 "READFILE.lss"
        -STITL READLINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  ######   #######     #     ######   #######  ###  #        #######  *
        *  #     #  #          # #    #     #  #         #   #        #        *
        *  #     #  #         #   #   #     #  #         #   #        #        *
        *  ######   #####    #     #  #     #  #####     #   #        #####    *
        *  #   #    #        #######  #     #  #         #   #        #        *
        *  #    #   #        #     #  #     #  #         #   #        #        *
        *  #     #  #######  #     #  ######   #        ###  #######  #######  *
        *                                                                      *
        * READFILE          READ COMPLETE FILE INTO STRING                     *
        *                                                                      *
        ************************************************************************
        *
        * READFILE.lss
        *
        -LINE 21 "READFILE.lss"
        -PUBLIC READFILE()
        *
2550             DEFINE('READFILE(FILE)F,U,E')                   :(READFILE_END)
        *
2551    READFILE SYSTEM() 'CSNOBOL4'                               :S(READFILE3)
2552             U = 20
2553             E = CHARS_NL
2554             INPUT(.F, U, FILE)                      :S(READFILE2)F(FRETURN)
2555    READFILE3
2556             U = IO_FINDUNIT()                                   :F(FRETURN)
2557             INPUT(.F, U, 'B,65536', FILE)                       :F(FRETURN)
2558    READFILE2
2559             READFILE = READFILE F E                           :S(READFILE2)
2560    READFILE4
2561             ENDFILE(U)
2562             DETACH(.F)                                            :(RETURN)
        *
2563    READFILE_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'REVL.INC'
        -INCLUDE 'SWAP.INC'
        -INCLUDE 'TIMER.INC'
        -LINE 12 "TIMER.lss"
        -INCLUDE 'RESOL.INC'
        -MODULE RESOL
        -LINE 9 "RESOL.lss"
        -LINE 50 "RESOL.lss"
        -IN72
        -STITL RESOL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 ######   #######   #####   #######  #                *
        *                 #     #  #        #     #  #     #  #                *
        *                 #     #  #        #        #     #  #                *
        *                 ######   #####     #####   #     #  #                *
        *                 #   #    #              #  #     #  #                *
        *                 #    #   #        #     #  #     #  #                *
        *                 #     #  #######   #####   #######  #######          *
        *                                                                      *
        * RESOL             TIMER RESOLUTION IN MILLISECONDS                   *
        *                                                                      *
        ************************************************************************
        *
        * RESOL.lss
        *
        -LINE 12 "RESOL.lss"
        -PUBLIC RESOLUTION()
        *
2564             DEFINE('RESOLUTION()T,N,R,T2')                :(RESOLUTION_END)
        *
2565    RESOLUTION
2566             DIFFER(RESOLUTION_)                                 :S(RESOL_4)
2567             R = 0.0
2568             T = TIME()
2569    RESOL_1  EQ(T, TIME())                                       :S(RESOL_1)
2570             T = TIME()
2571    RESOL_2  T2 = TIME()
2572    RESOL_3  EQ(T2, TIME())                                      :S(RESOL_3)
2573             RESOLUTION_ = TIME() - T
2574             R = R + (TIME() - T2)
2575             N = N + 1
2576             LE(N, 100000)                                       :S(RESOL_2)
2577             RESOLUTION_ = R / 100000
2578    RESOL_4  RESOLUTION = RESOLUTION_                              :(RETURN)
        *
2579    RESOLUTION_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SYSTEM.INC'
        -STITL TIMER
        -EJECT
        -LINE 78 "TIMER.lss"
        *
        ************************************************************************
        *                                                                      *
        *                 #######  ###  #     #  #######  ######               *
        *                    #      #   ##   ##  #        #     #              *
        *                    #      #   # # # #  #        #     #              *
        *                    #      #   #  #  #  #####    ######               *
        *                    #      #   #     #  #        #   #                *
        *                    #      #   #     #  #        #    #               *
        *                    #     ###  #     #  #######  #     #              *
        *                                                                      *
        * TIMER                       TIME STATEMENTS                          *
        *                                                                      *
        ************************************************************************
        *
        * TIMER.lss
        *
        -LINE 17 "TIMER.lss"
        -MODULE TIMER
        -PUBLIC TIMER()
2580             DEFINE('TIMER(S_,N_)C_,T_,I_,M_')                  :(TIMER_END)
        *
2581    TIMER    EQ(N_, 0)                                           :F(TIMER_N)
2582             N_ = 10
2583    TIMER_1  T_ = TIMER(' ;' S_, N_) - TIMER(, N_)               :F(FRETURN)
        * WAS 20 * RESOLUTION. NOW THAT RESOLUTION IS ON THE ORDER OF 4
        * MICROSECONDS, WE LOOK FOR 2000 * RESOLUTION (8 MILLISECONDS).
        *
        * FOR SPITBOL.EXE, RESOLUTION IS 1MS, CSNOBOL4, 4 MICROSECONDS FOR
        * ATOM, 1.5 MICROSECONDS FOR INTEL I3
        *
2584             M_ = RESOLUTION()
2585             M_ = ((LT(M_, 0.9) 2000), 20)
2586             N_ = LT(T_, M_ * RESOLUTION()) N_ * 2               :S(TIMER_1)
2587             T_ = CONVERT(T_, 'REAL')
2588             OUTPUT =
2589             OUTPUT = 'THE STATEMENT'
2590             OUTPUT = S_
        * CALCULATE THE TIME, AND SCALE TO MICROSECONDS, MILLISECONDS OR
        * SECONDS.
2591             T_ = T_ / N_
2592             C_ = ' MILLISECONDS'
2593             (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
2594             C_ = GE(T_, 1000.0) ' SECONDS'
2595             T_ = GE(T_, 1000.0) T_ / 1000.0                     :S(TIMER_2)
2596             T_ = T_ * 1000.0
2597             C_ = ' MICROSECONDS'
2598             (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
2599             T_ = T_ * 1000.0
2600             C_ = ' NANOSECONDS'
2601    TIMER_2  OUTPUT = 'REQUIRED ' T_ C_ ' +/- 10%'
2601    +           ' TO EXECUTE IN '  SYSTEM()                        :(RETURN)
        *
2602    TIMER_N  I_ = 1
2603             C_ = '          COLLECT()                             ;'
2603    +             '          TIMER = TIME()                        ;'
2603    +             'TIMER_4   EQ(TIMER, TIME())          :S(TIMER_4);'
2603    +             '          TIMER = TIME()                        ;'
2603    +             'TIMER_3 ' S_                                   ';'
2603    +             '          I_ = I_ + 1 LT(I_, ' N_ ') :S(TIMER_3);'
2603    +             '          TIMER = TIME() - TIMER       :(RETURN)'
2604             C_ = CODE(C_)                                  :S<C_>F(FRETURN)
        *
2605    TIMER_END
        *
        * CE: .MSNOBOL4;
2606     DATA('tmpl_token(token_type,token_end,token_args)')
        -USES HTML_ESCAPE(), JS_ESCAPE(), URL_ESCAPE()
        -PUBLIC TMPL_INIT()
2607     DEFINE('tmpl_init()')
        -PUBLIC TMPL_COMPILE()
2608     DEFINE('tmpl_compile(s)l')
        -PUBLIC TMPL_INTERPRET()
2609     DEFINE('tmpl_interpret(p,a)')
2610     DEFINE('none_escape(s)')
2611     DEFINE('interpret_tmpl(p,a)p1,p2,v,n,t,e,i')
2612     DEFINE('tmpl_parse(l)r')
2613     DEFINE('tmpl_seq()r,v,v2,p1,p2')
2614     DEFINE('tmpl_tokenize(s)l,r,p,tag,r,h,n,t')
2615     DEFINE('tmpl_parse_args(s)n,v')
2616      TMPL_INIT()
        -INCLUDE 'JSON.INC'
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'SCOOP.INC'
        -MODULE SCOOP
        -LINE 104 "SCOOP.lss"
        -INCLUDE 'TIMER.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -LINE 299 "SCOOP.lss"
        -EJECT
        -STITL SCOOP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *              #####    #####   #######  #######  ######               *
        *             #     #  #     #  #     #  #     #  #     #              *
        *             #        #        #     #  #     #  #     #              *
        *              #####   #        #     #  #     #  ######               *
        *                   #  #        #     #  #     #  #                    *
        *             #     #  #     #  #     #  #     #  #                    *
        *              #####    #####   #######  #######  #                    *
        *                                                                      *
        * SCOOP            OBJECT ORIENTED PROGRAMMING                         *
        *                                                                      *
        ************************************************************************
        *
        * SCOOP.lss
        *
        * THE SAFETY FLAG. IF 0, SOME CHECKS ARE NOT COMPILED IN. I RECOMMEND
        * THAT IT ALWAYS BE ENABLED.
        *
        -LINE 109 "SCOOP.lss"
        -PUBLIC OBJECT()
        *
2617             DATA('OBJECT(CLASS,IVARS,METHODS)')
        *
        -PUBLIC SEND(), SUPER(), SELF(), IVAR(), CVAR(), CLASS_OF(), |1
2618             DEFINE('SEND(THIS,METHOD,A1,A2,A3,A4,A5,A6,A7,A8)'
2618    +               'C,M,M_CLASS,T1,T2,T3')
2619             DEFINE('SUPER(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
2620             DEFINE('SELF(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
2621             DEFINE('FIND_METHOD(OBJ,METHOD)')
2622             DEFINE('IVAR(NAME)')
2623             DEFINE('CVAR(NAME)')
2624             DEFINE('CLASS_OF(OBJ)')
2625             OPSYN('|', 'IVAR', 1)
        *
        * INITIALIZE OOP SYSTEM, CREATE ROOT CLASS. MAKE SURE ROOT CLASS CAN
        * ANSWER NEW_CLASS, NEW, INIT, DOES_NOT_UNDERSTAND AND ADD_METHOD
        * MESSAGES. ALSO, ANSWER THE IS_A MESSAGE.
        *
        -PUBLIC CLASS:CLASS
2626             CLASS = OBJECT(, TABLE(), TABLE())
2627             IVARS(CLASS)<'CLASS'> = 'CLASS'
        -PUBLIC CLASS:'ADD_METHOD'
2628             METHODS(CLASS)<'ADD_METHOD'> =
2628    +           CODE(
2628    +              ' METHODS(THIS) = IDENT(METHODS(THIS)) TABLE();'
2628    +              ' THAW(METHODS(THIS));'
2628    +              ' METHODS(THIS)<A1> = A2;'
2628    +              ' FREEZE(METHODS(THIS)) :(RETURN)')
        *
        -PUBLIC CLASS:'NEW_CLASS'
2629             SEND(CLASS, 'ADD_METHOD', 'NEW_CLASS',
2629    +           CODE(
2629    +              ' THIS = OBJECT(THIS);'
2629    +              ' IVAR("CLASS") = A1;'
2629    +              ' SEND = THIS :(RETURN)'))
        -PUBLIC CLASS:'INIT'
2630             SEND(CLASS, 'ADD_METHOD', 'INIT',
2630    +           CODE(' :(RETURN)'))
        -PUBLIC CLASS:'NEW'
2631             SEND(CLASS, 'ADD_METHOD', 'NEW',
2631    +           CODE(
2631    +              ' THIS = OBJECT(THIS);'
2631    +              ' SELF("INIT", A1, A2, A3, A4, A5, A6, A7, A8);'
2631    +              ' SEND = THIS :(RETURN)'))
        -PUBLIC CLASS:'DOES_NOT_UNDERSTAND'
2632             SEND(CLASS, 'ADD_METHOD', 'DOES_NOT_UNDERSTAND',
2632    +           CODE(
2632    +            " TERMINAL = 'SCOOP: DOES NOT UNDERSTAND ' METHOD :(END)"))
2633             DEFINE('IS_A(ACLASS)')
        -PUBLIC CLASS:'IS_A'
2634             SEND(CLASS, 'ADD_METHOD', 'IS_A', 'IS_A')
2635                                                                  :(OOP_END)
        *
        * IS_A - IS OBJECT IN CLASS? ACLASS CAN BE A STRING WITH A CLASS NAME
        *        OR A CLASS OBJECT
        *
2636    IS_A     T1 = THIS
2637    IS_A_2   T1 = CLASS(T1)
2638             IDENT(T1)                                           :S(FRETURN)
2639             IDENT(T1, ACLASS)                                    :S(RETURN)
2640             IDENT(IVARS(T1)<'CLASS'>, ACLASS)           :S(RETURN)F(IS_A_2)
        *
        * ACCESS INSTANCE VARIABLE. CREATE THE INSTANCE VARIABLES IF THEY DO
        * NOT YET EXIST.
        *
2641    IVAR     IVARS(THIS) = IDENT(IVARS(THIS)) TABLE()
2642             IVAR = .(IVARS(THIS)<NAME>)                          :(NRETURN)
        *
        * ACCESS CLASS VARIABLE
        *
2643    CVAR     IVARS(CLASS(THIS)) = IDENT(IVARS(CLASS(THIS))) TABLE()
2644             CVAR = .(IVARS(CLASS(THIS))<NAME>)                   :(NRETURN)
        *
        * CLASS_OF RETURNS THE NAME OF THE CLASS OF THE PASSED OBJECT. THE
        * CLASS NAMES SHOULD BE UNIQUE WITHIN A PROGRAM. THE ROOT CLASS HAS
        * NAME 'CLASS' (ROOT'S SUPERCLASS IS NULL)
        *
2645    CLASS_OF CLASS_OF = IVARS(CLASS(OBJ))<'CLASS'>                 :(RETURN)
        *
        * FIND METHOD BEGINNING AT OBJ SEARCHING UP TO THE ROOT CLASS
        *
2646    FIND_METHOD
2647             M_CLASS =
2648             IDENT(OBJ)                                          :S(FRETURN)
2649             C = OBJ
2650    FIND_METHOD2
2651             FIND_METHOD = VDIFFER(METHODS(C))<METHOD>
2652             DIFFER(FIND_METHOD)                            :F(FIND_METHOD3)
2653             M_CLASS = C                                           :(RETURN)
2654    FIND_METHOD3
2655             IDENT(C = CLASS(C))                  :S(FRETURN)F(FIND_METHOD2)
        *
        * DISPATCH TO THE PARENT CLASS. THAT, IN TURN, MAY DISPATCH TO ITS
        * PARENT. THIS IS USED WITH 'INIT' (FOR EXAMPLE).
        *
        * TO IMPLEMENT SUPER, WE WANT TO START SEARCHING WITH THE CLASS OF THE
        * CLASS WE FOUND THE METHOD IN. THIS IS IN LOCAL SEND() VARIABLE
        * M_CLASS WHICH IS SET IN FIND_METHOD.
        *
2656    SUPER    SUPER = THIS
2657             IDENT(M_CLASS)                                       :S(RETURN)
2658             M = FIND_METHOD(CLASS(M_CLASS), METHOD)     :F(RETURN)S(SEND_3)
        *
        * DISPATCH METHOD FROM WITHIN A METHOD
        *
2659    SELF     SELF = THIS                                           :(SEND_2)
        *
        * DISPATCH METHOD TO OBJECT. DEFAULT ANSWER IS SIMPLY 'THIS' TO ALLOW
        * CHAINED METHODS
        *
2660    SEND     SEND = THIS
        *
        * ENSURE THAT THIS PARAMETER IS AN OBJECT (OR CLASS).
        *
2661             IDENT(THIS)                                         :S(FRETURN)
2662             IDENT(DATATYPE(THIS), 'OBJECT')                      :S(SEND_2)
2663             TERMINAL = 'SCOOP: SEND NEEDS OBJECT AS RECEIVER'        :(END)
        *
2664    SEND_2   M = FIND_METHOD(THIS, METHOD)                        :S(SEND_3)
2665             M = FIND_METHOD(THIS, 'DOES_NOT_UNDERSTAND')         :S(SEND_3)
        *
        * THIS ERROR SHOULD NOT HAPPEN! (THE ROOT CLASS SHOULD ALWAYS ANSWER
        * DOES_NOT_UNDERSTAND).
        *
2666             TERMINAL =
2666    +           'SCOOP: ROOT CLASS MISSING DOES_NOT_UNDERSTAND'       :(END)
        *
        * WE HAVE THE METHOD, DISPATCH IT. SINCE ALL VARIABLES ARE GLOBAL,
        * ACCESS TO 'THIS' WILL SIMPLY REFER TO SELF AS PASSED TO SEND()
        * WHICH IS WHAT WE WANT.
        *
        * IF THE METHOD IS CODE, EXECUTE IT. OTHERWISE, APPLY M TO THE PASSED
        * ARGUMENTS.
        *
2667    SEND_3   IDENT(DATATYPE(M), 'CODE')                                :S<M>
2668             SEND = APPLY(M, A1, A2, A3, A4, A5, A6, A7, A8)
2668    +                                                   :S(RETURN)F(FRETURN)
        *
2669    OOP_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'SESSION.INC'
        -LINE 81 "SESSION.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'JSON.INC'
        -INCLUDE 'NDBM.INC'
        -MODULE NDBM
        -LINE 10 "NDBM.lss"
        -IN72
        -LINE 70 "NDBM.lss"
        -STITL NDBM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #     #  ######   ######   #     #                   *
        *                 ##    #  #     #  #     #  ##   ##                   *
        *                 # #   #  #     #  #     #  # # # #                   *
        *                 #  #  #  #     #  ######   #  #  #                   *
        *                 #   # #  #     #  #     #  #     #                   *
        *                 #    ##  #     #  #     #  #     #                   *
        *                 #     #  ######   ######   #     #                   *
        *                                                                      *
        * NDBM               NDBM INTERFACE FOR CSNOBOL4                       *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * DECEMBER 3, 2005                                                     *
        *                                                                      *
        ************************************************************************
        *
        * NDBM.lss
        *
        -LINE 13 "NDBM.lss"
2670    NDBM_LOAD
        *
        -PUBLIC DBM_INSERT, DBM_REPLACE
        *
2671             DBM_INSERT = 0
2672             DBM_REPLACE = 1
        *
        -PUBLIC DBM_OPEN(), DBM_CLOSE()
        *
2673             LOAD('DBM_OPEN(STRING,STRING,STRING)INTEGER')
2674             LOAD('DBM_CLOSE(INTEGER)STRING')
        *
        -PUBLIC DBM_STORE(), DBM_FETCH(), DBM_DELETE()
        *
2675             LOAD('DBM_STORE(INTEGER,STRING,STRING,INTEGER)INTEGER')
2676             LOAD('DBM_FETCH(INTEGER,STRING)STRING')
2677             LOAD('DBM_DELETE(INTEGER,STRING)INTEGER')
        *
        -PUBLIC DBM_FIRSTKEY(), DBM_NEXTKEY()
        *
2678             LOAD('DBM_FIRSTKEY(INTEGER)STRING')
2679             LOAD('DBM_NEXTKEY(INTEGER)STRING')
        *
        -PUBLIC DBM_ERROR(), DBM_CLEARERR()
        *
2680             LOAD('DBM_ERROR(INTEGER)STRING')
2681             LOAD('DBM_CLEARERR(INTEGER)STRING')
        *
2682             CODE('NDBM_LOAD')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'WRTFILE.INC'
        -MODULE WRTFILE
        -LINE 13 "WRTFILE.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'SYSTEM.INC'
        -IN72
        -LINE 57 "WRTFILE.lss"
        -STITL WRTFILE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *      #     #  ######   #######  #######  ###  #        #######       *
        *      #  #  #  #     #     #     #         #   #        #             *
        *      #  #  #  #     #     #     #         #   #        #             *
        *      #  #  #  ######      #     #####     #   #        #####         *
        *      #  #  #  #   #       #     #         #   #        #             *
        *      #  #  #  #    #      #     #         #   #        #             *
        *       ## ##   #     #     #     #        ###  #######  #######       *
        *                                                                      *
        * WRTFILE          WRITE COMPLETE FILE FROM STRING                     *
        *                                                                      *
        ************************************************************************
        *
        * WRTFILE.lss
        *
        -LINE 19 "WRTFILE.lss"
2683             DEFINE('WRITEFILE(FILE,S)F,U,E,T')               :(WRTFILE_END)
        *
2684    WRITEFILE
2685             SYSTEM() 'CSNOBOL4'                              :S(WRITEFILE3)
2686             U = 20
2687             OUTPUT(.F, U, FILE)                                 :F(FRETURN)
2688    WRITEFILE2
2689             S BRKREM(CHARS_NL) . T (CHARS_NL | NULL) =
2690             F = T
2691             IDENT(S)                             :S(READFILE4)F(WRITEFILE2)
2692    WRITEFILE3
2693             U = IO_FINDUNIT()
2694             OUTPUT(.F, U, 'B,65536', FILE)
2695    WRITEFILE4
2696             T = LT(SIZE(S), 65536) S                         :F(WRITEFILE6)
2697             S =
2698    WRITEFILE5
2699             F = T
2700             IDENT(S)                             :S(READFILE4)F(WRITEFILE4)
2701    WRITEFILE6
2702             S LEN(65536) . T REM . S                          :(WRITEFILE5)
        *
2703    WRTFILE_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'REPL.INC'
        -INCLUDE 'TIME.INC'
        -STITL SESSION
        -EJECT
        -LINE 233 "SESSION.lss"
        *
        ************************************************************************
        *                                                                      *
        *       #####   #######   #####    #####   ###  #######  #     #       *
        *      #     #  #        #     #  #     #   #   #     #  ##    #       *
        *      #        #        #        #         #   #     #  # #   #       *
        *       #####   #####     #####    #####    #   #     #  #  #  #       *
        *            #  #              #        #   #   #     #  #   # #       *
        *      #     #  #        #     #  #     #   #   #     #  #    ##       *
        *       #####   #######   #####    #####   ###  #######  #     #       *
        *                                                                      *
        * SESSION               SESSION SUPPORT FOR CGI                        *
        *                                                                      *
        ************************************************************************
        *
        * SESSION.lss
        *
        -LINE 93 "SESSION.lss"
        -MODULE SESSION
        -PUBLIC SESSION_CREATE(), SESSION_DELETE(), SESSION_TOUCH()
        -PUBLIC SESSION_PERSIST(), SESSION_LOAD(), SESSION_EXPIRE()
        -PUBLIC SESSION_PERSIST_DIR
2704             DEFINE('SESSION_CREATE(EXPIRE_TIME)')
2705             DEFINE('SESSION_DELETE(SESSION)')
2706             DEFINE('SESSION_TOUCH(SESSION)')
2707             DEFINE('SESSION_PERSIST(SESSION)FILE,HANDLE,A,I')
2708             DEFINE('SESSION_LOAD(UUID)FILE,HANDLE,KEY,DATA,I')
2709             DEFINE('SESSION_EXPIRE()SESSION,TIME,UUID,L,I,S,P')
        *
2710             SESSION_PERSIST_DIR = '/var/lib/SESSION/'        :(SESSION_END)
        *
        * CREATE NEW SESSION. GENERATE UUID FOR SESSION. DEFAULT SESSION
        * EXPIRATION TO 10 MINUTES (UNLESS SPECIFIED).
        *
2711    SESSION_CREATE
2712             SESSION_CREATE = TABLE()
2713             SESSION_CREATE<'UUID'> = BQ('/usr/bin/uuid -v1')    :F(FRETURN)
2714             EXPIRE_TIME = IDENT(EXPIRE_TIME) 600
2715             SESSION_CREATE<'EXPIRE_TIME'> = EXPIRE_TIME           :(RETURN)
        *
        * TOUCH THE SESSION; SETS THE 'EXPIRE' TIME FOR NOW + EXPIRE_TIME.
        *
2716    SESSION_TOUCH
2717             IDENT(SESSION)                                      :S(FRETURN)
2718             SESSION<'EXPIRE'> = TV_SEC(GETTIMEOFDAY()) +
2718    +                               SESSION<'EXPIRE_TIME'>        :S(RETURN)
        *
        * PERSIST SESSION TO DISK. SCALAR VARIABLES ONLY. ARRAYS AND TABLES
        * ARE NOT PERSISTED (ONLY AS THEY PRINT).
        *
2719    SESSION_PERSIST
2720             FILE = SESSION_PERSIST_DIR 'session_' SESSION<'UUID'>
2721             SESSION_DELETE(SESSION)
2722             SESSION_TOUCH(SESSION)                              :F(FRETURN)
        *        A = CONVERT(SESSION, 'ARRAY')                       :F(FRETURN)
        *        HANDLE = DBM_OPEN(FILE, 'CW', '0660')               :F(FRETURN)
        *        SEQ(' DBM_STORE('
        *+                'HANDLE, A<I, 1>, VDIFFER(A<I, 2>), DBM_INSERT) ', .I)
        *        A<I>                                                :S(FRETURN)
        *        DBM_CLOSE(HANDLE)                          :S(RETURN)F(FRETURN)
2723             WRITEFILE(FILE '.db', JSON_ENCODE(SESSION))
2723    +                                                   :S(RETURN)F(FRETURN)
        *
        * DELETE SESSION
        *
2724    SESSION_DELETE
2725             DELETE(SESSION_PERSIST_DIR 'session_' SESSION<'UUID'> '.db')
2725    +                                                              :(RETURN)
        *
        * LOAD SESSION GIVEN UUID. USUALLY, THE UUID COMES FROM A COOKIE.
        *
2726    SESSION_LOAD
2727             UUID = REPL(UUID, ' ', '')
2728             UUID = REPL(UUID, CHARS_TAB, '')
2729             UUID = REPLACE(UUID, &UCASE, &LCASE)
2730             UUID POS(0) ANY('"' "'") REM . UUID
2731             UUID POS(0) SPAN(&DIGITS 'abcdef-') . UUID
        *        SESSION_LOAD = TABLE()
2732             FILE = SESSION_PERSIST_DIR 'session_' UUID
        *        HANDLE = DBM_OPEN(FILE, 'R')                        :F(FRETURN)
        *        KEY = DBM_FIRSTKEY(HANDLE)                    :F(SESSION_LOAD2)
        *        SEQ(' DATA = DBM_FETCH(HANDLE, KEY);'
        *+           ' SESSION_LOAD<KEY> = DATA;'
        *+           ' KEY = DBM_NEXTKEY(HANDLE) ', .I)
        *        DBM_CLOSE(HANDLE)                                   :F(FRETURN)
2733             SESSION_LOAD = JSON_DECODE(READFILE(FILE '.db'))    :F(FRETURN)
2734             IDENT(UUID, SESSION_LOAD<'UUID'>)          :S(RETURN)F(FRETURN)
2735    SESSION_LOAD2
2736             DBM_CLOSE(HANDLE)                                    :(FRETURN)
        *
        * REMOVE EXPIRED SESSIONS FROM DISK.
        *
2737    SESSION_EXPIRE
2738             L = BQ('ls ' SESSION_PERSIST_DIR 'session_*.db 2>/dev/null')
2738    +                                                             :F(RETURN)
2739             TIME = TV_SEC(GETTIMEOFDAY())
2740             L = CRACK(L, ' ')
2741             P = SESSION_PERSIST_DIR 'session_' BREAK('.') . UUID '.db'
2742    SESSION_EXPIRE2
2743             I = I + 1
2744             S = L<I>                                             :F(RETURN)
2745             S P                                                  :F(RETURN)
2746             SESSION = SESSION_LOAD(UUID)                :F(SESSION_EXPIRE2)
2747             GE(SESSION<'EXPIRE'>, TIME)                 :S(SESSION_EXPIRE2)
2748             SESSION_DELETE(SESSION)                      :(SESSION_EXPIRE2)
        *
2749    SESSION_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'UNIQUE.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -STITL CGI
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                         #####    #####   ###                         *
        *                        #     #  #     #   #                          *
        *                        #        #         #                          *
        *                        #        #  ####   #                          *
        *                        #        #     #   #                          *
        *                        #     #  #     #   #                          *
        *                         #####    #####   ###                         *
        *                                                                      *
        * CGI                    CGI SUPPORT FUNCTIONS                         *
        *                                                                      *
        ************************************************************************
        *
        * CGI.lss
        *
        -LINE 77 "CGI.lss"
        *
        -PUBLIC CLASS:CGI_CLASS
        *
2750             CGI_CLASS = SEND(CLASS, 'NEW_CLASS', 'CGI_CLASS')
2751             DEFINE('CGI_INIT()A,C')
        *
        -PUBLIC CGI_CLASS:'INIT'
        *
2752             SEND(CGI_CLASS, 'ADD_METHOD', 'INIT', 'CGI_INIT')
        *
        -PUBLIC CGI_CLASS:'GET_COOKIE_JAR'
        *
2753             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_COOKIE_JAR', CODE(
2753    +           ' SEND = |.COOKIE_JAR :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'GET_HEADER'
        *
2754             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_HEADER', CODE(
2754    +           ' SEND = |.HEADER :(RETURN)'))
2755             DEFINE('CGI_SEND()S')
        *
        -PUBLIC CGI_CLASS:'SEND'
        *
2756             SEND(CGI_CLASS, 'ADD_METHOD', 'SEND', 'CGI_SEND')
        *
        -PUBLIC CGI_CLASS:'GET_LOG'
        *
2757             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_LOG', CODE(
2757    +           ' SEND = |.LOG :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'GET_CONTENT'
        *
2758             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_CONTENT', CODE(
2758    +           ' SEND = |.CONTENT :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'SET_CONTENT'
        *
2759             SEND(CGI_CLASS, 'ADD_METHOD', 'SET_CONTENT', CODE(
2759    +           ' |.CONTENT = A1 :(RETURN)'))
2760             DEFINE('CGI_CLOSE()A')
        *
        -PUBLIC CGI_CLASS:'CLOSE'
        *
2761             SEND(CGI_CLASS, 'ADD_METHOD', 'CLOSE', 'CGI_CLOSE')
        *
        -PUBLIC CGI_CLASS:'GET_ENV'
        *
2762             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_ENV', CODE(
2762    +           ' SEND = |.ENV :(RETURN)'))
        *
        -PUBLIC CGI_CLASS:'GET_QUERY'
        *
2763             SEND(CGI_CLASS, 'ADD_METHOD', 'GET_QUERY', CODE(
2763    +           ' SEND = |.QUERY :(RETURN)'))
        *
2764                                                           :(CGI_OBJECT_END)
        *
        * CLOSE CGI OBJECT
        *
2765    CGI_CLOSE
2766             ENDFILE(|.OUT_UNIT)
2767             DETACH(|.OUT)
2768             ENDFILE(|.LOG_UNIT)
2769             DETACH(|.LOG)                                         :(RETURN)
        *
        * INITIALIZE CGI OBJECT
        *
2770    CGI_INIT CGI_INIT = SUPER('INIT')
        *
        * CREATE LOG CHANNEL
        *
2771             |.LOG_UNIT = IO_FINDUNIT()                          :F(FRETURN)
2772             |.LOG = UNIQUE()
        *
        * WITH ALL THE CHANGES GOING TO SYSTEMD, LOGGING APPEARS TO HAVE
        * SUFFERED. SPECIFICALLY, IF THE LOGGING IS ONLY FORWARDED TO
        * RSYSLOG, LOGGER LOCAL DOESN'T WORK. WE ENABLE RSYSLOG TO LISTEN TO
        * THE NETWORK, AND THEN LOGGER CAN LOG TO LOCALHOST. STRANGE, AND
        * PROBABLY NOT SUITABLE FOR PRODUCTION.
        *
        * IF USING SYSTEMD LOGGER, DON'T USE -n localhost
        *
2773             OUTPUT(|.LOG, |.LOG_UNIT, 'W',
2773    +               '|/usr/bin/logger -n localhost -t CGI')      :F(FRETURN)
        *+              '|/usr/bin/logger -t CGI')                   :F(FRETURN)
        *
        * CREATE OUT CHANNEL
        *
2774             |.OUT_UNIT = IO_FINDUNIT()                          :F(FRETURN)
2775             |.OUT = UNIQUE()
2776             OUTPUT(|.OUT, |.OUT_UNIT, 'B', '/dev/stdout')       :F(FRETURN)
        *
        * COLLECT ENVIRONMENT VARIABLES INTO INSTANCE VARIABLE ENV. WE ONLY
        * GATHER UP "KNOWN" ENVIRONMENT VARIABLES.
        *
2777             |.ENV = DIFFER(USE_FCGI) FCGI_ENV                 :S(CGI_ENV_2)
        *
2778             |.ENV = TABLE(38)
2779             A = %('AUTH_TYPE,CONTENT_LENGTH,CONTENT_TYPE,'
2779    +              'CONTEXT_DOCUMENT_ROOT,CONTEXT_PREFIX,DOCUMENT_ROOT,'
2779    +              'GATEWAY_INTERFACE,HTTP_ACCEPT,HTTP_ACCEPT_CHARSET,'
2779    +              'HTTP_ACCEPT_ENCODING,HTTP_ACCEPT_LANGUAGE,'
2779    +              'HTTP_CACHE_CONTROL,HTTP_CONNECTION,HTTP_COOKIE,'
2779    +              'HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,LIB_PATH,PATH,'
2779    +              'PATH_INFO,PATH_TRANSLATED,QUERY_STRING,REMOTE_ADDR,'
2779    +              'REMOTE_HOST,REMOTE_IDENT,REMOTE_PORT,REQUEST_METHOD,'
2779    +              'REQUEST_SCHEME,REQUEST_URI,SCRIPT_FILENAME,SCRIPT_NAME,'
2779    +              'SERVER_ADDR,SERVER_ADMIN,SERVER_NAME,SERVER_PORT,'
2779    +              'SERVER_PROTOCOL,SERVER_SIGNATURE,SERVER_SOFTWARE')
2780             SEQ(' (|.ENV)<A<I>> = HOST(HOST_GETENV, A<I>); A<I> ', .I)
2781    CGI_ENV_2
2782             $|.LOG = 'FCGI_ENV IN CGI'
2783             $|.LOG = JSON_ENCODE(FCGI_ENV)
2784             $|.LOG = 'QUERY_STRING: ' (|.ENV)<'QUERY_STRING'>
        *
        * FOR POST METHOD, READ (|.ENV)<'CONTENT_LENGTH'>. READ THAT NUMBER OF
        * BYTES, AND ONLY THAT NUMBER. NOTE THAT THIS MAY BE VERY LARGE. THIS
        * MAY FAIL DUE TO MEMORY EXHAUSTION. WE KNOW THAT WE CAN READ A LARGE
        * NUMBER OF BYTES, BUT I HAVE TO DETERMINE THE LIMIT.
        *
        * FOR FCGI, USE FCGI_IN. FIXME: SHOULD TEST CONTENT_LENGTH
        *
2785             (|.ENV)<'QUERY_STRING'> = DIFFER(USE_FCGI) VDIFFER(FCGI_IN)
2785    +                                                         :S(CGI_INIT_3)
2786             T3 = (|.ENV)<'CONTENT_LENGTH'>
2787             IDENT(T3)                                        :S(CGI_INIT_3)
2788             (INTEGER(T3) GT(T3))                             :F(CGI_INIT_3)
2789             T1 = IO_FINDUNIT()                                  :F(FRETURN)
2790             INPUT('T2', T1, 'B,' T3, '/dev/stdin')              :F(FRETURN)
2791             (|.ENV)<'QUERY_STRING'> = T2
2792             ENDFILE(T1)
2793             DETACH('T2')
2794    CGI_INIT_3
        *
        * PARSE QUERY_STRING INTO QUERY TABLE. HASH() IS USED TO PARSE
        * QUERY_STRING, BREAKING INTO NAME=VALUE SEPARATED BY &. EACH VALUE IS
        * PROCESSED WITH URL_DECODE().
        *
        * MULTI-VALUE FIELDS ARE SEPARATED BY 0. USED BY CHECKBOXES
        *
2795             |.QUERY = HASH((|.ENV)<'QUERY_STRING'>, '=', '&',,,,
2795    +                        'URL_DECODE', CHARS_NUL)
2796             $|.LOG = 'QUERY TABLE'
2797             $|.LOG = JSON_ENCODE(|.QUERY)
        *
        * PARSE HTTP_COOKIE INTO A COOKIE JAR. THERE MAY NOT BE ANY COOKIES,
        * IN WHICH CASE WE CREATE AN EMPTY COOKIE JAR. THE VALUES OF THE
        * COOKIES ARE NOT VALIDATED. HASH() PARSES THE COOKIE STRING. AFTER
        * THE TABLE IS GENERATED, IT IS CONVERTED TO AN ARRAY. SEQ() ADDS
        * EACH ELEMENT INTO THE COOKIE JAR.
        *
2798             |.COOKIE_JAR = NEW_COOKIE_JAR()
2799             A = HASH((|.ENV)<'HTTP_COOKIE'>, '=', ';',,,
2799    +                  'COOKIE_FIX_NAME', 'URL_DECODE')
2800             A = CONVERT(A, 'ARRAY')                          :F(CGI_INIT_2)
2801             SEQ(' PUT_COOKIE_IN_JAR(|.COOKIE_JAR,'
2801    +                               'A<I,1>, NEW_COOKIE(A<I,2>)) ', .I)
2802    CGI_INIT_2
        *
        * INITIALIZE HEADER. THE HEADER IS A TABLE() WITH AT LEAST CONTENT_TYPE
        * ENTRY.
        *
2803             |.HEADER = #'CONTENT_TYPE=TEXT/HTML,CHARSET='
        *
        * INITIALIZE CONTENT
        *
2804             |.CONTENT =
        *
        * WE NEED ROUTING IMPLEMENTED.
        *
        * WE NEED TO DO FURTHER PROCESSING ON THE FOLLOWING CGI ENVIRONMENT
        * VARIABLES.
        *
        * <ISINDEX> value1+value2+..
        * HTTP_ACCEPT
        *   ='TEXT/HTML,APPLICATION/XHTML+XML,APPLICATION/XML;Q=0.9,*/*;Q=0.8'
        * HTTP_ACCEPT_ENCODING='GZIP, DEFLATE'
        * HTTP_ACCEPT_LANGUAGE='EN-US,EN;Q=0.5'
        *
2805                                                                   :(RETURN)
        *
        * OUTPUT THE HEADER AND CONTENT
        *
2806    CGI_SEND
        *
        * FIRST, OUTPUT THE CONTENT-TYPE. IF CHARSET HAS BEEN SPECIFIED,
        * ADD THIS TO THE CONTENT-TYPE.
        *
2807             S = 'Content-type: ' (|.HEADER)<'CONTENT_TYPE'>
2808             S = S '; charset=' VDIFFER((|.HEADER)<'CHARSET'>)
2809             S = S CHARS_CR CHARS_NL
        *
        * GENERATE THE COOKIE STRING AND OUTPUT IF WE HAVE COOKIES TO SEND.
        *
2810             S = S VDIFFER(COOKIE_STRING(|.COOKIE_JAR))
        *
        * THE HEADER FINISHES WITH A CR/LF
        *
2811             S = S CHARS_CR CHARS_NL
2812             $|.OUT = IDENT(USE_FCGI) S
2813             DIFFER(USE_FCGI) FCGI_SEND(S)
        *
        * SEND CONTENT
        *
2814             $|.OUT = IDENT(USE_FCGI) |.CONTENT
2815             DIFFER(USE_FCGI) FCGI_SEND(|.CONTENT)
2816             DIFFER(USE_FCGI) FCGI_SEND('')
2817             DIFFER(USE_FCGI) FCGI_END(0, FCGI_REQUEST_COMPLETE)
2818                                                                   :(RETURN)
        *
2819    CGI_OBJECT_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'CH.INC'
        -INCLUDE 'COMB.INC'
        -MODULE COMB
        -LINE 9 "COMB.lss"
        -IN72
        -LINE 35 "COMB.lss"
        -STITL COMB
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                     #####   #######  #     #  ######                 *
        *                    #     #  #     #  ##   ##  #     #                *
        *                    #        #     #  # # # #  #     #                *
        *                    #        #     #  #  #  #  ######                 *
        *                    #        #     #  #     #  #     #                *
        *                    #     #  #     #  #     #  #     #                *
        *                     #####   #######  #     #  ######                 *
        *                                                                      *
        * COMB                        COMBINATIONS                             *
        *                                                                      *
        ************************************************************************
        *
        * COMB.lss
        *
        -LINE 12 "COMB.lss"
        -PUBLIC COMB()
        *
2820             DEFINE('COMB(N,M)')                                 :(COMB_END)
        *
2821    COMB     COMB = EQ(M, 0) 1                                    :S(RETURN)
2822             COMB = COMB(N - 1, M - 1) * N / M                     :(RETURN)
        *
2823    COMB_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COMPLEX.INC'
        -MODULE COMPLEX
        -LINE 8 "COMPLEX.lss"
        -IN72
        -LINE 59 "COMPLEX.lss"
        -STITL COMPLEX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *     #####   #######  #     #  ######   #        #######  #     #     *
        *    #     #  #     #  ##   ##  #     #  #        #         #   #      *
        *    #        #     #  # # # #  #     #  #        #          # #       *
        *    #        #     #  #  #  #  ######   #        #####       #        *
        *    #        #     #  #     #  #        #        #          # #       *
        *    #     #  #     #  #     #  #        #        #         #   #      *
        *     #####   #######  #     #  #        #######  #######  #     #     *
        *                                                                      *
        *                                                                      *
        * COMPLEX                   COMPLEX NUMBERS                            *
        *                                                                      *
        ************************************************************************
        *
        * COMPLEX.lss
        *
        -LINE 11 "COMPLEX.lss"
        -PUBLIC COMPLEX(), R(), I()
        *
2824             DATA('COMPLEX(R,I)')
        *
        -PUBLIC ADD_COMPLEX(), MUL_COMPLEX(), NEG_COMPLEX(), INV_COMPLEX()
        -PUBLIC PRINT_COMPLEX()
        *
2825             DEFINE('ADD_COMPLEX(X,Y)')
2826             DEFINE('MUL_COMPLEX(X,Y)A,B,C,D')
2827             DEFINE('NEG_COMPLEX(X)')
2828             DEFINE('INV_COMPLEX(X)D')
2829             DEFINE('PRINT_COMPLEX(X)SIGN')                   :(COMPLEX_END)
        *
2830    ADD_COMPLEX
2831             ADD_COMPLEX = COMPLEX(R(X) + R(Y), I(X) + I(Y))       :(RETURN)
        *
2832    MUL_COMPLEX
2836             A = R(X); B = I(X); C = R(Y); D = I(Y)
2837             MUL_COMPLEX = COMPLEX(A * C - B * D, B * C + A * D)   :(RETURN)
        *
2838    NEG_COMPLEX
2839             NEG_COMPLEX = COMPLEX(-R(X), -I(X))                   :(RETURN)
        *
2840    INV_COMPLEX
2841             D = (R(X) * R(X)) + (I(X) * I(X))
2842             INV_COMPLEX = COMPLEX(1.0 * R(X) / D, 1.0 * -I(X) / D)
2842    +                                                              :(RETURN)
        *
2843    PRINT_COMPLEX
2844             SIGN = GE(I(X)) '+'
2845             PRINT_COMPLEX = R(X) SIGN I(X) 'i'                    :(RETURN)
        *
2846    COMPLEX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COOKIE.INC'
        -INCLUDE 'COPYL.INC'
        -MODULE COPYL
        -LINE 10 "COPYL.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 47 "COPYL.lss"
        -STITL COPYL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                 #####   #######  ######   #     #  #                 *
        *                #     #  #     #  #     #   #   #   #                 *
        *                #        #     #  #     #    # #    #                 *
        *                #        #     #  ######      #     #                 *
        *                #        #     #  #           #     #                 *
        *                #     #  #     #  #           #     #                 *
        *                 #####   #######  #           #     #######           *
        *                                                                      *
        * COPYL                        COPY LIST                               *
        *                                                                      *
        ************************************************************************
        *
        * COPYL.lss
        *
        -LINE 14 "COPYL.lss"
        -PUBLIC COPYL()
        *
2847             DEFINE('COPYL(L)T')                                :(COPYL_END)
        *
2848    COPYL    DEFINE('COPYL(L)', 'COPYL_1')
2849             T = TABLE(100)
2850             COPYL = COPYL(L)
2851             DEFINE('COPYL(L)T')                                   :(RETURN)
2852    COPYL_1  COPYL = L
2853             IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
2854             COPYL = T<L>
2855             DIFFER(COPYL, NULL)                                  :S(RETURN)
2856             COPYL = COPY(L)
2857             T<L> = COPYL
2858             VALUE(COPYL) = COPYL(VALUE(L))
2859             NEXT(COPYL) = COPYL(NEXT(L))                          :(RETURN)
        *
2860    COPYL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'COPYT.INC'
        -INCLUDE 'COUNT.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'CVAR.INC'
        -MODULE CVAR
        -USES HASH()
        -LINE 73 "CVAR.lss"
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HASH.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'P64.INC'
        -LINE 264 "CVAR.lss"
        -IN72
        -STITL CVAR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                   #####   #     #     #     ######                   *
        *                  #     #  #     #    # #    #     #                  *
        *                  #        #     #   #   #   #     #                  *
        *                  #        #     #  #     #  ######                   *
        *                  #         #   #   #######  #   #                    *
        *                  #     #    # #    #     #  #    #                   *
        *                   #####      #     #     #  #     #                  *
        *                                                                      *
        * CVAR           C VARIABLE DECLARATIONS, AND LOAD/STORE               *
        *                                                                      *
        ************************************************************************
        *
        * CVAR.lss
        *
        -LINE 80 "CVAR.lss"
        *
        * FIXME - ISOLATE BY PASSING CVARSYMS
        *
        * THIS WILL ALLOW SUPPORT OF MULTIPLE ROUTINES. BUT... PARAMETER
        * PASSING WILL BE... DIFFICULT. RECURSION IS TOUGH. WE CAN SIMPLY
        * SET PARAMETER VARIABLES IF NEEDED. PARAMETERS ARE TOUGHER. WE
        * CAN RETRIEVE POINTER. BUT THAT DOESN'T DEFINE STORAGE! ON RECURSIVE
        * CALL WE WOULD NEED TO SAVE ALL PARAMETERS TO A STACK. WHICH WOULD
        * WORK FOR DIRECT RECURSIVE CALL. ALTERNATIVE IS PUSH AND RETRIEVE,
        * AND COPY BACK ON RETURN.
        *
        * PUSH/POP OF PARAMETERS TO ALTERNATE STACK... CRIB STACK CODE.
        * TO PUSH DOUBLE, PUSH TWO WORDS, OR ONE QWORD. REGISTER IS QWORD.
        * PUSH MEMORY_WORD, PUSH MEMORY_QWORD WOULD BE USEFUL... (AND POP
        * VARIANTS): PUSHMW PUSHMQ POPMW POPMQ, AND PUSH POP.
        *
        * THEN,
        *
        * FUNCTION NAME(P1,P2...PN)
        * INTEGER V(D1,D2,D3),V...
        * REAL V
        * DOUBLE PRECISION V
        * LOGICAL V
        * DIMENSION V(D1,D2,D3)
        * COMMON /NAME/ V,V,V...
        *
        * BY DEFAULT, FUNCTION CREATE COMMON BLOCK NAME_
        *
        * LABEL EXPR
        *       IF (EXPR) EXPR
        *       GOTO LABEL
        *
        * CALL THIS LANGUAGE "F00" - MINI-FORTRAN. WE CAN INTRODUCE DO,
        * RETURN, ETC.
        *
        -PUBLIC CVARSYMS(), CV_BASE(), CV_SYMTAB(), CV_END()
        *
2861             DATA('CVARSYMS(CV_BASE,CV_SYMTAB,CV_END)')
        *
        -PUBLIC CVART(), CV_OFFSET(), CV_SIZE(), CV_DIM(), CV_SIGN(), CV_ISINT()
        *
2862             DATA('CVART(CV_OFFSET,CV_SIZE,CV_DIM,CV_SIGN,CV_ISINT)')
        *
        -PUBLIC PTRV(), LOADV(), STOREV(), NEWDECLV(), DECLAREV()
        *
2863             DEFINE('PTRV(B,V,I)')
2864             DEFINE('LOADV(B,V,I)')
2865             DEFINE('STOREV(B,V,I,X)')
2866             DEFINE('NEWDECLV()')
2867             DEFINE('DECLAREV(L)SIGN,INT,FLOAT,AL,NU,SP,BS,BN,IDENT,DIM,'
2867    +                          'INTDECL,FLOATDECL,DECL,SIZE,ALIGN,ISINT,'
2867    +                          'S,T,I,N,SIGNED')
2868                                                             :(DECLAREV_END)
        *
2869    PTRV     V = VTAB<V>
2870             IDENT(V)                                            :S(FRETURN)
2871             I = IDENT(I) 0
2872             PTRV = B + CV_OFFSET(V) + I * CV_SIZE(V)              :(RETURN)
        *
2873    STOREV   B = PTRV(B, V, I)                                   :F(FRETURN)
2874             V = VTAB<V>                          :($('STOREV_' CV_SIZE(V)))
2875    STOREV_1 POKE_C(B, X)                                          :(RETURN)
2876    STOREV_2 POKE_S(B, X)                                          :(RETURN)
2877    STOREV_4 (EQ(CV_ISINT(V)) POKE_F(B, X))                       :S(RETURN)
2878             POKE_I(B, X)                                          :(RETURN)
2879    STOREV_8 (EQ(CV_ISINT(V)) POKE_D(B, X))                       :S(RETURN)
2880             POKE_P(B, X)                                          :(RETURN)
        *
2881    LOADV    B = PTRV(B, V, I)                                   :F(FRETURN)
2882             V = VTAB<V>                           :($('LOADV_' CV_SIZE(V)))
2883    LOADV_1  LOADV = PEEK_C(B)
2884             NE(CV_SIGN(V))                                       :S(RETURN)
2885             LOADV = LT(LOADV) (2 ** 8) + LOADV                    :(RETURN)
2886    LOADV_2  LOADV = PEEK_S(B)
2887                                                                   :(RETURN)
2888             NE(CV_SIGN(V))                                       :S(RETURN)
2889             LOADV = LT(LOADV) (2 ** 16) + LOADV                   :(RETURN)
2890    LOADV_4  LOADV = EQ(CV_ISINT(V)) PEEK_F(B)                    :S(RETURN)
2891             LOADV = PEEK_I(B)
        -LINE 168 "CVAR.lss"
2892             NE(CV_SIGN(V))                                       :S(RETURN)
2893             LOADV = LT(LOADV) (2 ** 32) + LOADV                   :(RETURN)
2894    LOADV_8  LOADV = EQ(CV_ISINT(V)) PEEK_D(B)                    :S(RETURN)
2895             LOADV = PEEK_P(B)                                     :(RETURN)
        *
2896    NEWDECLV VTAB = TABLE()
2897             VOFFSET = 0                                           :(RETURN)
        *
2898    DECLAREV SIGN = ('signed' | 'SIGNED' | 'unsigned' | 'UNSIGNED') . S
2899             INT =  ('char' | 'CHAR' | 'short' | 'SHORT' | 'int' |
2899    +                'INT' | 'long' | 'LONG' | 'pointer' | 'POINTER') . T
2900             FLOAT = ('float' | 'FLOAT' | 'double' | 'DOUBLE') . T
2901             AL = &UCASE &LCASE
2902             NU = &DIGITS
2903             SP = '_'
2904             BS = SPAN(' ' CHARS_TAB)
2905             BN = BS | NULL
2906             IDENT = (ANY(AL SP) (SPAN(AL NU SP) | NULL)) . I
2907             DIM = '[' BN SPAN(&DIGITS) . N BN ']'
2908             INTDECL = (SIGN BS INT) | SIGN | INT
2909             FLOATDECL = FLOAT
2910             DECL = BN (INTDECL | FLOATDECL) BN IDENT BN (DIM | NULL)
        *
2911             SIZE =
2911    +           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
2912             ALIGN =
2912    +           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
2913             ISINT =
2913    +           #'CHAR=1,SHORT=1,INT=1,LONG=1,POINTER=1,FLOAT=,DOUBLE='
        *
        * ASSIGN PATTERN VARIABLE TO DEFAULTS - SIGNED INT [1]
        *
2914             S = 'SIGNED'
2915             T = 'INT'
2916             I =
2917             N = 1
        *
        * SCAN THE DECLARATION, SETTING PATTERN VARIABLES S, T, I, N
        *
2918             L DECL                                              :F(FRETURN)
        *
        * CONVERT T AND S TO UPPERCASE
        *
2919             T = REPLACE(T, &LCASE, &UCASE)
2920             S = REPLACE(S, &LCASE, &UCASE)
        *
        * SIGNED = 1 IF SIGNED, 0 IF UNSIGNED
        *
2921             SIGNED = 0
2922             S 'UNSIGNED'                                         :S(DECLV2)
2923             SIGNED = 1
        *
        * ADJUST OFFSET FOR ALIGNMENT
        *
2924    DECLV2   R = REMDR(VOFFSET, ALIGN<T>)
2925             VOFFSET = NE(R) VOFFSET + (ALIGN<T> - R)
        *
        * ALREADY DECLARED?
        *
2926             V = VTAB<I>
2927             IDENT(V)                                            :F(FRETURN)
        *
        * CREATE CVART() RECORD FOR NEW VARIABLE
        *
2928             V = CVART(VOFFSET, SIZE<T>, N, SIGNED, ISINT<T>)
        *
        * PUT VARIABLE INTO SYMBOL TABLE
        *
2929             VTAB<I> = V
        *
        * ADJUST OFFSET BY SIZE OF NEW VARIABLE (INCLUDING DIMENSION)
        *
2930             VOFFSET = VOFFSET + SIZE<T> * N
        *
2931             DECLAREV = VOFFSET                                    :(RETURN)
        *
2932    DECLAREV_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DAY.INC'
        -MODULE DAY
        -LINE 10 "DAY.lss"
        -IN72
        -LINE 59 "DAY.lss"
        -STITL DAY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      ######      #     #     #                       *
        *                      #     #    # #     #   #                        *
        *                      #     #   #   #     # #                         *
        *                      #     #  #     #     #                          *
        *                      #     #  #######     #                          *
        *                      #     #  #     #     #                          *
        *                      ######   #     #     #                          *
        *                                                                      *
        * DAY                         DAY OF WEEK                              *
        *                                                                      *
        ************************************************************************
        *
        * DAY.lss
        *
        -LINE 13 "DAY.lss"
        -PUBLIC DAY()
        *
2933             DEFINE('DAY(DATE)M,Y,CD')
2934             YEAR_ = 365
2935             YEAR_4 = 4 * YEAR_ + 1
2936             CENT_ = (25 * YEAR_4) - 1
2937             CENT_4 = 4 * CENT_ + 1
2938             DAY_ZERO = 2                                         :(DAY_END)
        *
2939    DAY      CD = DATE()
2940             DIFFER(DATE)                                          :S(DAY_3)
        * IF NO DATE GIVEN, USE TODAY
2941             CD ARB . DATE ' '
2942    DAY_3    DATE BREAK('/') . M LEN(1)
2942    +           (BREAK('/') . D LEN(1) REM . Y | REM . D)
        * IF NO YEAR GIVEN, USE THIS YEAR
2943             (IDENT(Y) CD) '/' ARB '/' LEN(4) . Y
        * TWO DIGIT YEAR IS 20XX
2944             Y = EQ(SIZE(Y), 2) '20' Y
2945             M = LE(M, 2) M + 12                                   :F(DAY_1)
2946             Y = Y - 1
2947    DAY_1    M = M - 3
2948    DAY_2    DAY = (Y / 400) * CENT_4 + (REMDR(Y, 400) / 100) * CENT_
2948    +           +  (REMDR(Y, 100) / 4) * YEAR_4 +  REMDR(Y, 4) * YEAR_
2949             DAY = DAY + ((153 * M) + 2) / 5 + D + DAY_ZERO
2950             D = REMDR(DAY, 7)
2951             '0SUN1MON2TUES3WEDNES4THURS5FRI6SATUR7'
2951    +           D BREAK('01234567') . DAY
2952             DAY = DAY 'DAY'                                       :(RETURN)
        *
2953    DAY_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DDT.INC'
        -INCLUDE 'DEDUPA.INC'
        -MODULE DEDUPA
        -LINE 14 "DEDUPA.lss"
        -INCLUDE 'SIZEA.INC'
        -INCLUDE 'HASH.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'ARRAY0.INC'
        -IN72
        -LINE 46 "DEDUPA.lss"
        -STITL DEDUPA
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######   #######  ######   #     #  ######      #            *
        *         #     #  #        #     #  #     #  #     #    # #           *
        *         #     #  #        #     #  #     #  #     #   #   #          *
        *         #     #  #####    #     #  #     #  ######   #     #         *
        *         #     #  #        #     #  #     #  #        #######         *
        *         #     #  #        #     #  #     #  #        #     #         *
        *         ######   #######  ######    #####   #        #     #         *
        *                                                                      *
        *                                                                      *
        * DEDUPA                      DEDUP ARRAY                              *
        *                                                                      *
        ************************************************************************
        *
        * DEDUPA.lss
        *
        -LINE 21 "DEDUPA.lss"
        -PUBLIC DEDUPA()
        *
2954             DEFINE('DEDUPA(A)T,I')                            :(END_DEDUPA)
        *
2955    DEDUPA   DEDUPA = IDENT(A, ARRAY0) A                          :S(RETURN)
2956             T = TABLE()
2957             SEQ(' T<A<I>> = 1', .I)
2958             DEDUPA = KEYST(T)                                     :(RETURN)
        *
2959    END_DEDUPA
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DEXP.INC'
        -INCLUDE 'DISPLAY.INC'
        -MODULE DISPLAY
        -LINE 14 "DISPLAY.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'VDIFFER.INC'
        -IN72
        -LINE 147 "DISPLAY.lss"
        -STITL DISPLAY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *     ######   ###   #####   ######   #           #     #     #        *
        *     #     #   #   #     #  #     #  #          # #     #   #         *
        *     #     #   #   #        #     #  #         #   #     # #          *
        *     #     #   #    #####   ######   #        #     #     #           *
        *     #     #   #         #  #        #        #######     #           *
        *     #     #   #   #     #  #        #        #     #     #           *
        *     ######   ###   #####   #        #######  #     #     #           *
        *                                                                      *
        * DISPLAY            DISPLAY CONTROL (FULL-SCREEN)                     *
        *                                                                      *
        ************************************************************************
        *
        * DISPLAY.lss
        *
        -LINE 20 "DISPLAY.lss"
        -PUBLIC DS_SMSO, DS_RMSO, DS_SMUL, DS_RMUL, DS_BLINK
        -PUBLIC DS_BOLD, DS_DIM, DS_REV, DS_SGR0, DS_CIVIS, DS_CNORM, DS_CVVIS
        -PUBLIC DS_GOTO(), DS_FOREGROUND_COLOR(), DS_BACKGROUND_COLOR()
        -PUBLIC DS_BLACK, DS_RED, DS_GREEN, DS_YELLOW, DS_BLUE, DS_PURPLE
        -PUBLIC DS_CYAN, DS_WHITE, DS_IND, DS_RI
        -PUBLIC DS_EL, DS_HOME, DS_CLEAR, DS_COLS, DS_LINES
        *
2960    DISPLAY
        *
        * GATHER STATIC TERMINAL STRINGS.
        *
        * STANDOUT (BOLD)
2961             DS_SMSO  = BQ('tput smso')
        * STANDOUT OFF
2962             DS_RMSO  = BQ('tput rmso')
        * UNDERLINE
2963             DS_SMUL  = BQ('tput smul')
        * UNDERLINE OFF
2964             DS_RMUL  = BQ('tput rmul')
        * BLINK
2965             DS_BLINK = BQ('tput blink')
        * BOLD
2966             DS_BOLD  = BQ('tput bold')
        * DIM (HALF-BRIGHT)
2967             DS_DIM   = BQ('tput dim')
        * REVERSE
2968             DS_REV   = BQ('tput rev')
        * RESET ALL
2969             DS_SGR0  = BQ('tput sgr0')
        *
        * CURSOR OFF
2970             DS_CIVIS = BQ('tput civis')
        * CURSOR ON
2971             DS_CNORM = BQ('tput cnorm')
        * CURSOR VERY VISIBLE
2972             DS_CVVIS = BQ('tput cvvis')
        *
        * ERASE TO END-LINE
2973             DS_EL    = BQ('tput el')
        * HOME CURSOR
2974             DS_HOME  = BQ('tput home')
        * CLEAR DISPLAY
2975             DS_CLEAR = BQ('tput clear')
        *
        * NUMBER OF COLUMNS
2976             DS_COLS  = BQ('tput cols')
        *
        * NUMBER OF LINES
2977             DS_LINES = BQ('tput lines')
        *
        * DYNAMIC STRINGS. THESE ARE CACHED IN TABLE DS_
        *
2978             DS_ = TABLE(DS_LINES * DS_COLS + 16)
        *
2979             DEFINE('DS_GOTO(ROW,COL)')
2980             DEFINE('DS_FOREGROUND_COLOR(N)')
2981             DEFINE('DS_BACKGROUND_COLOR(N)')
        *
        * DEFINED COLORS
        *
2982             DS_BLACK  = 0
2983             DS_RED    = 1
2984             DS_GREEN  = 2
2985             DS_YELLOW = 3
2986             DS_BLUE   = 4
2987             DS_PURPLE = 5
2988             DS_CYAN   = 6
2989             DS_WHITE  = 7                                    :(DS_GOTO_END)
        *
        -LINE 96 "DISPLAY.lss"
        *
        * SET FOREGROUND COLOR.
        *
2990    DS_FOREGROUND_COLOR
2991             DS_FOREGROUND_COLOR = VDIFFER(DS<'F' N>)             :S(RETURN)
2992             DS_<'F' N> = BQ('tput setaf ' N)         :(DS_FOREGROUND_COLOR)
        *
        * SET BACKGROUND COLOR.
        *
2993    DS_BACKGROUND_COLOR
2994             DS_BACKGROUND_COLOR = VDIFFER(DS<'B' N>)             :S(RETURN)
2995             DS_<'B' N> = BQ('tput setab ' N)         :(DS_BACKGROUND_COLOR)
        *
        * POSITION CURSOR TO (ROW, COLUMN)
        *
2996    DS_GOTO  DS_GOTO = VDIFFER(DS_<ROW ' ' COL>)                  :S(RETURN)
        *
        -LINE 119 "DISPLAY.lss"
2997             DS_<ROW ' ' COL> = BQ('tput cup ' ROW ' ' COL)       :(DS_GOTO)
        *
2998    DS_GOTO_END
        *
        * IND - SCROLL UP
        * NOTE THAT IND IS NL, SO BQ RETURNS IS NOT SUITABLE WE THEREFORE
        * DON'T USE BQ('tput ind') BUT CHARS_NL DIRECTLY
        *
2999             DS_IND = DS_GOTO(DS_LINES - 1, 0) CHARS_NL
        * RI - SCROLL DOWN
3000             DS_RI = DS_HOME BQ('tput ri')
        *
3001             CODE('DISPLAY')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'DSERVE.INC'
        -INCLUDE 'DYNAMIC.INC'
        -MODULE DYNAMIC
        -LINE 11 "DYNAMIC.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'REPL.INC'
        -IN72
        -LINE 199 "DYNAMIC.lss"
        -STITL DYNAMIC
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    ######   #     #  #     #     #     #     #  ###   #####          *
        *    #     #   #   #   ##    #    # #    ##   ##   #   #     #         *
        *    #     #    # #    # #   #   #   #   # # # #   #   #               *
        *    #     #     #     #  #  #  #     #  #  #  #   #   #               *
        *    #     #     #     #   # #  #######  #     #   #   #               *
        *    #     #     #     #    ##  #     #  #     #   #   #     #         *
        *    ######      #     #     #  #     #  #     #  ###   #####          *
        *                                                                      *
        * DYNAMIC       CREATE DYNAMICALLY LOADABLE MODULE FOR LOAD()          *
        *                                                                      *
        * PHIL BUDNE, NOVEMBER 2005                                            *
        *                                                                      *
        ************************************************************************
        *
        * DYNAMIC.lss
        *
        -LINE 17 "DYNAMIC.lss"
        -PUBLIC COMPILE_COBOL(), COMPILE_FORTRAN(), COMPILE_SCHEME()
        -PUBLIC COMPILE_DYNAMIC(), LIBS_FORTRAN(), LIBS_COBOL(), LIBS_SCHEME()
        *
3002    DYNAMIC  DEFINE('COMPILE_COBOL(SRC)CMD,COBC')
3003             DEFINE('COMPILE_FORTRAN(SRC)CMD')
3004             DEFINE('COMPILE_SCHEME(SRC)CMD,CC,DL_CFLAGS,COPT')
3005             DEFINE('COMPILE_DYNAMIC(SRC)CMD,CC,DL_CFLAGS,COPT,CINC')
3006             DEFINE('LIBS_FORTRAN()')
3007             DEFINE('LIBS_COBOL()')
3008             DEFINE('LIBS_SCHEME()')                  :(COMPILE_DYNAMIC_END)
        *
        -LINE 33 "DYNAMIC.lss"
3009    LIBS_FORTRAN
3010             LIBS_FORTRAN = '-lgfortran'                           :(RETURN)
        *
        -LINE 42 "DYNAMIC.lss"
3011    LIBS_COBOL
3012             LIBS_COBOL = BQ('cob-config --libs')                  :(RETURN)
        *
        -LINE 50 "DYNAMIC.lss"
3013    LIBS_SCHEME
3014             LIBS_SCHEME = 'prog_.o -lgambc -ldl -lm -lutil'       :(RETURN)
        -LINE 59 "DYNAMIC.lss"
        *
        * DYNAMIC COMPILE COBOL SOURCE
        *
3015    COMPILE_COBOL
3016             CMD = 'cobc -C ' SRC
3017             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3018             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3019             COBC = BQ('cob-config --cflags')
3020             SRC '.cbl' =
3021             SRC '.CBL' =
3022             CC = HOST(HOST_CC)                                  :F(FRETURN)
3023             IDENT(CC)                                           :S(FRETURN)
3024             DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
3025             COPT = HOST(HOST_COPT) ' '
3026             CMD = CC ' -c ' COPT DL_CFLAGS ' -DPIC -O3 ' COBC ' ' SRC '.c'
3027             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3028             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3029             DELETE(SRC '.c')
3030             DELETE(SRC '.c.h')
3031             DELETE(SRC '.c.l.h')                                  :(RETURN)
        -LINE 90 "DYNAMIC.lss"
        *
        * DYNAMIC COMPILE FORTRAN SOURCE
        *
3032    COMPILE_FORTRAN
3033             CMD = 'gfortran -c -fpic -O3 -ff2c -std=legacy ' SRC
3034             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3035             HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
        *
        -LINE 105 "DYNAMIC.lss"
3036    COMPILE_SCHEME
3037             CMD = 'gsc -c ' SRC
3038             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3039             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
3040             SRC '.scm' = '.c'
3041             SRC '.six' = '.c'
3042             CMD = 'gsc -link -o prog_.c ' SRC
3043             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3044             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3045             CC = HOST(HOST_CC)                                  :F(FRETURN)
3046             IDENT(CC)                                           :S(FRETURN)
3047             DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
3048             COPT = HOST(HOST_COPT) ' '
3049             CMD = CC ' -c -D___LIBRARY ' COPT DL_CFLAGS ' ' SRC ' prog_.c'
3050             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3051             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
        *
3052             DELETE(SRC)
3053             DELETE('prog_.c')                                     :(RETURN)
        -LINE 131 "DYNAMIC.lss"
        *
        * DYNAMIC COMPILE C SOURCE
        *
3054    COMPILE_DYNAMIC
3055             CC = HOST(HOST_CC)                                  :F(FRETURN)
3056             IDENT(CC)                                           :S(FRETURN)
3057             DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
3058             COPT = HOST(HOST_COPT) ' '
3059             CINC = HOST(HOST_SNOLIB_DIR)
3060             CINC = HOST(HOST_INCLUDE_DIR)
3061             CMD = CC ' -c ' COPT DL_CFLAGS ' -I' CINC ' ' SRC
3062             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3063             HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
        *
3064    COMPILE_DYNAMIC_END
        *
        -PUBLIC LINK_DYNAMIC()
3065
3066             DEFINE('LINK_DYNAMIC(OUT,OBJ,LIBS)'
3066    +               'CMD,DL_LD,DL_EXT,DL_LDFLAGS,DSEP')  :(LINK_DYNAMIC_END)
        *
3067    LINK_DYNAMIC
3068             DL_LD = HOST(HOST_DL_LD)                            :F(FRETURN)
3069             IDENT(DL_LD)                                        :S(FRETURN)
3070             DL_EXT = HOST(HOST_DL_EXT)
3071             OUT = DIFFER(DL_EXT) OUT DL_EXT
3072             DL_LDFLAGS = HOST(HOST_DL_LDFLAGS) ' '
3073             CMD = DL_LD ' ' DL_LDFLAGS '-o ' OUT ' ' OBJ ' ' LIBS
3074             TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
3075             HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
3076             LINK_DYNAMIC = OUT
3077             DSEP = HOST(HOST_DIR_SEP)
3078             LINK_DYNAMIC BREAK(DSEP) DSEP                        :S(RETURN)
3079             LINK_DYNAMIC = '.' DSEP LINK_DYNAMIC                  :(RETURN)
3080    LINK_DYNAMIC_END
        *
        * MAKE A DYNAMIC MODULE, GIVEN C SOURCES
        * LIBS MAY CONTAIN BOTH OBJECTS AND LIBRARIES
        *
        -PUBLIC MAKE_DYNAMIC_MODULE()
        *
3081             DEFINE('MAKE_DYNAMIC_MODULE(OUT,SRC,LIBS)OBJ')
3082                                                  :(MAKE_DYNAMIC_MODULE_END)
3083    MAKE_DYNAMIC_MODULE
3084             IDENT(SRC)                                         :S(MDM_LINK)
3085             COMPILE_DYNAMIC(SRC)                                :F(FRETURN)
3086             OBJ = REPL(SRC, '.o', '.c')
3087    MDM_LINK IDENT(OBJ LIBS)                                     :S(FRETURN)
3088             MAKE_DYNAMIC_MODULE = LINK_DYNAMIC(OUT, OBJ, LIBS)  :F(FRETURN)
3089                                                                   :(RETURN)
3090    MAKE_DYNAMIC_MODULE_END
        *
3091    DYNAMIC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'EDITLINE.INC'
        -INCLUDE 'FASTBAL.INC'
        -MODULE FASTBAL
        -LINE 20 "FASTBAL.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 99 "FASTBAL.lss"
        -STITL FASTBAL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #######     #      #####   #######  ######      #     #           *
        *    #          # #    #     #     #     #     #    # #    #           *
        *    #         #   #   #           #     #     #   #   #   #           *
        *    #####    #     #   #####      #     ######   #     #  #           *
        *    #        #######        #     #     #     #  #######  #           *
        *    #        #     #  #     #     #     #     #  #     #  #           *
        *    #        #     #   #####      #     ######   #     #  #######     *
        *                                                                      *
        * FASTBAL                                                              *
        *                                                                      *
        ************************************************************************
        *
        * FASTBAL.lss
        *
        -LINE 24 "FASTBAL.lss"
        -PUBLIC FASTBAL()
        *
3092             DEFINE('FASTBAL(PARENS,QTS,S)NAME,IBAL,SPCHARS,ELEM'
3092    +               ',LPS,Q,LP,RP')                           :(FASTBAL_END)
        *
3093    FASTBAL  NAME = UNIQUE()
3094             IBAL = CONVERT(NAME, 'EXPRESSION')
3095             IBAL = DIFFER(S, NULL) FASTBAL(PARENS, QTS)
3096             SPCHARS = PARENS QTS S
        -LINE 40 "FASTBAL.lss"
3097             ELEM = NOTANY(PARENS QTS) BREAK(SPCHARS)
        -LINE 48 "FASTBAL.lss"
3098    FASTBAL_1
3099             QTS LEN(1) . Q  =                                 :F(FASTBAL_2)
3100             ELEM = Q BREAK(Q) Q | ELEM                         :(FASTBAL_1)
        -LINE 59 "FASTBAL.lss"
3101    FASTBAL_2
3102             PARENS LEN(1) . LP RTAB(1) . PARENS LEN(1) . RP   :F(FASTBAL_3)
3103             ELEM = LP IBAL RP | ELEM                           :(FASTBAL_2)
        -LINE 79 "FASTBAL.lss"
3104    FASTBAL_3
3105             FASTBAL = BREAK(SPCHARS) ARBNO(ELEM)
3106             $NAME = FASTBAL                                       :(RETURN)
        *
3107    FASTBAL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FCGI.INC'
        -INCLUDE 'FENCE.INC'
        -MODULE FENCE
        -LINE 34 "FENCE.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 64 "FENCE.lss"
        -STITL FENCE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             #######  #######  #     #   #####   #######              *
        *             #        #        ##    #  #     #  #                    *
        *             #        #        # #   #  #        #                    *
        *             #####    #####    #  #  #  #        #####                *
        *             #        #        #   # #  #        #                    *
        *             #        #        #    ##  #     #  #                    *
        *             #        #######  #     #   #####   #######              *
        *                                                                      *
        ************************************************************************
        *
        * FENCE.lss
        *
        -LINE 38 "FENCE.lss"
        -PUBLIC FENCE()
        *
3108            DEFINE('FENCE(P)N')                                 :(FENCE_END)
        *
3109    FENCE   N = UNIQUE()
3110            FENCE = EVAL('@' N
3110    +                    ' P '
3110    +                    ' "" $ *$(.' N ' DIFFER(' N '))'
3110    +                   )                                          :(RETURN)
        *
3111    FENCE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FFI.INC'
        -INCLUDE 'FIND.INC'
        -MODULE FIND
        -LINE 14 "FIND.lss"
        -IN72
        -LINE 47 "FIND.lss"
        -STITL FIND
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                    #######  ###  #     #  ######                     *
        *                    #         #   ##    #  #     #                    *
        *                    #         #   # #   #  #     #                    *
        *                    #####     #   #  #  #  #     #                    *
        *                    #         #   #   # #  #     #                    *
        *                    #         #   #    ##  #     #                    *
        *                    #        ###  #     #  ######                     *
        *                                                                      *
        * FIND                       FIND EXTREME                              *
        *                                                                      *
        ************************************************************************
        *
        * FIND.lss
        *
        -LINE 17 "FIND.lss"
        -PUBLIC FIND()
        *
3112             DEFINE('FIND(A,PRED)EX,I,MAX,TEST')                 :(FIND_END)
        *
3113    FIND     EX = CONVERT(PRED '(MAX,TEST)', 'EXPRESSION')
3114             FIND = 1
3115             MAX = A<FIND>
3116             I = 1
3117    FIND_1   I = I + 1
3118             TEST = A<I>                                          :F(RETURN)
3119             EVAL(EX)                                             :S(FIND_1)
3120             MAX = TEST
3121             FIND = I                                              :(FIND_1)
        *
3122    FIND_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FLOOR.INC'
        -INCLUDE 'FOREACH.INC'
        -PLUSOPS 1
3123      :(FOREACH.1)
        -SNOCONE
        -MODULE FOREACH
        -LINE 11 "FOREACH.lss"
        -LINE 73 "FOREACH.lss"
        -IN1024
        -STITL FOREACH
        -EJECT
        -LINE 15 "FOREACH.lss"
        -PUBLIC FOREACH()
        -LINE 20 "FOREACH.lss"
3124      :(FOREACH.END)
        -LINE 21
3125    FOREACH I = DATATYPE(X)
        -LINE 22
3126     IDENT(I,'ARRAY') :F(FOREACH.2)
        -LINE 23
3127     I = 1
        -LINE 24
3128     PROTOTYPE(X) ? FENCE BREAK(':') . I
        -LINE 25
3129    FOREACH.3 A = X<I> :F(FOREACH.4)
        -LINE 26
3130     APPLY(PROC,A) :S(FOREACH.5)F(FRETURN)
        -LINE 28
3131    FOREACH.5 I = I + 1 :(FOREACH.3)
        -LINE 30
3132    FOREACH.4  :(FOREACH.6)
3133    FOREACH.2 IDENT(I,'TABLE') :F(FOREACH.7)
        -LINE 31
3134     X = CONVERT(X,'ARRAY') :S(FOREACH.8)F(FRETURN)
        -LINE 33
3135    FOREACH.8 X = SORT(X)
        -LINE 34
3136     I = 1
        -LINE 35
3137    FOREACH.9 A = X<I,2> :F(FOREACH.10)
        -LINE 36
3138     APPLY(PROC,A,X<I,1>) :S(FOREACH.11)F(FRETURN)
        -LINE 38
3139    FOREACH.11 I = I + 1 :(FOREACH.9)
        -LINE 40
3140    FOREACH.10  :(FOREACH.12)
3141    FOREACH.7 IDENT(I,'EXPRESSION') :F(FOREACH.13)
        -LINE 41
3142    FOREACH.14 A = EVAL(X) :F(FOREACH.15)
        -LINE 42
3143     APPLY(PROC,A) :S(FOREACH.16)F(FRETURN)
        -LINE 44
3144    FOREACH.16  :(FOREACH.14)
        -LINE 45
3145    FOREACH.15  :(FOREACH.17)
        -LINE 46
3146    FOREACH.13 APPLY(PROC,X) :S(RETURN)F(FOREACH.18)
        -LINE 49
3147    FOREACH.18  :(FRETURN)
3148    FOREACH.19
3149    FOREACH.17
3150    FOREACH.12
        -LINE 51
3151    FOREACH.6  :(RETURN)
3152    FOREACH.END
3153    FOREACH.1
        -INCLUDE 'DEXP.INC'
3154     DEFINE('foreach(x,proc)a,i')
        -INCLUDE 'FOR.INC'
        -MODULE FOR
        -LINE 61 "FOR.lss"
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'TIMER.INC'
        -IN72
        -LINE 260 "FOR.lss"
        -STITL FOR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #######  #######  ######                        *
        *                      #        #     #  #     #                       *
        *                      #        #     #  #     #                       *
        *                      #####    #     #  ######                        *
        *                      #        #     #  #   #                         *
        *                      #        #     #  #    #                        *
        *                      #        #######  #     #                       *
        *                                                                      *
        * FOR                         FOR LOOP                                 *
        *                                                                      *
        ************************************************************************
        *
        * FOR.lss
        *
        -LINE 66 "FOR.lss"
        -PUBLIC CODE_(), WHILE_COMPILE(), IF_COMPILE(), FOR_COMPILE()
        -PUBLIC STMT_COMPILE(), PROG2_COMPILE(), SET_RVAL(), EVAL_CODE_()
        -PUBLIC FOR(), WHILE()
        *
3155             DATA('CODE_(TYPE,INIT,TEST,INCR,STMT,ELSE,'
3155    +                        'INIT_,TEST_,INCR_,STMT_,ELSE_)')
3156             DEFINE('WHILE_COMPILE(TEST_,STMT_)')
3157             DEFINE('IF_COMPILE(TEST_,STMT_,ELSE_)')
3158             DEFINE('FOR_COMPILE(INIT_,TEST_,INCR_,STMT_)')
3159             DEFINE('STMT_COMPILE(STMT_)')
3160             DEFINE('PROG2_COMPILE(INIT_,STMT_)')
3161             DEFINE('SET_RVAL(R)')
3162             DEFINE('EVAL_CODE_(F_)')
        *
3163             OPSYN('FOR', 'EVAL_CODE_')
3164             OPSYN('WHILE', 'EVAL_CODE_')                         :(FOR_END)
        *
3165    SET_RVAL EVAL_CODE_ = R
3166             SET_RVAL = R                                          :(RETURN)
        *
3167    PROG2_COMPILE
3168             PROG2_COMPILE = CODE_('PROG2')
3169             INIT_(PROG2_COMPILE) = INIT_
3170             STMT_(PROG2_COMPILE) = STMT_
3171             INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
3171    +           ' EVAL_CODE_(INIT_(F_))'
3172             INIT(PROG2_COMPILE) =
3172    +           CODE(INIT_ ' :<STMT(F_)>')                         :F(ERROR)
3173             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3173    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3174             STMT(PROG2_COMPILE) =
3174    +           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
        *
3175    STMT_COMPILE
3176             STMT_COMPILE = CODE_('STMT')
3177             STMT_(STMT_COMPILE) = STMT_
3178             INIT(STMT_COMPILE) = CODE(' :<STMT(F_)>')
3179             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3179    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3180             STMT(STMT_COMPILE) =
3180    +           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
        *
3181    IF_COMPILE
3182             IF_COMPILE = CODE_('IF')
3183             TEST_(IF_COMPILE) = TEST_
3184             STMT_(IF_COMPILE) = STMT_
3185             ELSE_(IF_COMPILE) = ELSE_
3186             INIT(IF_COMPILE) = CODE(' :<TEST(F_)>')
3187             TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
3187    +           ' EVAL_CODE_(TEST_(F_))'
3188             TEST(IF_COMPILE) =
3188    +           CODE(TEST_ ' :S<STMT(F_)>F<ELSE(F_)>')             :F(ERROR)
3189             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3189    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3190             STMT(IF_COMPILE) =
3190    +           CODE(STMT_ ' :S(RETURN)F(FRETURN)')                :F(ERROR)
3191             ELSE_ = IDENT(DATATYPE(STMT_), 'CODE_')
3191    +           ' EVAL_CODE_ = EVAL_CODE_(ELSE_(F_))'
3192             ELSE(IF_COMPILE) =
3192    +           CODE(ELSE_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
        *
3193    WHILE_COMPILE
3194             WHILE_COMPILE = FOR_COMPILE(, TEST_,, STMT_)
3195             TYPE(WHILE_COMPILE) = 'WHILE'                         :(RETURN)
        *
3196    FOR_COMPILE
3197             FOR_COMPILE = CODE_('FOR')
3198             TEST_(FOR_COMPILE) = TEST_
3199             STMT_(FOR_COMPILE) = STMT_
3200             INCR_(FOR_COMPILE) = INCR_
3201             INIT_(FOR_COMPILE) = INIT_
3202             TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
3202    +           ' EVAL_CODE_(TEST_(F_))'
3203             TEST(FOR_COMPILE) =
3203    +           CODE(TEST_ ' :S<STMT(F_)>F(RETURN)')               :F(ERROR)
3204             STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
3204    +           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
3205             STMT(FOR_COMPILE) =
3205    +           CODE(STMT_ ' :S<INCR(F_)>F(FRETURN)')              :F(ERROR)
3206             INCR_ = IDENT(DATATYPE(INCR_), 'CODE_')
3206    +           ' EVAL_CODE_(INCR_(F_))'
3207             INCR(FOR_COMPILE) =
3207    +           CODE(INCR_ ' :S<TEST(F_)>F(ERROR)')                :F(ERROR)
3208             INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
3208    +           ' EVAL_CODE_(INIT_(F_))'
3209             INIT(FOR_COMPILE) =
3209    +           CODE(INIT_ ' :S<TEST(F_)>F(ERROR)')       :S(RETURN)F(ERROR)
        *
3210    EVAL_CODE_                                                   :<INIT(F_)>
        *
3211    FOR_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FORMAT.INC'
        -MODULE FORMAT
        -LINE 8 "FORMAT.lss"
        -IN72
        -LINE 359 "FORMAT.lss"
        -STITL FORMAT
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #######  #######  ######   #     #     #     #######         *
        *         #        #     #  #     #  ##   ##    # #       #            *
        *         #        #     #  #     #  # # # #   #   #      #            *
        *         #####    #     #  ######   #  #  #  #     #     #            *
        *         #        #     #  #   #    #     #  #######     #            *
        *         #        #     #  #    #   #     #  #     #     #            *
        *         #        #######  #     #  #     #  #     #     #            *
        *                                                                      *
        * FORMAT                 FORTRAN IV FORMAT()                           *
        *                                                                      *
        ************************************************************************
        *
        * FORMAT.lss
        *
        -LINE 11 "FORMAT.lss"
        -LINE 12 "FORMAT.lss"
        -LINE 13 "FORMAT.lss"
        -LINE 14 "FORMAT.lss"
        -LINE 15 "FORMAT.lss"
        -LINE 16 "FORMAT.lss"
        -LINE 17 "FORMAT.lss"
        -LINE 20 "FORMAT.lss"
3212             FORMAT = 'format.c'
        -LINE 271 "FORMAT.lss"
        -LINE 272 "FORMAT.lss"
        -LINE 273 "FORMAT.lss"
        -LINE 274 "FORMAT.lss"
        -LINE 275 "FORMAT.lss"
        -LINE 276 "FORMAT.lss"
        -LINE 341 "FORMAT.lss"
        -PUBLIC FTN_FORMAT()
        *
3213             LOAD('FTN_FORMAT(STRING,STRING)STRING', 'format.so')
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'FREEZE.INC'
        -INCLUDE 'GCD.INC'
        -MODULE GCD
        -LINE 8 "GCD.lss"
        -IN72
        -LINE 39 "GCD.lss"
        -STITL GCD
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       #####    #####   ######                        *
        *                      #     #  #     #  #     #                       *
        *                      #        #        #     #                       *
        *                      #  ####  #        #     #                       *
        *                      #     #  #        #     #                       *
        *                      #     #  #     #  #     #                       *
        *                       #####    #####   ######                        *
        *                                                                      *
        * GCD                   GREATEST COMMON DIVISOR                        *
        *                                                                      *
        ************************************************************************
        *
        * GCD.lss
        *
        -LINE 11 "GCD.lss"
        -PUBLIC GCD()
        *
3214             DEFINE('GCD(I,J)')                                   :(GCD_END)
        *
3215    GCD      EQ(I)                                               :S(FRETURN)
3216             EQ(J)                                               :S(FRETURN)
3217    GCD.1    GCD = REMDR(I, J)
3218             GCD = EQ(GCD) J                                      :S(RETURN)
3219             I = J
3220             J = GCD                                                :(GCD.1)
        *
3221    GCD_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'GDDT.INC'
        -LIST
        -INCLUDE 'GETKEY.INC'
        -MODULE GETKEY
        -LINE 44 "GETKEY.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'HOST.INC'
        -IN72
        -LINE 150 "GETKEY.lss"
        -STITL GETKEY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *           #####   #######  #######  #    #  #######  #     #         *
        *          #     #  #           #     #   #   #         #   #          *
        *          #        #           #     #  #    #          # #           *
        *          #  ####  #####       #     ###     #####       #            *
        *          #     #  #           #     #  #    #           #            *
        *          #     #  #           #     #   #   #           #            *
        *           #####   #######     #     #    #  #######     #            *
        *                                                                      *
        * GETKEY      GET KEY, INCLUDING ARROWS AND FUNCTION KEYS              *
        *                                                                      *
        ************************************************************************
        *
        * GETKEY.lss
        *
        -LINE 50 "GETKEY.lss"
        -PUBLIC GETKEY()
        *
3222             DEFINE('GETKEY(IN)KEY,M')
        *
3223    GETKEY_INIT
        *
        -PUBLIC KEY_ESC, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_PAGEDN
        -PUBLIC KEY_PAGEUP, KEY_HOME, KEY_END, KEY_INS
        *
3224             KEY_ESC    = CHARS_ESC CHARS_ESC
3225             KEY_LEFT   = BQ('tput kcub1')
3226             KEY_RIGHT  = BQ('tput kcuf1')
3227             KEY_UP     = BQ('tput kcuu1')
3228             KEY_DOWN   = BQ('tput kcud1')
3229             KEY_PAGEDN = BQ('tput knp')
3230             KEY_PAGEUP = BQ('tput kpp')
3231             KEY_HOME   = BQ('tput khome')
3232             KEY_END    = BQ('tput kend')
3233             KEY_INS    = BQ('tput kich1')
        -LINE 79 "GETKEY.lss"
3234             BQ('echo $TERM') 'xterm'                         :F(GETKEY_END)
3235             KEY_LEFT   = REPLACE(KEY_LEFT,  'O', '[')
3236             KEY_RIGHT  = REPLACE(KEY_RIGHT, 'O', '[')
3237             KEY_UP     = REPLACE(KEY_UP,    'O', '[')
3238             KEY_DOWN   = REPLACE(KEY_DOWN,  'O', '[')
3239             KEY_HOME   = REPLACE(KEY_HOME,  'O', '[')
3240             KEY_END    = REPLACE(KEY_END,   'O', '[')
3241             KEY_INS    = REPLACE(KEY_INS,   'O', '[')
3242                                                               :(GETKEY_END)
        *
3244    GETKEY   &INPUT = 1; KEY =
3246    GK1      M = ; KEY = KEY $IN
        *
3247    GK2      M = ?(KEY_UP ? FENCE KEY) 1                             :F(GK3)
3248             EQ(SIZE(KEY), SIZE(KEY_UP))                             :S(GKR)
        *
3249    GK3      M = ?(KEY_DOWN ? FENCE KEY) 1                           :F(GK4)
3250             EQ(SIZE(KEY), SIZE(KEY_DOWN))                           :S(GKR)
        *
3251    GK4      M = ?(KEY_RIGHT ? FENCE KEY) 1                          :F(GK5)
3252             EQ(SIZE(KEY), SIZE(KEY_RIGHT))                          :S(GKR)
        *
3253    GK5      M = ?(KEY_LEFT ? FENCE KEY) 1                           :F(GK6)
3254             EQ(SIZE(KEY), SIZE(KEY_LEFT))                           :S(GKR)
        *
3255    GK6      M = ?(KEY_PAGEDN ? FENCE KEY) 1                         :F(GK7)
3256             EQ(SIZE(KEY), SIZE(KEY_PAGEDN))                         :S(GKR)
        *
3257    GK7      M = ?(KEY_PAGEUP ? FENCE KEY) 1                         :F(GK8)
3258             EQ(SIZE(KEY), SIZE(KEY_PAGEUP))                         :S(GKR)
        *
3259    GK8      M = ?(KEY_HOME ? FENCE KEY) 1                           :F(GK9)
3260             EQ(SIZE(KEY), SIZE(KEY_HOME))                           :S(GKR)
        *
3261    GK9      M = ?(KEY_END ? FENCE KEY) 1                           :F(GK10)
3262             EQ(SIZE(KEY), SIZE(KEY_END))                            :S(GKR)
        *
3263    GK10     M = ?(KEY_INS ? FENCE KEY) 1                           :F(GK11)
3264             EQ(SIZE(KEY), SIZE(KEY_INS))                            :S(GKR)
        *
3265    GK11     M = ?(KEY_ESC ? FENCE KEY) 1                           :F(GK12)
3266             EQ(SIZE(KEY), SIZE(KEY_ESC))                            :S(GKR)
3266    +                                                                 F(GK1)
        -LINE 129 "GETKEY.lss"
3267    GK12     DIFFER(M)                                               :S(GK1)
3268    GKR      GETKEY = KEY                                          :(RETURN)
        *
3269             CODE('GETKEY_INIT')
        *
3270    GETKEY_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'HASH.INC'
        -INCLUDE 'HEX.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'HTMLESC.INC'
        -INCLUDE 'HTMLTMPL.INC'
        -INCLUDE 'INFINIP.INC'
        -MODULE INFINIP
        -LINE 10 "INFINIP.lss"
        -INCLUDE 'REDEFINE.INC'
        -MODULE REDEFINE
        -LINE 16 "REDEFINE.lss"
        -IN72
        -LINE 58 "REDEFINE.lss"
        -STITL REDEFINE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *  ######   #######  ######   #######  #######  ###  #     #  #######  *
        *  #     #  #        #     #  #        #         #   ##    #  #        *
        *  #     #  #        #     #  #        #         #   # #   #  #        *
        *  ######   #####    #     #  #####    #####     #   #  #  #  #####    *
        *  #   #    #        #     #  #        #         #   #   # #  #        *
        *  #    #   #        #     #  #        #         #   #    ##  #        *
        *  #     #  #######  ######   #######  #        ###  #     #  #######  *
        *                                                                      *
        * REDEFINE             REDEFINE OPERATORS                              *
        *                                                                      *
        ************************************************************************
        *
        * REDEFINE.lss
        *
        * FMGW:
        *
        * - ADD REDEFINERESTORE() TO ALLOW INFINIP.SNO TO ENABLE/DISABLE
        *   LONG INTEGERS
        * - FACTOR REDEFINECOMMON() TO ALLOW REDEFINE() AND REDEFINERESTORE()
        *   TO SHARE CODE
        *
        -LINE 19 "REDEFINE.lss"
        -PUBLIC REDEFINE(), REDEFINERESTORE()
        *
3271             DEFINE('REDEFINE(OP,DEF,LBL)NAME,N,FLAG')
3272             DEFINE('REDEFINERESTORE(OP,DEF)NAME,N,FLAG')
3273             DEFINE('REDEFINECOMMON()')                      :(REDEFINE_END)
        *
3274    REDEFINECOMMON
3275             DEF BREAK('(') . NAME '(' BREAK('),') LEN(1) . FLAG
3276             N = 1
3277             N = IDENT(FLAG, ',') 2
3278             N = IDENT(OP)
3279             OP = IDENT(OP) NAME
3280                                                                   :(RETURN)
        *
3281    REDEFINE REDEFINECOMMON()
3282             OPSYN(NAME '.', OP, N)
3283             DEFINE(DEF, LBL)
3284             OPSYN(OP, NAME, N)                                    :(RETURN)
        *
3285    REDEFINERESTORE
3286             REDEFINECOMMON()
3287             OPSYN(OP, NAME '.', N)                                :(RETURN)
        *
3288    REDEFINE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SWAP.INC'
        -IN72
        -LINE 190 "INFINIP.lss"
        -STITL INFINIP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *            ###  #     #  #######  ###  #     #  ###  ######          *
        *             #   ##    #  #         #   ##    #   #   #     #         *
        *             #   # #   #  #         #   # #   #   #   #     #         *
        *             #   #  #  #  #####     #   #  #  #   #   ######          *
        *             #   #   # #  #         #   #   # #   #   #               *
        *             #   #    ##  #         #   #    ##   #   #               *
        *            ###  #     #  #        ###  #     #  ###  #               *
        *                                                                      *
        * INFINIP          INFINITE PRECISION INTEGER MATH                     *
        *                                                                      *
        ************************************************************************
        *
        * INFINIP.lss
        *
        -LINE 15 "INFINIP.lss"
3289             SIGN_OFF  = POS(0) '-'
3290             LDG_ZEROS = BREAK('123456789') | RTAB(1)
3291             NO_DIGITS = 4
        *
        -PUBLIC INFINP_START(), INFINP_STOP()
3292             DEFINE('XYZERO()')
3293             DEFINE('INFFLOAT()')
3294             DEFINE('SMALL()')
3295             DEFINE('SPLIT(NAME,PAT)')
3296             DEFINE('INFINIP_START()')
3297             DEFINE('INFINIP_STOP()')                         :(INFINIP_END)
        *
3298    INFINIP_START
3299             REDEFINE('-', 'MINUS(X)Y')
3300             REDEFINE(   , 'GT(X,Y)')
3301             REDEFINE(   , 'EQ(X,Y)')
3302             REDEFINE(   , 'GE(X,Y)')
3303             REDEFINE(   , 'NE(X,Y)')
3304             REDEFINE(   , 'LT(X,Y)')
3305             REDEFINE(   , 'LE(X,Y)')
3306             REDEFINE('-', 'DIFF(X,Y)')
3307             REDEFINE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
3308             REDEFINE('*', 'MULT(X,Y)X1,X2,K')
3309             REDEFINE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
3310             REDEFINE(   , 'REMDR(X,Y)')                           :(RETURN)
        *
3311    INFINIP_STOP
3312             REDEFINERESTORE('-', 'MINUS(X)Y')
3313             REDEFINERESTORE(   , 'GT(X,Y)')
3314             REDEFINERESTORE(   , 'EQ(X,Y)')
3315             REDEFINERESTORE(   , 'GE(X,Y)')
3316             REDEFINERESTORE(   , 'NE(X,Y)')
3317             REDEFINERESTORE(   , 'LT(X,Y)')
3318             REDEFINERESTORE(   , 'LE(X,Y)')
3319             REDEFINERESTORE('-', 'DIFF(X,Y)')
3320             REDEFINERESTORE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
3321             REDEFINERESTORE('*', 'MULT(X,Y)X1,X2,K')
3322             REDEFINERESTORE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
3323             REDEFINERESTORE(   , 'REMDR(X,Y)')                    :(RETURN)
        *
        * FMGW:
        * ADDED XYZERO TO ALLOW '' + 1 ETC. TO WORK AS NORMAL
        * INFFLOAT TO ALLOW REAL TO WORK AS NORMAL
        *
        * THERE IS STILL THE PROBLEM OF MIXING A LARGE INTEGER WITH A REAL IN
        * ARITHMETIC. THIS WILL NOT WORK CORRECTLY. IF THE LARGE INTEGER CANNOT
        * BE CONVERTED, AN ERROR WILL BE RAISED. WE SHOULD CHECK THE RANGE,
        * AND CONVERT THE INTEGER TO REAL OURSELVES. THIS CAN BE DONE IN
        * THE INFFLOAT() FUNCTION. NOTE THAT INFFLOAT() IS CALLED AFTER
        * XYZERO(), SO BOTH X AND Y ARE (AT LEAST) 0, AND NOT THE EMPTY STRING.
        *
        * XYZERO() AND INFFLOAT() COULD BE MERGED, BUT ARE KEPT SEPARATE FOR
        * CLARITY.
        *
        * INFINIP_START() AND INFINIP_STOP() ADDED TO CONTROL THE REDEFINITION
        * OF OPERATIONS.
        *
3324    INFFLOAT DATATYPE(X) 'REAL'                                   :S(RETURN)
3325             DATATYPE(Y) 'REAL'                                   :S(RETURN)
3326                                                                  :(FRETURN)
        *
3327    XYZERO   X = IDENT(X) 0
3328             Y = IDENT(Y) 0                                        :(RETURN)
        *
3329    SMALL    (LE.(SIZE(X), NO_DIGITS)
3329    +         LE.(SIZE(Y), NO_DIGITS))                  :S(RETURN)F(FRETURN)
        *
3330    SPLIT    PAT = IDENT(PAT) LEN(SIZE($NAME) / 2)
3331             $NAME (PAT | '') . $(NAME 1) @SPLIT  (SPAN('0') | '')
3331    +           REM . $(NAME 2)
3332             SPLIT = SIZE($NAME) - SPLIT                           :(RETURN)
        *
3333    MINUS    XYZERO()
3334             MINUS = INFFLOAT() MINUS.(X)                         :S(RETURN)
3335             MINUS = SMALL() MINUS.(X)                            :S(RETURN)
3336             MINUS = X
3337             MINUS SIGN_OFF =                                     :S(RETURN)
3338             MINUS = '-' X                                         :(RETURN)
        *
3339    GT       XYZERO()
3340             INFFLOAT()                                             :S(GT_3)
3341             SMALL()                                                :F(GT_1)
3342    GT_3     GT.(X,Y)                                   :S(RETURN)F(FRETURN)
3343    GT_1     X SIGN_OFF =                                           :F(GT_2)
3344             Y SIGN_OFF =                                        :F(FRETURN)
3345             SWAP(.X, .Y)
3346    GT_2     Y SIGN_OFF =                                         :S(RETURN)
3347             LGT(LPAD(X, SIZE(Y), '0'),
3347    +            LPAD(Y, SIZE(X), '0'))                 :S(RETURN)F(FRETURN)
        *
3348    EQ       XYZERO()
3349             INFFLOAT()                                             :S(EQ_2)
3350             SMALL()                                                :F(EQ_1)
3351    EQ_2     EQ.(X, Y)                                  :S(RETURN)F(FRETURN)
3352    EQ_1     IDENT(X, Y)                                :S(RETURN)F(FRETURN)
        *
3353    GE       ~(~GT(X, Y) ~EQ(X, Y))                     :S(RETURN)F(FRETURN)
        *
3354    NE       EQ(X, Y)                                   :S(FRETURN)F(RETURN)
        *
3355    LT       GE(X, Y)                                   :S(FRETURN)F(RETURN)
        *
3356    LE       GT(X, Y)                                   :S(FRETURN)F(RETURN)
        *
3357    DIFF     DIFF = X + -Y                                         :(RETURN)
        *
3358    SUM      XYZERO()
3359             SUM = INFFLOAT() SUM.(X, Y)                          :S(RETURN)
3360             SUM = SMALL() SUM.(X, Y)                             :S(RETURN)
3361             SUM = LT(X,0) -(-X + -Y)                             :S(RETURN)
3362             Y SIGN_OFF =                                          :S(SUM_1)
3363             (LT(X, Y) SWAP(.X, .Y))
3364             K = SPLIT(.X)
3365             Y = Y + X2
3366             SPLIT(.Y, RTAB(K))
3367             SUM = (Y1 + X1) LPAD(Y2, K, '0')                      :(RETURN)
3368    SUM_1    SUM = GT(Y, X) -(Y - X)                              :S(RETURN)
3369             Y = LPAD(Y, SIZE(X), '0')
        * ADD 10's COMPLEMENT OF Y
3370             SUM = X + 1 + REPLACE(Y, '0123456789', '9876543210')
3371             SUM '1' LDG_ZEROS REM . SUM                           :(RETURN)
        *
3372    MULT     XYZERO()
3373             MULT = INFFLOAT() MULT.(X, Y)                        :S(RETURN)
3374             MULT = LE(SIZE(X) + SIZE(Y), NO_DIGITS)
3374    +           MULT.(X, Y)                                       :S(RETURN)
3375             MULT = LT(X, 0) -X * -Y                              :S(RETURN)
3376             MULT = LT(Y, 0) -(X * -Y)                            :S(RETURN)
3377             (GT(Y, X)  SWAP(.X, .Y))
3378             MULT = EQ(Y, 0) 0                                    :S(RETURN)
3379             K = SPLIT(.X)
3380             MULT = (Y * X1) DUPL('0', K)
3381             MULT = MULT + X2 * Y                                  :(RETURN)
        *
3382    DIV      XYZERO()
3383             DIV = INFFLOAT() DIV.(X, Y)                          :S(RETURN)
3384             DIV = SMALL() DIV.(X, Y)                             :S(RETURN)
3385             DIV = LT(X, 0) -(-X / Y)                             :S(RETURN)
3386             DIV = LT(Y, 0) -(X / -Y)                             :S(RETURN)
3387             DIV = GT(Y, X) 0                                     :S(RETURN)
        * ORIGINAL STATEMENTS FROM BOOK:
        *        KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
        *        KX = SPLIT(.X, LEN(NO_DIGITS))
        * SUGGESTED REPLACEMENT TO AVOID GENERATING ERROR TERMS THAT ARE
        * LARGER THAN THE INCOMING NUMERATOR. SUCH A SITUATION CAN PRODUCE
        * CYCLES.
3388             KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
3389             KX = SPLIT(.X, LEN(NO_DIGITS / 2) | REM)
3390             KX = LT.(X1, Y1) SPLIT(.X, LEN(NO_DIGITS / 2 + 1) | REM)
        * END OF REPLACEMENT STATEMENTS.
3391             T1 = X1 / Y1
3392             T2 = DUPL('0', KX - KY)
3393             T = X - ((T1 * Y)  T2)
3394             DIV = T1 T2
3395             T = LT(T, 0) T + 1 - Y
3396             DIV = DIV + (T / Y)                                   :(RETURN)
        *
3397    REMDR    REMDR = X - (X / Y) * Y                               :(RETURN)
        *
3398    INFINIP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ITERDIR.INC'
        -MODULE ITERDIR
        -LINE 45 "ITERDIR.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'ATOL.INC'
        -INCLUDE 'CHARS.INC'
        -IN72
        -LINE 105 "ITERDIR.lss"
        -STITL ITERDIR
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *        ###  #######  #######  ######   ######   ###  ######          *
        *         #      #     #        #     #  #     #   #   #     #         *
        *         #      #     #        #     #  #     #   #   #     #         *
        *         #      #     #####    ######   #     #   #   ######          *
        *         #      #     #        #   #    #     #   #   #   #           *
        *         #      #     #        #    #   #     #   #   #    #          *
        *        ###     #     #######  #     #  ######   ###  #     #         *
        *                                                                      *
        * ITERDIR                   DIRECTORY ITERATOR                         *
        *                                                                      *
        ************************************************************************
        *
        * ITERDIR.lss
        *
        -LINE 52 "ITERDIR.lss"
        -PUBLIC VALUE_DIR(), ITER_DIR(), NEXT_DIR()
        *
3399             DEFINE('ITER_DIR(W)P,L')
3400             DEFINE('VALUE_DIR(D)')
3401             DEFINE('NEXT_DIR(D)')                           :(END_ITER_DIR)
        *
3402    VALUE_DIR
3403             VALUE_DIR = DIFFER(D) VALUE(D)             :S(RETURN)F(FRETURN)
        *
3404    ITER_DIR DIFFER(FORCEPATTERN)                               :S(ITERDIR2)
3405             DATATYPE(W) 'PATTERN'                              :S(ITERDIR2)
        *
3406             ITER_DIR = ATOL(CRACK(BQ('ls 2>/dev/null ' W, CHARS_NL),
3406    +           CHARS_NL))                              :S(RETURN)F(FRETURN)
        *
3407    ITERDIR2 ITER_DIR =
3407    +           ATOL(CRACK(BQ('ls 2>/dev/null', CHARS_NL), CHARS_NL))
3408             P = ITER_DIR
3409    ITERDIR3 IDENT(P)                                             :S(RETURN)
3410             VALUE(P) W                                         :S(ITERDIR4)
3411             NEXT(VDIFFER(L)) = NEXT(P)
3412             ITER_DIR = IDENT(L) NEXT(ITER_DIR)
3413             P = IDENT(L) ITER_DIR                              :S(ITERDIR3)
3414             P = NEXT(P)                                         :(ITERDIR3)
3416    ITERDIR4 L = P; P = NEXT(P)                                  :(ITERDIR3)
        *
3417    NEXT_DIR NEXT_DIR = DIFFER(D) NEXT(D)               :S(RETURN)F(FRETURN)
        *
3418    END_ITER_DIR
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'JIT.INC'
        -INCLUDE 'JSON.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'LAST.INC'
        -INCLUDE 'LIKE.INC'
        -MODULE LIKE
        -LINE 16 "LIKE.lss"
        -IN72
        -LINE 51 "LIKE.lss"
        -STITL LIKE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                     #        ###  #    #  #######                    *
        *                     #         #   #   #   #                          *
        *                     #         #   #  #    #                          *
        *                     #         #   ###     #####                      *
        *                     #         #   #  #    #                          *
        *                     #         #   #   #   #                          *
        *                     #######  ###  #    #  #######                    *
        *                                                                      *
        * LIKE                PATTERN TO MATCH LIKE STRING                     *
        *                                                                      *
        ************************************************************************
        *
        * LIKE.lss
        *
        -LINE 19 "LIKE.lss"
        -PUBLIC LIKE()
        *
3419             DEFINE('LIKE(S)C,T1,T2,N')                          :(LIKE_END)
        *
3420    LIKE     LIKE = S
3421    LIKE_1   S TAB(N) . T1 REM . T2                               :F(RETURN)
3422             N = N + 1
        * INSERTION OF CHARACTER AT POSITION N
3423             LIKE = LIKE | (T1 LEN(1) T2)
        * DELETION OF CHARACTER AT POSITION N
3424             T2 LEN(1) . C  =                                     :F(RETURN)
3425             LIKE = LIKE | (T1 T2)
        * TRANSPOSITION OF TWO CHARACTERS
3426             T2 POS(1) = C                                        :F(LIKE_1)
3427             LIKE = LIKE | (T1 T2)                                 :(LIKE_1)
        *
3428    LIKE_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'LINK.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'LOG.INC'
        -INCLUDE 'LOWA.INC'
        -INCLUDE 'LPROG.INC'
        -MODULE LPROG
        -LINE 15 "LPROG.lss"
        -IN72
        -LINE 41 "LPROG.lss"
        -STITL LPROG
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *               #        ######   ######   #######   #####             *
        *               #        #     #  #     #  #     #  #     #            *
        *               #        #     #  #     #  #     #  #                  *
        *               #        ######   ######   #     #  #  ####            *
        *               #        #        #   #    #     #  #     #            *
        *               #        #        #    #   #     #  #     #            *
        *               #######  #        #     #  #######   #####             *
        *                                                                      *
        * LPROG                    LENGTH OF PROGRAM                           *
        *                                                                      *
        ************************************************************************
        *
        * LPROG.lss
        *
        -LINE 18 "LPROG.lss"
        -PUBLIC LPROG()
        *
3429             DEFINE('LPROG()')                                  :(LPROG_END)
        *
3430    LPROG                                :<CODE(' LPROG = &STNO :(RETURN)')>
        *
3431    LPROG_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MAX.INC'
        -MODULE MAX
        -LINE 9 "MAX.lss"
        -IN72
        -LINE 24 "MAX.lss"
        -STITL MAX
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #     #     #     #     #                       *
        *                      ##   ##    # #     #   #                        *
        *                      # # # #   #   #     # #                         *
        *                      #  #  #  #     #     #                          *
        *                      #     #  #######    # #                         *
        *                      #     #  #     #   #   #                        *
        *                      #     #  #     #  #     #                       *
        *                                                                      *
        * MAX                      MAX/MIN FUNCTIONS                           *
        *                                                                      *
        ************************************************************************
        *
        * MAX.lss
        *
        -PUBLIC MAX(), MIN()
        *
3432             DEFINE('MAX(X,Y)')
3433             DEFINE('MIN(X,Y)')                                   :(MAX_END)
        *
3434    MAX      MAX = GT(X, Y) X                                     :S(RETURN)
3435             MAX = Y                                               :(RETURN)
        *
3436    MIN      MIN = LT(X, Y) X                                     :S(RETURN)
3437             MIN = Y                                               :(RETURN)
        *
3438    MAX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MBUG.INC'
        -MODULE MBUG
        -INCLUDE 'READLINE.INC'
        -INCLUDE 'EDITLINE.INC'
        -INCLUDE 'HASH.INC'
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'FFI.INC'
        -INCLUDE 'NSPAN.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'ARRAY0.INC'
        -INCLUDE 'BRKREM.INC'
        -IN72
        -STITL MBUG
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                  #     #  ######   #     #   #####                   *
        *                  ##   ##  #     #  #     #  #     #                  *
        *                  # # # #  #     #  #     #  #                        *
        *                  #  #  #  ######   #     #  #  ####                  *
        *                  #     #  #     #  #     #  #     #                  *
        *                  #     #  #     #  #     #  #     #                  *
        *                  #     #  ######    #####    #####                   *
        *                                                                      *
        * MBUG                 MACHINE LEVEL DEBUGGER                          *
        *                                                                      *
        ************************************************************************
        *
        * MBUG. A SIMPLE MACHINE LEVEL DEBUG FACILITY FOR USE WITH FFI BASED
        * CODE. USES PTRACE(). FORK PROCESS. PARENT RUNS MBUG. CHILD ENTERS
        * PTRACE. PARENT ACCEPTS COMMANDS AND CONTROLS CHILD. NEVER TERMINATES.
        * ONCE MBUG IS IN CONTROL, THE ONLY EXIT IS EXIT! WE DO THIS BECAUSE
        * NORMALLY DATA IS FED INTO THE MACHINE CODE, AND RESULTS RETURNED.
        * UNDER PTRACE, THE PROCESS IS FORKED AND THE CHILD IS RUNNING IN
        * A COMPLETELY SEPARATE ADDRESS SPACE. NO DATA EXCHANGE IS POSSIBLE.
        * THE SIMPLEST SOLUTION IS TO DEMAND AN APPLICATION SHUTDOWN AFTER THE
        * DEBUG IS COMPLETE. IN FUTURE, MBUG MAY BE STARTED EARLIER, ALLOWING
        * THE PROCESS TO CONTINUE. BUT IT IS DIFFICULT TO DETERMINE WHERE TO
        * SET BREAKPOINTS IN THE DYNAMIC CODE (FROM JIT.INC OR ASM.INC LAYERS).
        * FOR THIS REASON, WE TAKE THE SIMPLE APPROACH (USEFUL, EVEN IF NOT
        * COMPLETE).
        *
        * MBUG IS NOT A VERY SOPHISTICATED DEBUGGER. HOWEVER, MBUG IS
        * INTEGRATED WITH ASM/JIT. SYMBOL TABLES ARE SUPPLIED, AND DISASSEMBLY
        * OF CODE PROVIDED FROM ASM/JIT TO MBUG.
        *
        * HOW TO USE:
        *
        * MAKE SURE ROUTINES AND VARIABLES OF INTEREST ARE MARKED 'EXPORT' IN
        * THE ASM SOURCE FILE. THESE NAMES WILL BE AVAILABLE IN MBUG. USE
        * 'B NAME' TO SET BREAKPOINTS ON ROUTINES, 'S' TO EXAMINE/CHANGE DATA,
        * 'X' OR 'X RAX' (REGISTER NAME) TO EXAMINE/CHANGE REGISTERS. 'G' TO
        * EXECUTE TO BREAKPOINT. 'T' TO TRACE CODE. DISASSEMBLY FROM JIT IS
        * AVAILABLE, ALONG WITH 'NOTE()' COMMENTS IN THE CODE. SEE RUN FOR
        * HOW THIS IS INTERFACED INTO MBUG. NOTE THAT JIT_DISASSEMBLE()
        * ALWAYS SENDS RESULTS TO STANDARD OUT -- RUN FORKS A SUBPROCESS, AND
        * IN THAT SUBPROCESS REDIRECTS STANDARD OUT. THE DISASSEMBLY IS
        * CAPTURED SO IT CAN BE SENT TO MBUG().
        *
        * TO DO: ADD TYPING TO 'S' COMMAND (REAL, INTEGER).
        *
        -PUBLIC MBUG(), INT3
        *
3439             DEFINE('MBUG(SYMTAB,SRC)')
        *
                 INT3 = HI('CC') ;* OR CD 03
        *
        -PUBLIC PTRACE_TRACEME, PTRACE_PEEKTEXT, PTRACE_PEEKDATA
        *
3441             PTRACE_TRACEME            = 0
3442             PTRACE_PEEKTEXT           = 1
3443             PTRACE_PEEKDATA           = 2
        *
        -PUBLIC PTRACE_PEEKUSER, PTRACE_POKETEXT, PTRACE_POKEDATA
        *
3444             PTRACE_PEEKUSER           = 3
3445             PTRACE_POKETEXT           = 4
3446             PTRACE_POKEDATA           = 5
        *
        -PUBLIC PTRACE_POKEUSER, PTRACE_CONT, PTRACE_KILL, PTRACE_SINGLESTEP
        *
3447             PTRACE_POKEUSER           = 6
3448             PTRACE_CONT               = 7
3449             PTRACE_KILL               = 8
3450             PTRACE_SINGLESTEP         = 9
        *
        -PUBLIC PTRACE_GETREGS, PTRACE_SETREGS, PTRACE_GETFPREGS
        *
3451             PTRACE_GETREGS            = 12
3452             PTRACE_SETREGS            = 13
3453             PTRACE_GETFPREGS          = 14
        *
        -PUBLIC PTRACE_SETFPREGS, PTRACE_ATTACH, PTRACE_DETACH
        *
3454             PTRACE_SETFPREGS          = 15
3455             PTRACE_ATTACH             = 16
3456             PTRACE_DETACH             = 17
        *
        -PUBLIC PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, PTRACE_SYSCALL
        *
3457             PTRACE_GETFPXREGS         = 18
3458             PTRACE_SETFPXREGS         = 19
3459             PTRACE_SYSCALL            = 24
        *
        -PUBLIC PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG, PTRACE_GETSIGINFO
        *
3460             PTRACE_SETOPTIONS         = HI('4200')
3461             PTRACE_GETEVENTMSG        = HI('4201')
3462             PTRACE_GETSIGINFO         = HI('4202')
        *
        -PUBLIC PTRACE_SETSIGINFO, PTRACE_GETREGSET, PTRACE_SETREGSET
        *
3463             PTRACE_SETSIGINFO         = HI('4203')
3464             PTRACE_GETREGSET          = HI('4204')
3465             PTRACE_SETREGSET          = HI('4205')
        *
        -PUBLIC PTRACE_SEIZE, PTRACE_INTERRUPT, PTRACE_LISTEN
        *
3466             PTRACE_SEIZE              = HI('4206')
3467             PTRACE_INTERRUPT          = HI('4207')
3468             PTRACE_LISTEN             = HI('4208')
        *
        -PUBLIC PTRACE_PEEKSIGINFO, PTRACE_SEIZE_DEVEL, PTRACE_O_TRACESYSGOOD
        *
3469             PTRACE_PEEKSIGINFO        = HI('4209')
3470             PTRACE_SEIZE_DEVEL        = HI('80000000')
3471             PTRACE_O_TRACESYSGOOD     = HI('00000001')
        *
        -PUBLIC PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK, PTRACE_O_TRACECLONE
        *
3472             PTRACE_O_TRACEFORK        = HI('00000002')
3473             PTRACE_O_TRACEVFORK       = HI('00000004')
3474             PTRACE_O_TRACECLONE       = HI('00000008')
        *
        -PUBLIC PTRACE_O_TRACEEXEC, PTRACE_O_TRACEVFORKDONE, PTRACE_TRACEEXIT
        *
3475             PTRACE_O_TRACEEXEC        = HI('00000010')
3476             PTRACE_O_TRACEVFORKDONE   = HI('00000020')
3477             PTRACE_O_TRACEEXIT        = HI('00000040')
        *
        -PUBLIC PTRACE_O_TRACESECCOMP, PTRACE_O_EXITKILL, PTRACE_O_MASK
        *
3478             PTRACE_O_TRACESECCOMP     = HI('00000080')
3479             PTRACE_O_EXITKILL         = HI('00100000')
3480             PTRACE_O_MASK             = HI('001000FF')
        *
        -PUBLIC PTRACE_EVENT_FORK, PTRACE_EVENT_VFORK, PTRACE_EVENT_CLONE
        *
3481             PTRACE_EVENT_FORK         = 1
3482             PTRACE_EVENT_VFORK        = 2
3483             PTRACE_EVENT_CLONE        = 3
        *
        -PUBLIC PTRACE_EVENT_EXEC, PTRACE_EVENT_VFORK_DONE, PTRACE_EVENT_EXIT
        *
3484             PTRACE_EVENT_EXEC         = 4
3485             PTRACE_EVENT_VFORK_DONE   = 5
3486             PTRACE_EVENT_EXIT         = 6
        *
        -PUBLIC PTRACE_EVENT_SECCOMP, PTRACE_PEEKSIGINFO_SHARED
        *
3487             PTRACE_EVENT_SECCOMP      = 5
3488             PTRACE_PEEKSIGINFO_SHARED = 1
        *
        * PTRACE_PEEKSIGINFO ARG
        *     UINT64 OFF
        *     UINT32 FLAGS
        *     INT32 NR
        *
        * INDEX INTO ARRAY OF 8 BYTE LONGS RETURNED FROM PTRACE FOR LOCATION
        * OF THE USERS' GENERAL PURPOSE REGISTERS (216 BYTES)
        *
        -PUBLIC REGS_R15, REGS_R14, REGS_R13, REGS_R12, REGS_RBP, REGS_RBX
        *
3489             REGS_R15      = 0
3490             REGS_R14      = 1
3491             REGS_R13      = 2
3492             REGS_R12      = 3
3493             REGS_RBP      = 4
3494             REGS_RBX      = 5
        *
        -PUBLIC REGS_R11, REGS_R10, REGS_R9, REGS_R8, REGS_RAX, REGS_RCX
        *
3495             REGS_R11      = 6
3496             REGS_R10      = 7
3497             REGS_R9       = 8
3498             REGS_R8       = 9
3499             REGS_RAX      = 10
3500             REGS_RCX      = 11
        *
        -PUBLIC REGS_RDX, REGS_RSI, REGS_RDI, REGS_ORIG_RAX, REGS_RIP
        *
3501             REGS_RDX      = 12
3502             REGS_RSI      = 13
3503             REGS_RDI      = 14
3504             REGS_ORIG_RAX = 15
3505             REGS_RIP      = 16
        *
        -PUBLIC REGS_CS, REGS_EFLAGS, REGS_RSP, REGS_SS, REGS_FS_BASE
        *
3506             REGS_CS       = 17
3507             REGS_EFLAGS   = 18
3508             REGS_RSP      = 19
3509             REGS_SS       = 20
3510             REGS_FS_BASE  = 21
        *
        -PUBLIC REGS_GS_BASE, REGS_DS, REGS_ES, REGS_FS, REGS_GS
        *
3511             REGS_GS_BASE  = 22
3512             REGS_DS       = 23
3513             REGS_ES       = 24
3514             REGS_FS       = 25
3515             REGS_GS       = 26
        *
        * FP REGS. THESE ARE BYTE OFFSETS (user.h)
        *
        * FIXME: NOT PUBLISHED YET AS -PUBLIC, WAIT UNTIL TESTED!
        *
3516             FPREGS_CWD       = 0
3517             FPREGS_SWD       = 2
3518             FPREGS_FTW       = 4
3519             FPREGS_FOP       = 6
3520             FPREGS_RIP       = 8
3521             FPREGS_RDP       = 16
3522             FPREGS_MXCSR     = 24
3523             FPREGS_MXCR_MASK = 28
        * 8 * 16 BYTES FOR EACH FP-REG = 128 BYTES
3524             FPREGS_ST_SPACE  = 32
        * 16 * 16 BYTES FOR EACH XMM REG = 256 BYTES
3525             FPREGS_XMM_SPACE = FP_FPREGS_ST_SPACE + 128
        * PADDING = 96 BYTES
3526             FPREGS_PADDING   = FPREGS_XMM_SPACE + 256
        *
        * NEED REGISTER DEFINITIONS FOR 386, OTHER MACHINES AS APPROPRIATE.
        * RIGHT NOW, ALL OF MY WORK IS ON X86_64 PLATFORM, NOT ABLE TO TEST
        * OTHERS.
        *
        * LONG PTRACE(ENUM __PTRACE_REQUEST REQUEST, PID_T PID,
        *             VOID *ADDR, VOID *DATA)
        *
3527             FFI_PTRACE = FFI_NEW('L', 'I,I,P,P')
3528             FFI_SET_CALLP(FFI_PTRACE, DLSYM(0, 'ptrace'))
        *
        -PUBLIC PTRACE()
        *
3529             DEFINE('PTRACE(REQUEST,PID,ADDR,DATA)')
        *
        * NOTE: CSNOBOL4 CALLS OPENING AN ARBITRARY FD BUT DOESN'T ALLOW
        * USING A FILE*, EVEN THOUGH THE UNDERLYING I/O SYSTEM USING STREAM
        * IO. THIS IS OK, AS WE CAN RECOVER THE DATA AS A STRING ANYWAY.
        * FOR THIS REASON, WE DEFINE OPEN_MEMSTREAM BUT NOT FMEMOPEN.
        * WE ALSO DEFINE FCLOSE. NOTE THAT THE STREAM DOES NOT HAVE AN FD
        * ASSOCIATED. WHAT ABOUT io_mkfile(int, FILE*, char*) -- MATCH
        * WITH io_getfp(int)
        *
3530             FFI_OPEN_MEMSTREAM = FFI_NEW('P', 'P,P')
3531             FFI_SET_CALLP(FFI_OPEN_MEMSTREAM, DLSYM(0, 'open_memstream'))
        *
        -PUBLIC OPEN_MEMSTREAM()
        *
3532             DEFINE('OPEN_MEMSTREAM(PS,PL)')
        *
3533             FFI_FCLOSE = FFI_NEW('I', 'P')
3534             FFI_SET_CALLP(FFI_FCLOSE, DLSYM(0, 'fclose'))
        *
        -PUBLIC FCLOSE()
        *
3535             DEFINE('FCLOSE(F)')
        *
        * LINK TO DISASSEMBLER
        *
        -PUBLIC DISASSEMBLE_INFO_ENDIAN, BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE
        -PUBLIC BFD_ENDIAN_UNKNOWN, BFD_DISASSEMBLE_INFO_MACH, BFD_MACH_X86_64
        -PUBLIC BFD_MACH_I386_SYNTAX, DISASSEMBLE_INFO_BUFFER
        -PUBLIC DISASSEMBLE_INFO_BUFFER_LENGTH, INIT_DISASSEMBLE_INFO()
        -PUBLIC PRINT_INSN_I386()
        *
                 DISASSEMBLE_INFO_ENDIAN        = 40  ;* 4 BYTES
3537             BFD_ENDIAN_BIG                 = 0
3538             BFD_ENDIAN_LITTLE              = 1
3539             BFD_ENDIAN_UNKNOWN             = 2
                 DISASSEMBLE_INFO_MACH          = 32  ;* 8 BYTES
3541             BFD_MACH_X86_64                = 8
3542             BFD_MACH_I386_INTEL_SYNTAX     = 1
                 DISASSEMBLE_INFO_BUFFER        = 152 ;* 8 BYTES
                 DISASSEMBLE_INFO_BUFFER_VMA    = 160 ;* 8 BYTES
                 DISASSEMBLE_INFO_BUFFER_LENGTH = 168 ;* 4 BYTES
3546             H = DLOPEN('/usr/lib64/libopcodes-2.23.2.so', RTLD_NOW)
3547             FFI_INIT_DISASSEMBLE_INFO = FFI_NEW('V', 'P,P,P')
3548             FFI_SET_CALLP(FFI_INIT_DISASSEMBLE_INFO,
3548    +           DLSYM(H, 'init_disassemble_info'))
3549             DEFINE('INIT_DISASSEMBLE_INFO(DINFO,FILEP,FFUNC)')
3550             FFI_PRINT_INSN_I386 = FFI_NEW('I', 'P,P')
3551             FFI_SET_CALLP(FFI_PRINT_INSN_I386, DLSYM(H, 'print_insn_i386'))
3552             DEFINE('PRINT_INSN_I386(VMADDR,DINFO)')
        *
3553             DEFINE('DISASSEMBLE(ADDR)F,P,N,PTR,SIZ,DINFO,DIS,S,I,S2')
        *
3554             DEFINE('MBUG_ARG(S)')
3555             MBUG_REGS = MALLOC(256)
        * ORIG_RAX=15 - ORIGINAL RAX ON SYSCALL
3556             MBUG_RNAMES = #('R15=0,R14=1,R13=2,R12=3,RBP=4,RBX=5,R11=6,'
3556    +                        'R10=7,R9=8,R8=9,RAX=10,RCX=11,RDX=12,RSI=13,'
3556    +                        'RDI=14,RIP=16,EFLAGS=18,RSP=19')
3557             MBUG_R2 = KEYST(MBUG_RNAMES)                        :(MBUG_END)
        *
        * AN ARGUMENT IS A REGISTER, A SYMBOL NAME, OR A HEX VALUE. IF REGISTER,
        * THE VALUE OF THE REGISTER IS USED. THE ARGUMENT MAY BE EMPTY, IN
        * WHICH CASE THE LAST ARGUMENT IS USED. THE ARGUMENT MAY BE FOLLOWED
        * BY + OR - AND A HEX VALUE. FOR EXAMPLE:
        *
        * D STRINGS, +10
        *
        * WILL DUMP FROM SYMBOL STRINGS TO STRINGS+10 BYTES.  THE RETAINED
        * ARGUMENT IS RETAINED BETWEEN COMMANDS.
        *
3558    MBUG_ARG S = TRIMB(S)
3559             OP =
3560             R = 0
3561             S BRKREM('+-') . S REM . R
3562             R LEN(1) . OP REM . R
3563             LA = VDIFFER(S)
3564             S = IDENT(S) LA
3565             U = REPLACE(S, &LCASE, &UCASE)
3566             MBUG_ARG = PEEK_P(MBUG_REGS + 8 * VDIFFER(MBUG_RNAMES<U>))
3566    +                                                           :S(MBUG_AR2)
3567             MBUG_ARG = VDIFFER(SYMTAB<S>)                      :S(MBUG_AR2)
3568             MBUG_ARG = VDIFFER(SYMTAB<U>)                      :S(MBUG_AR2)
3569             MBUG_ARG = HI(S)                                      :(RETURN)
3570    MBUG_AR2 IDENT(OP)                                            :S(RETURN)
3571             R = HI(VDIFFER(R))
3572             MBUG_ARG = EVAL(MBUG_ARG ' ' OP ' ' R)                :(RETURN)
        *
3573    PTRACE   FFI_PAR_N_INTEGER(FFI_PTRACE, 1, REQUEST)
3574             FFI_PAR_N_INTEGER(FFI_PTRACE, 2, PID)
3575             FFI_PAR_N_PTR(FFI_PTRACE, 3, ADDR)
3576             FFI_PAR_N_PTR(FFI_PTRACE, 4, DATA)
3577             PTRACE = FFI_CALL_PTR(FFI_PTRACE)                     :(RETURN)
        *
3578    FCLOSE   FFI_PAR_N_PTR(FFI_FCLOSE, 1, F)
3579             FCLOSE = FFI_CALL_INTEGER(FFI_FCLOSE)                 :(RETURN)
        *
3580    OPEN_MEMSTREAM
3581             FFI_PAR_N_PTR(FFI_OPEN_MEMSTREAM, 1, PS)
3582             FFI_PAR_N_PTR(FFI_OPEN_MEMSTREAM, 2, PL)
3583             OPEN_MEMSTREAM = FFI_CALL_PTR(FFI_OPEN_MEMSTREAM)     :(RETURN)
        *
3584    INIT_DISASSEMBLE_INFO
3585             FFI_PAR_N_PTR(FFI_INIT_DISASSEMBLE_INFO, 1, DINFO)
3586             FFI_PAR_N_PTR(FFI_INIT_DISASSEMBLE_INFO, 2, FILEP)
3587             FFI_PAR_N_PTR(FFI_INIT_DISASSEMBLE_INFO, 3, FFUNC)
3588             FFI_CALL_VOID(FFI_INIT_DISASSEMBLE_INFO)              :(RETURN)
        *
3589    PRINT_INSN_I386
3590             FFI_PAR_N_PTR(FFI_PRINT_INSN_I386, 1, VMADDR)
3591             FFI_PAR_N_PTR(FFI_PRINT_INSN_I386, 2, DINFO)
3592             PRINT_INSN_I386 = FFI_CALL_INTEGER(FFI_PRINT_INSN_I386)
3592    +                                                              :(RETURN)
        *
3593    DISASSEMBLE
3594             S = LPAD(IH(ADDR), 16, '0') ': '
3595             DIS = MALLOC(16)
3596             DINFO = MALLOC(1024)
3597             PTR = MALLOC(16)
3598             SIZ = MALLOC(16)
3599             N = PTRACE(PTRACE_PEEKTEXT, PID, ADDR + 0, 0)
3600             POKE_P(DIS + 0, N)
3601             N = PTRACE(PTRACE_PEEKTEXT, PID, ADDR + 8, 0)
3602             POKE_P(DIS + 8, N)
3603             POKE_P(PTR, 0)
3604             POKE_P(SIZ, 0)
3605             F = OPEN_MEMSTREAM(PTR, SIZ)
3606             INIT_DISASSEMBLE_INFO(DINFO, F, DLSYM(0, 'fprintf'))
3607             POKE_P(DINFO + DISASSEMBLE_INFO_MACH, BFD_MACH_X86_64)
3608             POKE_I(DINFO + DISASSEMBLE_INFO_ENDIAN, BFD_ENDIAN_LITTLE)
3609             POKE_P(DINFO + DISASSEMBLE_INFO_BUFFER, DIS)
        *        POKE_P(DINFO + DISASSEMBLE_INFO_BUFFER_VMA, ADDR)
        *        POKE_P(DINFO + DISASSEMBLE_INFO_BUFFER_VMA, 0)
3610             POKE_I(DINFO + DISASSEMBLE_INFO_BUFFER_LENGTH, 16)
3611             INSTRUCTION_BYTES = PRINT_INSN_I386(0, DINFO)
3612             FCLOSE(F)
3613             P = PEEK_P(PTR)
3614             N = PEEK_I(SIZ)
        *        TERMINAL = 'INSTRUCTION BYTES: ' INSTRUCTION_BYTES
3615             I = 0
3616    DIS2     S2 = '  '
3617             S2 = LT(I, INSTRUCTION_BYTES) LPAD(IH(PEEK_C(DIS + I)), 2, '0')
3618             S = S S2 ' '
3619             I = I + 1
3620             LT(I, 4)                                               :S(DIS2)
3621             DISASSEMBLE = S PEEK_BUFFER(P, N)
3622    DIS4     GE(I, INSTRUCTION_BYTES)                               :S(DIS3)
3623             DISASSEMBLE = EQ(REMDR(I, 4))
3623    +           DISASSEMBLE CHAR(10) DUPL(' ', 18)
3624             S2 = LPAD(IH(PEEK_C(DIS + I)), 2, '0')
3625             DISASSEMBLE = DISASSEMBLE S2 ' '
3626             I = I + 1                                               :(DIS4)
3627    DIS3     FREE(DIS)
3628             FREE(DINFO)
3629             FREE(P)
3630             FREE(PTR)
3631             FREE(SIZ)                                             :(RETURN)
        *
        * MBUG ENTRY. THE 'MAIN' PROCESS NEVER RETURNS. MBUG FORK()S AND THE
        * NEW CHILD PROCESS RETURNS, BUT UNDER MBUG CONTROL.
        *
3632    MBUG     TERMINAL = 'MBUG (TUE JUL  8 21:08:00 EDT 2014)'
        *
        * CONVERT SRC TO ARRAY OF LINES. INDEX BY ADDRESS. THE ADDRESSES ARE
        * ABSOLUTE ADDRESSES. ON THE 'L' COMMAND AND ON BREAK, ISSUE SOURCE
        * IF POSSIBLE.
        *
3633             SRC = CRACK(SRC, CHARS_NL)
3634             SRCIDX = TABLE()
3635             I = 1
3636    MBUG5    S = SRC<I>                                            :F(MBUG6)
3637             S SPAN(' ') '0x' SPAN(&DIGITS 'abcdef') . IDX         :F(MBUG7)
3638             IDX = REPLACE(IDX, &LCASE, &UCASE)
3639             IDX = HI(IDX)
3640             SRCIDX<IDX> = I
3641    MBUG7    I = I + 1                                              :(MBUG5)
3642    MBUG6    B = 0
        *
        * TABLE OF BREAKPOINTS (SEE MBUG.B)
        *
3643             BREAKPOINTS = TABLE()
3644             BREAKA = ARRAY0
        *
        * MAP SIGNAL TO SIGNAL NAME
        *
3645             SIGNALS = TABLE(32)
3646             SIGNALS<SIGHUP>    = 'SIGHUP'
3647             SIGNALS<SIGINT>    = 'SIGINT'
3648             SIGNALS<SIGQUIT>   = 'SIGQUIT'
3649             SIGNALS<SIGILL>    = 'SIGILL'
3650             SIGNALS<SIGTRAP>   = 'SIGTRAP'
3651             SIGNALS<SIGABRT>   = 'SIGABRT'
3652             SIGNALS<SIGBUS>    = 'SIGBUS'
3653             SIGNALS<SIGFPE>    = 'SIGFPE'
3654             SIGNALS<SIGKILL>   = 'SIGKILL'
3655             SIGNALS<SIGUSR1>   = 'SIGUSR1'
3656             SIGNALS<SIGSEGV>   = 'SIGSEGV'
3657             SIGNALS<SIGUSR2>   = 'SIGUSR2'
3658             SIGNALS<SIGPIPE>   = 'SIGPIPE'
3659             SIGNALS<SIGALRM>   = 'SIGALRM'
3660             SIGNALS<SIGTERM>   = 'SIGTERM'
3661             SIGNALS<SIGSTKFLT> = 'SIGSTKFLT'
3662             SIGNALS<SIGCHLD>   = 'SIGCHLD'
3663             SIGNALS<SIGCONT>   = 'SIGCONT'
3664             SIGNALS<SIGSTOP>   = 'SIGSTOP'
3665             SIGNALS<SIGTSTP>   = 'SIGTSTP'
3666             SIGNALS<SIGTTIN>   = 'SIGTTIN'
3667             SIGNALS<SIGTTOU>   = 'SIGTTOU'
3668             SIGNALS<SIGURG>    = 'SIGURG'
3669             SIGNALS<SIGXCPU>   = 'SIGXCPU'
3670             SIGNALS<SIGXFSZ>   = 'SIGXFSZ'
3671             SIGNALS<SIGVTALRM> = 'SIGVTALRM'
3672             SIGNALS<SIGPROF>   = 'SIGPROF'
3673             SIGNALS<SIGWINCH>  = 'SIGWINCH'
3674             SIGNALS<SIGIO>     = 'SIGIO'
3675             SIGNALS<SIGPWR>    = 'SIGPWR'
3676             SIGNALS<SIGSYS>    = 'SIGSYS'
        *
        * TABLE OF ORIGINAL CODE BYTES (SEE MBUG.B, MBUG.G)
        *
3677             ORIGINAL = TABLE()
        *
3678             PID = FORK()
3679             LT(PID)                                               :F(MBUG2)
3680             PERROR('FORK')                                           :(END)
3681    MBUG2    EQ(PID)                                               :S(MBUG3)
        *
        * 'MAIN' PROCESS. ESTABLISH COMMAND HISTORY. FIXME: THINGS LIKE
        * BREAKPOINT AND ORIGINAL CAN BE COMPLETELY MOVED HERE, BECAUSE THEY
        * SHOULD NEVER BE NEEDED IN THE CHILD.
        *
3682             RLAPPNAME('MBUG')
3683             READ_HISTORY('.MBUG')
3684             STIFLE_HISTORY(50)
        *
        * WAIT FOR SIGSTOP FIRST (19), SINGLE STEP (5), NORMAL EXIT (0).
        *
3685    MBUG_TOP WAITPID(-1, 0)
3686             STATUS = GET_STATUS()
3687             EC = STATUS / 256
3688             P = 'MBUG EXITED (Q TO QUIT): '
3689             EQ(EC)                                             :S(MBUG_CMD)
3690             MS_DIS = MALLOC(16)
        *
3691             EQ(EC, SIGTRAP)                                     :S(MBUG_RB)
3692             TERMINAL = 'EC: ' EC ' ' SIGNALS<EC>
        *
        * REMOVE BREAKPOINTS, REWIND RIP BY ONE BYTE (INT3 IS A ONE BYTE
        * INSTRUCTION).
        *
3693    MBUG_RB  IDENT(BRKSET)                                       :S(MBUG_PR)
3694             I = 1
3695    MBUG_NB  BREAKA<I>                                           :F(MBUG_PR)
3696             V2 = PTRACE(PTRACE_PEEKDATA, PID, BREAKA<I>, 0)
3697             M = HI('FFFFFFFFFFFFFF00')
3698             V2 = AND(V2, M)
3699             V2 = OR(V2, ORIGINAL<BREAKA<I>>)
3700             N = PTRACE(PTRACE_POKEDATA, PID, BREAKA<I>, V2)
3701             I = I + 1                                            :(MBUG_NB)
        *
3702    MBUG_PR  PTRACE(PTRACE_GETREGS, PID, 0, MBUG_REGS)
3703             RIP = PEEK_P(MBUG_REGS + 8 * MBUG_RNAMES<'RIP'>)
        *
        * IF EC IS 5 AND BRKSET, WE HIT A BREAKPOINT (5 COULD ALSO BE SINGLE
        * STEP, BUT WE DON'T SET BREAKPOINTS IN THAT CASE). BACK UP RIP BY
        * ONE BYTE.
        *
3704             (EQ(EC, SIGTRAP) DIFFER(BRKSET))                    :F(MBUG_P2)
3705             RIP = RIP - 1
3706             POKE_P(MBUG_REGS + 8 * MBUG_RNAMES<'RIP'>, RIP)
3707             PTRACE(PTRACE_SETREGS, PID, 0, MBUG_REGS)
        *
        * PROMPT CONTAINS RIP (INSTRUCTION POINTER). FIXME: SHOULD MOVE TO
        * MBUG_CMD, IN CASE X RIP COMMAND IS USED TO EDIT THE RIP.
        *
3708    MBUG_P2  BRKSET =
3709             P = 'MBUG ' IH(RIP) ': '
3710             L = SRCIDX<RIP>                                    :F(MBUG_INS)
3711             TERMINAL = SRC<L>                                  :S(MBUG_CMD)
        *
3712    MBUG_INS S = DISASSEMBLE(RIP)
3713             TERMINAL = S
        *
3714    MBUG_CMD MBUG_IN = TRIM(HISTORY_EXPAND(READLINE(P)))             :F(END)
3715             IDENT(MBUG_IN)                                     :S(MBUG_CMD)
3716             ADD_HISTORY(MBUG_IN)
        *
        * FIXME: ADD U (UNASSEMBLE) COMMAND - LIST N INSTRUCTIONS, UPDATE
        *        SAME AS L
3717             CMD = FENCE NSPAN(' ' CHARS_TAB)
3717    +              ANY('TtDdBbXxLlSsGgEeQqYyRrKkHhUu=?') . C
3717    +              NSPAN(' ' CHARS_TAB) REM . ARGS
3718             MBUG_IN CMD                                        :F(MBUG_BAD)
3719             ARGS = TRIM(ARGS)
3720             C = REPLACE(C, '?=', 'HE')                      :($('MBUG.' C))
3721    MBUG_BAD TERMINAL = 'BAD COMAND, TRY H FOR HELP'             :(MBUG_CMD)
        *
        * DUMP SYMBOL TABLE. ARGS IS A PATTERN TO APPLY. FIXME: SHOULD
        * EVAL() TO BUILD THE PATTERN -- AS IT IS THE PATTERN IS TAKEN AS
        * A SIMPLE STRING.
        *
3722    MBUG.Y   A = KEYST(SYMTAB)                                  :F(MBUG_CMD)
3723             A = SORT(A)
3724             I = 1
3725    MBUG.Y2  A<I>                                               :F(MBUG_CMD)
3726             TERMINAL = (A<I> ? ARGS)
3726    +           LPAD(IH(SYMTAB<A<I>>), 16, '0') ' ' A<I>
3727             I = I + 1                                            :(MBUG.Y2)
        *
        * DISPLAY MEMORY
        *
3728    MBUG.D   IDENT(ARGS)                                         :S(MBUG.D5)
3729             ARGS BRKREM(',') . A1 =
3730             ARGS FENCE ',' =
3731             B = MBUG_ARG(A1)
3732             IDENT(ARGS)                                         :S(MBUG.D5)
3733             E = MBUG_ARG(ARGS)
3734             GT(E, B)                                            :S(MBUG.D4)
3735    MBUG.D5  E = B + 256
        *
3736    MBUG.D4  A = LPAD(IH(B), 16, '0') ': '
3737             H =
3738             S =
3739    MBUG.D2  V = AND(PTRACE(PTRACE_PEEKDATA, PID, B, 0), 255)
3740             S = S (LT(V, 32) '.', GT(V, 126) '.', CHAR(V))
3741             V = LPAD(IH(V), 2, '0')
3742             H = H V
3743             H = NE(AND(B, 1)) H ' '
3744             B = B + 1
3745             GE(B, E)                                            :S(MBUG.D3)
3746             EQ(AND(B, 15))                                      :F(MBUG.D2)
3747             TERMINAL = A LPAD(H, 40, ' ') S                      :(MBUG.D4)
3748    MBUG.D3  TERMINAL = A RPAD(H, 40, ' ') S
3749             B = E                                               :(MBUG_CMD)
        *
3750    MBUG.B   CT = 'SET'
3751    MBUG.B2  IDENT(ARGS)                                         :S(MBUG.B4)
3752             ARGS BRKREM(',') . A =
3753             ARGS FENCE ',' =
3754             A = TRIMB(A)
3755             IDENT(A)                                            :S(MBUG.B2)
3756             A2 = MBUG_ARG(A)
3757             IDENT(CT, 'SET')                                    :F(MBUG.B3)
3758             DIFFER(BREAKPOINTS<A2>)                             :S(MBUG.B2)
3759             BREAKPOINTS<A2> = A                                  :(MBUG.B2)
3760    MBUG.B3  IDENT(BREAKPOINTS<A2>)                              :S(MBUG.B2)
3761             BREAKPOINTS<A2> =                                    :(MBUG.B2)
3762    MBUG.B4  BREAKA = (KEYST(BREAKPOINTS), ARRAY0)               :(MBUG_CMD)
        *
3763    MBUG.R   I = 1
3764    MBUG.R2  BREAKA<I>                                          :F(MBUG_CMD)
3765             TERMINAL = LPAD(IH(BREAKA<I>), 16, '0')
3765    +           ' (' BREAKPOINTS<BREAKA<I>> ')'
3766             I = I + 1                                            :(MBUG.R2)
        *
3767    MBUG.K   CT = 'CLEAR'                                         :(MBUG.B2)
        *
3768    MBUG.U   UA = MBUG_ARG(VDIFFER(ARGS))                        :F(MBUG.U3)
3769             UA = IDENT(UA) RIP
3770             TERMINAL = '(' ARGS '):'
3771    MBUG.U3  N = 12
3772    MBUG.U2  TERMINAL = DISASSEMBLE(UA)
3773             UA = UA + INSTRUCTION_BYTES
3774             N = N - 1
3775             GT(N)                                    :S(MBUG.U2)F(MBUG_CMD)
        *
3776    MBUG.L   A = MBUG_ARG(VDIFFER(ARGS))                         :F(MBUG.L3)
3777             L = SRCIDX<A>                                      :F(MBUG_CMD)
3778             TERMINAL = LPAD(IH(A), 16, '0') ' (' ARGS '):'
3779    MBUG.L3  N = 12
3780    MBUG.L2  TERMINAL = SRC<L>                                  :F(MBUG_CMD)
3781             L = L + 1
3782             N = N - 1
3783             GT(N)                                    :S(MBUG.L2)F(MBUG_CMD)
        *
        * TYPES FOR EDITING - HEX/INTEGER/REAL, WIDTH, MASKS.
        * HAVE HEX COVERED, NEED INTEGER, REAL, POSSIBLY STRING.
        *
3784    MBUG.S   ARGS BRKREM(',') . ARGS REM . OPTS
3785             OPTS FENCE ',' =
3786             OPTS = REPLACE(TRIMB(OPTS), &LCASE, &UCASE)
3787             TYPEM = TABLE()
3788             TYPEM<''>        = 'BYTE'
3789             TYPEM<'BYTE'>    = 'BYTE'
3790             TYPEM<'WORD'>    = 'WORD'
3791             TYPEM<'DWORD'>   = 'DWORD'
3792             TYPEM<'QWORD'>   = 'QWORD'
3793             TYPEM<'B'>       = 'BYTE'
3794             TYPEM<'W'>       = 'WORD'
3795             TYPEM<'D'>       = 'DWORD'
3796             TYPEM<'Q'>       = 'QWORD'
3797             TYPEM<'I'>       = 'INTEGER'
        *
        * THREE PHASES TO THE EDIT: FETCH DATA, EDIT, PUT DATA.
        * FETCH DATA - GET 8 BYTES FROM MEMORY. 'AND' WITH MASKS
        * NOW, WE NEED TO CONVERT TO INTEGER/REAL IF NEEDED. IN THE
        * EDIT ROUTINE, WE POKE INTO MEMORY, PEEK FROM MEMORY, AND EDIT
        * ON STORE, WE NEED TO DO THE SAME -- NOT ACCURATE. THIS MUST DEAL
        * WITH ENDIAN DIFFERENCES. AFTER MASKING, WE STILL NEED ENDIAN
        * CORRECTION. FOR OUR IMMEDIATE NEEDS -- WE ARE OK. VALUE AFTER
        * MASKING IS UNSIGNED INTEGER VALUE. SIGNED IF QWORD. WE SIMPLY
        * NEED TO SIGN EXTEND THE VALUE.
        *
3798             EDITT = TABLE()
3799             EDITT<'BYTE'>    = 'HEX'
3800             EDITT<'WORD'>    = 'HEX'
3801             EDITT<'DWORD'>   = 'HEX'
3802             EDITT<'QWORD'>   = 'HEX'
3803             EDITT<'INTEGER'> = 'INTEGER'
3804             OPTS = TYPEM<OPTS>
3805             IDENT(MASKS<OPTS>)                                 :S(MBUG_BAD)
3806             SA = MBUG_ARG(VDIFFER(ARGS))
3807             MASKS = TABLE()
3808             MASKC = TABLE()
3809             SIZET = TABLE()
3810             MASKS<'BYTE'>    = HI('00000000000000FF')
3811             MASKC<'BYTE'>    = HI('FFFFFFFFFFFFFF00')
3812             SIZET<'BYTE'>    = 1
3813             MASKS<'WORD'>    = HI('000000000000FFFF')
3814             MASKC<'WORD'>    = HI('FFFFFFFFFFFF0000')
3815             SIZET<'WORD'>    = 2
3816             MASKS<'DWORD'>   = HI('00000000FFFFFFFF')
3817             MASKS<'INTEGER'> = HI('00000000FFFFFFFF')
3818             MASKC<'DWORD'>   = HI('FFFFFFFF00000000')
3819             MASKC<'INTEGER'> = HI('FFFFFFFF00000000')
3820             SIZET<'DWORD'>   = 4
3821             SIZET<'INTEGER'> = 4
3822             MASKS<'QWORD'>   = HI('FFFFFFFFFFFFFFFF')
3823             MASKC<'QWORD'>   = HI('0000000000000000')
3824             SIZET<'QWORD'>   = 8
3825    MBUG.S2  V = AND(PTRACE(PTRACE_PEEKDATA, PID, SA, 0), MASKS<OPTS>)
        *
3826             V = IDENT(EDITT<OPTS>, 'HEX') LPAD(IH(V), SIZET<OPTS> * 2, '0')
        *
3827             V = EDITLINE(LPAD(IH(SA), 16, '0') ': ', V)
3828             V = TRIMB(V)
3829             IDENT(V)                                           :S(MBUG_CMD)
3830             V ANY('/')                                         :S(MBUG_CMD)
        *
3831             V = IDENT(EDITT<OPTS>, 'HEX') HI(V)
        *
3832             V = AND(V, MASKS<OPTS>)
3833             V2 = PTRACE(PTRACE_PEEKDATA, PID, SA, 0)
        *        M = HI('FFFFFFFFFFFFFF00')
3834             V2 = AND(V2, MASKC<OPTS>)
3835             V2 = OR(V2, V)
3836             N = PTRACE(PTRACE_POKEDATA, PID, SA, V2)
3837             SA = SA + SIZET<OPTS>                                :(MBUG.S2)
        *
        * G, EXECUTE
        *
        * ESTABLISH BREAKPOINTS - SAVE ORIGINAL VALUES, PUT IN INT3 CODES
        *
3838    MBUG.G   I = 1
3839             BRKSET = 1
3840    MBUG.G3  BREAKA<I>                                           :F(MBUG.G2)
3841             V = AND(PTRACE(PTRACE_PEEKTEXT, PID, BREAKA<I>, 0), 255)
3842             ORIGINAL<BREAKA<I>> = V
3843             V2 = PTRACE(PTRACE_PEEKTEXT, PID, BREAKA<I>, 0)
3844             M = HI('FFFFFFFFFFFFFF00')
3845             V2 = AND(V2, M)
3846             V2 = OR(V2, INT3)
3847             N = PTRACE(PTRACE_POKETEXT, PID, BREAKA<I>, V2)
3848             I = I + 1                                            :(MBUG.G3)
3849    MBUG.G2  PTRACE(PTRACE_CONT, PID, 0, 0)                      :(MBUG_TOP)
        *
3850    MBUG.E   TERMINAL = ARGS ' = ' EVAL(ARGS)                    :(MBUG_CMD)
        *
3851    MBUG.Q   WRITE_HISTORY('.MBUG')
3852             KILL(PID, SIGKILL)                                       :(END)
        *
3853    MBUG.X   DIFFER(ARGS)                                        :S(MBUG.X2)
        *
        * X ALONE DISPLAYS ALL REGISTERS. WE DON'T DO FLOATING POINT REGISTERS
        * YET.
        *
3854             I = 1
3855             S =
3856             TWIDTH = 72
3857    MBUG.X3  R = MBUG_R2<I>
3858             N = PEEK_P(MBUG_REGS + 8 * MBUG_RNAMES<R>)
3859             N = R '=' IH(N)
3860             X = SIZE(S) + SIZE(N) + 2
3861             TERMINAL = GE(X, TWIDTH) S
3862             S = GE(X, TWIDTH)
3863             S = VDIFFER(S) ', '
3864             S = S N
3865             I = I + 1
3866             MBUG_R2<I>                                          :S(MBUG.X3)
3867             TERMINAL = VDIFFER(S)                               :(MBUG_CMD)
        *
        * X REG DISPLAYS SPECIFIC REGISTER, ALLOWS EDIT OF REGISTER VALUE.
        *
3868    MBUG.X2  ARGS = REPLACE(TRIMB(ARGS), &LCASE, &UCASE)
3869             IDENT(MBUG_RNAMES<ARGS>)                           :S(MBUG_CMD)
3870             N = PEEK_P(MBUG_REGS + 8 * MBUG_RNAMES<ARGS>)
3871             N = IH(N)
3872             N = EDITLINE(ARGS ': ', N)
3873             N = HI(N)
3874             POKE_P(MBUG_REGS + 8 * MBUG_RNAMES<ARGS>, N)
3875             N = PTRACE(PTRACE_SETREGS, PID, 0, MBUG_REGS)       :(MBUG_CMD)
        *
        * HELP FOR MBUG
        *
3876    MBUG.H   TERMINAL = 'MBUG COMMANDS:'
3877             TERMINAL = 'T           TRACE, SINGLE STEP'
3878             TERMINAL = 'X [REG]     EXAMINE/CHANGE REGISTERS'
3879             TERMINAL = 'G           GO'
3880             TERMINAL = 'E EXPR      EVALUATE EXPRESSION'
3881             TERMINAL = 'Q           QUIT MBUG - EXIT TO SYSTEM'
3882             TERMINAL = 'H           HELP'
3883             TERMINAL = 'D B,E       DISPLAY MEMORY'
3884             TERMINAL = 'B ADDR      SET BREAKPOINT'
3885             TERMINAL = 'K ADDR      REMOVE BREAKPOINT'
3886             TERMINAL = 'R           REPORT BREAKPOINTS'
3887             TERMINAL = 'L ADDR      LIST CODE'
3888             TERMINAL = 'S ADDR[,T]  SET/EXAMINE MEMORY'
3889             TERMINAL = 'H           HELP'
3890             TERMINAL = 'Y PAT       SYMBOLS, MATCHING PAT'
3891             TERMINAL = 'U ADDR      UNASSEMBLE'
3892                                                                 :(MBUG_CMD)
        *
3893    MBUG.T   PTRACE(PTRACE_SINGLESTEP, PID, 0, 0)                :(MBUG_TOP)
        *
        * IN CHILD. WE CALL PTRACE() TO BECOME A CALLEE. PTRACE_TRACEME
        * WON'T CAUSE THE CHILD TO STOP. THIS IS WHY WE IMMEDIATELY FOLLOW
        * UP WITH RAISE(SIGSTOP). THE WAITPID() IN MBUG WILL NOW RETURN,
        * WITH THE CHILD TRACED.
        *
3894    MBUG3    PTRACE(PTRACE_TRACEME, 0, 0, 0)
3895             RAISE(SIGSTOP)
        *
        * AFTER RETURN, ENTER FFI BASED OR LOAD() CODE IMMEDIATELY. ALL CODE
        * AFTER THE RAISE(SIGSTOP) IS RUN UNDER THE CONTROL OF MBUG.
        *
3896                                                                   :(RETURN)
        *
        * CE: .MSNOBOL4;
        *
3897    MBUG_END
        -INCLUDE 'MD5.INC'
        -MODULE MD5
        -LINE 11 "MD5.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'MKTEMP.INC'
        -MODULE MKTEMP
        -LINE 10 "MKTEMP.lss"
        -INCLUDE 'BQ.INC'
        -IN72
        -LINE 39 "MKTEMP.lss"
        -STITL MKTEMP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         #     #  #    #  #######  #######  #     #  ######           *
        *         ##   ##  #   #      #     #        ##   ##  #     #          *
        *         # # # #  #  #       #     #        # # # #  #     #          *
        *         #  #  #  ###        #     #####    #  #  #  ######           *
        *         #     #  #  #       #     #        #     #  #                *
        *         #     #  #   #      #     #        #     #  #                *
        *         #     #  #    #     #     #######  #     #  #                *
        *                                                                      *
        * MKTEMP               CREATE TEMPORARY FILE                           *
        *                                                                      *
        ************************************************************************
        *
        * MKTEMP.lss
        *
        -LINE 14 "MKTEMP.lss"
        -PUBLIC MKTEMP()
        *
3898             DEFINE('MKTEMP()')                                :(MKTEMP_END)
        *
3899    MKTEMP   MKTEMP = BQ('mktemp')                                 :(RETURN)
3900
3901    MKTEMP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'WRTFILE.INC'
        -IN72
        -LINE 46 "MD5.lss"
        -STITL MD5
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                       #     #  ######   #####                        *
        *                       ##   ##  #     #  #                            *
        *                       # # # #  #     #  #                            *
        *                       #  #  #  #     #  #####                        *
        *                       #     #  #     #      #                        *
        *                       #     #  #     #      #                        *
        *                       #     #  ######   #####                        *
        *                                                                      *
        * MD5                           MD5 HASH                               *
        *                                                                      *
        ************************************************************************
        *
        * MD5.lss
        *
        -LINE 18 "MD5.lss"
        -PUBLIC MD5()
        *
3902             DEFINE('MD5(S)T')                                    :(MD5_END)
        *
3903    MD5      T = MKTEMP()
3904             WRITEFILE(T, S)
3905             MD5 = BQ('md5sum ' T)
3906             MD5 BREAK(' ') . MD5
3907             DELETE(T)                                             :(RETURN)
        *
3908    MD5_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MDY.INC'
        -MODULE MDY
        -LINE 10 "MDY.lss"
        -IN72
        -LINE 48 "MDY.lss"
        -STITL MDY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                      #     #  ######   #     #                       *
        *                      ##   ##  #     #   #   #                        *
        *                      # # # #  #     #    # #                         *
        *                      #  #  #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  #     #     #                          *
        *                      #     #  ######      #                          *
        *                                                                      *
        * MDY                       M/D/Y FROM Y/D                             *
        *                                                                      *
        ************************************************************************
        *
        * MDY.lss
        *
        -LINE 13 "MDY.lss"
        -PUBLIC MDY()
        *
3909             DEFINE('MDY(Y,DY)X,T')
3910             DAY_MONTH = '(334,12)(304,11)(273,10)(243,9)'
3910    +           '(212,8)(181,7)(151,6)(120,5)(90,4)(59,3)(31,2)(0,1)'
3911             LY_DAY_MONTH = '(335,12)(305,11)(274,10)(244,9)'
3911    +           '(213,8)(182,7)(152,6)(121,5)(91,4)(60,3)(31,2)(0,1)'
3912             I = SPAN('0123456789')
3913             SEARCH.X.M = '(' I $ X *GT(DY, X) ',' I $ M          :(MDY_END)
        *
3914    MDY      T = EQ(REMDR(Y, 400), 0) LY_DAY_MONTH                 :S(MDY_1)
3915             T = EQ(REMDR(Y, 100), 0) DAY_MONTH                    :S(MDY_1)
3916             T = EQ(REMDR(Y,   4), 0) LY_DAY_MONTH                 :S(MDY_1)
3917             T = DAY_MONTH
3918    MDY_1    T SEARCH.X.M                                        :F(FRETURN)
3919             D = DY - X
3920             GT(D, 31)                                           :S(FRETURN)
3921             MDY = M '/' D '/' Y                                   :(RETURN)
        *
3922    MDY_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'MERGET.INC'
        -INCLUDE 'MKTEMP.INC'
        -INCLUDE 'NDBM.INC'
        -INCLUDE 'NOTIFY.INC'
        -MODULE NOTIFY
        -INCLUDE 'HOST.INC'
        -INCLUDE 'DDT.INC'
        -IN72
        -STITL NOTIFY
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *           #     #  #######  #######  ###  #######  #     #           *
        *           ##    #  #     #     #      #   #         #   #            *
        *           # #   #  #     #     #      #   #          # #             *
        *           #  #  #  #     #     #      #   #####       #              *
        *           #   # #  #     #     #      #   #           #              *
        *           #    ##  #     #     #      #   #           #              *
        *           #     #  #######     #     ###  #           #              *
        *                                                                      *
        * NOTIFY                    NOTIFY USER                                *
        *                                                                      *
        ************************************************************************
        *
        * NOTIFICATION FROM A PROCESS. JUST A WRAPPER FOR notify-send. COULD USE
        * DBUS DIRECTLY. TIMEOUT IS IN MILLISECONDS. URGENCY IS LOW, NORMAL,
        * CRITICAL. BODY CAN HAVE <I>, </B>, <U>, <IMG>, <A HREF>
        *
3923             DEFINE('NOTIFY(SUMMARY,BODY,URGENCY,TIMEOUT)')    :(NOTIFY_END)
        *
3924    NOTIFY
3925             HOST(HOST_GETENV, 'DBUS_SESSION_BUS_ADDRESS')        :F(RETURN)
3926             URGENCY = ' -u ' VDIFFER(URGENCY)
3927             TIMEOUT = ' -t ' VDIFFER(TIMEOUT)
3928             SUMMARY = ' "' SUMMARY '"'
3929             BODY = ' "' BODY '"'
3930             NOTIFY = '/usr/bin/notify-send' URGENCY TIMEOUT SUMMARY BODY
3931             HOST(HOST_SYSCMD, NOTIFY)                             :(RETURN)
        *
3932    NOTIFY_END
        *
        * CE: .MSNOBOL4;
3933
        -INCLUDE 'NOTP.INC'
        -MODULE NOTP
        -LINE 11 "NOTP.lss"
        -INCLUDE 'STACK.INC'
        -LINE 11 "STACK.lss"
        -INCLUDE 'REPL.INC'
        -STITL STACK
        -EJECT
        -LINE 52 "STACK.lss"
        *
        ************************************************************************
        *                                                                      *
        *               #####   #######     #      #####   #    #              *
        *              #     #     #       # #    #     #  #   #               *
        *              #           #      #   #   #        #  #                *
        *               #####      #     #     #  #        ###                 *
        *                    #     #     #######  #        #  #                *
        *              #     #     #     #     #  #     #  #   #               *
        *               #####      #     #     #   #####   #    #              *
        *                                                                      *
        * STACK                     CREATE STACK                               *
        *                                                                      *
        ************************************************************************
        *
        * STACK.lss
        *
        -LINE 15 "STACK.lss"
        -MODULE STACK
        -PUBLIC STACK()
3934             DEFINE('STACK(SUF)S')
3935             STACK()
        -PUBLIC PUSH(), POP(), TOP()
3936             OPSYN('PUSH', 'PUSH_')
3937             OPSYN('POP',  'POP_')
3938             OPSYN('TOP',  'TOP_')                              :(STACK_END)
        *
3939    STACK    S = 'PUSH_SUF STACK_SUF = LINK(V, STACK_SUF)         ;'
3939    +            '         PUSH_SUF = .VALUE(STACK_SUF) :(NRETURN);'
3939    +            'POP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
3939    +            '         POP_SUF = VALUE(STACK_SUF)             ;'
3939    +            '         STACK_SUF = NEXT(STACK_SUF)   :(RETURN);'
3939    +            'TOP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
3939    +            '         TOP_SUF = .VALUE(STACK_SUF)  :(NRETURN);'
3940             CODE(REPL(S, 'SUF', SUF))
3941             DEFINE('PUSH_' SUF '(V)')
3942             DEFINE('POP_'  SUF '()' )
3943             DEFINE('TOP_'  SUF '()' )                             :(RETURN)
        *
3944    STACK_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 46 "NOTP.lss"
        -STITL NOTP
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                   #     #  #######  #######  ######                  *
        *                   ##    #  #     #     #     #     #                 *
        *                   # #   #  #     #     #     #     #                 *
        *                   #  #  #  #     #     #     ######                  *
        *                   #   # #  #     #     #     #                       *
        *                   #    ##  #     #     #     #                       *
        *                   #     #  #######     #     #                       *
        *                                                                      *
        * NOTP                       INVERT PATTERN                            *
        *                                                                      *
        ************************************************************************
        *
        * NOTP.lss
        *
        -LINE 15 "NOTP.lss"
        -PUBLIC NOTP()
        *
3945             DEFINE('NOTP(P)')                                   :(NOTP_END)
        *
        -LINE 27 "NOTP.lss"
3946    NOTP     NOTP = PUSH() P *?(POP() PUSH(1)) FAIL |
3946    +               *IDENT(POP())                                  :(RETURN)
        *
3947    NOTP_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'NSPAN.INC'
        -INCLUDE 'ONCE.INC'
        -MODULE ONCE
        -LINE 13 "ONCE.lss"
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 43 "ONCE.lss"
        -STITL ONCE
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  #######  #     #   #####   #######                  *
        *                  #     #  ##    #  #     #  #                        *
        *                  #     #  # #   #  #        #                        *
        *                  #     #  #  #  #  #        #####                    *
        *                  #     #  #   # #  #        #                        *
        *                  #     #  #    ##  #     #  #                        *
        *                  #######  #     #   #####   #######                  *
        *                                                                      *
        * ONCE                                                                 *
        *                                                                      *
        ************************************************************************
        *
        * ONCE.lss
        *
        -LINE 17 "ONCE.lss"
        -PUBLIC ONCE()
        *
3948             DEFINE('ONCE(ID)NAME')                              :(ONCE_END)
3949    ONCE     ONCE = IDENT(ID, NULL)
3949    +               CONVERT('ONCE(' 1 ')', 'EXPRESSION')          :S(RETURN)
3950             NAME = UNIQUE()
3951             ONCE = $NAME
3952             $NAME = FAIL                                          :(RETURN)
        *
3953    ONCE_END
        *
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ORDER.INC'
        -MODULE ORDER
        -LINE 9 "ORDER.lss"
        -IN72
        -LINE 37 "ORDER.lss"
        -STITL ORDER
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                #######  ######   ######   #######  ######            *
        *                #     #  #     #  #     #  #        #     #           *
        *                #     #  #     #  #     #  #        #     #           *
        *                #     #  ######   #     #  #####    ######            *
        *                #     #  #   #    #     #  #        #   #             *
        *                #     #  #    #   #     #  #        #    #            *
        *                #######  #     #  ######   #######  #     #           *
        *                                                                      *
        * ORDER                   ORDER CHARACTERS IN STRING                   *
        *                                                                      *
        ************************************************************************
        *
        * ORDER.lss
        *
        -LINE 12 "ORDER.lss"
        -PUBLIC ORDER()
        *
3954             DEFINE('ORDER(S)T,HIGHS,S1')                       :(ORDER_END)
        *
3955    ORDER    S LEN(1) . T =                                       :F(RETURN)
3956             &ALPHABET BREAK(T) REM . HIGHS
3957             ORDER (BREAK(HIGHS) | REM) . S1 = S1 T                 :(ORDER)
        *
3958    ORDER_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'P64.INC'
        -INCLUDE 'PRUNET.INC'
        -MODULE PRUNET
        -LINE 14 "PRUNET.lss"
        -INCLUDE 'KEYST.INC'
        -INCLUDE 'SEQ.INC'
        -IN72
        -LINE 43 "PRUNET.lss"
        -STITL PRUNET
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######   ######   #     #  #     #  #######  #######         *
        *         #     #  #     #  #     #  ##    #  #           #            *
        *         #     #  #     #  #     #  # #   #  #           #            *
        *         ######   ######   #     #  #  #  #  #####       #            *
        *         #        #   #    #     #  #   # #  #           #            *
        *         #        #    #   #     #  #    ##  #           #            *
        *         #        #     #   #####   #     #  #######     #            *
        *                                                                      *
        * PRUNET                       PRUNE TABLE                             *
        *                                                                      *
        ************************************************************************
        *
        * PRUNET.lss
        *
        -LINE 19 "PRUNET.lss"
        -PUBLIC PRUNET()
        *
3959             DEFINE('PRUNET(T)A,I')                            :(PRUNET_END)
        *
3960    PRUNET   PRUNET = TABLE()
3961             A = KEYST(T)                                         :F(RETURN)
3962             SEQ(' PRUNET<A<I>> = VDIFFER(T<A<I>>)', .I)           :(RETURN)
        *
3963    PRUNET_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'PSQL.INC'
        -MODULE PSQL
        -LINE 71 "PSQL.lss"
        -INCLUDE 'BQ.INC'
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'COUNT.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'SCOOP.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'TIMER.INC'
        -INCLUDE 'UNIQUE.INC'
        -LINE 396 "PSQL.lss"
        -IN72
        -STITL PSQL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                  ######    #####    #####   #                        *
        *                  #     #  #     #  #     #  #                        *
        *                  #     #  #        #     #  #                        *
        *                  ######    #####   #     #  #                        *
        *                  #              #  #   # #  #                        *
        *                  #        #     #  #    #   #                        *
        *                  #         #####    #### #  #######                  *
        *                                                                      *
        * PSQL                 INTERFACE TO POSTGRESQL                         *
        *                                                                      *
        ************************************************************************
        *
        * PSQL.lss
        *
        -LINE 120 "PSQL.lss"
        *
        * THESE THREE ARE FUNCTIONS -- SIMPLY EASIER THAT WAY.
        *
        -PUBLIC PSQL_INSERT(), PSQL_RESULT(), PSQL_ESCAPE()
        *
3964             DEFINE('PSQL_INSERT(T)N,V,I')
3965             DEFINE('PSQL_RESULT(S)I,N,R,T,KEY,DAT')
3966             DEFINE('PSQL_ESCAPE(S)')
        *
        * CREATE CLASS PSQL_CLASS AND POPULATE ITS METHODS
        *
        -PUBLIC CLASS:PSQL_CLASS
        *
3967             PSQL_CLASS = SEND(CLASS, 'NEW_CLASS', 'PSQL_CLASS')
3968             DEFINE('PSQL_OPEN()L')
        *
        -PUBLIC PSQL_CLASS:'OPEN'
        *
3969             SEND(PSQL_CLASS, 'ADD_METHOD', 'OPEN', 'PSQL_OPEN')
3970             DEFINE('PSQL_CLOSE()PID')
        *
        -PUBLIC PSQL_CLASS:'CLOSE'
        *
3971             SEND(PSQL_CLASS, 'ADD_METHOD', 'CLOSE', 'PSQL_CLOSE')
        *
        -PUBLIC PSQL_CLASS:'GET_PIPE'
        *
3972             SEND(PSQL_CLASS, 'ADD_METHOD', 'GET_PIPE', CODE(
3972    +           ' SEND = |.PIPE :(RETURN)'))
3973             DEFINE('PSQL_DISCARD()L')
        *
        -PUBLIC PSQL_CLASS:'DISCARD'
        *
3974             SEND(PSQL_CLASS, 'ADD_METHOD', 'DISCARD', 'PSQL_DISCARD')
3975             DEFINE('PSQL_OUTPUT()L')
        *
        -PUBLIC PSQL_CLASS:'OUTPUT'
        *
3976             SEND(PSQL_CLASS, 'ADD_METHOD', 'OUTPUT', 'PSQL_OUTPUT')
        *
3977                                                                 :(PSQL_END)
        *
        * CONVERT TABLE TO "(NAME, ...) VALUES (DATA, ...)" READY FOR SQL
        * INSERT. USES PSQL_ESCAPE() TO ENSURE THAT VALUES ARE QUOTED CORRECTLY.
        *
3978    PSQL_INSERT
3979             T = CONVERT(T, 'ARRAY')
3980             SEQ(' N = N T<I, 1> ", "; '
3980    +            ' V = V PSQL_ESCAPE(T<I, 2>) ", " ', .I)
3981             IDENT(N)                                            :S(FRETURN)
3982             N ', ' RPOS(0) =
3983             V ', ' RPOS(0) =
3984             PSQL_INSERT = '(' N ') VALUES (' V ')'                :(RETURN)
        *
        * CONVERT PSQL_OUTPUT() INTO ARRAY OF TABLES
        *
3985    PSQL_RESULT
3986             IDENT(S)                                            :S(FRETURN)
3987             S = S CHARS_NL
3988             N = COUNT(S, CHARS_NL CHARS_NL)
3989             EQ(N)                                               :S(FRETURN)
3990             PSQL_RESULT = ARRAY(N)
3991    PSQL5    S POS(0) ARB . T CHARS_NL CHARS_NL REM . S           :F(RETURN)
3992             R = TABLE()
3993    PSQL6    T POS(0) BREAK('|') . KEY '|'
3993    +          BRKREM(CHARS_NL) . DAT (CHARS_NL | RPOS(0)) =       :F(PSQL7)
3994             R<KEY> = DAT                                           :(PSQL6)
3995    PSQL7    I = I + 1
3996             PSQL_RESULT<I> = R                                     :(PSQL5)
        *
        * ESCAPE AND QUOTE AN SQL STRING
        *
3997    PSQL_ESCAPE
3998             PSQL_ESCAPE = "'" REPL(S, "'", "''") "'"              :(RETURN)
        *
        * DISCARD OUTPUT FROM LAST SQL COMMAND.
        *
3999    PSQL_DISCARD
4000             L = $|.PIPE                                         :F(FRETURN)
4001             L POS(0) '*' RPOS(0)                  :S(RETURN)F(PSQL_DISCARD)
        *
        * GATHER AND RETURN OUTPUT FROM SQL COMMAND. DISCARD COMMAND ECHO,
        * RETURNING ONLY RESULTS.
        *
4002    PSQL_OUTPUT
4003    PSQL2    L = $|.PIPE                                         :F(FRETURN)
4004             L POS(0) '*' RPOS(0)                                  :S(PSQL3)
4005             PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
4006    PSQL3    PSQL_OUTPUT CHARS_NL CHARS_NL RPOS(0) = CHARS_NL      :S(PSQL3)
4007    PSQL4    PSQL_OUTPUT BREAK(CHARS_NL) CHARS_NL REM . PSQL_OUTPUT
4007    +                                                            :F(FRETURN)
4008             PSQL_OUTPUT POS(0) '# '                      :S(PSQL4)F(RETURN)
        *
        * OPEN PSQL COMMAND. SEND COMMANDS TO MAKE PSQL_OUTPUT() EASIER,
        * PSQL_RESULT() FOR PARSING SELECT RESULTS AND BUILDING RESULT ARRAYS.
        *
4009    PSQL_OPEN
4010             |.UNIT = IO_FINDUNIT()                              :F(FRETURN)
4011             |.PIPE = UNIQUE()
4012             INPUT(|.PIPE, |.UNIT, 'U', '||/usr/bin/psql -q')    :F(FRETURN)
4013             OUTPUT(|.PIPE, |.UNIT)                              :F(FRETURN)
4014             $|.PIPE = "\set PROMPT1 '\n*\n'"                    :F(FRETURN)
4015             SELF('DISCARD')                                     :F(FRETURN)
4016             $|.PIPE = "\set PROMPT2 '# '"                       :F(FRETURN)
4017             SELF('DISCARD')                                     :F(FRETURN)
4018             $|.PIPE = "\pset pager off"                         :F(FRETURN)
4019             SELF('DISCARD')                                     :F(FRETURN)
4020             $|.PIPE = "\a"                                      :F(FRETURN)
4021             SELF('DISCARD')                                     :F(FRETURN)
4022             $|.PIPE = "\x on"                                   :F(FRETURN)
4023             SELF('DISCARD')                            :F(FRETURN)S(RETURN)
        *
        * CLOSE PSQL
        *
4024    PSQL_CLOSE
4025             $|.PIPE = '\q'                                      :F(FRETURN)
4026             ENDFILE(|.UNIT)                                     :F(FRETURN)
4027             DETACH(|.PIPE)                                      :F(FRETURN)
        *
        * ENDFILE() CLOSES PSQL. INDEED, WE SEND A QUIT COMMAND (\q) FIRST!
        * BUT... THE CLOSE CODE IN THE INTERPRETER DOES NOT REAP THE ZOMBIE.
        * WAIT() IS DEFINED IN CSNOBOL4, USE WAIT() TO REAP. THIS IS WRONG,
        * WE MAY REAP THE WRONG PROCESS! SHOULD FIX THIS IN IO.C - THE CODE
        * IS IN IO.C, BUT ISN'T WORKING (?)
        *
4028             PID = WAIT()                               :S(RETURN)F(FRETURN)
        *
4029    PSQL_END
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'QUOTE.INC'
        -INCLUDE 'RANDOM.INC'
        -MODULE RANDOM
        -LINE 9 "RANDOM.lss"
        -IN72
        -LINE 42 "RANDOM.lss"
        -STITL RANDOM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *         ######      #     #     #  ######   #######  #     #         *
        *         #     #    # #    ##    #  #     #  #     #  ##   ##         *
        *         #     #   #   #   # #   #  #     #  #     #  # # # #         *
        *         ######   #     #  #  #  #  #     #  #     #  #  #  #         *
        *         #   #    #######  #   # #  #     #  #     #  #     #         *
        *         #    #   #     #  #    ##  #     #  #     #  #     #         *
        *         #     #  #     #  #     #  ######   #######  #     #         *
        *                                                                      *
        * RANDOM                 RANDOM NUMBER FUNCTIONS                       *
        *                                                                      *
        * PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
        * JANUARY 4, 2011                                                      *
        *                                                                      *
        ************************************************************************
        *
        * RANDOM.lss
        *
        -LINE 12 "RANDOM.lss"
        -PUBLIC RANDOM(), SRANDOM(), SRANDOMDEV() RANDOMI()
        *
4030             LOAD('RANDOM()INTEGER')
4031             LOAD('SRANDOM(INTEGER)STRING')
4032             LOAD('SRANDOMDEV()STRING')
4033             DEFINE('RANDOMI(N)')                              :(RANDOM_END)
        *
        * RANDOM() RETURNS INTEGER 0 .. 2 ** 31 - 1
        * RETURN 1 .. N
        *
4034    RANDOMI  RANDOMI = RANDOM()
4035             RANDOMI = RANDOMI / 2147483647.0
4036             RANDOMI = NE(N, 0) CONVERT(RANDOMI * N, 'INTEGER') + 1
4037                                                                   :(RETURN)
4038    RANDOM_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READFILE.INC'
        -INCLUDE 'READL.INC'
        -MODULE READL
        -LINE 14 "READL.lss"
        -INCLUDE 'LINK.INC'
        -IN72
        -LINE 46 "READL.lss"
        -STITL READL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             ######   #######     #     ######   #                    *
        *             #     #  #          # #    #     #  #                    *
        *             #     #  #         #   #   #     #  #                    *
        *             ######   #####    #     #  #     #  #                    *
        *             #   #    #        #######  #     #  #                    *
        *             #    #   #        #     #  #     #  #                    *
        *             #     #  #######  #     #  ######   #######              *
        *                                                                      *
        * READL                      READ LIST                                 *
        *                                                                      *
        ************************************************************************
        *
        * READL.lss
        *
        -LINE 18 "READL.lss"
        -PUBLIC READL()
        *
4039             DEFINE('READL(P,IN)N,S')                           :(READL_END)
        *
4040    READL    P = IDENT(P) ABORT
4041             IN = IDENT(IN) .INPUT
4042             N = .READL
4043    READL_1  S = $IN                                              :F(RETURN)
4044             S P                                                  :S(RETURN)
4045             $N = LINK(S)
4046             N = .NEXT($N)                                        :(READL_1)
        *
4047    READL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'READLINE.INC'
        -INCLUDE 'REAL.INC'
        -MODULE REAL
        -STITL REAL
        *
        ************************************************************************
        *                                                                      *
        *                  ######   #######     #     #                        *
        *                  #     #  #          # #    #                        *
        *                  #     #  #         #   #   #                        *
        *                  ######   #####    #     #  #                        *
        *                  #   #    #        #######  #                        *
        *                  #    #   #        #     #  #                        *
        *                  #     #  #######  #     #  #######                  *
        *                                                                      *
        * REAL                 FASBOL II REAL PREDICATE                        *
        *                                                                      *
        ************************************************************************
        *
        * REAL.INC
        *
        -PUBLIC REAL()
        *
4048             DEFINE('REAL(X)')                                   :(END_REAL)
        *
4049    REAL     IDENT(DATATYPE(X), 'REAL')                            :(RETURN)
4050             INTEGER(X)                                          :S(FRETURN)
4051             (IDENT(DATATYPE(X), 'STRING') CONVERT(X, 'REAL'))
4051    +                                                   :S(RETURN)F(FRETURN)
        *
4052    END_REAL
        *
        * CE: .MSNOBOL4;
        *
        -INCLUDE 'REDEFINE.INC'
        -INCLUDE 'REPL.INC'
        -INCLUDE 'RESOL.INC'
        -INCLUDE 'REVL.INC'
        -INCLUDE 'ROMAN.INC'
        -MODULE ROMAN
        -LINE 12 "ROMAN.lss"
        -IN72
        -LINE 57 "ROMAN.lss"
        -STITL ROMAN
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *             ######   #######  #     #     #     #     #              *
        *             #     #  #     #  ##   ##    # #    ##    #              *
        *             #     #  #     #  # # # #   #   #   # #   #              *
        *             ######   #     #  #  #  #  #     #  #  #  #              *
        *             #   #    #     #  #     #  #######  #   # #              *
        *             #    #   #     #  #     #  #     #  #    ##              *
        *             #     #  #######  #     #  #     #  #     #              *
        *                                                                      *
        * ROMAN                      ROMAN NUMERAL                             *
        *                                                                      *
        ************************************************************************
        *
        * ROMAN.lss
        *
        -LINE 15 "ROMAN.lss"
        -PUBLIC ROMAN()
        *
4053             DEFINE('ROMAN(N)T')                                :(ROMAN_END)
        *
4054    ROMAN    N RPOS(1) LEN(1) . T =                               :F(RETURN)
4055             '0,1I,2II,3III,4IV,5V,6VI,7VII,8VIII,9IX,'
4055    +           T BREAK(',') . T                                 :F(FRETURN)
4056             ROMAN = REPLACE(ROMAN(N), 'IVXLCDM', 'XLCDM**') T
4056    +                                                   :S(RETURN)F(FRETURN)
        *
4057    ROMAN_END
        *
        -PUBLIC ARABIC()
4058             DEFINE('ARABIC(R)T,X')                            :(ARABIC_END)
        *
4059    ARABIC   R RPOS(1) LEN(1) . T =                               :F(RETURN)
4060             'M1000,D500,C100,L50,X10,V5,I1,' T BREAK(',') . T   :F(FRETURN)
4061             T = LT(T, X) -T
4062             ARABIC = ARABIC + (X = T)                             :(ARABIC)
        *
4063    ARABIC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ROTATER.INC'
        -MODULE ROTATER
        -LINE 9 "ROTATER.lss"
        -IN72
        -LINE 38 "ROTATER.lss"
        -STITL ROTATER
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    ######   #######  #######     #     #######  #######  ######      *
        *    #     #  #     #     #       # #       #     #        #     #     *
        *    #     #  #     #     #      #   #      #     #        #     #     *
        *    ######   #     #     #     #     #     #     #####    ######      *
        *    #   #    #     #     #     #######     #     #        #   #       *
        *    #    #   #     #     #     #     #     #     #        #    #      *
        *    #     #  #######     #     #     #     #     #######  #     #     *
        *                                                                      *
        * ROTATER                    ROTATE STRING                             *
        *                                                                      *
        ************************************************************************
        *
        * ROTATER.lss
        *
        -LINE 12 "ROTATER.lss"
        -PUBLIC ROTATER()
        *
4064             DEFINE('ROTATER(S,N)S1')                         :(ROTATER_END)
        *
4065    ROTATER  IDENT(S)                                             :S(RETURN)
4066             N = REMDR(N, SIZE(S))
4067             N = LT(N, 0) SIZE(S) + N
4068             S RTAB(N) . S  REM . S1 = S1 S
4069             ROTATER = S                                           :(RETURN)
        *
4070    ROTATER_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'ROUTING.INC'
        -MODULE ROUTING
        -LINE 16 "ROUTING.lss"
        -INCLUDE 'BRKREM.INC'
        -INCLUDE 'SDIFF.INC'
        -INCLUDE 'UNIQUE.INC'
        -IN72
        -LINE 121 "ROUTING.lss"
        -STITL ROUTING
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *      ######   #######  #     #  #######  ###  #     #   #####        *
        *      #     #  #     #  #     #     #      #   ##    #  #     #       *
        *      #     #  #     #  #     #     #      #   # #   #  #             *
        *      ######   #     #  #     #     #      #   #  #  #  #  ####       *
        *      #   #    #     #  #     #     #      #   #   # #  #     #       *
        *      #    #   #     #  #     #     #      #   #    ##  #     #       *
        *      #     #  #######   #####      #     ###  #     #   #####        *
        *                                                                      *
        * ROUTING                   ROUTING FOR CGI                            *
        *                                                                      *
        ************************************************************************
        *
        * ROUTING.lss
        *
        -LINE 22 "ROUTING.lss"
        -PUBLIC ROUTING_INIT(), ROUTING_ADD(), ROUTING()
        *
4071             DEFINE('ROUTING_INIT()')
4072             DEFINE('ROUTING_ADD(ROUTE,PATTERN,ACTION_)NAME,P')
4073             DEFINE('ROUTING(METHOD,ROUTE,VARS_)P,S')
        *
4074             ROUTING_VAR = ':'
4075             ROUTING_NAME_C = &UCASE &LCASE '0123456789' '._'
4076             ROUTING_NAME = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789._')
4077             MAKE_UNIQUE('ROUTING')
        *
4078                                                              :(ROUTING_END)
        *
        * INITIALIZE ROUTE. THE INITIAL ROUTE ALWAYS FAILS.
        *
4079    ROUTING_INIT
4080             UNIQUE_ROUTING('CLEAR')
4081             ROUTING_INIT = ABORT                                  :(RETURN)
        *
        * ADD PATTERN TO ROUTE, WITH ACTION. ON MATCH, YIELDS ACTION, AND
        * SUCCESS.
        *
4082    ROUTING_ADD
4083             NAME = UNIQUE_ROUTING()
4084             $NAME = ACTION_
4085             P = EVAL('PATTERN *?(ACTION = ' NAME ')')
4086             ROUTING_ADD = P | ROUTE                               :(RETURN)
        *
        * MAKE A ROUTING PATTERN. METHOD WILL BE SOMETHING LIKE 'GET', 'POST',
        * '', ('GET' | 'POST'). ROUTE WILL BE '/A/B/C', '/A/:VAR/C'
        *
4087    ROUTING  METHOD = IDENT(METHOD) BREAK('\')
4088    ROUTE_3  ROUTE POS(0) BRKREM(ROUTING_VAR) . S =
4089             P = DIFFER(S) P S
4090             IDENT(ROUTE)                                        :S(ROUTE_9)
4091             ROUTE POS(0) LEN(1) BRKREM(ROUTING_NAME) . S =
4092             IDENT(S)                                            :S(ROUTE_3)
4093             ROUTE LEN(1) . B =                                  :F(ROUTE_4)
4094             P = P BREAK(B) . ($VARS_)<S> B                       :(ROUTE_3)
4095    ROUTE_4  P = P REM . ($VARS_)<S>
4096    ROUTE_9  ROUTING = METHOD '\' P                                :(RETURN)
        *
4097    ROUTING_END
        *
        *
        * CE: .F.MSNOBOL4;
        -INCLUDE 'SCOOP.INC'
        -INCLUDE 'SDIFF.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'SESSION.INC'
        -INCLUDE 'SIZEA.INC'
        -INCLUDE 'SIZEL.INC'
        -LINE 9 "SIZEL.lss"
        -INCLUDE 'LINK.INC'
        -STITL SIZEL
        -EJECT
        -LINE 38 "SIZEL.lss"
        *
        ************************************************************************
        *                                                                      *
        *                #####   ###  #######  #######  #                      *
        *               #     #   #        #   #        #                      *
        *               #         #       #    #        #                      *
        *                #####    #     #      #####    #                      *
        *                     #   #    #       #        #                      *
        *               #     #   #   #        #        #                      *
        *                #####   ###  #######  #######  #######                *
        *                                                                      *
        * SIZEL                    SIZE OF LIST                                *
        *                                                                      *
        ************************************************************************
        *
        * SIZEL.lss
        *
        -LINE 13 "SIZEL.lss"
        -MODULE SIZEL
        -PUBLIC SIZEL()
        *
4098             DEFINE('SIZEL(L)')                                 :(END_SIZEL)
        *
4099    SIZEL    SIZEL = 0
4100    SIZEL_2  SIZEL = DIFFER(L) SIZEL + 1                          :F(RETURN)
4101             L = NEXT(L)                                          :(SIZEL_2)
        *
4102    END_SIZEL
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SIZET.INC'
        -MODULE SIZEL
        -IN72
        -LINE 10 "SIZET.lss"
        -INCLUDE 'HASH.INC'
        -INCLUDE 'SIZEA.INC'
        -LINE 37 "SIZET.lss"
        -STITL SIZET
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                #####   ###  #######  #######  #######                *
        *               #     #   #        #   #           #                   *
        *               #         #       #    #           #                   *
        *                #####    #     #      #####       #                   *
        *                     #   #    #       #           #                   *
        *               #     #   #   #        #           #                   *
        *                #####   ###  #######  #######     #                   *
        *                                                                      *
        * SIZET                    SIZE OF TABLE                               *
        *                                                                      *
        ************************************************************************
        *
        * SIZET.lss
        *
        -LINE 15 "SIZET.lss"
        -PUBLIC SIZET()
        *
4103             DEFINE('SIZET(T)')                                 :(END_SIZET)
        *
4104    SIZET    SIZET =  SIZEA(KEYST(T))                              :(RETURN)
        *
4105    END_SIZET
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SKIM.INC'
        -LINE 11 "SKIM.lss"
        -INCLUDE 'SDIFF.INC'
        -STITL SKIM
        -EJECT
        -LINE 40 "SKIM.lss"
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                    #####   #    #  ###  #     #                      *
        *                   #     #  #   #    #   ##   ##                      *
        *                   #        #  #     #   # # # #                      *
        *                    #####   ###      #   #  #  #                      *
        *                         #  #  #     #   #     #                      *
        *                   #     #  #   #    #   #     #                      *
        *                    #####   #    #  ###  #     #                      *
        *                                                                      *
        * SKIM                 SKIM UNIQUE CHARACTERS                          *
        *                                                                      *
        ************************************************************************
        *
        * SKIM.lss
        *
        -LINE 15 "SKIM.lss"
        -MODULE SKIM
        -PUBLIC SKIM()
4106             DEFINE('SKIM(S)C')                                  :(SKIM_END)
        *
4107    SKIM     S LEN(1) . C =                                       :F(RETURN)
4108             SKIM C                                               :S(SKIM_D)
4109             SKIM = SKIM C                                           :(SKIM)
4110    SKIM_D   S = SDIFF(S, SKIM)                                      :(SKIM)
        *
4111    SKIM_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SLOAD.INC'
        -INCLUDE 'SOUNDEX.INC'
        -STITL SOUNDEX
        -EJECT
        *
        -LINE 46 "SOUNDEX.lss"
        ************************************************************************
        *                                                                      *
        *     #####   #######  #     #  #     #  ######   #######  #     #     *
        *    #     #  #     #  #     #  ##    #  #     #  #         #   #      *
        *    #        #     #  #     #  # #   #  #     #  #          # #       *
        *     #####   #     #  #     #  #  #  #  #     #  #####       #        *
        *          #  #     #  #     #  #   # #  #     #  #          # #       *
        *    #     #  #     #  #     #  #    ##  #     #  #         #   #      *
        *     #####   #######   #####   #     #  ######   #######  #     #     *
        *                                                                      *
        * SOUNDEX                   NARA SOUNDEX                               *
        *                                                                      *
        ************************************************************************
        *
        * SOUNDEX.lss
        *
        -LINE 11 "SOUNDEX.lss"
        -MODULE SOUNDEX
        -PUBLIC SOUNDEX()
4112             DEFINE('SOUNDEX(STR)SDXMAP,INIT,CH')             :(SOUNDEX_END)
        *
4113    SOUNDEX  SDXMAP = '01230127022455012623017202'
4114             STR = REPLACE(STR, &LCASE, &UCASE)
4115    SDX1     STR NOTANY(&UCASE) =                                   :S(SDX1)
4116             INIT = SUBSTR(STR, 1, 1)
4117             STR = REPLACE(STR, &UCASE, SDXMAP)
4118    SDX2     STR LEN(1) $ CH SPAN(*CH) = CH                         :S(SDX2)
        * OMIT NEXT LINE FOR KNUTH'S SIMPLE SOUNDEX
4119    SDX3     STR LEN(1) $ CH ('7' *CH) = CH                         :S(SDX3)
4120             STR LEN(1) = INIT
4121    SDX4     STR ANY('07') =                                        :S(SDX4)
4122             STR = SUBSTR(STR, 1, 4)
4123             STR = LT(SIZE(STR), 4) STR DUPL('0', 4 - SIZE(STR))
4124             SOUNDEX = STR                                         :(RETURN)
        *
4125    SOUNDEX_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SPELL.INC'
        -STITL SPELL
        -EJECT
        *
        -LINE 58 "SPELL.lss"
        ************************************************************************
        *                                                                      *
        *                 #####   ######   #######  #        #                 *
        *                #     #  #     #  #        #        #                 *
        *                #        #     #  #        #        #                 *
        *                 #####   ######   #####    #        #                 *
        *                      #  #        #        #        #                 *
        *                #     #  #        #        #        #                 *
        *                 #####   #        #######  #######  #######           *
        *                                                                      *
        * SPELL                    SPELL OUT A NUMBER                          *
        *                                                                      *
        ************************************************************************
        *
        * SPELL.lss
        *
        -LINE 12 "SPELL.lss"
        -MODULE SPELL
        -PUBLIC SPELL()
4126             DEFINE('SPELL(N)M')                                :(SPELL_END)
        *
4127    SPELL    GE(N, 1000)                                      :S(SPELL_1000)
4128             GE(N, 100)                                        :S(SPELL_100)
4129             GE(N, 20)                                          :S(SPELL_20)
4130             GE(N, 13)                                          :S(SPELL_13)
4131             ('1ONE,2TWO,3THREE,4FOUR,5FIVE,6SIX,7SEVEN,8EIGHT,9NINE,'
4131    +           '10TEN,11ELEVEN,12TWELVE,') N ARB . SPELL ','      :(RETURN)
4132    SPELL_13 N 1 LEN(1) . M
4133             SPELL = SPELL(M 0)
4134             SPELL 'TY' = 'TEEN'
4135             SPELL 'FOR' = 'FOUR'                                  :(RETURN)
4136    SPELL_20 N LEN(1) . M =
4137             '2TWEN,3THIR,4FOR,5FIF,6SIX,7SEVEN,8EIGH,9NINE,'
4137    +           M BREAK(',') . SPELL
4138             SPELL = SPELL 'TY'
4139             SPELL = NE(N,0) SPELL '-' SPELL(N)                    :(RETURN)
4140    SPELL_100
4141             N LEN(1) . M  =
4142             SPELL = SPELL(M) ' HUNDRED'
4143             SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
4144    SPELL_1000
4145             N RTAB(3) . M  =
4146             SPELL = SPELL(M)
4147             SPELL 'THOUSAND' = 'MILLION'
4148             SPELL = SPELL ' THOUSAND'
4149             SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
        *
4150    SPELL_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'STACK.INC'
        -INCLUDE 'STCL.INC'
        -INCLUDE 'STROUT.INC'
        -STITL STROUT
        -EJECT
        *
        -LINE 43 "STROUT.lss"
        ************************************************************************
        *                                                                      *
        *            #####   #######  ######   #######  #     #  #######       *
        *           #     #     #     #     #  #     #  #     #     #          *
        *           #           #     #     #  #     #  #     #     #          *
        *            #####      #     ######   #     #  #     #     #          *
        *                 #     #     #   #    #     #  #     #     #          *
        *           #     #     #     #    #   #     #  #     #     #          *
        *            #####      #     #     #  #######   #####      #          *
        *                                                                      *
        * STROUT                    ARRAY TO STRING                            *
        *                                                                      *
        ************************************************************************
        *
        * STROUT.lss
        *
        -LINE 16 "STROUT.lss"
        -MODULE STROUT
        -PUBLIC STRINGOUT()
4151             DEFINE('STRINGOUT(A,SEP)I')                    :(STRINGOUT_END)
        *
4152    STRINGOUT
4153             I = 1
4154             STRINGOUT = A<1>                                     :F(RETURN)
4155    STRINGOUT_1
4156             I = I + 1
4157             STRINGOUT = STRINGOUT SEP A<I>         :S(STRINGOUT_1)F(RETURN)
        *
4158    STRINGOUT_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SWAP.INC'
        -INCLUDE 'SYSLOG.INC'
        -LINE 10 "SYSLOG.lss"
        -INCLUDE 'FFI.INC'
        -INCLUDE 'UNIX.INC'
        -STITL SYSLOG
        -EJECT
        -LINE 108 "SYSLOG.lss"
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *          #####   #     #   #####   #        #######   #####          *
        *         #     #   #   #   #     #  #        #     #  #     #         *
        *         #          # #    #        #        #     #  #               *
        *          #####      #      #####   #        #     #  #  ####         *
        *               #     #           #  #        #     #  #     #         *
        *         #     #     #     #     #  #        #     #  #     #         *
        *          #####      #      #####   #######  #######   #####          *
        *                                                                      *
        * SYSLOG        INTERFACE TO OPENLOG/SYSLOG/CLOSELOG                   *
        *                                                                      *
        ************************************************************************
        *
        * SYSLOG.lss
        *
        -LINE 15 "SYSLOG.lss"
        -MODULE SYSLOG
4159             FFI_OPENLOG = FFI_NEW('V', 'P,I,I')
4160             FFI_SET_CALLP(FFI_OPENLOG, DLSYM(0, 'openlog'))
4161             FFI_SYSLOG = FFI_NEW('V', 'I,P,P')
4162             FFI_SET_CALLP(FFI_SYSLOG, DLSYM(0, 'syslog'))
4163             FFI_CLOSELOG = FFI_NEW('V', 'V')
4164             FFI_SET_CALLP(FFI_CLOSELOG, DLSYM(0, 'closelog'))
        *
        * PRIORITY
        *
        -PUBLIC LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING
        -PUBLIC LOG_NOTICE, LOG_INFO, LOG_DEBUG
4165             LOG_EMERG   = 0
4166             LOG_ALERT   = 1
4167             LOG_CRIT    = 2
4168             LOG_ERR     = 3
4169             LOG_WARNING = 4
4170             LOG_NOTICE  = 5
4171             LOG_INFO    = 6
4172             LOG_DEBUG   = 7
        *
        * FACILITY
        *
        -PUBLIC LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_SYSLOG
        -PUBLIC LOG_LPR, LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_AUTHPRIV, LOG_FTP
        -PUBLIC LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4
        -PUBLIC LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7
4173             LOG_KERN     =  0 * 8
4174             LOG_USER     =  1 * 8
4175             LOG_MAIL     =  2 * 8
4176             LOG_DAEMON   =  3 * 8
4177             LOG_AUTH     =  4 * 8
4178             LOG_SYSLOG   =  5 * 8
4179             LOG_LPR      =  6 * 8
4180             LOG_NEWS     =  7 * 8
4181             LOG_UUCP     =  8 * 8
4182             LOG_CRON     =  9 * 8
4183             LOG_AUTHPRIV = 10 * 8
4184             LOG_FTP      = 11 * 8
4185             LOG_LOCAL0   = 16 * 8
4186             LOG_LOCAL1   = 17 * 8
4187             LOG_LOCAL2   = 18 * 8
4188             LOG_LOCAL3   = 19 * 8
4189             LOG_LOCAL4   = 20 * 8
4190             LOG_LOCAL5   = 21 * 8
4191             LOG_LOCAL6   = 22 * 8
4192             LOG_LOCAL7   = 23 * 8
        *
        * OPTIONS
        *
        -PUBLIC LOG_PID, LOG_CONS, LOG_ODELAY, LOG_NDELAY, LOG_NOWAIT
        -PUBLIC LOG_PERROR
4193             LOG_PID    =  1
4194             LOG_CONS   =  2
4195             LOG_ODELAY =  4
4196             LOG_NDELAY =  8
4197             LOG_NOWAIT = 16
4198             LOG_PERROR = 32
        *
        -PUBLIC OPENLOG(), SYSLOG() CLOSELOG()
4199             DEFINE('OPENLOG(IDENT,OPTION,FACILITY)P')
4200             DEFINE('SYSLOG(PRIORITY,S)')
4201             DEFINE('CLOSELOG()')                           :(SYSLOG_FN_END)
        *
4202    OPENLOG  P = STRDUP(IDENT)
4203             FFI_PAR_N_PTR(FFI_OPENLOG, 1, P)
4204             FFI_PAR_N_INTEGER(FFI_OPENLOG, 2, OPTION)
4205             FFI_PAR_N_INTEGER(FFI_OPENLOG, 3, FACILITY)
4206             FFI_CALL_VOID(FFI_OPENLOG)                            :(RETURN)
        *
4207    SYSLOG   FFI_PAR_N_INTEGER(FFI_SYSLOG, 1, PRIORITY)
4208             FFI_PAR_N_STRING(FFI_SYSLOG, 2, '%s')
4209             FFI_PAR_N_STRING(FFI_SYSLOG, 3, S)
4210             FFI_CALL_VOID(FFI_SYSLOG)                             :(RETURN)
        *
4211    CLOSELOG FFI_CALL_VOID(FFI_CLOSELOG)                           :(RETURN)
        *
4212    SYSLOG_FN_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'SYSTEM.INC'
        -INCLUDE 'TEST.INC'
        -LINE 16 "TEST.lss"
        -INCLUDE 'UNIQUE.INC'
        -STITL TEST
        -EJECT
        -LINE 46 "TEST.lss"
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *                  #######  #######   #####   #######                  *
        *                     #     #        #     #     #                     *
        *                     #     #        #           #                     *
        *                     #     #####     #####      #                     *
        *                     #     #              #     #                     *
        *                     #     #        #     #     #                     *
        *                     #     #######   #####      #                     *
        *                                                                      *
        * TEST                                                                 *
        *                                                                      *
        ************************************************************************
        *
        * TEST.lss
        *
        -LINE 20 "TEST.lss"
        -MODULE TEST
        -PUBLIC TESTP()
4213             DEFINE('TESTP(ARG)NAME')                            :(TEST_END)
        *
4214    TESTP    IDENT(DATATYPE(ARG), 'EXPRESSION')                   :F(TEST_1)
4215             NAME = UNIQUE()
4216             $NAME = ARG
4217             TEST = EVAL("NULL $ *TEST('" NAME "')")               :(RETURN)
4218    TEST_1   TEST = ?EVAL($ARG) .TEST_                 :S(NRETURN)F(FRETURN)
        *
4219    TEST_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TIMEGC.INC'
        -LINE 13 "TIMEGC.lss"
        -INCLUDE 'LINK.INC'
        -INCLUDE 'RESOL.INC'
        -INCLUDE 'SYSTEM.INC'
        -STITL TIMEGC
        -EJECT
        -LINE 70 "TIMEGC.lss"
        *
        ************************************************************************
        *                                                                      *
        *           #######  ###  #     #  #######   #####    #####            *
        *              #      #   ##   ##  #        #     #  #     #           *
        *              #      #   # # # #  #        #        #                 *
        *              #      #   #  #  #  #####    #  ####  #                 *
        *              #      #   #     #  #        #     #  #                 *
        *              #      #   #     #  #        #     #  #     #           *
        *              #     ###  #     #  #######   #####    #####            *
        *                                                                      *
        * TIMEGC                TIME GARBAGE COLLECT                           *
        *                                                                      *
        ************************************************************************
        *
        * TIMEGC.lss
        *
        -LINE 19 "TIMEGC.lss"
        -MODULE TIMEGC
        -PUBLIC TIMEGC()
4220             DEFINE('TIMEGC(N)I,S,A,L,T,K,FREED')              :(TIMEGC_END)
        *
4224    TIMEGC   I = ; S = ; A = ; L =
4225             COLLECT()
4226             N = IDENT(N) 25
4227             A = ARRAY(N)
4228    TIMEGC_1 I = I + 1
4229             $I = DUPL(' ', 78) I
4230             A<I> = DUPL('*', I)
4231             L = LINK(NULL, L)
4232             GE(I, N)                                           :F(TIMEGC_1)
4233             STREM = COLLECT()
4236    TIMEGC_2 $I = ; A<I> = ; L = NEXT(L)
4237             I = I - 2 GT(I, 2)                                 :S(TIMEGC_2)
4238             T = TIME()
4239             FREED = FREED + (COLLECT() - STREM)
4240             TIMEGC = TIMEGC + (TIME() - T)
4241             K = K + 1
4242             M = 50
4243             M = LT(RESOLUTION(), 0.9) 5000
4244             LT(TIMEGC, M * RESOLUTION())                         :S(TIMEGC)
4245             OUTPUT =
4246             OUTPUT = 'IN ' SYSTEM() ' ' K ' GARBAGE COLLECTS'
4246    +           ' REQUIRED A TOTAL OF ' TIMEGC ' MILLISECONDS TO FREE '
4246    +           FREED ' STORAGE UNITS.'
4247             TIMEGC = CONVERT(TIMEGC, 'REAL')
4248             OUTPUT = 'THIS AVERAGES TO ' (TIMEGC / K) ' MILLISECONDS PER'
4248    +           ' GARBAGE COLLECT AND ' (TIMEGC * 1000000 / FREED)
4248    +           ' NANOSECONDS PER STORAGE UNIT.'                   :(RETURN)
        *
4249    TIMEGC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'TIME.INC'
        -INCLUDE 'TIMER.INC'
        -INCLUDE 'TRIMB.INC'
        -INCLUDE 'TRUNC.INC'
        -LINE 12 "TRUNC.lss"
        -INCLUDE 'SEQ.INC'
        -STITL TRUNC
        -EJECT
        -LINE 40 "TRUNC.lss"
        *
        ************************************************************************
        *                                                                      *
        *             #######  ######   #     #  #     #   #####               *
        *                #     #     #  #     #  ##    #  #     #              *
        *                #     #     #  #     #  # #   #  #                    *
        *                #     ######   #     #  #  #  #  #                    *
        *                #     #   #    #     #  #   # #  #                    *
        *                #     #    #   #     #  #    ##  #     #              *
        *                #     #     #   #####   #     #   #####               *
        *                                                                      *
        * TRUNC                     TRUNCATE ARRAY                             *
        *                                                                      *
        ************************************************************************
        *
        * TRUNC.lss
        *
        -LINE 16 "TRUNC.lss"
        -MODULE TRUNC
        -PUBLIC TRUNC()
4250             DEFINE('TRUNC(A,L,H)')                             :(TRUNC_END)
        *
4251    TRUNC    TRUNC = ARRAY(H - L + 1)
4252             L = L - 1
4253             SEQ(' TRUNC<I> = A<L + I> ',.I)                       :(RETURN)
        *
4254    TRUNC_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'UNIQUE.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'UTF8.INC'
        -MODULE UTF8
        -STITL UTF8
        -EJECT
        -LINE 249 "UTF8.lss"
        *
        ************************************************************************
        *                                                                      *
        *                   #     #  #######  #######   ###                    *
        *                   #     #     #     #        #   #                   *
        *                   #     #     #     #        #   #                   *
        *                   #     #     #     #####     ###                    *
        *                   #     #     #     #        #   #                   *
        *                   #     #     #     #        #   #                   *
        *                    #####      #     #         ###                    *
        *                                                                      *
        * UTF8                                                                 *
        *                                                                      *
        ************************************************************************
        *
        * SNOBOL4 FUNCTIONS TO IMPLEMENT UTF-ENCODED UNICODE HANDLING
        * UTF8.lss
        *
        -LINE 12 "UTF8.lss"
        * PHIL BUDNE <PHIL@ULTIMATE.COM>
        * SEPTEMBER 1996
        * UPDATED FOR 4/5/6 BYTE RUNES JUNE 1997
        *
        * MOST OF THIS IS JUST AWFUL, BUT THIS IS JUST A PROOF OF CONCEPT,
        * AND LIKE ALL SNOBOL THERE IS ALWAYS A SMALLER, FASTER AND MORE
        * PERVERSE WAY TO DO ANYTHING.
        *
        * TODO
        *
        * UTFNOTANY
        * UTFSPAN
        * UTFBREAK
        * UTFBREAKX
        *
        * PATTERN TO MATCH ONE UTF ENCODED RUNE
        *
        * SNOBOL4 LACKS CHAR(), SPITBOL CHAR() LOSES ON CHAR(0)!
        *
4255             DEFINE("XCHAR(N)")                                    :(EXCHAR)
        *
4256    XCHAR    &ALPHABET ARB POS(N) LEN(1) . XCHAR        :S(RETURN)F(FRETURN)
        *
4257    EXCHAR
        *
        * HELPER FUNCTION TO PATTERN THAT MATCHES A RANGE OF BYTE VALUES.
        * THE TRUE SNO-HEAD MIGHT IMPLEMENT THIS AS A FUNCTION THAT TAKES
        * STRINGS OF SPAN('01') ARBNO('X') DIRECTLY!!
        *
4258             DEFINE("RANGE(START,END)")                            :(ERANGE)
        *
4259    RANGE
        *
        * SPITBOL COMPILES ANY() INTO A BITMAP;
4260             &ALPHABET ARB (XCHAR(START) ARB XCHAR(END)) . RANGE :F(FRETURN)
        * SPITBOL COMPILES TABLES ONCE
4261             RANGE = ANY(RANGE)                                    :(RETURN)
        * FOR SNOBOL4; CREATE BIG PATTERN
        *        GE(START, END)                                      :S(FRETURN)
        *        RANGE = XCHAR(START)
        *RANGE1  GE(STAT, END)                                        :S(RETURN)
        *        START = START + 1
        *        RANGE = RANGE | XCHAR(START)                          :(RANGE1)
        *
4262    ERANGE
        *
        * SINGLE BYTE:       0XXXXXXX  VALUES 0..0X7F
        *
4263             UTF.T1 = RANGE(0, 127)
        *
        * TWO-BYTE LEADER:   110XXXXX  VALUES 0X80..0X7FF
        *
4264             UTF.T2 = RANGE(192, 223)
        *
        * THREE-BYTE LEADER: 1110XXXX  VALUES 0X800..0XFFFF
        *
4265             UTF.T3 = RANGE(224, 239)
        *
        * FOUR-BYTE LEADER:  11110XXX  VALUES 0X10000..0X1FFFFF
        *
4266             UTF.T4 = RANGE(240, 247)
        *
        * FIVE-BYTE LEADER:  111110XX  VALUES 0X200000..0X3FFFFFF
        *
4267             UTF.T5 = RANGE(248, 251)
        *
        * FIVE-BYTE LEADER:  1111110X  VALUES 0X4000000..0X7FFFFFFF
        *
4268             UTF.T6 = RANGE(252, 253)
        *
        * SUBSEQUENT BYTE:   10XXXXXX
        *
4269             UTF.TX = RANGE(128, 191)
        *
4270             UTF.RUNE = FENCE
4270    +           (UTF.T1 |
4270    +            UTF.T2 UTF.TX |
4270    +            UTF.T3 UTF.TX UTF.TX |
4270    +            UTF.T4 UTF.TX UTF.TX UTF.TX |
4270    +            UTF.T5 UTF.TX UTF.TX UTF.TX UTF.TX |
4270    +            UTF.T6 UTF.TX UTF.TX UTF.TX UTF.TX UTF.TX)
        *
4271             UTF.RUNE0 = POS(0) UTF.RUNE
        *
        * PATTERN TO MOVE TO NEXY SYNC CHAR;
        *
        *        UTF.SYNC = BREAKX(UTF.T1 UTF.T2 UTF.T3 UTF.T4 UTF.T5 UTF.T6)
        *
        * UTF ANALOG OF ARB
        *
4272             UTFARB = ARBNO(UTF.RUNE)
        *
        * UTF ANALOG OF LEN
        *
4273             DEFINE("UTFLEN(N)")                                  :(EUTFLEN)
        *
4274    UTFLEN   LT(N, 0)                                             :(FRETURN)
4275             UTFLEN =
4276    UTFLEN2  EQ(N, 0)                                             :S(RETURN)
4277             UTFLEN = UTFLEN UTF.RUNE
4278             N = N - 1                                            :(UTFLEN2)
        *
4279    EUTFLEN
        *
        * UTF ANALOG FOR ANY(STR)
        *
4280             DEFINE("UTFANY(STR)R")                               :(EUTFANY)
        *
4281    UTFANY   STR UTF.RUNE0 . UTFANY =                            :F(FRETURN)
4282    UTFANY2  IDENT(STR)                                           :S(RETURN)
4283             STR UTF.RUNE0 . R =                                 :F(FRETURN)
4284             UTFANY = UTFANY | R                                  :(UTFANY2)
4285    EUTFANY
        *
        * UTF ANALOG FOR CHAR(N)
        *
4286             DEFINE("RUNE(N)")                                      :(ERUNE)
        *
4287    RUNE     LT(N, 0)                                            :S(FRETURN)
4288             GT(N, 127)                                            :S(RUNE2)
        * SINGLE BYTE RUNE
4289             RUNE = XCHAR(N)                                       :(RETURN)
4290    RUNE2    GT(N, 2047)                                           :S(RUNE3)
        * TWO-BYTE RUNE
4291             RUNE = XCHAR(192 + (N / 64))
4291    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * THREE-BYTE RUNE
4292    RUNE3    GT(N, 65535)                                          :S(RUNE4)
4293             RUNE = XCHAR(224 + N / 4096)
4293    +               XCHAR(128 + REMDR(N / 64, 64))
4293    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * FOUR-BYTE RUNE
4294    RUNE4    GT(N, 2097151)                                        :S(RUNE5)
4295             RUNE = XCHAR(240 + N / 262144)
4295    +               XCHAR(128 + REMDR(N / 65536, 64))
4295    +               XCHAR(128 + REMDR(N / 64, 64))
4295    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * FIVE-BYTE RUNE
4296    RUNE5    GT(N, 67108863)                                       :S(RUNE6)
4297             RUNE = XCHAR(248 + N / 16777216)
4297    +               XCHAR(128 + REMDR(N / 262144, 64))
4297    +               XCHAR(128 + REMDR(N / 4096, 64))
4297    +               XCHAR(128 + REMDR(N / 64, 64))
4297    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        * SIX-BYTE RUNE
4298    RUNE6    GT(N, 2147483647)                                   :S(FRETURN)
4299             RUNE = XCHAR(252 + N / 1073741824)
4299    +               XCHAR(128 + REMDR(N / 16777216, 64))
4299    +               XCHAR(128 + REMDR(N / 262144, 64))
4299    +               XCHAR(128 + REMDR(N / 4096, 64))
4299    +               XCHAR(128 + REMDR(N / 64, 64))
4299    +               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
        *
4300    ERUNE
        *
        * UTF ANALOG FOR SIZE(STR)
        *
4301             DEFINE("UTFSIZE(STR)")                              :(EUTFSIZE)
        *
4302    UTFSIZE  STR UTF.RUNE =                                      :F(UTFSIZ2)
4303             UTFSIZE = UTFSIZE + 1                                :(UTFSIZE)
4304    UTFSIZ2  IDENT(STR)                                 :S(RETURN)F(FRETURN)
        *
4305    EUTFSIZE
        *
        * UTF ANALOG FOR REPLACE()
        *
4306             DEFINE("UTFREPLACE(IN,FROM,TO)T,R1,R2")          :(EUTFREPLACE)
        *
4307    UTFREPLACE
4308             T = TABLE()
        * PEEL RUNES OFF INPUT AND OUTPUT LANGUAGES ONE AT A TIME
4309    UTFREP1  FROM UTF.RUNE0 . R1 =                               :F(UTFREP2)
4310             TO UTF.RUNE0 . R2 =                                 :F(UTFREP2)
4311             T<R1> = R2                                           :(UTFREP1)
        * BOTH INPUT AND OUTPUT LANGUAGES SHOULD NOW BE EMPTY
4312    UTFREP2  DIFFER(FROM)                                        :S(FRETURN)
4313             DIFFER(TO)                                          :S(FRETURN)
        * FREEZE TABLE FOR SNOBOL4+?
        * PEEL RUNES INPUT ONE AT A TIME, FEED THRU TABLE
4314             UTFREPLACE =
4315    UTFREP3  IN UTF.RUNE0 . R1 =                                 :F(UTFREP4)
4316             UTFREPLACE = UTFREPLACE (IDENT(T<R1>) R1, T<R1>)     :(UTFREP3)
4317    UTFREP4  IDENT(IN)                                  :S(RETURN)F(FRETURN)
        *
4318    EUTFREPLACE
        *
        ************************************************************************
        *
        * TESTS
        *
        *        &ANCHOR = 1
        *        S = "Hello World!!"
        *
        *        OUTPUT = UTFREPLACE(S,&UCASE "!",&LCASE "?")
        *
        *L       S UTF.RUNE $ OUTPUT =                                     :S(L)
        *
        *        "HELLO WORLD!" UTFARB . OUTPUT RPOS(0)
        *        "Hello World!" UTFARB UTFANY(&LCASE) . OUTPUT
        *        "Hello World!" UTFANY(&UCASE) . OUTPUT
        *
        *        OUTPUT = RUNE(0)
        *        OUTPUT = RUNE(127)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(128)
        *        OUTPUT = RUNE(255)
        *        OUTPUT = RUNE(2047)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(2048)
        *        OUTPUT = RUNE(65535)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(65536)
        *        OUTPUT = RUNE(2097151)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(2097152)
        *        OUTPUT = RUNE(67108863)
        *        OUTPUT = '-------'
        *        OUTPUT = RUNE(67108864)
        *        OUTPUT = RUNE(2147483647)
        *
        *END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'VDIFFER.INC'
        -INCLUDE 'WRAPPER.INC'
        -MODULE WRAPPER
        -LINE 9 "WRAPPER.lss"
        -STITL WRAPPER
        -LINE 295 "WRAPPER.lss"
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *    #     #  ######      #     ######   ######   #######  ######      *
        *    #  #  #  #     #    # #    #     #  #     #  #        #     #     *
        *    #  #  #  #     #   #   #   #     #  #     #  #        #     #     *
        *    #  #  #  ######   #     #  ######   ######   #####    ######      *
        *    #  #  #  #   #    #######  #        #        #        #   #       *
        *    #  #  #  #    #   #     #  #        #        #        #    #      *
        *     ## ##   #     #  #     #  #        #        #######  #     #     *
        *                                                                      *
        * WRAPPER   CREATE C CODE TO WRAP A FUNCTION FOR LOAD()'ING            *
        *                                                                      *
        * PHIL BUDNE, DECEMBER, 2001                                           *
        *                                                                      *
        ************************************************************************
        *
        * WRAPPER.lss
        *
        * FMGW
        *
        *     STRING_FREE, FREE RETURNED STRING AFTER COPYING TO SNOBOL4
        *     STRING2, REQUIRES LEN PARAMETER, COPY FIXED LENGTH
        *     REMOVE HANDLE TYPE COMPLETELY
        *
        -LINE 12 "WRAPPER.lss"
4319             WPMAXSTR = 1024
4320             WPSTRTYPE = 'STRING'
4321             WPSTRFREE = 'STRING_FREE'
4322             WPSTRTYP2 = 'STRING2'
4323             WPINTTYPE = 'INTEGER'
4324             WPPTRTYPE = 'POINTER'
4325             WPLONGTYPE = 'LONG'
4326             WPREALTYPE = 'REAL'
4327             WPREDTYPE = 'PREDICATE'
4328             WPSPREDTYPE = 'SYSPRED'
4329             WPTYPES = WPLONGTYPE | WPINTTYPE | WPREALTYPE | WPSTRTYPE |
4329    +                  WPPTRTYPE
4330             WPRTYPES = WPTYPES | WPREDTYPE | WPSPREDTYPE | WPSTRFREE |
4330    +                   WPSTRTYP2 | ''
4331             WPNAME = ANY(&UCASE &LCASE '_')
4331    +                 SPAN(&UCASE &LCASE '0123456789_')
4332             WPEND = ANY(',)')
4333             WP4SP = '    '
4334             WP8SP = '	'
        *
        * WRAPPER_STARTFILE(OUTPUT_NAME)
        *
        * OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VAR FOR C FILE
        *
        -PUBLIC WRAPPER_STARTFILE()
4335             DEFINE('WRAPPER_STARTFILE(FN)')        :(WRAPPER_STARTFILE_END)
        *
4336    WRAPPER_STARTFILE
4337             $FN = '/* Generated by WRAPPER on ' DATE() ' */'
4338             $FN =
4339             $FN = '#include "config.h"'
4340             $FN = '#include "h.h"'
4341             $FN = '#include "snotypes.h"'
4342             $FN = '#include "macros.h"'
4343             $FN = '#include "load.h"'
4344             $FN = '#include "equ.h"'
4345             $FN = '#include <string.h>'
4346             $FN =                                                 :(RETURN)
        *
4347    WRAPPER_STARTFILE_END
        *
        -PUBLIC WRAPPER_COBOL()
4348             DEFINE('WRAPPER_COBOL(FN)')                :(WRAPPER_COBOL_END)
        *
4349    WRAPPER_COBOL
4350             $FN = '#include <libcob.h>'                           :(RETURN)
        *
4351    WRAPPER_COBOL_END
        *
        * WRAPPER_PROTO(PROTOTYPE,OUTPUT_NAME)
        *
        * PROTOTYPE:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
        *              C FUNCTION TO CALL IS THE LOWERCASE VERSION
        *              OF THE FUNCTION NAME.
        * OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
        *
        -PUBLIC WRAPPER_PROTO(), C_WRAPPER_PROTO(), COBOL_WRAPPER_PROTO()
        -PUBLIC SCHEME_WRAPPER_PROTO()
4352             DEFINE('WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
4353             DEFINE('C_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4353    +           'WRAPPER_PROTO')
4354             DEFINE('COBOL_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4354    +           'WRAPPER_PROTO')
4355             DEFINE('SCHEME_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4355    +           'WRAPPER_PROTO')                        :(WRAPPER_PROTO_END)
        *
4356    WRAPPER_PROTO
4357             $FN =
4358             $FN = '/* ' PROTO ' */'
4359             PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
4360             N = 0
4361             WPCOPY = 0
4362             TYPES = ARRAY('0:29')
4363             PROTO POS(0) ')' =                                  :S(WPEPARS)
4364    WPLOOP   PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
4365             TYPES<N> = TYPE                                       :F(WPERR)
4366             N = N + 1
4367             WPCOPY = IDENT(TYPE, WPSTRTYPE) WPCOPY + 1
4368             IDENT(C, ')')                              :S(WPEPARS)F(WPLOOP)
4369    WPERR    TERMINAL = 'ERROR IN PROTOTYPE: >' PROTO '<'         :(FRETURN)
4370    WPEPARS  PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
4371             I = 0
4372             $FN = NAME '( LA_ALIST ) LA_DCL'
4373             $FN = '{'
4374             EQ(WPCOPY, 0)                                      :S(WPNOSTRS)
        *
4375    WPLOOP2  IDENT(TYPES<I>, WPSTRTYPE)                          :F(WPNEXT2)
4376             $FN = WP4SP 'char arg' I '[' WPMAXSTR '];'
4377    WPNEXT2  I = I + 1
4378             LT(I, N)                                            :S(WPLOOP2)
        *
4379             I = 0
4380    WPCOPY                                           :($('WPCPY_' TYPES<I>))
4381    WPCPY_STRING
4382             $FN = WP4SP
4382    +              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
4383                                                                  :(WPNCOPY)
4384    WPCPY_LONG
4385    WPCPY_INTEGER
4386    WPCPY_REAL
4387    WPCPY_POINTER
4388    WPCPY_
4389    WPNCOPY  I = I + 1
4390             LT(I, N)                                             :S(WPCOPY)
        *
4391    WPNOSTRS CALL = REPLACE(NAME, &UCASE, &LCASE) '('
4392             I = 0
4393    WPCALL   GE(I, N)                                            :S(WPECALL)
4394             CALL = GT(I, 0) CALL ','                :($('WPARG_' TYPES<I>))
4395    WPARG_POINTER
4396             CALL = CALL '(void *)(long)LA_INT(' I ')'            :(WPNCALL)
4397    WPARG_LONG
4398             CALL = CALL '(long)LA_INT(' I ')'                    :(WPNCALL)
4399    WPARG_INTEGER
4400             CALL = CALL '(int)LA_INT(' I ')'                     :(WPNCALL)
4401    WPARG_REAL
4402             CALL = CALL '(double)LA_REAL(' I ')'                 :(WPNCALL)
4403    WPARG_STRING
4404             CALL = CALL 'arg' I
4405    WPNCALL  I = I + 1                                             :(WPCALL)
4406    WPECALL  CALL = CALL ')'                            :($('WPRET_' PROTO))
        *
4407    WPRET_STRING
4408             $FN = WP4SP 'RETSTR((char *)' CALL ');'               :(WPDONE)
4409    WPRET_STRING2
4410             $FN = WP4SP 'RETSTR2((char *)' CALL ',' LEN ');'      :(WPDONE)
4411    WPRET_STRING_FREE
4412             $FN = WP4SP 'RETSTR_FREE((char *)' CALL ');'          :(WPDONE)
4413    WPRET_POINTER
4414             $FN = WP4SP 'RETINT((long)' CALL ');'                 :(WPDONE)
4415    WPRET_LONG
4416             $FN = WP4SP 'RETINT((long)' CALL ');'                 :(WPDONE)
4417    WPRET_INTEGER
4418             $FN = WP4SP 'RETINT(' CALL ');'                       :(WPDONE)
4419    WPRET_REAL
4420             $FN = WP4SP 'RETREAL(' CALL ');'                      :(WPDONE)
4421    WPRET_PREDICATE
4422             $FN = WP4SP 'if (' CALL ')'
4423             $FN = WP8SP 'RETNULL;'
4424             $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
        * SYSTEM CALL (< 0 FOR FAILURE)
4425    WPRET_SYSPRED
4426             $FN = WP4SP 'if (' CALL ' >= 0)'
4427             $FN = WP8SP 'RETNULL;'
4428             $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
4429    WPRET_
4430             $FN = WP4SP CALL ';'
4431             $FN = WP4SP 'RETNULL;'
        * END OF FUNCTION
4432    WPDONE   $FN = '}'                                             :(RETURN)
        *
4433    WRAPPER_PROTO_END
        *
        * FWRAPPER
        *
        * MAKE WRAPPER FOR FORTRAN FUNCTION
        *
        * SIMILAR TO C WRAPPER, BUT:
        *
        *     - ALL PARAMETERS NEED TO BE COPIED
        *     - STRINGS ARE PASSED AS TWO PARAMETERS
        *     - STRING RETURN IS AN ADDED PARAMETER ON THE FRONT OF THE ARG
        *       LIST
        *
        * FWRAPPER_PROTO(PROTO,FN,LEN)
        *
        * PROTO:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
        *          FORTRAN FUNCTION TO CALL IS THE LOWERCASE VERSION
        *          OF THE FUNCTION NAME WITH _ APPENDED.
        * FN:      THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
        *
        -PUBLIC FWRAPPER_PROTO(), FORTRAN_WRAPPER_PROTO()
4434             DEFINE('FWRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
4435             DEFINE('FORTRAN_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
4435    +           'FWRAPPER_PROTO')                      :(FWRAPPER_PROTO_END)
        *
4436    FWRAPPER_PROTO
4437             $FN =
4438             $FN = '/* FORTRAN ' PROTO ' */'
4439             PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
4440             N = 0
4441             TYPES = ARRAY('0:29')
4442             PROTO POS(0) ')' =                                 :S(FWPEPARS)
4443    FWPLOOP  PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
4444             TYPES<N> = TYPE                                       :F(WPERR)
4445             N = N + 1
4446             IDENT(C, ')')                            :S(FWPEPARS)F(FWPLOOP)
4447    FWPEPARS WPCOPY = N
4448             PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
4449             I = 0
4450             $FN = NAME '( LA_ALIST ) LA_DCL'
4451             $FN = '{'
4452             $FN = IDENT(PROTO, WPREALTYPE)
4452    +           WP4SP 'double ' REPLACE(NAME, &UCASE, &LCASE) '_();'
4453             $FN = IDENT(PROTO, WPSTRTYPE)
4453    +           WP4SP 'char result[' WPMAXSTR '];'
4454             EQ(WPCOPY, 0)                                     :S(FWPNOSTRS)
        *
4455    FWPLOOP2 $FN = IDENT(TYPES<I>, WPSTRTYPE)
4455    +           WP4SP 'char arg' I '[' WPMAXSTR '];'            :S(FWPNEXT2)
4456             $FN = IDENT(TYPES<I>, WPLONGTYPE)
4456    +           WP4SP 'long arg' I ';'                          :S(FWPNEXT2)
4457             $FN = IDENT(TYPES<I>, WPINTTYPE)
4457    +           WP4SP 'int arg' I ';'                           :S(FWPNEXT2)
4458             $FN = IDENT(TYPES<I>, WPREALTYPE)
4458    +           WP4SP 'double arg' I ';'                        :S(FWPNEXT2)
4459    FWPNEXT2 I = I + 1
4460             LT(I, N)                                           :S(FWPLOOP2)
        *
4461             I = 0
4462    FWPCOPY                                         :($('FWPCPY_' TYPES<I>))
4463    FWPCPY_STRING
4464             $FN = WP4SP
4464    +              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
4465                                                                 :(FWPNCOPY)
4466    FWPCPY_LONG
4467             $FN = WP4SP 'arg' I ' = (long)LA_INT(' I ');'       :(FWPNCOPY)
4468    FWPCPY_INTEGER
4469             $FN = WP4SP 'arg' I ' = (int)LA_INT(' I ');'        :(FWPNCOPY)
4470    FWPCPY_REAL
4471             $FN = WP4SP 'arg' I ' = (double)LA_REAL(' I ');'    :(FWPNCOPY)
4472    FWPCPY_
4473    FWPNCOPY I = I + 1
4474             LT(I, N)                                            :S(FWPCOPY)
        *
4475    FWPNOSTRS
4476             CALL = REPLACE(NAME, &UCASE, &LCASE) '_('
4477             I = 0
4478    FWPCALL  GE(I, N)                                           :S(FWPECALL)
4479             CALL = GT(I, 0) CALL ','               :($('FWPARG_' TYPES<I>))
4480    FWPARG_LONG
4481    FWPARG_INTEGER
4482    FWPARG_REAL
4483             CALL = CALL '&arg' I                                :(FWPNCALL)
4484    FWPARG_STRING
4485             CALL = CALL 'arg' I ', strlen(arg' I ')'
4486    FWPNCALL I = I + 1                                            :(FWPCALL)
4487    FWPECALL CALL = CALL ')'                           :($('FWPRET_' PROTO))
        *
4488    FWPRET_STRING
4489             LEN = 1024
4490    FWPRET_STRING2
4491             CALL '()' = '(result, sizeof result)'             :S(FWPRETST2)
4492             CALL '(' = '(result, sizeof result,'
4493    FWPRETST2
4494             CALL = CALL ', result'
4495             $FN = WP4SP 'RETSTR2((' CALL '), ' LEN ');'          :(FWPDONE)
4496    FWPRET_LONG
4497    FWPRET_INTEGER
4498             $FN = WP4SP 'RETINT(' CALL ');'                      :(FWPDONE)
4499    FWPRET_REAL
4500             $FN = WP4SP 'RETREAL(' CALL ');'                     :(FWPDONE)
4501    FWPRET_PREDICATE
4502             $FN = WP4SP 'if (' CALL ')'
4503             $FN = WP8SP 'RETNULL;'
4504             $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
        * SYSTEM CALL (< 0 FOR FAILURE)
4505    FWPRET_SYSPRED
4506             $FN = WP4SP 'if (' CALL ' >= 0)'
4507             $FN = WP8SP 'RETNULL;'
4508             $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
4509    FWPRET_
4510             $FN = WP4SP CALL ';'
4511             $FN = WP4SP 'RETNULL;'
        * END OF FUNCTION
4512    FWPDONE  $FN = '}'                                             :(RETURN)
        *
4513    FWRAPPER_PROTO_END
        *
        * CE: .MSNOBOL4;
        -INCLUDE 'WRTFILE.INC'
        -INCLUDE 'XTERM.INC'
        -MODULE XTERM
        -INCLUDE 'SCOOP.INC'
        -INCLUDE 'HOST.INC'
        -INCLUDE 'CHARS.INC'
        -INCLUDE 'BQ.INC'
        -INCLUDE 'CRACK.INC'
        -INCLUDE 'SEQ.INC'
        -INCLUDE 'UNIX.INC'
        -INCLUDE 'CSNOBOL4.INC'
        -INCLUDE 'DISPLAY.INC'
        -INCLUDE 'READLINE.INC'
        -INCLUDE 'FFI.INC'
        -INCLUDE 'LOGIC.INC'
        -INCLUDE 'P64.INC'
        -INCLUDE 'UNIQUE.INC'
        -INCLUDE 'DDT.INC'
        -IN72
        -STITL XTERM
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                                                                      *
        *             #     #  #######  #######  ######   #     #              *
        *              #   #      #     #        #     #  ##   ##              *
        *               # #       #     #        #     #  # # # #              *
        *                #        #     #####    ######   #  #  #              *
        *               # #       #     #        #   #    #     #              *
        *              #   #      #     #        #    #   #     #              *
        *             #     #     #     #######  #     #  #     #              *
        *                                                                      *
        * XTERM                     XTERM TERMINAL                             *
        *                                                                      *
        ************************************************************************
        *
        * LAUNCH XTERM AS AN EXTERNAL TERMINAL FOR APPLICATIONS. THIS CAN
        * PROVIDE TEXT AND TEK 4014 GRAPHICS. AS WELL, THE READLINE LIBRARY
        * CAN USE THE XTERM TERMINAL.
        *
        -PUBLIC CLASS:XTERM_CLASS
        *
4514             XTERM_CLASS = SEND(CLASS, 'NEW_CLASS', 'XTERM_CLASS')
4515             DEFINE('XTERM_INIT(OPTIONS)')
        *
        -PUBLIC XTERM_CLASS:'INIT'
        *
4516             SEND(XTERM_CLASS, 'ADD_METHOD', 'INIT', 'XTERM_INIT')
        *
        -PUBLIC FDOPEN()
        *
4517             FFI_FDOPEN = FFI_NEW('P', 'I,P')
4518             FFI_SET_CALLP(FFI_FDOPEN, DLSYM(0, 'fdopen'))
4519             DEFINE('FDOPEN(FD,MODE)')
        *
        -PUBLIC XTERM_CLASS:'CLOSE'
        *
4520             DEFINE('XTERM_CLOSE()E')
4521             SEND(XTERM_CLASS, 'ADD_METHOD', 'CLOSE', 'XTERM_CLOSE')
        *
        -PUBLIC XTERM_CLASS:'GET_XTERM'
        *
4522             SEND(XTERM_CLASS, 'ADD_METHOD', 'GET_XTERM', CODE(
4522    +           ' SEND = |.XTERM :(RETURN)'))
        *
        -PUBLIC XTERM_CLASS:'PREP_READLINE'
        *
4523             DEFINE('XTERM_READLINE()')
4524             SEND(XTERM_CLASS, 'ADD_METHOD',
4524    +           'PREP_READLINE', 'XTERM_READLINE')
        *
        -PUBLIC XTERM_CLASS:'NO_READLINE'
        *
4525             DEFINE('XTERM_NOREADLINE()')
4526             SEND(XTERM_CLASS, 'ADD_METHOD',
4526    +           'NO_READLINE', 'XTERM_NOREADLINE')              :(XTERM_END)
        *
4527    XTERM_INIT
4528             XTERM_INIT = SUPER('INIT')
        *
4529             |.RL_INSTREAM = DLSYM(0, 'rl_instream')
4530             |.RL_OUTSTREAM = DLSYM(0, 'rl_outstream')
4531             |.OLD_RL_INSTREAM = PEEK_P(|.RL_INSTREAM)
4532             |.OLD_RL_OUTSTREAM = PEEK_P(|.RL_OUTSTREAM)
4533             |.UNIT = IO_FINDUNIT()
4534             |.XTERM = UNIQUE()
4535             INPUT(|.XTERM, |.UNIT, 'U',
4535    +           '|/usr/bin/xterm -Sxx0 ' OPTIONS ' 2>/dev/null')
4536             OUTPUT(|.XTERM, |.UNIT, 'W,T')
4537             |.ID = $|.XTERM
4538             TERMINAL = |.ID                                       :(RETURN)
        *
4539    FDOPEN   FFI_PAR_N_INTEGER(FFI_FDOPEN, 1, FD)
4540             FFI_PAR_N_STRING(FFI_FDOPEN, 2, MODE)
4541             FDOPEN = FFI_CALL_PTR(FFI_FDOPEN)                     :(RETURN)
        *
        * PREPARE XTERM FOR READLINE/EDITLINE
        *
4542    XTERM_READLINE
4543             |.FILEH = IDENT(|.FILEH)
4543    +           FDOPEN(FILENO(IO_GETFP(|.UNIT)), 'r+')
        *
4544             POKE_P(|.RL_INSTREAM, |.FILEH)
4545             POKE_P(|.RL_OUTSTREAM, |.FILEH)                       :(RETURN)
        *
4546    XTERM_NOREADLINE
4547             POKE_P(|.RL_INSTREAM, |.OLD_RL_INSTREAM)
4548             POKE_P(|.RL_OUTSTREAM, |.OLD_RL_OUTSTREAM)            :(RETURN)
        *
4549    XTERM_CLOSE
4550             HOST(HOST_SYSCMD, '/usr/bin/xkill -id 0x' |.ID ' >/dev/null')
4551             E = &ERRLIMIT
4552             &ERRLIMIT = 1
4553             ENDFILE(|.UNIT)
4554             DETACH(|.XTERM)
4555             &ERRLIMIT = E                                         :(RETURN)
        *
4556    XTERM_END
        *
        * CE: .MSNOBOL4;
        -IN72
        -LINE 188 "ALL.lss"
        -STITL ALL
        -EJECT
        *
        ************************************************************************
        *                                                                      *
        *                         #     #        #                             *
        *                        # #    #        #                             *
        *                       #   #   #        #                             *
        *                      #     #  #        #                             *
        *                      #######  #        #                             *
        *                      #     #  #        #                             *
        *                      #     #  #######  #######                       *
        *                                                                      *
        *                                                                      *
        * ALL                      INCLUDE ALL                                 *
        *                                                                      *
        ************************************************************************
        *
        * ALL.lss
        *
        * CE: .MSNOBOL4;
        -MODULE ENDCARD
        -LINE 8 "ENDCARD.lss"
        -IN72
        -LINE 26 "ENDCARD.lss"
        -STITL ENDCARD
        -EJECT
        ************************************************************************
        *                                                                      *
        *    #######  #     #  ######    #####      #     ######   ######      *
        *    #        ##    #  #     #  #     #    # #    #     #  #     #     *
        *    #        # #   #  #     #  #         #   #   #     #  #     #     *
        *    #####    #  #  #  #     #  #        #     #  ######   #     #     *
        *    #        #   # #  #     #  #        #######  #   #    #     #     *
        *    #        #    ##  #     #  #     #  #     #  #    #   #     #     *
        *    #######  #     #  ######    #####   #     #  #     #  ######      *
        *                                                                      *
        * ENDCARD      AN END CARD FOR USE WITH -M (MULTI-FILE)                *
        *                                                                      *
        ************************************************************************
        *
        * ENDCARD.lss
        *
        * CE: .MSNOBOL4;
        *
        -LINE 11 "ENDCARD.lss"
4557    END
