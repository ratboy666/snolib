#!/usr/bin/bash
         export "SNOLIB=/home/fred/snolib"; export "SNOPATH=/home/fred/snolib"; export "LD_LIBRARY_PATH=/home/fred/snolib"
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-LINE 319 "CGI.lss"
-INCLUDE 'FCGI.INC'
-INCLUDE 'CGI.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'HTMLTMPL.INC'
-INCLUDE 'SESSION.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'DSERVE.INC'
-INCLUDE 'ROUTING.INC'
*
         CGI.tmpl = 'CGI.tmpl'
         &CODE = 1
*
* A CGI APPLICATION IS EITHER A SINGLE-RUN CGI SCRIPT, OR AN FCGI
* (FAST CGI) APPLICATION. AN FCGI APPLICATION WAITS WITH ACCEPT(),
* GATHERS DATA USING PACKETS, AND THEN EXECUTES THE CGI PART. RESPONSES
* ARE SENT WITH PACKETS. THIS IS HANDLED IN THE CGI CLASS, SO AS NOT
* TO REQUIRE WEB APPLICATION CHANGES. FCGI_ACCEPT() WILL HANDLE EITHER
* CGI OR FCGI APPLICATIONS, BUT, IF IT IS KNOWN THAT FCGI WON'T BE
* DEPLOYED, IT CAN BE OMMITED IN THAT CASE.
*
CGI_TOP  FCGI_ACCEPT()
         DSERVE()
*
         BASE_TIME = TIME()
         BASE_ST = &STEXEC
*
* CREATE NEW CGI OBJECT
*
* NOTE THAT THIS IS IN AN ACCEPT LOOP IF FCGI IS IN USE. DATABASE
* ACCESS CAN BE HOISTED OUTSIDE THIS LOOP AS WELL, IN THAT CASE.
*
         CGI = SEND(CGI_CLASS, 'NEW')
*
* GET LOGGING CHANNEL
*
         LOG = SEND(CGI, 'GET_LOG')
*
* LOG ENTRY
*
         $LOG = 'CGI ENTERED'
         $LOG = 'CURRENT DIRECTORY IS ' BQ('pwd')
         $LOG = DIFFER(USE_FCGI) 'FAST CGI'
         $LOG = IDENT(USE_FCGI) 'CGI'
*
* GET THE COOKIE JAR
*
         JAR = SEND(CGI, 'GET_COOKIE_JAR')
*
* LOAD THE SESSION. SESSION ID IS TAKEN FROM COOKIE 'SESSION'. AFTER
* USING THE SESSION COOKIE, DESTROY IT (IT WILL GET RECREATED IF
* NEEDED WHEN THE SESSION IS PERSISTED).
*
         SESSION =
         C = GET_COOKIE_FROM_JAR(JAR, 'SESSION')
         PUT_COOKIE_IN_JAR(JAR, 'SESSION', )
         SESSION = SESSION_LOAD(COOKIE_VALUE(VDIFFER(C)))
*
* CREATE SESSION IF IT DOESN'T EXIST.
*
         SESSION = IDENT(SESSION) SESSION_CREATE(600)
*
* CREATE A PSQL OBJECT. OPEN THE DATABASE, AND GET THE PIPE HANDLE.
* WE WILL LEAVE THE DATABASE OBJECT AROUND, FOR EFFICIENCY WITH
* FCGI.
*
         DIFFER(PSQL)                                      :S(PSQL_CONN)
         PSQL = SEND(PSQL_CLASS, 'NEW')
         &ERRLIMIT = 1
         SEND(PSQL, 'OPEN')
         &ERRLIMIT = 0
         DB = SEND(PSQL, 'GET_PIPE')
PSQL_CONN
*
* SET HEADER
*
         H = SEND(CGI, 'GET_HEADER')
         H<'CONTENT_TYPE'> = 'text/html'
         H<'CHARSET'> = 'UTF-8'
*
* RETRIEVE THE COUNTER COOKIE. IF IT DOESN'T EXIST, CREATE IT.
*
         C = GET_COOKIE_FROM_JAR(JAR, 'COUNTER')
         IDENT(C) PUT_COOKIE_IN_JAR(JAR, 'COUNTER', NEW_COOKIE(0))
*
* CREATE ANOTHER COOKIE 'TESTER' WITH VALUE 'SNOBOL4'
*
         PUT_COOKIE_IN_JAR(JAR, 'TESTER', NEW_COOKIE('SNOBOL4'))
*
* INCREMENT THE VALUE OF THE COUNTER COOKIE. WE VALIDATE THAT THE
* VALUE OF COUNTER IS AN INTEGER.
*
         C = GET_COOKIE_FROM_JAR(JAR, 'COUNTER')
         V = COOKIE_VALUE(C)
         V = ~INTEGER(V) 0
         COOKIE_SET_VALUE(C,  V + 1)
*
* A SESSION VARIABLE
*
         SESSION<'NAME'> = 'FRED'
*
* INCREMENT THE COUNTER SESSION VARIABLE
*
         V = SESSION<'COUNTER'>
         V = ~INTEGER(V) 0
         SESSION<'COUNTER'> = V + 1
*
* PERSIST THE SESSION. THIS SAVES THE SESSION TO DISK AND CREATES
* THE BROWSER COOKIE TO ALLOW THE RETRIEVAL OF THE SESSION LATER.
*
         SESSION_PERSIST(SESSION)                            :F(FRETURN)
         T = SESSION<'EXPIRE_TIME'>
         C = NEW_COOKIE(SESSION<'UUID'>)
         PUT_COOKIE_IN_JAR(JAR, 'SESSION', C)
         COOKIE_SET_CRUMB(C, 'EXPIRES', COOKIE_EXPIRY(T))
*
* READ AND COMPILE THE HTML TEMPLATE. WE CACHE THIS FOR FCGI.
*
         DIFFER(P_TM)                                         :S(NO_T_C)
         S_TM = READFILE('CGI.tmpl')
         P_TM = TMPL_COMPILE(S_TM)
NO_T_C
*
* BUILD TABLE OF VARIABLES TO SUBSTITUTE INTO THE TEMPLATE
* THIS HAS THE RAW COOKIE STRING, THE VALUE OF COUNTER FROM THE
* COOKIE JAR AND THE VALUE OF COUNTER FROM THE SESSION.
*
         A = TABLE()
*
* FROM THE ENV
*
         E = SEND(CGI, 'GET_ENV')
         A<'REQUEST_METHOD'> = E<'REQUEST_METHOD'>
*
* REQUEST URI http://localhost/cgi-bin/cgi.fcgi/x/y?...
* ON GET, APPENDS '/' ACTION TO THE END BEFORE THE ? PART.
*
         A<'REQUEST_URI'> = E<'REQUEST_URI'>
         A<'PATH_INFO'> = E<'PATH_INFO'>
*
* TAKE REQUEST_METHOD, PATH_INFO AND MATCH AGAINST ROUTING PATTERN
*
* V = TABLE()
* R = ROUTING_INIT()
* M = ROUTING(METHOD, PATH, .V)
* A = ACTION
* R = ROUTING_ADD(R, M, A)
*
* (METHOD '\' PATH_INFO) R
* IF SUCCESS, ACTION IS SET, V<> IS FILLED IN
*
* FROM THE COOKIE JAR
*
         A<'COOKIE_COUNTER'> =
+           COOKIE_VALUE(GET_COOKIE_FROM_JAR(JAR, 'COUNTER'))
*
* SESSION VARIABLE
*
         A<'SESSION_COUNTER'> =  SESSION<'COUNTER'>
*
* QUERY VARIABLES
*
         Q = SEND(CGI, 'GET_QUERY')
         A<'FIRST_NAME'> = Q<'firstname'>
         A<'VEHICLE'> = Q<'vehicle'>
*
* INTERPRET THE TEMPLATE WITH THE SUPPLIED VARIABLES
*
         S = TMPL_INTERPRET(P_TM, A)
*
* TRANSMIT THE EXPANDED PAGE TO THE CLIENT
*
         SEND(CGI, 'SET_CONTENT', S)
*
         SEND(CGI, 'SEND')
*
* CLOSE THE DATABASE
*
*        SEND(PSQL, 'CLOSE')
*
* LOG COMPLETION AND SHOW PERFORMANCE DATA
*
         $LOG = 'CGI COMPLETE'
         $LOG = TIME() - BASE_TIME ' MILLISECONDS FOR REQUEST'
         $LOG = &GCTIME  ' IN GARBAGE COLLECTOR (TOTAL)'
         $LOG = &STEXEC - BASE_ST ' STATEMENTS EXECUTED'
*
         SEND(CGI, 'CLOSE')
         &CODE = 0
*
* IF USING FCGI, LOOP BACK TO THE ACCEPT() CALL RATHER THAN EXIT THE
* PROCESS.
*
         DIFFER(USE_FCGI)                                    :S(CGI_TOP)
END
