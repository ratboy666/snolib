-LINE 19 "CSNOBOL4.lss"
-INCLUDE 'P64.INC'
-INCLUDE 'FFI.INC'
-STITL CSNOBOL4
-EJECT
-LINE 609 "CSNOBOL4.lss"
*
************************************************************************
*                                                                      *
*  #####    #####   #     #  #######  ######   #######  #        #   # *
* #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *
* #        #        # #   #  #     #  #     #  #     #  #        #   # *
* #         #####   #  #  #  #     #  ######   #     #  #        ##### *
* #              #  #   # #  #     #  #     #  #     #  #            # *
* #     #  #     #  #    ##  #     #  #     #  #     #  #            # *
*  #####    #####   #     #  #######  ######   #######  #######      # *
*                                                                      *
* CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *
*                                                                      *
************************************************************************
*
* CSNOBOL4.lss
*
-LINE 24 "CSNOBOL4.lss"
-SNOBOL SLOAD('BQ.INC')
-LINE 25 "CSNOBOL4.lss"
-SNOBOL SLOAD('DYNAMIC.INC')
-LINE 26 "CSNOBOL4.lss"
-SNOBOL SLOAD('WRAPPER.INC')
-LINE 27 "CSNOBOL4.lss"
-SNOBOL SLOAD('CRACK.INC')
-LINE 28 "CSNOBOL4.lss"
-SNOBOL SLOAD('SEQ.INC')
-LINE 29 "CSNOBOL4.lss"
-SNOBOL TERMINAL = 'CSNOBOL4 (MON NOV 11 12:50:40 EST 2013)'
-LINE 30 "CSNOBOL4.lss"
-LINE 33 "CSNOBOL4.lss"
-EMBED C 'format'
#line 37 "CSNOBOL4.lss"
-SNOBOL WRAPPER_STARTFILE(.EMBED)
#line 38 "CSNOBOL4.lss"

/* Adds FORTRAN IV FORMAT to CSNOBOL4 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
#include "p64.h"

static int status;

static int pipefds[2];

static int createpipe(void)
{
    return pipe(pipefds);
}

-SNOBOL C_WRAPPER_PROTO('CREATEPIPE()INTEGER', .EMBED)
#line 62 "CSNOBOL4.lss"

static int getpipefd(int n)
{
    if ((n < 0) || (n > 1))
        return -1;
    return pipefds[n];
}

-SNOBOL C_WRAPPER_PROTO('GETPIPEFD(INTEGER)INTEGER', .EMBED)
#line 71 "CSNOBOL4.lss"

static int get_errno(void)
{
    return errno;
}

-SNOBOL C_WRAPPER_PROTO('GET_ERRNO()INTEGER', .EMBED)
#line 78 "CSNOBOL4.lss"

/* fd_set holds a set of file descriptors. On 64 bit Linux, this is
 * a 128 byte object. This may be as little as 4 bytes on some systems
 * (which would limit the number of fd's to 32).
 */

static int sizeof_timeval(void)
{
    return sizeof (struct timeval);
}

-SNOBOL C_WRAPPER_PROTO('SIZEOF_TIMEVAL()INTEGER', .EMBED)
#line 90 "CSNOBOL4.lss"

static int set_timeval_(int sec, int usec)
{
    struct timeval *tv = p;
    tv->tv_sec = sec;
    tv->tv_usec = usec;
}

-SNOBOL C_WRAPPER_PROTO('SET_TIMEVAL_(INTEGER,INTEGER)', .EMBED)
#line 99 "CSNOBOL4.lss"

static int sizeof_fd_set(void)
{
    return sizeof (fd_set);
}

-SNOBOL C_WRAPPER_PROTO('SIZEOF_FD_SET()INTEGER', .EMBED)
#line 106 "CSNOBOL4.lss"

static int fd_isset_(int fd)
{
    return FD_ISSET(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_ISSET_(INTEGER)INTEGER', .EMBED)
#line 113 "CSNOBOL4.lss"

static void fd_zero_(void)
{
    FD_ZERO((fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_ZERO_()', .EMBED)
#line 120 "CSNOBOL4.lss"

static void fd_clr(int fd)
{
    FD_ClR(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_CLR_(INTEGER)', .EMBED)
#line 127 "CSNOBOL4.lss"

static void fd_set_(int fd)
{
    FD_SET(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_SET_(INTEGER)', .EMBED)
#line 134 "CSNOBOL4.lss"

static int clear_errno(void)
{
    errno = 0;
}

-SNOBOL C_WRAPPER_PROTO('CLEAR_ERRNO()', .EMBED)
#line 141 "CSNOBOL4.lss"

static int waitpid_(int pid, int options)
{
    return waitpid(pid, &status, options);
}

-SNOBOL C_WRAPPER_PROTO('WAITPID_(INTEGER,INTEGER)INTEGER', .EMBED)
#line 148 "CSNOBOL4.lss"

static int get_status(void)
{
    return status;
}

-SNOBOL C_WRAPPER_PROTO('GET_STATUS()INTEGER', .EMBED)
#line 155 "CSNOBOL4.lss"

static int format(char **in_s, char **fmt, char **buf, char **limit,
           char **base, int reps, int level)
{
    int w, r;
    char *bfmt = *fmt;
    char c;
    int aseen = 0;

    for (; reps; --reps) {
	for (*fmt = bfmt; **fmt;) {
	    while ((**fmt == ',') || (**fmt == ' ')) {
		++*fmt;
	    }
	    if (isdigit(**fmt)) {
		r = 0;
		while (isdigit(**fmt)) {
		    r = r * 10 + **fmt - '0';
		    ++*fmt;
		}
		r &= 0xff;
	    } else {
		r = -1;
	    }
	    c = **fmt;
	    ++*fmt;
	    switch (c) {
		case ',': break;
		case 'X':
		    if (r < 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = ' ';
			++*buf;
		    }
		    break;
		case 'A':
		    ++aseen;
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - '0';
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (r < 0) {
			r = 1;
		    }
		    r *= w;
		    for (; r; --r) {
			if (**in_s == 0) {
			    break;
			}
			**buf = **in_s;
			++*buf;
			++*in_s;
		    }
		    for (; r; --r) {
			**buf = ' ';
			++*buf;
		    }
		    break;
		case '/':
		    if (r < 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = '\n';
			++*buf;
			*base = *buf;
		    }
		    break;
		case '\'':
		    for (;;) {
			if (**fmt == 0) {
			    fprintf(stderr,
                   "ftn_format: missing close \' in string constant\n");
			    return 1;
			}
			if (**fmt == '\'') {
			    ++*fmt;
			    if (**fmt == '\'') {
				**buf = '\'';
				++*buf;
				++*fmt;
			    } else {
				break;
			    }
			} else {
			    **buf = **fmt;
			    ++*buf;
			    ++*fmt;
			}
		    }
		    break;
		case 'H':
		    if (r == 0) {
			break;
		    }
		    for (; r; --r) {
			if (**fmt == 0) {
			    fprintf(stderr,
                          "ftn_format: Hollerith constant too short\n");
			    return 1;
			}
			**buf = **fmt;
			++*buf;
			++*fmt;
		    }
		    break;
		case 'T': /* T TL TR */
		    if (**fmt == 'R') {
			c = 'R';
			++*fmt;
		    } else if (**fmt == 'L') {
			c = 'L';
			++*fmt;
		    }
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - '0';
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (c == 'L') {
			*buf -= w;
		    } else if (c == 'R') {
			*buf += w;
		    } else {
			*buf = *base + w - 1;
		    }
		    break;
		case ')':
		    if (**in_s == 0) {
			return 0;
		    }
		    if ((level == 1) && **in_s) {
			reps = 2;
			goto btm;
		    }
		    if ((level > 1) && (reps > 1)) {
			goto btm;
		    }
		    if ((level > 1) && (reps < 0) && (aseen == 0)) {
			return 0;
		    }
		    goto btm;
		    return 0;
		case '(':
		    r = format(in_s, fmt, buf, limit, base,
			       r, level + 1);
		    if (r) {
			return r;
		    }
		    break;
		default:
		    if (c == 0) {
			fprintf(stderr,
                               "ftn_format: premature end of format\n");
		    } else {
			fprintf(stderr,
                           "ftn_format: bad format character: %c\n", c);
		    }
		    return 1;
	    }
	    if (*limit < *buf) {
		*limit = *buf;
	    }
	}
btm: ;
    }
    return 0;
}

static char *ftn_format(char *s, char *f)
{
    char *in_s, *fmt, *buf, *limit, *base, *b;
    int r;

    /* format state */
    base = malloc(4096);
    fmt = f;
    in_s = s;
    buf = base;
    limit = base;
    b = base;

    for (r = 0; r < 4096; ++r) {
	base[r] = ' ';
    }
    if (*fmt != '(') {
	fprintf(stderr, "ftn_format: missing begin (\n");
	goto err;
    }
    if (*(fmt + strlen(fmt) - 1)  != ')') {
	fprintf(stderr, "ftn_format: missing end )\n");
	goto err;
    }

    ++fmt;
    r = format(&in_s, &fmt, &buf, &limit, &b, 1, 1);
    if (r == 0) {
	*limit = 0;
	return base;
    }
err:
    free(base);
    return NULL;
}

/* FTN_FORMAT(STRING,STRING)STRING_FREE
 *
 * First STRING is the FORMAT, second is the FORMAT
 */
FTN_FORMAT( LA_ALIST ) LA_DCL
{
    char *result;
    char data[4096];
    char format[1024];
    getstring(LA_PTR(0), format, sizeof(format));
    getstring(LA_PTR(1), data, sizeof(data));
    result = ftn_format(data, format);
    if (result == NULL)
	RETFAIL;
    RETSTR_FREE(result);
}
-END
-LINE 391 "CSNOBOL4.lss"
-SNOBOL DYNAMIC_DEBUG = 1
-LINE 392 "CSNOBOL4.lss"
-SNOBOL COMPILE_DYNAMIC(format) :F(ERROR) ;
-LINE 393 "CSNOBOL4.lss"
-SNOBOL P64 = BQ('pwd') '/p64.so'
-LINE 394 "CSNOBOL4.lss"
-SNOBOL LIBS = P64
-LINE 395 "CSNOBOL4.lss"
-SNOBOL OBJECTS = format ; OBJECTS '.c' = '.o'
-LINE 396 "CSNOBOL4.lss"
-SNOBOL LINK_DYNAMIC('./format', OBJECTS, LIBS) :F(ERROR) ;
-LINE 397 "CSNOBOL4.lss"
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS FORMAT.SO
-SNOBOL A = CRACK(format ' ' OBJECTS, ' ')
-LINE 401 "CSNOBOL4.lss"
-SNOBOL SEQ(' DELETE(A<K>) ', .K)
-LINE 402 "CSNOBOL4.lss"
-LINE 408 "CSNOBOL4.lss"
-PUBLIC FORK()
         LOAD('FORK()INTEGER')
-LINE 416 "CSNOBOL4.lss"
-PUBLIC WAIT()
         LOAD('WAIT()INTEGER')
-LINE 437 "CSNOBOL4.lss"
-PUBLIC SPRINTF()
         LOAD('SPRINTF(STRING,)STRING')
-LINE 499 "CSNOBOL4.lss"
-PUBLIC FTN_FORMAT(), CREATEPIPE(), GETPIPEFD(), GET_ERRNO()
-PUBLIC CLEAR_ERRNO(), WAITPID(), GET_STATUS(), SIZEOF_TIMEVAL()
-PUBLIC SET_TIMEVAL(), SIZEOF_FD_SET, FD_ZERO(), FD_CLR(), FD_SET()
-PUBLIC FD_ISSET()
         LOAD('FTN_FORMAT(STRING,STRING)STRING', 'format.so')
         LOAD('CREATEPIPE()INTEGER', 'format.so')
         LOAD('GETPIPEFD(INTEGER)INTEGER', 'format.so')
         LOAD('GET_ERRNO()INTEGER', 'format.so')
         LOAD('CLEAR_ERRNO()', 'format.so')
         LOAD('WAITPID_(INTEGER,INTEGER)INTEGER', 'format.so')
         LOAD('GET_STATUS()INTEGER', 'format.so')
         LOAD('SIZEOF_TIMEVAL()INTEGER', 'format.so')
         LOAD('SET_TIMEVAL_()', 'format.so')
         LOAD('SIZEOF_FD_SET()INTEGER', 'format.so')
         LOAD('FD_ZERO_()', 'format.so')
         LOAD('FD_CLR_(INTEGER)', 'format.so')
         LOAD('FD_SET_(INTEGER)', 'format.so')
         LOAD('FD_ISSET_(INTEGER)INTEGER', 'format.so')
         DEFINE('FD_ZERO(FD_SET)')
         DEFINE('FD_CLR(FD,FD_SET)')
         DEFINE('FD_ISSET(FD,FD_SET)')
         DEFINE('FD_SET(FD,FD_SET)')
         DEFINE('SET_TIMEVAL(TV,SEC,USEC)')
-LINE 535 "CSNOBOL4.lss"
-PUBLIC CLOSE(), SELECT(), IO_GETFP(), FILENO()
         CLOSE_FFI = FFI_NEW('I', 'I')
         FFI_SET_CALLP(CLOSE_FFI, DLSYM(0, 'close'))
         DEFINE('CLOSE(FD)')
         SELECT_FFI = FFI_NEW('I', 'I,P,P,P,P')
         FFI_SET_CALLP(SELECT_FFI, DLSYM(0, 'select'))
         DEFINE('SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)')
         IO_GETFP_FFI = FFI_NEW('P', 'I')
         FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, 'io_getfp'))
         FILENO_FFI = FFI_NEW('I', 'P')
         FFI_SET_CALLP(FILENO_FFI, DLSYM(0, 'fileno'))
         DEFINE('IO_GETFP(UNIT)')
         DEFINE('FILENO(FP)')                            :(CSNOBOL4_END)
*
CLOSE    FFI_PAR_N_INTEGER(CLOSE_FFI, 1, FD)
         CLOSE = FFI_CALL_INTEGER(CLOSE_FFI)                   :(RETURN)

SET_TIMEVAL
         SET_P(TV)
         SET_TIMEVAL_(SEC, USEC)                               :(RETURN)

FD_CLR   SET_P(FD_SET)
         FD_CLR_(FD)                                           :(RETURN)
*
FD_ISSET SET_P(FD_SET)
         FD_ISSET = FD_ISSET_(FD)                              :(RETURN)
*
FD_SET   SET_P(FD_SET)
         FD_SET_(FD)                                           :(RETURN)
*
FD_ZERO  SET_P(FD_SET)
         FD_ZERO_()                                            :(RETURN)
*
IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
         IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 :(RETURN)
*
FILENO   FFI_PAR_N_PTR(FILENO_FFI, 1, FP)
         FILENO = FFI_CALL_INTEGER(FILENO_FFI)                 :(RETURN)
*
SELECT   FFI_PAR_N_INTEGER(SELECT_FFI, 1, NFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 2, READFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 3, WRITEFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 4, EXCEPTFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 5, TIMEOUT)
         SELECT = FFI_CALL_INTEGER(SELECT_FFI)                 :(RETURN)
*
CSNOBOL4_END
*
* CE: .MSNOBOL4;
