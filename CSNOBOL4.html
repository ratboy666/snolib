<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CSNOBOL4 - Functions specific to CSNOBOL4</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
These are functions specific to <font face="Source Code Pro">CSNOBOL4</font> and Unix or Unix-like
systems.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
We use FFI to access io_getfp() to retrieve the FILE * for a unit.
This allows proper implementation of pipe i/o where CSNOBOL4 1.5
has problems.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FORK()</font>, <font face="Source Code Pro">WAIT()</font>, and <font face="Source Code Pro">SPRINTF()</font> are in the CSNOBOL4 image.
<font face="Source Code Pro">FTN_FORMAT()</font> is in an external module. <font face="Source Code Pro">IO_GETFP()</font> is also in
the image, and <font face="Source Code Pro">FILENO()</font> is available in <font face="Source Code Pro">clib</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Added more functions here to create pipes, close file handles,
handle fd sets -- these should be in a <font face="Source Code Pro">UNIX</font> component. fileno()
actually belongs there as well, as does fork() and wait().
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;P64.INC&#39;
-INCLUDE &#39;FFI.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-SNOBOL SLOAD(&#39;BQ.INC&#39;)
-SNOBOL SLOAD(&#39;DYNAMIC.INC&#39;)
-SNOBOL SLOAD(&#39;WRAPPER.INC&#39;)
-SNOBOL SLOAD(&#39;CRACK.INC&#39;)
-SNOBOL SLOAD(&#39;SEQ.INC&#39;)
-SNOBOL TERMINAL = &#39;CSNOBOL4 (MON NOV 11 12:50:40 EST 2013)&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-EMBED C &#39;format&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4,TYPE=C&raquo;&equiv;</b>
-SNOBOL WRAPPER_STARTFILE(.EMBED)

/* Adds FORTRAN IV FORMAT to CSNOBOL4 */

<font color="#818181"><i>#include &lt;stdio.h&gt;</i></font>
<font color="#818181"><i>#include &lt;stdlib.h&gt;</i></font>
<font color="#818181"><i>#include &lt;ctype.h&gt;</i></font>
<font color="#818181"><i>#include &lt;errno.h&gt;</i></font>
<font color="#818181"><i>#include &lt;time.h&gt;</i></font>
<font color="#818181"><i>#include &lt;sys/select.h&gt;</i></font>
<font color="#818181"><i>#include &lt;sys/time.h&gt;</i></font>
<font color="#818181"><i>#include &lt;sys/types.h&gt;</i></font>
<font color="#818181"><i>#include &lt;unistd.h&gt;</i></font>
<font color="#818181"><i>#include &quot;p64.h&quot;</i></font>

static int status;

static int pipefds[2];

static int createpipe(void)
{
    return pipe(pipefds);
}

-SNOBOL C_WRAPPER_PROTO(&#39;CREATEPIPE()INTEGER&#39;, .EMBED)

static int getpipefd(int n)
{
    if ((n &lt; 0) || (n &gt; 1))
        return -1;
    return pipefds[n];
}

-SNOBOL C_WRAPPER_PROTO(&#39;GETPIPEFD(INTEGER)INTEGER&#39;, .EMBED)

static int get_errno(void)
{
    return errno;
}

-SNOBOL C_WRAPPER_PROTO(&#39;GET_ERRNO()INTEGER&#39;, .EMBED)

/* fd_set holds a set of file descriptors. On 64 bit Linux, this is
 * a 128 byte object. This may be as little as 4 bytes on some systems
 * (which would limit the number of fd&#39;s to 32).
 */

static int sizeof_timeval(void)
{
    return sizeof (struct timeval);
}

-SNOBOL C_WRAPPER_PROTO(&#39;SIZEOF_TIMEVAL()INTEGER&#39;, .EMBED)

static int set_timeval_(int sec, int usec)
{
    struct timeval *tv = get_p_();
    tv-&gt;tv_sec = sec;
    tv-&gt;tv_usec = usec;
}

-SNOBOL C_WRAPPER_PROTO(&#39;SET_TIMEVAL_(INTEGER,INTEGER)&#39;, .EMBED)

static int sizeof_fd_set(void)
{
    return sizeof (fd_set);
}

-SNOBOL C_WRAPPER_PROTO(&#39;SIZEOF_FD_SET()INTEGER&#39;, .EMBED)

static int fd_isset_(int fd)
{
    return FD_ISSET(fd, (fd_set *)get_p_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_ISSET_(INTEGER)INTEGER&#39;, .EMBED)

static void fd_zero_(void)
{
    FD_ZERO((fd_set *)get_p_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_ZERO_()&#39;, .EMBED)

static void fd_clr(int fd)
{
    FD_ClR(fd, (fd_set *)get_p_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_CLR_(INTEGER)&#39;, .EMBED)

static void fd_set_(int fd)
{
    FD_SET(fd, (fd_set *)get_p_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_SET_(INTEGER)&#39;, .EMBED)

static int clear_errno(void)
{
    errno = 0;
}

-SNOBOL C_WRAPPER_PROTO(&#39;CLEAR_ERRNO()&#39;, .EMBED)

static int waitpid_(int pid, int options)
{
    return waitpid(pid, &amp;status, options);
}

-SNOBOL C_WRAPPER_PROTO(&#39;WAITPID_(INTEGER,INTEGER)INTEGER&#39;, .EMBED)

static int get_status(void)
{
    return status;
}

-SNOBOL C_WRAPPER_PROTO(&#39;GET_STATUS()INTEGER&#39;, .EMBED)

static int format(char **in_s, char **fmt, char **buf, char **limit,
           char **base, int reps, int level)
{
    int w, r;
    char *bfmt = *fmt;
    char c;
    int aseen = 0;

    for (; reps; --reps) {
	for (*fmt = bfmt; **fmt;) {
	    while ((**fmt == &#39;,&#39;) || (**fmt == &#39; &#39;)) {
		++*fmt;
	    }
	    if (isdigit(**fmt)) {
		r = 0;
		while (isdigit(**fmt)) {
		    r = r * 10 + **fmt - &#39;0&#39;;
		    ++*fmt;
		}
		r &amp;= 0xff;
	    } else {
		r = -1;
	    }
	    c = **fmt;
	    ++*fmt;
	    switch (c) {
		case &#39;,&#39;: break;
		case &#39;X&#39;:
		    if (r &lt; 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = &#39; &#39;;
			++*buf;
		    }
		    break;
		case &#39;A&#39;:
		    ++aseen;
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - &#39;0&#39;;
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (r &lt; 0) {
			r = 1;
		    }
		    r *= w;
		    for (; r; --r) {
			if (**in_s == 0) {
			    break;
			}
			**buf = **in_s;
			++*buf;
			++*in_s;
		    }
		    for (; r; --r) {
			**buf = &#39; &#39;;
			++*buf;
		    }
		    break;
		case &#39;/&#39;:
		    if (r &lt; 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = &#39;\n&#39;;
			++*buf;
			*base = *buf;
		    }
		    break;
		case &#39;\&#39;&#39;:
		    for (;;) {
			if (**fmt == 0) {
			    fprintf(stderr,
                   &quot;ftn_format: missing close \&#39; in string constant\n&quot;);
			    return 1;
			}
			if (**fmt == &#39;\&#39;&#39;) {
			    ++*fmt;
			    if (**fmt == &#39;\&#39;&#39;) {
				**buf = &#39;\&#39;&#39;;
				++*buf;
				++*fmt;
			    } else {
				break;
			    }
			} else {
			    **buf = **fmt;
			    ++*buf;
			    ++*fmt;
			}
		    }
		    break;
		case &#39;H&#39;:
		    if (r == 0) {
			break;
		    }
		    for (; r; --r) {
			if (**fmt == 0) {
			    fprintf(stderr,
                          &quot;ftn_format: Hollerith constant too short\n&quot;);
			    return 1;
			}
			**buf = **fmt;
			++*buf;
			++*fmt;
		    }
		    break;
		case &#39;T&#39;: /* T TL TR */
		    if (**fmt == &#39;R&#39;) {
			c = &#39;R&#39;;
			++*fmt;
		    } else if (**fmt == &#39;L&#39;) {
			c = &#39;L&#39;;
			++*fmt;
		    }
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - &#39;0&#39;;
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (c == &#39;L&#39;) {
			*buf -= w;
		    } else if (c == &#39;R&#39;) {
			*buf += w;
		    } else {
			*buf = *base + w - 1;
		    }
		    break;
		case &#39;)&#39;:
		    if (**in_s == 0) {
			return 0;
		    }
		    if ((level == 1) &amp;&amp; **in_s) {
			reps = 2;
			goto btm;
		    }
		    if ((level &gt; 1) &amp;&amp; (reps &gt; 1)) {
			goto btm;
		    }
		    if ((level &gt; 1) &amp;&amp; (reps &lt; 0) &amp;&amp; (aseen == 0)) {
			return 0;
		    }
		    goto btm;
		    return 0;
		case &#39;(&#39;:
		    r = format(in_s, fmt, buf, limit, base,
			       r, level + 1);
		    if (r) {
			return r;
		    }
		    break;
		default:
		    if (c == 0) {
			fprintf(stderr,
                               &quot;ftn_format: premature end of format\n&quot;);
		    } else {
			fprintf(stderr,
                           &quot;ftn_format: bad format character: %c\n&quot;, c);
		    }
		    return 1;
	    }
	    if (*limit &lt; *buf) {
		*limit = *buf;
	    }
	}
btm: ;
    }
    return 0;
}

static char *ftn_format(char *s, char *f)
{
    char *in_s, *fmt, *buf, *limit, *base, *b;
    int r;

    /* format state */
    base = malloc(4096);
    fmt = f;
    in_s = s;
    buf = base;
    limit = base;
    b = base;

    for (r = 0; r &lt; 4096; ++r) {
	base[r] = &#39; &#39;;
    }
    if (*fmt != &#39;(&#39;) {
	fprintf(stderr, &quot;ftn_format: missing begin (\n&quot;);
	goto err;
    }
    if (*(fmt + strlen(fmt) - 1)  != &#39;)&#39;) {
	fprintf(stderr, &quot;ftn_format: missing end )\n&quot;);
	goto err;
    }

    ++fmt;
    r = format(&amp;in_s, &amp;fmt, &amp;buf, &amp;limit, &amp;b, 1, 1);
    if (r == 0) {
	*limit = 0;
	return base;
    }
err:
    free(base);
    return NULL;
}

/* FTN_FORMAT(STRING,STRING)STRING_FREE
 *
 * First STRING is the FORMAT, second is the FORMAT
 */
FTN_FORMAT( LA_ALIST ) LA_DCL
{
    char *result;
    char data[4096];
    char format[1024];
    getstring(LA_PTR(0), format, sizeof(format));
    getstring(LA_PTR(1), data, sizeof(data));
    result = ftn_format(data, format);
    if (result == NULL)
	RETFAIL;
    RETSTR_FREE(result);
}
-END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(format) :F(ERROR) ;
-SNOBOL LIBS = &#39;-L. -lp64&#39;
-SNOBOL OBJECTS = format ; OBJECTS &#39;.c&#39; = &#39;.o&#39;
-SNOBOL LINK_DYNAMIC(&#39;./format&#39;, OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON&#39;T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS format.so
-CMNT -SNOBOL A = CRACK(format &#39; &#39; OBJECTS, &#39; &#39;)
-CMNT -SNOBOL SEQ(&#39; DELETE(A&lt;K&gt;) &#39;, .K)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FORK()</font> copies the current process, and returns the pid (process
identifier) of the new process. In the child, it returns 0.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC FORK()
         LOAD(&#39;FORK()INTEGER&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">WAIT()</font> waits for the completion of a child process. It returns the
pid of the child process that has terminated, or negative on error.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC WAIT()
         LOAD(&#39;WAIT()INTEGER&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
To exit a child process, Unix supplies <font face="Source Code Pro">exit()</font>. However, <font face="Source Code Pro">EXIT()</font>
causes execution of new image in <font face="Source Code Pro">CSNOBOL4</font>. To exit a process,
assign the result status to <font face="Source Code Pro">&amp;CODE</font> and branch to <font face="Source Code Pro">END</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     &amp;CODE = 0  :(END)
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SPRINTF(F,V)</font> formats an <font face="Source Code Pro">INTEGER</font> or <font face="Source Code Pro">REAL</font> value <font face="Source Code Pro">V</font> using
the <font face="Source Code Pro">C</font> format <font face="Source Code Pro">F</font> and returns the result as a string. For example:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     SPRINTF("%d", I)
|     SPRINTF("%g", X)
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC SPRINTF()
         LOAD(&#39;SPRINTF(STRING,)STRING&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FTN_FORMAT(F, S)</font> formats string <font face="Source Code Pro">S</font> using <font face="Source Code Pro">FORTRAN IV FORMAT</font>
<font face="Source Code Pro">F</font> and returns the result as a string. <font face="Source Code Pro">CSNOBOL4</font> doesn't (natively)
support <font face="Source Code Pro">FORTRAN IV FORMAT</font> but this function provides the missing
support.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
FORMAT codes supported are
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     N H        Hollerith
|     N A M      Alphanumeric
|     N X        Spacing
|     T N        Tab to column N
|     TL N       Tab left by N
|     TR N       Tab right by N
|     N /        Record end
|     'TEXT'     Use '' for single '
|     N ( ... )  Grouping with repetition
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Other <font face="Source Code Pro">FORTRAN IV</font> conversion (I, F, etc.) not supported. FORMAT and
DATA limited to 1023 characters. Z conversion is not supported.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
When outputing to a printer, FORTRAN convention is that the first
character of the line controls line spacing and paging.The <font face="Source Code Pro">asa</font>
and <font face="Source Code Pro">asapdf</font> utilities interpret such print files. Generally, a
printer page is 132 columns by 60 lines. <font face="Source Code Pro">asa</font> specifies 4 characters
for control:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     ' '   Single line space
|     '0'   Double line space
|     '1'   New page
|     '+'   Overprint line
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The <font face="Source Code Pro">asapdf</font> utility takes an <font face="Source Code Pro">ASA</font> file, and encodes to <font face="Source Code Pro">PDF</font>.
<font face="Source Code Pro">asapdf</font> adds the following line controls:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     '-'   Triple line space (IBM extension)
|     'H'   Half line adance
|     'R'   No line advance, print RED
|     'G'   No line advance, print GREEN
|     'B'   No line advance, print BLUE
|     'r'   Advance, print RED
|     'g'   Advance, print GREEN
|     'b'   Advance, print BLUE
|     '^'   Overprint line, adding 127 to characters
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
MAINBOL default formats
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     OUTPUT  (1X,132A1)
|     CARD    (80A1)
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC FTN_FORMAT(), CREATEPIPE(), GETPIPEFD(), GET_ERRNO()
-PUBLIC CLEAR_ERRNO(), WAITPID(), GET_STATUS(), SIZEOF_TIMEVAL()
-PUBLIC SET_TIMEVAL(), SIZEOF_FD_SET, FD_ZERO(), FD_CLR(), FD_SET()
-PUBLIC FD_ISSET()
         LOAD(&#39;FTN_FORMAT(STRING,STRING)STRING&#39;, &#39;format.so&#39;)
         LOAD(&#39;CREATEPIPE()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;GETPIPEFD(INTEGER)INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;GET_ERRNO()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;CLEAR_ERRNO()&#39;, &#39;format.so&#39;)
         LOAD(&#39;WAITPID_(INTEGER,INTEGER)INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;GET_STATUS()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;SIZEOF_TIMEVAL()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;SET_TIMEVAL_()&#39;, &#39;format.so&#39;)
         LOAD(&#39;SIZEOF_FD_SET()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_ZERO_()&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_CLR_(INTEGER)&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_SET_(INTEGER)&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_ISSET_(INTEGER)INTEGER&#39;, &#39;format.so&#39;)
         DEFINE(&#39;FD_ZERO(FD_SET)&#39;)
         DEFINE(&#39;FD_CLR(FD,FD_SET)&#39;)
         DEFINE(&#39;FD_ISSET(FD,FD_SET)&#39;)
         DEFINE(&#39;FD_SET(FD,FD_SET)&#39;)
         DEFINE(&#39;SET_TIMEVAL(TV,SEC,USEC)&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
We want to retrieve the FILE * for a unit. This can be used to perform
other forms of i/o, or to retrieve the underlying file descriptor.
Use FFI to access <font face="Source Code Pro">io_getfp()</font> and <font face="Source Code Pro">fileno()</font>. There may be a
bug in CSNOBOL4 1.5. When doing I/O using <font face="Source Code Pro">fgets()</font> (normal line
oriented) to a bi-direction pipe, we get errno 29 (ESPIPE) errors,
indicating that seek on the pipe failed. Of course, we can't seek
on the pipe; this is done solely to separate read and write. But,
there may be a timing issue because there are two separate processes
involved.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC CLOSE(), SELECT(), IO_GETFP(), FILENO()
         CLOSE_FFI = FFI_NEW(&#39;I&#39;, &#39;I&#39;)
         FFI_SET_CALLP(CLOSE_FFI, DLSYM(0, &#39;close&#39;))
         DEFINE(&#39;CLOSE(FD)&#39;)
         SELECT_FFI = FFI_NEW(&#39;I&#39;, &#39;I,P,P,P,P&#39;)
         FFI_SET_CALLP(SELECT_FFI, DLSYM(0, &#39;select&#39;))
         DEFINE(&#39;SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)&#39;)
         IO_GETFP_FFI = FFI_NEW(&#39;P&#39;, &#39;I&#39;)
         FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, &#39;io_getfp&#39;))
         FILENO_FFI = FFI_NEW(&#39;I&#39;, &#39;P&#39;)
         FFI_SET_CALLP(FILENO_FFI, DLSYM(0, &#39;fileno&#39;))
         DEFINE(&#39;IO_GETFP(UNIT)&#39;)
         DEFINE(&#39;FILENO(FP)&#39;)                            <b>:(CSNOBOL4_END)</b>
<font color="#818181"><i>*</i></font>
CLOSE    FFI_PAR_N_INTEGER(CLOSE_FFI, 1, FD)
         CLOSE = FFI_CALL_INTEGER(CLOSE_FFI)                   <b>:(RETURN)</b>

SET_TIMEVAL
         SET_P(TV)
         SET_TIMEVAL_(SEC, USEC)                               <b>:(RETURN)</b>

FD_CLR   SET_P(FD_SET)
         FD_CLR_(FD)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_ISSET SET_P(FD_SET)
         FD_ISSET = FD_ISSET_(FD)                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_SET   SET_P(FD_SET)
         FD_SET_(FD)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_ZERO  SET_P(FD_SET)
         FD_ZERO_()                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
         IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FILENO   FFI_PAR_N_PTR(FILENO_FFI, 1, FP)
         FILENO = FFI_CALL_INTEGER(FILENO_FFI)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SELECT   FFI_PAR_N_INTEGER(SELECT_FFI, 1, NFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 2, READFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 3, WRITEFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 4, EXCEPTFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 5, TIMEOUT)
         SELECT = FFI_CALL_INTEGER(SELECT_FFI)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CSNOBOL4_END
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Open /dev/stdout (fd 1) as unit 10. Write to new I/O variable.
Obtain the FILE * (file pointer) for unit 10. Obtain the underlying
FD for the file pointer. Display both file pointer and file number,
and confirm that FD is 1.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CSNOBOL4.INC&#39;
         &amp;CODE = 1
         OUTPUT(.T_OUT, 10,, &#39;/dev/stdout&#39;)
         T_OUT = &#39;HELLO, WORLD&#39;
         FP = IO_GETFP(10)
         FD = FILENO(FP)
         OUTPUT = &#39;FILE * = &#39; FP
         OUTPUT = &#39;FD     = &#39; FD
         EQ(FD, 1)                                               <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL CSNOBOL4
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*  #####    #####   #     #  #######  ######   #######  #        #   # *</i></font>
<font color="#818181"><i>* #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *</i></font>
<font color="#818181"><i>* #        #        # #   #  #     #  #     #  #     #  #        #   # *</i></font>
<font color="#818181"><i>* #         #####   #  #  #  #     #  ######   #     #  #        ##### *</i></font>
<font color="#818181"><i>* #              #  #   # #  #     #  #     #  #     #  #            # *</i></font>
<font color="#818181"><i>* #     #  #     #  #    ##  #     #  #     #  #     #  #            # *</i></font>
<font color="#818181"><i>*  #####    #####   #     #  #######  ######   #######  #######      # *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CSNOBOL4.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CSNOBOL4&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Wed Jun  4 04:34:36 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
