<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DDT - An Interactive SNOBOL4 Debugger</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<i>DDT</i> is a source level debugger for CSNOBOL4.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">INCLUDE 'DDT.INC'</font> into the program to be debugged. At the point
that the debugger should be activated, insert the statement
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|    DDT()
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
which will enter the debugger.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Source statements can be made available by creating an environment
variable named <font face="Source Code Pro">LIST</font> equated to the name of a listing file, or by
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     LIST=SRC.LST ./PROG.SNO
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
or
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     DDT: X snobol4 -n -l SRC.LST SRC.SNO
|     DDT: S
|     LISTING: SRC.LST
|     SOURCE LISTING LOADED
|     DDT:
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Supplying a <font face="Source Code Pro">LIST=</font> environment automatically attempts loading the
listing at debugger start. This will give a symbolic line for the
first line after the <font face="Source Code Pro">DDT()</font> invocation.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If there is a block of statements that are to be excluded from tracing
(such as initializations), bracket them with
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     &TRACE = 0 ..... &TRACE = 999999999
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FREEZE()</font> and <font face="Source Code Pro">THAW()</font> are used to prevent entries from being
inserted into the breakpoint and source tables, keeping the footprint
of <font face="Source Code Pro">DDT</font> smaller. <font face="Source Code Pro">READLINE()</font> is used to allow editing and
retrieval of command lines.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<i>DDT</i> will display user datatypes with the = command. More
sophisticated behavious will be introduced with the INSPECT module
at a future date. (see DDT.E)
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SLOAD</font> is not actually needed for <font face="Source Code Pro">DDT</font>. It is included to allow
additional tools to be incorporated while debugging.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS">CHARS</a><br>
<a href="FREEZE">FREEZE</a><br>
<a href="HOST">HOST</a><br>
<a href="QUOTE">QUOTE</a><br>
<a href="READLINE">READLINE</a><br>
<a href="SLOAD">SLOAD</a><br>
<a href="TRIMB">TRIMB</a><br>
<a href="VDIFFER">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;FREEZE.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;QUOTE.INC&#39;
-INCLUDE &#39;READLINE.INC&#39;
-INCLUDE &#39;SLOAD.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
-WEAK DSERVE_APPNAME
-USES SLOAD()
-PUBLIC DDT(), DEBUG(), DDT_LOADED, DDT_ACTIVE
         DEFINE(&#39;DDT(S)&#39;)
         DEFINE(&#39;DEBUG(S)&#39;, &#39;DDT&#39;)
<font color="#818181"><i>*</i></font>
         DDT_LOADED = 1
         DDT_ACTIVE = 0
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REMOTE DEBUG, DDT_USE_R IS FLAG TO GET INPUT FROM REMOTE (= 1).</i></font>
<font color="#818181"><i>* IF 2, WE ARE IN GUI.</i></font>
<font color="#818181"><i>* DDT_T IS OUTPUT (ALWAYS) AND DDT_R IN READ CHANNEL. IF DDT_USE_R</i></font>
<font color="#818181"><i>* IS NULL, READLINE() WILL BE USED. IF IT IS NOT NULL, DDT_R WILL</i></font>
<font color="#818181"><i>* BE USED FOR COMMANDS AND INPUT.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC DDT_T, DDT_USE_R, DDT_R
         DDT_T_UNIT = IO_FINDUNIT()
         OUTPUT(.DDT_T, DDT_T_UNIT, &#39;W&#39;, &#39;/dev/stderr&#39;)
         DDT_USE_R =
<font color="#818181"><i>*        DDT_R_UNIT = IO_FINDUNIT()</i></font>
<font color="#818181"><i>*        INPUT(.DDT_R, DDT_R_UNIT,, &#39;/dev/stdin&#39;)</i></font>
                                                              <b>:(DDT_END)</b>
<font color="#818181"><i>*</i></font>
DDT      DDT_ACTIVE = 1
         DDT_COUNT = 0
         DDT_IGNORE =
         DDT_UNIT2 =
         RLAPPNAME(&#39;DDT&#39;)
         READ_HISTORY(&#39;.DDT&#39;)
         STIFLE_HISTORY(50)
         DEFINE(&#39;DDT(S)&#39;, &#39;DDT_&#39;)
         DEFINE(&#39;DEBUG(S)&#39;, &#39;DDT_&#39;)
         DEFINE(&#39;DDT_SOURCE()&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DDT()</font> and <font face="Source Code Pro">DEBUG()</font> are the primary calls into the
debugger. <font face="Source Code Pro">DDT_SUSPEND()</font> will suspend the debugger, and
<font face="Source Code Pro">DDT_RESUME()</font> will resume normal operation.  <font face="Source Code Pro">DDT_ACTIVE</font> and
<font face="Source Code Pro">DDT_LOADED</font> variables can be examined. <font face="Source Code Pro">DDT_LOADED</font> will be
<font face="Source Code Pro">NULL</font> if <font face="Source Code Pro">DDT</font> has not been loaded. See <A HREF="BQ.html">BQ</A>
for an example of this use.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
-PUBLIC DDT_SUSPEND(), DDT_RESUME(), DDT_TOUT()
         DEFINE(&#39;DDT_SUSPEND()&#39;, &#39;DDT.O&#39;)
         DEFINE(&#39;DDT_RESUME()&#39;)
         DEFINE(&#39;DDT_TOUT(S)&#39;)
<font color="#818181"><i>*</i></font>
         DDT_TOUT(&#39;DDT (FRI MAY 23 15:30:53 EDT 2014)&#39;)
         DDT_TOUT(&#39;TRY H FOR HELP&#39;)
         DDT_SOURCE =
         DDT_LIST_F =
         DDT_LIST_L =
         DDT_FINAL_STMT =
         DDT_CURR_STMT =
         DDT_BREAK_TAB = TABLE()
         DDT_BREAK_TEMP = TABLE()
         DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_WHITE = CHARS_HT &#39; &#39;
         DDT_G_PAT = FENCE &#39;=&#39; (BREAK(DDT_WHITE &#39;,&#39;) | REM)
+           . DDT_CMD (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DDT_CHARU = CHARS_HT &#39; CBE=GHKLPQRTI+-?!XOSMV*.&#39;
         DDT_CHARL = CHARS_HT &#39; cbe=ghklpqrti+-?!xosmv*.&#39;
         DDT_CHARR =      &#39;C&#39; &#39;CCBEEGHKLPQRTI+-HXXOSMV*.&#39;
         DDT_CHARS = FENCE ANY(DDT_CHARU DDT_CHARL) . DDT_C
+           (SPAN(DDT_WHITE) | &#39;&#39;)
         DDT_DL_PAT = FENCE LEN(8) (NOTANY(DDT_WHITE)
+           (BREAK(DDT_WHITE CHARS_NL) | REM)) . DDT_LABEL
         DDT_GET_PAT1 = FENCE SPAN(&amp;DIGITS) . DDT_GET_STMT
+           (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DDT_GET_PAT2 = FENCE (BREAK(&#39;,&#39;) | REM) . LABEL
+           (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DDT_GET_PAT3 = FENCE BREAK(&#39;+-&#39; DDT_WHITE) . LABEL
+           BREAK(&#39;+-&#39;) LEN(1) . SIGN BREAK(&amp;DIGITS)
+           SPAN(&amp;DIGITS) . OFFSET
+           (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DEFINE(&#39;DDT_LABEL(STNO)OFFSET&#39;)
         DEFINE(&#39;DDT_GET_STMT(S)LABEL,SIGN,OFFSET&#39;)
         DEFINE(&#39;DDT_FNC()&#39;)
         DEFINE(&#39;DDT_CASE(DDT_CASE)&#39;)
         DEFINE(&#39;DDT_CMD()&#39;
+           &#39;DDT_A,DDT_B,DDT_C,DDT_IN,DDT_I,DDT_FIELD,DDT_RESULT,DDT_V&#39;)
         DEFINE(&#39;DDT_READLIST(LABTAB,LAST)&#39;
+           &#39;STNO,STMT,LINE,LABEL,PAT1,PAT2,PAT3,PAT4,PAT5&#39;)
         DDT_STMTS = TABLE()
         DDT_LBLS = TABLE(50, 50)
         FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         HOST(HOST_GETENV, &#39;LIST&#39;)                              <b>:F(DDT_)</b>
         DDT_SOURCE()
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
The <font face="Source Code Pro">DDT()</font> function can be invoked to re-enter the debugger. This is
usually used to generate “complex” breakpoints. <font face="Source Code Pro">DDT()</font> (also known
as <font face="Source Code Pro">DEBUG()</font>) can be given an argument. This name can be reference
in an I command: <font face="Source Code Pro">I 'MSG' N</font> which ignores the next <font face="Source Code Pro">N</font> calls to
<font face="Source Code Pro">DDT/DEBUG</font> with the matching string. After this, the <font face="Source Code Pro">DDT()</font> or
<font face="Source Code Pro">DEBUG()</font> call will enter the debugger.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_     S DDT_IGNORE                                          <b>:F(DDT2_)</b>
         DDT_COUNT = GT(DDT_COUNT) DDT_COUNT - 1              <b>:S(RETURN)</b>
DDT2_    DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_TOUT(&#39;DDT(&#39; S &#39;)&#39;)
DDT_RESUME
         &amp;STLIMIT = 999999999
         &amp;TRACE = 999999999
         TRACE(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;,, &#39;DDT_FNC&#39;)               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CURRENT STATEMENT</i></font>
<font color="#818181"><i>*</i></font>
DDT_FNC  DDT_CURR_STMT = &amp;LASTNO
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF NOT SINGLE-STEPPING AND DID NOT HIT A BREAKPOINT, JUST RETURN.</i></font>
<font color="#818181"><i>*</i></font>
         (LE(DDT_STEP_COUNT)
+           IDENT(DDT_BREAK_TAB&lt;DDT_CURR_STMT&gt;)
+           IDENT(DDT_BREAK_TEMP&lt;DDT_CURR_STMT&gt;))             <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF IT WAS A BREAKPOINT, TURN OFF ANY SINGLE-STEPPING.</i></font>
<font color="#818181"><i>*</i></font>
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TAB&lt;DDT_CURR_STMT&gt;)
+                                                        <b>:S(DDT_DISPLAY)</b>
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TEMP&lt;DDT_CURR_STMT&gt;)
+                                                        <b>:S(DDT_DISPLAY)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF DOING A P TRACE, DON&#39;T STOP IF DOWN IN A FUNCTION.</i></font>
<font color="#818181"><i>*</i></font>
         GT(&amp;FNCLEVEL, DDT_FNCLEVEL)                          <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MUST HAVE BEEN SINGLE-STEPPING. DECREMENT COUNT.</i></font>
<font color="#818181"><i>*</i></font>
         DDT_STEP_COUNT = DDT_STEP_COUNT - 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPLAY CURRENT STATEMENT.</i></font>
<font color="#818181"><i>*</i></font>
DDT_DISPLAY
         DIFFER(DDT_HOOK)                              <b>:S(DDT_DISPLAY_2)</b>
         DDT_FNC = DDT_LABEL(DDT_CURR_STMT)
         DDT_TOUT(VDIFFER(DDT_FNC))
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) DDT_STMTS&lt;DDT_CURR_STMT&gt;)
         DDT_TOUT(IDENT(DDT_FINAL_STMT) DDT_CURR_STMT)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CALL EXTERNAL ROUTINE IF DEFINED TO REGISTER BREAK. THIS CAN</i></font>
<font color="#818181"><i>* REPLICATE SOME OF THE ABOVE IF NEEDED.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC DDT_HOOK
DDT_DISPLAY_2
         DIFFER(DDT_HOOK) APPLY(DDT_HOOK, &#39;BREAK&#39;, DDT_CURR_STMT)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LISTING BEGINS HERE</i></font>
<font color="#818181"><i>*</i></font>
         DDT_LIST_F = DDT_CURR_STMT
         DDT_LIST_L = DDT_CURR_STMT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF MORE SINGLE-STEPPING TO DO, JUST EXIT</i></font>
<font color="#818181"><i>*</i></font>
         GT(DDT_STEP_COUNT)                                   <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Here is where we read commands from the user. Control stays within
DDT.CMD until it is time to return to the user program. A failure
return means resume where interrupted. A success return requests a
direct jump to a user label. This direct jump is kludgy because we are
“down one level” in function call depth &ndash; too many of these and the
stack will overflow. Too bad you can't manipulate return.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
         THAW(DDT_BREAK_TAB)
         THAW(DDT_BREAK_TEMP)
         DDT_BREAK_TEMP = TABLE()
         DDT_ACTIVE = 1
         DDT_CURR_STMT = DDT_CMD()                            <b>:F(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JUMP TO USER&#39;S LABEL WITHOUT CLEARING INTERRUPT</i></font>
<font color="#818181"><i>*</i></font>
         &amp;TRACE = 999999999                            <b>:($DDT_CURR_STMT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONVERT TO UPPERCASE IF SOURCE IS NOT CASE SENSITIVE</i></font>
<font color="#818181"><i>*</i></font>
DDT_CASE DDT_CASE = NE(&amp;CASE)
+           REPLACE(DDT_CASE, &amp;LCASE, &amp;UCASE)                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Function to return <font face="Source Code Pro">'('</font> and statement label and offset <font face="Source Code Pro">')'</font>
given a statement number. If <font face="Source Code Pro">DDT_FINAL_STMT</font> is <font face="Source Code Pro">NULL</font>, there
is no listing available, and we just return a <font face="Source Code Pro">NULL</font> string.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_LABEL
         IDENT(DDT_FINAL_STMT)                                <b>:S(RETURN)</b>
DDT_LAB2 DDT_STMTS&lt;STNO&gt; DDT_DL_PAT                         <b>:S(DDT_LAB1)</b>
         STNO = GT(STNO, 1) STNO - 1                        <b>:F(DDT_LAB1)</b>
         OFFSET = OFFSET + 1                                 <b>:(DDT_LAB2)</b>
DDT_LAB1 DDT_LABEL = IDENT(OFFSET) &#39;(&#39; DDT_LABEL &#39;)&#39;          <b>:S(RETURN)</b>
         DDT_LABEL = &#39;(&#39; DDT_LABEL &#39; + &#39; OFFSET &#39;)&#39;            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Get optional statement number
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Input is name of variable containing string with statement number or
label. Label may be followed by <font face="Source Code Pro">' +-N'</font>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Output is statement number or <font face="Source Code Pro">NULL</font> if none provided. Fails and
displays error if bad syntax or illegal label. Statement number or
label is removed from argument string.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_GET_STMT
         IDENT($S)                                            <b>:S(RETURN)</b>
<font color="#818181"><i>* CHECK FOR SIMPLE NUMBER</i></font>
         $S DDT_GET_PAT1 =                                    <b>:S(RETURN)</b>
<font color="#818181"><i>* CHECK FOR TEXT LABEL</i></font>
         $S DDT_GET_PAT2 =                                  <b>:F(DDT_GET1)</b>
<font color="#818181"><i>* CHECK FOR OPTIONAL +N OR -N AFTER LABEL</i></font>
         LABEL DDT_GET_PAT3
         OFFSET = IDENT(SIGN, &#39;-&#39;) -OFFSET
<font color="#818181"><i>* MAP CASE-CONVERTED LABEL TO STATEMENT NUMBER</i></font>
         DDT_GET_STMT = DDT_LBLS&lt;DDT_CASE(LABEL)&gt;
<font color="#818181"><i>* CHECK IF LABEL UNKNOWN TO US, AND ADD OFFSET.</i></font>
         DDT_GET_STMT = VDIFFER(DDT_GET_STMT)
+           + OFFSET                                          <b>:S(RETURN)</b>
DDT_GET1 DDT_TOUT(&#39;BAD LABEL OR STATEMENT NUMBER&#39;)            <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Function to read a listing file. Only numbered program statements
are retained.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Listing format is 4 columns of statement number, four blank columns,
then the user's statement.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_READLIST
         PAT1 = FENCE (LEN(4) | SPAN(&amp;DIGITS)) . STNO
+           (LEN(4) | &#39;&#39;) REM . STMT
         PAT2 = FENCE (NOTANY(&#39;-+.*;|#! &#39; CHARS_NP CHARS_HT)
+           BREAK(CHARS_HT &#39; &#39;) ) . LABEL
         PAT3 = FENCE NOTANY(&amp;DIGITS &#39; &#39; CHARS_HT)
         PAT4 = FENCE ANY(&#39;+.&#39;)
         PAT5 = FENCE ANY(&#39;*;|#!&#39;)
         DDT_READLIST = TABLE(151)
DDT_RL1  LINE = TRIM(DDT_SOURCE)                              <b>:F(RETURN)</b>
         IDENT(LINE)                                         <b>:S(DDT_RL1)</b>
         LINE PAT1                                           <b>:F(DDT_RL1)</b>
<font color="#818181"><i>* IGNORE PAGE THROW, ERROR MESSAGE, FORM FEED, AND TITLES IN LISTING</i></font>
<font color="#818181"><i>* FILE.</i></font>
         STNO PAT3                                           <b>:S(DDT_RL1)</b>
         STNO = TRIM(STNO)
         INTEGER(STNO)                                       <b>:F(DDT_RL4)</b>
<font color="#818181"><i>* IGNORE COMMENTS</i></font>
         STMT PAT5                                           <b>:S(DDT_RL1)</b>
<font color="#818181"><i>* CONTINUATION LINES</i></font>
         STMT PAT4                                           <b>:S(DDT_RL2)</b>
<font color="#818181"><i>* ADJUST $LAST IF NEW STATEMENT NUMBER</i></font>
         $LAST = +VDIFFER(STNO)                    <b>:S(DDT_RL3)F(DDT_RL1)</b>
<font color="#818181"><i>* APPEND LF TO EXISTING TEXT IF CONTINUED STATEMENT</i></font>
DDT_RL2  DDT_READLIST&lt;$LAST&gt; = VDIFFER(DDT_READLIST&lt;$LAST&gt;) CHARS_NL
<font color="#818181"><i>* PLACE STATEMENT IN TABLE</i></font>
DDT_RL3  DDT_READLIST&lt;$LAST&gt; = DDT_READLIST&lt;$LAST&gt; LINE
<font color="#818181"><i>* EXTRACT LABEL</i></font>
         (STMT &#39; &#39;) PAT2                                     <b>:F(DDT_RL1)</b>
<font color="#818181"><i>* RECORD CASE-CONVERTED LABEL TO STATEMENT NUMBER MAPPING</i></font>
         ITEM(LABTAB, DDT_CASE(LABEL)) = $LAST                <b>:(DDT_RL1)</b>
DDT_RL4  DDT_TOUT(&#39;INCORRECT PROGRAM LIST FILE, LINE IN ERROR:&#39;)
         DDT_TOUT(LINE)                                       <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Function to read and process debug commands. <font face="Source Code Pro">FAIL</font>s when caller
should return to the interrupted user program (the 'normal' exit).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Returns <font face="Source Code Pro">SUCCESS</font> to jump indirect to a user label (but down one
function level). The function value is the label name.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If <font face="Source Code Pro">EOF</font> is read from keyboard, debugger shuts itself off.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_CMD  IDENT(DDT_UNIT2)                                   <b>:S(DDT_CMD2)</b>
         DDT_IN = DDT_INPUT                                 <b>:F(DDT_CMD4)</b>
         DDT_TOUT(&#39;DDT: &#39; DDT_IN)                            <b>:(DDT_CMD3)</b>
DDT_CMD4 ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =
DDT_CMD2 DDT_LL2 = DDT_LL
         IDENT(DDT_USE_R)                                   <b>:S(DDT_CMD5)</b>
         DDT_TOUT(EQ(DDT_USE_R, 1) &#39;DDT REMOTE (&#39; DSERVE_APPNAME &#39;)&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NOTE: THIS IS THE ONLY READ FROM DDT_R.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF DDT_HOOK IS DEFINED, WE WILL CALL WITH THAT WITH &#39;READ&#39;. SEE</i></font>
<font color="#818181"><i>* DDT_HOOK CALL WITH &#39;DISPLAY&#39; ABOVE. IF THIS FAILS, WE ASSUME NORMAL</i></font>
<font color="#818181"><i>* READ IS NEEDED. IF USE_DDT_R, AND DDT_HOOK IS NOT SET, WE READ</i></font>
<font color="#818181"><i>* FROM DDT_R.</i></font>
<font color="#818181"><i>*</i></font>
         IDENT(DDT_HOOK)                                    <b>:S(DDT_CMD7)</b>
         DDT_IN = TRIM(APPLY(DDT_HOOK, &#39;READ&#39;))  <b>:F(DDT_CMD5)S(DDT_CMD3)</b>
DDT_CMD7 DDT_IN = TRIM(DDT_R)                       <b>:S(DDT_CMD3)F(DDT.O)</b>
DDT_CMD5 DDT_IN = TRIM(HISTORY_EXPAND(READLINE(&#39;DDT: &#39;)))      <b>:F(DDT.O)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ONLY ADD NON-NULL COMMANDS THAT DIFFER FROM LAST COMMAND TO HISTORY</i></font>
<font color="#818181"><i>*</i></font>
DDT_CMD6 IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_LL = DDT_IN
         ADD_HISTORY(VDIFFER(DDT_IN, DDT_LL2))
DDT_CMD3 IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TEST FOR VALID COMMAND AND BRANCH TO APPROPRIATE PROCESSOR (DDT.?).</i></font>
<font color="#818181"><i>* LOWER-CASE COMMANDS ARE EQUIVALENT TO UPPER-CASE, AND BLANK AND</i></font>
<font color="#818181"><i>* TAB ARE CONVERTED TO THE COMMAND &#39;C&#39;.</i></font>
<font color="#818181"><i>*</i></font>
         DDT_IN DDT_CHARS =                              <b>:F(DDT_CMD_ERR)</b>
         DDT_STEP_COUNT = 0
                       <b>:($(&#39;DDT.&#39; REPLACE(DDT_C, DDT_CHARL, DDT_CHARR)))</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** INVALID COMMAND</i></font>
<font color="#818181"><i>*</i></font>
DDT_CMD_ERR
         DDT_TOUT(&#39;?&#39;)                                        <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** TURN OFF DEBUGGER</i></font>
<font color="#818181"><i>*</i></font>
DDT.O    DDT_ACTIVE = 0
         WRITE_HISTORY(&#39;.DDT&#39;)
         &amp;STLIMIT = -1
         STOPTR(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;)                         <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** V - VIEW FILE</i></font>
<font color="#818181"><i>*</i></font>
DDT.V    DDT_IN = IDENT(DDT_IN) DDT_FNAME
         (IDENT(DDT_IN) DIFFER(DDT_USE_R))                    <b>:S(DDT.V2)</b>
         DDT_IN = IDENT(DDT_IN) READLINE(&#39;FILE: &#39;)
         DDT_FNAME = VDIFFER(DDT_IN)                         <b>:F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME: NEED SOMETHING BETTER. LIST FOR LOCAL, BUT DUMP TO DDT_T FOR</i></font>
<font color="#818181"><i>* REMOTE.</i></font>
<font color="#818181"><i>*</i></font>
         HOST(HOST_SYSCMD, &#39;LIST &#39; DDT_IN)                    <b>:(DDT_CMD)</b>
DDT.V2   DDT_TOUT(&#39;USE V FILENAME&#39;)                           <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** M - MODIFY VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
DDT.M    IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_TOUT(DIFFER(DDT_USE_R) &#39;SORRY, NEED EDITLINE&#39;)  <b>:S(DDT_CMD)</b>
         DATATYPE($DDT_IN) &#39;STRING&#39; | &#39;NAME&#39; | &#39;INTEGER&#39; | &#39;REAL&#39;
+                                                             <b>:S(DDT.M2)</b>
         DDT_TOUT(&quot;SORRY, CAN&#39;T MODIFY &quot; DATATYPE($DDT_IN))   <b>:(DDT_CMD)</b>
DDT.M2   $DDT_IN = EDITLINE(&#39;EDIT&lt;&#39; DDT_IN &#39;&gt;: &#39;, $DDT_IN)    <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** . - SOURCE FILE</i></font>
<font color="#818181"><i>*</i></font>
DDT..    IDENT(DDT_UNIT2)                                     <b>:S(DDT..1)</b>
         DDT_TOUT(&#39;. COMMANDS CANNOT BE NESTED&#39;)               <b>:(DDT..2)</b>
DDT..1   IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_TOUT(&#39;SOURCING &#39; DDT_IN)
         DDT_UNIT2 = IO_FINDUNIT()
         INPUT(.DDT_INPUT, DDT_UNIT2,, DDT_IN)               <b>:S(DDT_CMD)</b>
         DDT_TOUT(&#39;CANNOT OPEN &#39; DDT_IN)
DDT..2   ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =                                          <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** * - COMMENT</i></font>
<font color="#818181"><i>*</i></font>
DDT.*                                                         <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** H OR ? - HELP</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;HELP&raquo;</b>
                                                              <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** I - IGNORE</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*       CALLS TO DDT() OR DEBUG() MAY HAVE A STRING. THE I COMMAND</i></font>
<font color="#818181"><i>*       IGNORES THE NEXT N CALLS TO DDT() WITH A MATCHING STRING.</i></font>
<font color="#818181"><i>*       NORMALLY, I IS FOLLOWED BY O TO EXECUTE AT FULL SPEED.</i></font>
<font color="#818181"><i>*</i></font>
DDT.I    DDT_IGNORE =
         DDT_IN ((&quot;&#39;&quot; ARB . DDT_IGNORE &quot;&#39;&quot;) | &#39;&#39;) SPAN(DDT_WHITE &#39;,&#39;)
+           SPAN(&amp;DIGITS) . DDT_COUNT RPOS(0)                <b>:S(DDT_CMD)</b>
         DDT_TOUT(&#39;BAD I SYNTAX&#39;)                             <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** Q - QUIT</i></font>
<font color="#818181"><i>*</i></font>
DDT.Q    WRITE_HISTORY(&#39;.DDT&#39;)                                    <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** X - EXECUTE SHELL COMMAND</i></font>
<font color="#818181"><i>*</i></font>
DDT.X    HOST(HOST_SYSCMD, DDT_IN)
         DDT_TOUT()                                           <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** C - IMMEDIATE EXECUTION OF AN UNLABELED CODE STATEMENT.</i></font>
<font color="#818181"><i>*       APPEND OUR OWN GOTOS TO REGAIN CONTROL AFTER EXECUTION.</i></font>
<font color="#818181"><i>*</i></font>
DDT.C    DDT_C = CODE(&#39; &#39; DDT_IN &#39; :S(DDT_SS)F(DDT_FF)&#39;)       <b>:S&lt;DDT_C&gt;</b>
         DDT_TOUT(&#39;COMPILATION ERROR: &#39; &amp;ERRTEXT)             <b>:(DDT_CMD)</b>
DDT_SS   DDT_TOUT(&#39;SUCCESS&#39;)                                  <b>:(DDT_CMD)</b>
DDT_FF   DDT_TOUT(&#39;FAILURE&#39;)                                  <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** E - EXAMINE VARIABLE OR EVALUATE EXPRESSION. WE DISPLAY STRINGS,</i></font>
<font color="#818181"><i>*       NUMBERS AS SCALARS, ARRAYS AND TABLES AS PROTOTYPES, CODE,</i></font>
<font color="#818181"><i>*       EXPRESSION, PATTERN AS TYPE NAME, USER TYPES ARE DISPLAYED AS</i></font>
<font color="#818181"><i>*       MEMBERS</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME - DATATYPE &#39;NAME&#39; MAY BE AN ISSUE, SEE READL.INC AND FIX HERE</i></font>
<font color="#818181"><i>*         AND IN MODIFY DDT.M</i></font>
<font color="#818181"><i>*</i></font>
DDT.E    DDT_RESULT = EVAL(DDT_IN)                            <b>:F(DDT.E2)</b>
         DDT_V = DATATYPE(DDT_RESULT)
         IDENT(DDT_RESULT)                                    <b>:S(DDT.E3)</b>
         DDT_RESULT = ?(DDT_V ? &#39;STRING&#39; | &#39;NAME&#39;) QUOTE(DDT_RESULT)
+                                                             <b>:S(DDT.E3)</b>
         DDT_V &#39;INTEGER&#39; | &#39;REAL&#39;                             <b>:S(DDT.E3)</b>
         DDT_RESULT = ?(DDT_V ? &#39;CODE&#39; | &#39;EXPRESSION&#39; | &#39;PATTERN&#39; |
+           &#39;TABLE&#39; | &#39;ARRAY&#39;) CONVERT(DDT_RESULT, &#39;STRING&#39;)  <b>:S(DDT.E3)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* USER DEFINED DATATYPE - FIELD(&#39;TYPE&#39;,1..N)</i></font>
<font color="#818181"><i>*</i></font>
         DDT_TOUT(DATATYPE(DDT_RESULT))
         DDT_I =
DDT.E4   DDT_I = DDT_I + 1
         DDT_FIELD = FIELD(DATATYPE(DDT_RESULT), DDT_I)      <b>:F(DDT_CMD)</b>
         DDT_V = DATATYPE(APPLY(DDT_FIELD, DDT_RESULT))
         DDT_V = IDENT(APPLY(DDT_FIELD, DDT_RESULT))          <b>:S(DDT.E5)</b>
         DDT_V = ?(DDT_V ? &#39;STRING&#39; | &#39;NAME&#39;)
+           QUOTE(APPLY(DDT_FIELD, DDT_RESULT))               <b>:S(DDT.E5)</b>
         DDT_V = ?(DDT_V ? &#39;INTEGER&#39; | &#39;REAL&#39;)
+           APPLY(DDT_FIELD, DDT_RESULT)                      <b>:S(DDT.E5)</b>
         DDT_V = CONVERT(APPLY(DDT_FIELD, DDT_RESULT), &#39;STRING&#39;)
DDT.E5   DDT_TOUT(&#39;    &#39; RPAD(DDT_FIELD, 10) &#39;: &#39; DDT_V)       <b>:(DDT.E4)</b>
DDT.E3   DDT_TOUT(DDT_RESULT)                                 <b>:(DDT_CMD)</b>
DDT.E2   DDT_TOUT(&#39;EVALUATION ERROR: &#39; &amp;ERRTEXT)              <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** T - STEP N STATEMENTS, DESCENDING INTO PROCEDURES</i></font>
<font color="#818181"><i>*</i></font>
DDT.T    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        <b>:F(DDT_CMD_ERR)</b>
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = 50000
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** P - STEP N STATEMENTS, TREAT PROCEDURES AS INTACT ENTITIES</i></font>
<font color="#818181"><i>*</i></font>
DDT.P    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        <b>:F(DDT_CMD_ERR)</b>
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = &amp;FNCLEVEL - 1
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** R - REPORT BREAKPOINTS</i></font>
<font color="#818181"><i>*</i></font>
DDT.R    DDT_A = SORT(DDT_BREAK_TAB)                          <b>:F(DDT_R2)</b>
         DDT_C = 0
DDT_R1   DDT_C = DDT_C + 1
         DDT_TOUT(DDT_A&lt;DDT_C, 1&gt; &#39; &#39;
+           DDT_LABEL(DDT_A&lt;DDT_C, 1&gt;))             <b>:S(DDT_R1)F(DDT_CMD)</b>
DDT_R2   DDT_TOUT(&#39;NONE&#39;)                                     <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** K - KILL BREAKPOINT(S)</i></font>
<font color="#818181"><i>*</i></font>
DDT.K    IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_BREAK_TAB&lt;+DDT_GET_STMT(.DDT_IN)&gt; =     <b>:S(DDT.K)F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** B - SET BREAKPOINT(S)</i></font>
<font color="#818181"><i>*</i></font>
DDT.B    IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_BREAK_TAB&lt;+DDT_GET_STMT(.DDT_IN)&gt; = 1   <b>:S(DDT.B)F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** G - GO &lt;=OPTIONAL DIRECT TRANSFER LABEL&gt; &lt;OPTIONAL BREAKPOINTS(S)&gt;</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIRST TEST FOR SIMPLE G BY ITSELF</i></font>
DDT.G    DDT_STEP_COUNT = 0
         IDENT(DDT_IN)                                       <b>:S(FRETURN)</b>
<font color="#818181"><i>* CHECK FOR =LABEL, ASSIGN LABEL TO DDT_CMD</i></font>
         DDT_IN DDT_G_PAT =                                   <b>:F(DDT_G1)</b>
         DDT_CMD = DDT_CASE(DDT_CMD)
<font color="#818181"><i>* ERROR IF LABEL UNKNOWN</i></font>
         DDT_TOUT(IDENT(DDT_LBLS&lt;DDT_CMD&gt;) &#39;UNKNOWN LABEL =&#39;
+           DDT_CMD)                                         <b>:S(DDT_CMD)</b>
<font color="#818181"><i>* PROCESS ANY BREAKPOINTS</i></font>
DDT_G1   DIFFER(DDT_IN)                                       <b>:F(DDT_G2)</b>
         DDT_BREAK_TEMP&lt;+DDT_GET_STMT(.DDT_IN)&gt; = 1 <b>:S(DDT_G1)F(DDT_CMD)</b>
<font color="#818181"><i>* CHOOSE FRETURN TO RESUME EXECUTION WHERE INTERRUPTED, RETURN TO</i></font>
<font color="#818181"><i>* TRANSFER TO THE LABEL IN DDT_CMD.</i></font>
DDT_G2   FREEZE(DDT_BREAK_TEMP)
         FREEZE(DDT_BREAK_TAB)
         DIFFER(DDT_CMD)                            <b>:S(RETURN)F(FRETURN)</b>
<b>&laquo;LIST&raquo;</b>
DDT_TOUT DIFFER(DDT_HOOK) APPLY(DDT_HOOK, &#39;DISPLAY&#39;, S)
         DDT_T = S                                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** S(FILE) - LOAD SOURCE LISTING</i></font>
<font color="#818181"><i>*</i></font>
DDT.S    DDT_SOURCE()                                         <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
DDT_SOURCE
         THAW(DDT_STMTS)
         THAW(DDT_LBLS)
         DDT_LBLS = TABLE(50, 50)
         DDT_FINAL_STMT =
         DDT_UNIT = IO_FINDUNIT()
         DDT_FNAME = TRIMB(DDT_IN)
         DIFFER(DDT_FNAME)                                    <b>:S(DDT_S3)</b>
         INPUT(&#39;DDT_SOURCE&#39;, DDT_UNIT,,
+              DDT_FNAME = HOST(HOST_GETENV, &#39;LIST&#39;))         <b>:S(DDT_S1)</b>
         DDT_TOUT(DIFFER(DDT_USE_R) &#39;USE S FILE&#39;)             <b>:S(DDT_S2)</b>
         DDT_FNAME = TRIM(HISTORY_EXPAND(READLINE(&#39;LISTING: &#39;)))
DDT_S3   INPUT(&#39;DDT_SOURCE&#39;, DDT_UNIT,, DDT_FNAME)            <b>:S(DDT_S1)</b>
         DDT_FNAME =
         DDT_TOUT(&#39;NO LISTING FILE PROVIDED&#39;)                  <b>:(DDT_S2)</b>
DDT_S1   DDT_STMTS = DDT_READLIST(DDT_LBLS, .DDT_FINAL_STMT)
         ENDFILE(DDT_UNIT)
         DETACH(.DDT_SOURCE)
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) &#39;SOURCE LISTING LOADED&#39;)
DDT_S2   FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DDT_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Provide “help” for <font face="Source Code Pro">DDT</font>. Commands are a single letter followed
by (optional) arguments. This provides a reminder of the commands,
and what they do.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HELP&raquo;&equiv;</b>
DDT.H
 DDT_TOUT(&#39;STNO - STATEMENT NUMBERS SPECIFIED AS INTEGERS, OR LABEL+-N&#39;)
 DDT_TOUT(&#39;          BRACKETED ITEMS ARE OPTIONAL&#39;)
 DDT_TOUT(&#39;H            (OR ?)     HELP (THIS LIST)&#39;)
 DDT_TOUT(&#39;C STATEMENT  (OR TAB)   IMMEDIATE EXECUTION OF STATEMENT&#39;)
 DDT_TOUT(&#39;E EXPRESSION (OR =EXP)  EVALUATE EXPRESSION&#39;)
 DDT_TOUT(&#39;X COMMAND    (OR !)     EXECUTE SHELL COMMAND&#39;)
 DDT_TOUT(&#39;T [N]                   TRACE N STATEMENTS (INTO PROCS)&#39;)
 DDT_TOUT(&#39;P [N]                   TRACE N STATEMENTS (NO PROCEDURES)&#39;)
 DDT_TOUT(&#39;B STNO [,STNO,...]      SET BREAKPOINT(S)&#39;)
 DDT_TOUT(&#39;K BKPT [,BKPT,...]      KILL BREAKPOINT(S)&#39;)
 DDT_TOUT(&#39;R                       REPORT BREAKPOINTS SET&#39;)
 DDT_TOUT(&#39;G [=LABEL,](STNO1,...]  GO (FROM SPECIFIED LABEL),&#39;)
 DDT_TOUT(&#39;                          SET TEMPORARY BREAKPOINT(S)&#39;)
 DDT_TOUT(&#39;L [STNO1 [,STNO2]]      LIST STATEMENT OR RANGE&#39;)
 DDT_TOUT(&#39;+ [N]  OR  -[N]         LIST NEXT/PREVIOUS N STATEMENTS&#39;)
 DDT_TOUT(&#39;++ OR --                LIST 12 STATEMENTS FORWARD OR BACK&#39;)
 DDT_TOUT(&#39;Q                       QUIT&#39;)
 DDT_TOUT(&#39;O (OR ^D)               OFF - RESUME PROGRAM, STOP DEBUG&#39;)
 DDT_TOUT(&#39;S [FILE]                LOAD SOURCE&#39;)
 DDT_TOUT(&#39;M NAME                  MODIFY VARIABLE&#39;)
 DDT_TOUT(&quot;I &#39;MSG&#39; N               IGNORE NEXT N CALLS TO DDT(MSG)&quot;)
 DDT_TOUT(&#39;* COMMENT               COMMENT (NO ACTION)&#39;)
 DDT_TOUT(&#39;. FILE                  SOURCE FILE (DO NOT NEST)&#39;)
 DDT_TOUT(&#39;V (FILE)                VIEW FILE (DEFAULT TO LIST FILE)&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">L</font> by itself lists the statement about to be executed<br>
<font face="Source Code Pro">L STMT</font> lists the specified statement<br>
<font face="Source Code Pro">L STMT1,STMT2</font> lists all statements in the specified range<br>
See also <font face="Source Code Pro">+</font> and <font face="Source Code Pro">-</font> commands, below<br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DDT_A</font> is the first statement to print, <font face="Source Code Pro">DDT_C</font> is the last,
<font face="Source Code Pro">DDT_LIST_F</font> and <font face="Source Code Pro">DDT_LIST_L</font> are reference numbers for subsequent
<font face="Source Code Pro">+</font> and <font face="Source Code Pro">-</font>'s.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LIST&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** L - LIST STATEMENT(S)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPATCH IF L BY ITSELF</i></font>
DDT.L    DDT_A = IDENT(DDT_IN) DDT_CURR_STMT                  <b>:S(DDT_L1)</b>
<font color="#818181"><i>* GET FIRST LINE NUMBER</i></font>
         DDT_A = +DDT_GET_STMT(.DDT_IN)                      <b>:F(DDT_CMD)</b>
<font color="#818181"><i>* IF JUST ONE, DISPLAY IT BY ITSELF</i></font>
         IDENT(DDT_IN)                                        <b>:S(DDT_L1)</b>
<font color="#818181"><i>* IF ANOTHER, GET IT AS THE ENDING LINE NUMBER</i></font>
         DDT_C = +DDT_GET_STMT(.DDT_IN)             <b>:S(DDT_L2)F(DDT_CMD)</b>
<font color="#818181"><i>* DISPLAY ONE LINE AT DDT_A</i></font>
DDT_L1   DDT_C = DDT_A
<font color="#818181"><i>* USE DDT_C AS THE REFERENCE FOR SUBSEQUENT DISPLAY</i></font>
DDT_L2   DDT_B = .DDT_C
<font color="#818181"><i>* CHECK RANGE OF VALUES SPECIFIED</i></font>
         IDENT(DDT_FINAL_STMT)                               <b>:S(DDT_CMD)</b>
         DDT_A = LT(DDT_A, 1) 1
         DDT_A = GT(DDT_A, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_C = LT(DDT_C, DDT_A) DDT_A
         DDT_C = GT(DDT_C, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_LIST_F = DDT_A
         DDT_LIST_L = DDT_C
<font color="#818181"><i>* DISPLAY LOOP</i></font>
DDT_L3   DDT_TOUT(VDIFFER(DDT_STMTS&lt;DDT_A&gt;))
         DDT_A = LT(DDT_A, DDT_C) DDT_A + 1         <b>:S(DDT_L3)F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** +&lt;N&gt; - LIST NEXT STATEMENT(S), ++ LISTS THE NEXT 12 LINES.</i></font>
<font color="#818181"><i>*</i></font>
DDT.+    DDT_A = DDT_LIST_L + 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      <b>:S(DDT_L4)</b>
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 <b>:F(DDT_CMD_ERR)</b>
         DDT_C = LE(DDT_C) 1
DDT_L4   DDT_C = DDT_A + DDT_C - 1                             <b>:(DDT_L2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** -&lt;N&gt; - LIST PREVIOUS STATEMENT(S), -- LISTS THE PREVIOUS 12 LINES.</i></font>
<font color="#818181"><i>*</i></font>
DDT.-    DDT_B = DDT_LIST_F - 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      <b>:S(DDT_L5)</b>
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 <b>:F(DDT_CMD_ERR)</b>
         DDT_C = LE(DDT_C) 1
DDT_L5   DDT_A = DDT_B - DDT_C + 1
         DDT_C = DDT_B                                         <b>:(DDT_L2)</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DDT.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE DDT
<b>&laquo;INCLUDES&raquo;</b>
-STITL DDT
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      ######   ######   #######                       *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      ######   ######      #                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DDT             AN INTERACTIVE SNOBOL4 DEBUGGER                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DDT.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DDT&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 13:34:21 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
