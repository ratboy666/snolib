<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>JSON - JSON Support Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
JSON is used to serialize/deserialize data structures to JSON form.
Tables, arrays, strings, integers, reals and data types are supported.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Arrays are restricted to a single dimension (1..n) and DATA() types
are not supported (yet). Serializing DATA() would allow for serializing
SCOOP objects, which would be useful. Being able to serialize any
array would also be useful.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Values JSON_NULL, JSON_TRUE and JSON_FALSE are converted to 'null',
'true' and 'false'. The empty array is converted to ARRAY0.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
But, even with the current limitations, JSON is useful with WEB
applications, and allows some data to be serialized into data bases
(mostly NDBM). It can also be used for configuration files and other
(for example, snapshots of calculations).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
JSON does not have comments. There are a few approaches to commenting.
This decoder supports comments # or // to end of line or /* */
are taken as comments and ignored. This decoder also doesn't need ,
between array elements: [ 1 2 3 ] is the same as [ 1,2,3 ].
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
JASON_NL and JASON_IN can be set to control the newline and indent
sequences generated by JSON_ENCODE(). SNOBOL4 does not have concepts
for null, true or false. These three constants are defined as
JSON_NULL, JSON_TRUE and JSON_FALSE.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CH.html">CH</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HASH.html">HASH</a><br>
<a href="HEX.html">HEX</a><br>
<a href="SDIFF.html">SDIFF</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="SIZEA.html">SIZEA</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CH.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;HEX.INC&#39;
-INCLUDE &#39;SDIFF.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;SIZEA.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JSON&raquo;&equiv;</b>
-MODULE JSON
-PUBLIC JSON_ENCODE(), JSON_DECODE()
         DEFINE(&#39;JSON_ENCODE(X)L&#39;)
         DEFINE(&#39;JSON_DECODE(X)&#39;)
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;JSON_DECODE_STRING()S&#39;)
         DEFINE(&#39;JSON_DECODE_VALUE()&#39;)
         DEFINE(&#39;JSON_DECODE_OBJECT()T,T2&#39;)
         DEFINE(&#39;JSON_DECODE_ARRAY()T,I&#39;)
         DEFINE(&#39;JSON_ESCAPE(C)&#39;)
         DEFINE(&#39;JSON_INDENT()&#39;)
         DEFINE(&#39;JSON_ENCODE_OBJECT(X)K,I&#39;)
         DEFINE(&#39;JSON_ENCODE_ARRAY(X)I&#39;)
         DEFINE(&#39;JSON_ENCODE_STRING(S)L,C&#39;)
         DEFINE(&#39;JSON_ENCODE_VALUE(X)&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON WHITESPACE. THIS CAN BE BETWEEN TOKENS, AND WILL BE IGNORED</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ALSO EATS &#39;COMMENTS&#39; DEFINED AS # TO END OF LINE, // TO END OF</i></font>
<font color="#818181"><i>* LINE AND /* TO */</i></font>
<font color="#818181"><i>*</i></font>
         JSON_WS2 = SPAN(CHARS_TAB CHARS_SPACE CHARS_FF CHARS_LF
+                        CHARS_CR) |
+                   (&#39;#&#39; BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   (&#39;//&#39; BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   (&#39;/*&#39; BREAK(&#39;*&#39;) &#39;*/&#39;)
         JSON_WS = (JSON_WS2 *JSON_WS) |
+                  NULL
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A JSON NUMBER. PATTERN JSON_NUMBER IS ONLY USED TO DECODE JSON.</i></font>
<font color="#818181"><i>* ENCODING USES THE NORMAL OUTPUT FORMATTING, WITH THE RULE THAT</i></font>
<font color="#818181"><i>* A TRAILING &#39;0&#39; IS ADDED IF THE NUMBER OUTPUT ENDS IN &#39;.&#39;</i></font>
<font color="#818181"><i>*</i></font>
         JSON_DIGIT19 = ANY(&quot;123456789&quot;)
         JSON_DIGIT = ANY(&quot;0123456789&quot;)
         JSON_DIGITS = JSON_DIGIT (*JSON_DIGITS | NULL)
         JSON_E = &#39;e+&#39; | &#39;e-&#39; | &#39;E+&#39; | &#39;E-&#39; | &#39;e&#39; | &#39;E&#39;
         JSON_EXP = JSON_E JSON_DIGITS
         JSON_FRAC = &quot;.&quot; JSON_DIGITS
         JSON_INT = (&quot;-&quot; | NULL)
+                   ((JSON_DIGIT19 JSON_DIGITS) | JSON_DIGIT)
         JSON_NUMBER = JSON_INT (JSON_FRAC | NULL) (JSON_EXP | NULL)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON CONSTANTS. THESE ARE NOT IN THE SNOBOL4 LEXICON, SO WE</i></font>
<font color="#818181"><i>* CREATE A TYPE THAT REPRESENT THESE VALUES UNIQUELY.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC JSON_NULL, JSON_TRUE, JSON_FALSE
         DATA(&#39;JSON_CONSTANT(VALUE)&#39;)
         JSON_NULL = JSON_CONSTANT(&#39;null&#39;)
         JSON_TRUE = JSON_CONSTANT(&#39;true&#39;)
         JSON_FALSE = JSON_CONSTANT(&#39;false&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON_NL AND JSON_IN ARE PRODUCED FOR NEWLINE AND INDENT SEPARATION.</i></font>
<font color="#818181"><i>* DEFAULT IS A NEWLINE AND TWO SPACES. TO PRODUCE COMPACT JSON, REPLACE</i></font>
<font color="#818181"><i>* WITH NULL.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC JSON_NL, JSON_IN
         JSON_NL = CHARS_NL
         JSON_IN = &#39;  &#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON_REST IS THE REST OF THE INPUT AFTER PARSING A JSON DOCUMENT</i></font>
<font color="#818181"><i>* FROM THE FRONT. THIS IS MEANT TO ALLOW CONCATENATION OF JSON</i></font>
<font color="#818181"><i>* DOCUMENTS.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC JSON_REST
         JSON_REST =
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON_HEX IS A HEX DIGIT USED BY THE \u CHARACTER IS A JSON STRING.</i></font>
<font color="#818181"><i>* JSON_NSET IS THE SET OF CHARACTERS WHICH CAN BE SIMPLY ACCEPTED IN</i></font>
<font color="#818181"><i>* A STRING. ANY CHARACTER NOT IN JSON_NSET (NORMAL SET) IS ESCAPED.</i></font>
<font color="#818181"><i>*</i></font>
         JSON_HEX = ANY(&#39;0123456789abcdefABCDEF&#39;)
         JSON_NSET = SDIFF(CHARS_PRINTABLE, &#39;&quot;\/&#39;)           <b>:(JSON_END)</b>
<font color="#818181"><i>*</i></font>
JSON_ESCAPE
         JSON_ESCAPE = IDENT(C, &#39;&quot;&#39;) &#39;\&quot;&#39;                     <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, &#39;\&#39;) &#39;\\&#39;                     <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, &#39;/&#39;) &#39;\/&#39;                     <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_BS) &#39;\b&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_FF) &#39;\f&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_NL) &#39;\n&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_HT) &#39;\t&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_CR) &#39;\r&#39;                <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME: NOT RIGHT. SHOULD PASS THROUGH UTF-8, AND ONLY CONVERT CONTROL</i></font>
<font color="#818181"><i>*        WE ARE CHEATING BY JUST USING THIS TO CONVERT BYTES.</i></font>
<font color="#818181"><i>*</i></font>
         JSON_ESCAPE = &#39;\u00&#39; HEX(C)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_STRING
         L =
         S (SPAN(JSON_NSET) | NULL) . L REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING L
         IDENT(S)                               <b>:S(JSON_ENCODE_STRING_2)</b>
         S LEN(1) . C REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING JSON_ESCAPE(C)
+                                                  <b>:(JSON_ENCODE_STRING)</b>
JSON_ENCODE_STRING_2
         JSON_ENCODE_STRING = &#39;&quot;&#39; JSON_ENCODE_STRING &#39;&quot;&#39;       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CAREFUL WITH REAL VALUES. CSNOBOL4 WILL PRINT &#39;4.&#39; (FOR EXAMPLE).</i></font>
<font color="#818181"><i>* BY THE SYNTAX SPECIFIED, THIS IS NOT LEGAL. &#39;4.0&#39; IS THE LEGAL</i></font>
<font color="#818181"><i>* FORM. FIX THIS BY APPENDING A &#39;0&#39; IF THE FINAL CHARACTER OF A REAL</i></font>
<font color="#818181"><i>* CONVERSION IS &#39;.&#39;.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BOTH TABLE AND ARRAY TYPES CAUSE A RECURSION. DATA() TYPES CANNOT</i></font>
<font color="#818181"><i>* BE SERIALIZED.</i></font>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_VALUE
         JSON_ENCODE_VALUE = IDENT(X, JSON_NULL) &#39;null&#39;       <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(X, JSON_TRUE) &#39;true&#39;       <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(X, JSON_FALSE) &#39;false&#39;     <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(X) &#39;&quot;&quot;&#39;                    <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;INTEGER&#39;) X  <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;REAL&#39;) X
+                                                <b>:F(JSON_ENCODE_VALUE_2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THE FOLLOWING CONDITION WILL NOT HAPPEN WITH SPITBOL.EXE</i></font>
<font color="#818181"><i>*</i></font>
         JSON_ENCODE_VALUE &#39;nan&#39; | &#39;inf&#39;         <b>:S(JSON_ENCODE_VALUE_3)</b>
         JSON_ENCODE_VALUE RTAB(1) &#39;.&#39;                        <b>:F(RETURN)</b>
         JSON_ENCODE_VALUE = JSON_ENCODE_VALUE &#39;0&#39;             <b>:(RETURN)</b>
JSON_ENCODE_VALUE_2
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;STRING&#39;)
+                            JSON_ENCODE_STRING(X)            <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;TABLE&#39;)
+                            JSON_ENCODE_OBJECT(X)            <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;ARRAY&#39;)
+                            JSON_ENCODE_ARRAY(X)             <b>:S(RETURN)</b>
JSON_ENCODE_VALUE_3
         TERMINAL = &#39;JSON_ENCODE_VALUE: CANNOT ENCODE: &#39;
+                   DATATYPE(X) &#39; &#39; X
                                                                  <b>:(END)</b>
<font color="#818181"><i>*</i></font>
JSON_INDENT
         JSON_INDENT = DUPL(JSON_IN, L)                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_ARRAY
         JSON_ENCODE_ARRAY = &#39;[&#39;
         L = L + 1
         DIFFER(DATATYPE(X), &#39;ARRAY&#39;)            <b>:S(JSON_ENCODE_ARRAY_2)</b>
         I = 1
         X&lt;I&gt;                                    <b>:F(JSON_ENCODE_ARRAY_2)</b>
JSON_ENCODE_ARRAY_1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT()
+                            JSON_ENCODE_VALUE(X&lt;I&gt;)
         I = I + 1
         X&lt;I&gt;                                    <b>:F(JSON_ENCODE_ARRAY_2)</b>
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY &#39;,&#39;
+                                                 <b>:(JSON_ENCODE_ARRAY_1)</b>
JSON_ENCODE_ARRAY_2
         L = L - 1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT() &#39;]&#39;                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_OBJECT
         JSON_ENCODE_OBJECT = &#39;{&#39;
         L = L + 1
         DIFFER(DATATYPE(X), &#39;TABLE&#39;)           <b>:S(JSON_ENCODE_OBJECT_2)</b>
         K = KEYS_IN_TABLE(X)                   <b>:F(JSON_ENCODE_OBJECT_2)</b>
         I = 1
JSON_ENCODE_OBJECT_1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT()
+                             JSON_ENCODE_STRING(K&lt;I&gt;) &#39;: &#39;
+                             JSON_ENCODE_VALUE(X&lt;K&lt;I&gt;&gt;)
         I = I + 1
         K&lt;I&gt;                                   <b>:F(JSON_ENCODE_OBJECT_2)</b>
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT &#39;,&#39;
+                                                <b>:(JSON_ENCODE_OBJECT_1)</b>
JSON_ENCODE_OBJECT_2
         L = L - 1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT() &#39;}&#39;                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE
         L = 0
         JSON_ENCODE = JSON_ENCODE_VALUE(X)                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_STRING
         X BREAK(&#39;\&quot;&#39;) . S =                                 <b>:F(FRETURN)</b>
         JSON_DECODE_STRING = JSON_DECODE_STRING S
         X POS(0) &#39;&quot;&#39; =                                       <b>:S(RETURN)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\b&#39; =)
+                     JSON_DECODE_STRING CHARS_BS <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\f&#39; =)
+                     JSON_DECODE_STRING CHARS_FF <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\n&#39; =)
+                     JSON_DECODE_STRING CHARS_NL <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\t&#39; =)
+                     JSON_DECODE_STRING CHARS_HT <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\r&#39; =)
+                     JSON_DECODE_STRING CHARS_CR <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\&quot;&#39; =)
+                     JSON_DECODE_STRING &#39;&quot;&#39;      <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\\&#39; =)
+                     JSON_DECODE_STRING &#39;\&#39;      <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\/&#39; =)
+                     JSON_DECODE_STRING &#39;/&#39;      <b>:S(JSON_DECODE_STRING)</b>
<font color="#818181"><i>* FIXME: HANDLE UTF SEQUENCES PROPERLY</i></font>
         X POS(0) &#39;\u00&#39; (JSON_HEX JSON_HEX) . C =
+                                               <b>:F(JSON_DECODE_STRING_2)</b>
         JSON_DECODE_STRING = JSON_DECODE_STRING CH(C)
+                                                  <b>:(JSON_DECODE_STRING)</b>
JSON_DECODE_STRING_2
         TERMINAL = &#39;JSON_DECODE_STRING: &#39; X                      <b>:(END)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_VALUE
         X POS(0) JSON_WS =
         IDENT(X)                                            <b>:S(FRETURN)</b>
         JSON_DECODE_VALUE = ?(X ? POS(0) &#39;null&#39; =) JSON_NULL
+                                                             <b>:S(RETURN)</b>
         JSON_DECODE_VALUE = ?(X ? POS(0) &#39;true&#39; =) JSON_TRUE
+                                                             <b>:S(RETURN)</b>
         JSON_DECODE_VALUE = ?(X ? POS(0) &#39;false&#39; =) JSON_FALSE
+                                                             <b>:S(RETURN)</b>
         X POS(0) &#39;&quot;&#39; =                          <b>:F(JSON_DECODE_VALUE_2)</b>
         JSON_DECODE_VALUE =  JSON_DECODE_STRING()  <b>:S(RETURN)F(FRETURN)</b>
JSON_DECODE_VALUE_2
         X POS(0) &#39;{&#39; =                          <b>:F(JSON_DECODE_VALUE_3)</b>
         JSON_DECODE_VALUE = JSON_DECODE_OBJECT()   <b>:S(RETURN)F(FRETURN)</b>
JSON_DECODE_VALUE_3
         X POS(0) &#39;[&#39; =                          <b>:F(JSON_DECODE_VALUE_4)</b>
         JSON_DECODE_VALUE = JSON_DECODE_ARRAY()    <b>:S(RETURN)F(FRETURN)</b>
JSON_DECODE_VALUE_4
         X JSON_NUMBER . JSON_DECODE_VALUE =                 <b>:F(FRETURN)</b>
         JSON_DECODE_VALUE = +JSON_DECODE_VALUE                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_ARRAY
         T = TABLE()
         I = 0
JSON_DECODE_ARRAY_1
         X POS(0) JSON_WS =
         IDENT(X)                                            <b>:S(FRETURN)</b>
         X POS(0) &#39;]&#39; =                          <b>:S(JSON_DECODE_ARRAY_2)</b>
         I = I + 1
         T&lt;I&gt; = JSON_DECODE_VALUE()                          <b>:F(FRETURN)</b>
         X POS(0) JSON_WS &#39;,&#39; =                   <b>:(JSON_DECODE_ARRAY_1)</b>
JSON_DECODE_ARRAY_2
         JSON_DECODE_ARRAY = EQ(I) ARRAY0                     <b>:S(RETURN)</b>
         JSON_DECODE_ARRAY = ARRAY(I)
         SEQ(&#39; JSON_DECODE_ARRAY&lt;I&gt; = T&lt;I&gt; &#39;, .I)              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_OBJECT
         JSON_DECODE_OBJECT = TABLE()
JSON_DECODE_OBJECT_1
         X POS(0) JSON_WS =
         IDENT(X)                                            <b>:S(FRETURN)</b>
         X POS(0) &#39;}&#39; =                                       <b>:S(RETURN)</b>
         X POS(0) &#39;&quot;&#39; =                                      <b>:F(FRETURN)</b>
         T = JSON_DECODE_STRING()                            <b>:F(FRETURN)</b>
         X POS(0) JSON_WS &#39;:&#39; =                              <b>:F(FRETURN)</b>
         T2 = JSON_DECODE_VALUE()                            <b>:F(FRETURN)</b>
         JSON_DECODE_OBJECT&lt;T&gt; = T2
         X POS(0) JSON_WS &#39;,&#39; =                  <b>:(JSON_DECODE_OBJECT_1)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE
         X = X CHARS_NL
         JSON_DECODE = JSON_DECODE_VALUE()                   <b>:F(FRETURN)</b>
         JSON_REST = X                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DDT.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         OUTPUT = JSON_ENCODE()
         OUTPUT = JSON_ENCODE(TABLE())
         OUTPUT = JSON_ENCODE(#&#39;A=1,B=2&#39;)
         T = #&#39;A=1,B=2.&#39;
         T2 = TABLE()
         T2&lt;&#39;C&#39;&gt; = &#39;HELLO&#39;
         T2&lt;&#39;D&#39;&gt; = T
         OUTPUT = JSON_ENCODE(T2)
         T2 = TABLE()
         T2&lt;&#39;INTEGER&#39;&gt; = 42
         T2&lt;&#39;REAL&#39;&gt; = &amp;PI
         T2&lt;&#39;REAL2&#39;&gt; = 1.23456789E23
         T2&lt;&#39;STRING&#39;&gt; = &#39;Hello world&#39;
         T2&lt;&#39;STRING2&#39;&gt; = &#39;&quot;Hello world&#39; CHARS_BS CHAR(255)
         T2&lt;&#39;STRING3&#39;&gt; = CHARS_PRINTABLE
         T2&lt;&#39;STRING4&#39;&gt; = CHARS_HIGH
         T2&lt;&#39;STRING5&#39;&gt; = CHARS_CONTROL
         T2&lt;&#39;ARRAY EMPTY&#39;&gt; = ARRAY0
         T2&lt;&#39;ARRAY&#39;&gt; = %&#39;1,2,3&#39;
         T2&lt;&#39;NULL&#39;&gt; = &#39;&#39;
         OUTPUT = JSON_ENCODE(T2)
         OUTPUT = JSON_ENCODE(&#39;A String&#39;)
         OUTPUT = JSON_ENCODE(JSON_NULL)
         OUTPUT = JSON_ENCODE(JSON_TRUE)
         OUTPUT = JSON_ENCODE(JSON_FALSE)
         OUTPUT = JSON_ENCODE(%&#39;1,2,3&#39;)
         X = &#39;hello, world\&quot;\\\/&quot;&#39;
         OUTPUT = JSON_DECODE_STRING()
         X = &#39;0\b\u00FF1&quot;&#39;
         OUTPUT = HEX(JSON_DECODE_STRING())
         X = JSON_DECODE(&#39;{ &quot;A&quot;: 1, &quot;B&quot;: &quot;hello&quot; }&#39;)
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE(&#39;[ 1, 2, 3 ]&#39;)
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE(&#39;[[] {}]&#39;)
         OUTPUT = JSON_ENCODE(X)
         JSON_DECODE(&#39;[&#39;)                                        <b>:S(END)</b>
         JSON_DECODE(&#39;{&#39;)                                        <b>:S(END)</b>
         S = &#39;1 2 3&#39;
         JSON_DECODE(S)                                          <b>:F(END)</b>
         JSON_DECODE(JSON_REST)                                  <b>:F(END)</b>
         JSON_DECODE(JSON_REST)                                  <b>:F(END)</b>
         JSON_DECODE(JSON_REST)                                  <b>:S(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME: USE SETEXIT() HERE TO CATCH BRANCH TO END, AND MAKE TEST</i></font>
<font color="#818181"><i>* SUCCESSFUL. GENERALLY, WE SHOULD HAVE A HARNESS THAT PERMITS, AND</i></font>
<font color="#818181"><i>* CHECKS AND LOGS OUTPUTS. A LIGHTWEIGHT TEST HARNESS FOR UNIT TESTING.</i></font>
<font color="#818181"><i>*</i></font>
         &amp;CODE = 0
         JSON_ENCODE(1E309)                                      <b>:S(END)</b>
         &amp;CODE = 1
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL JSON
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                        #   #####   #######  #     #                  *</i></font>
<font color="#818181"><i>*                        #  #     #  #     #  ##    #                  *</i></font>
<font color="#818181"><i>*                        #  #        #     #  # #   #                  *</i></font>
<font color="#818181"><i>*                        #   #####   #     #  #  #  #                  *</i></font>
<font color="#818181"><i>*                  #     #        #  #     #  #   # #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #     #  #    ##                  *</i></font>
<font color="#818181"><i>*                   #####    #####   #######  #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* JSON                  CONVERT TO AND FROM JSON                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;JSON&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:44 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
