<h1>AGT - Alphabetic comparision with upper and lower equal</h1>

[[AGT(S1,S2)]] is the same as [[LGT(S1,S2)]] but considers upper and
lower case identical. [[AGT]] converts both strings to lowercase.
This is done by creating a translation table based on [[&ALPHABET]].

After the strings have been translated, [[LGT]] is used for the
comparision.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<AGT>>=
-PUBLIC AGT()
*
         DEFINE('AGT(S1,S2)')
         AGT_TT = REPLACE(&ALPHABET, &UCASE, &LCASE)          :(AGT_END)
*
AGT      LGT(REPLACE(S1, &ALPHABET, AGT_TT),
+            REPLACE(S2, &ALPHABET, AGT_TT))        :S(RETURN)F(FRETURN)
*
AGT_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'AGT.INC'
         &CODE = 1
         AGT('abd', 'ABC')                                       :F(END)
         AGT('abc', 'ABC')                                       :S(END)
         &CODE = 0
END
@

<<>>=
-MODULE AGT
-IN72
<<INCLUDES>>
-STITL AGT
-EJECT
*
************************************************************************
*                                                                      *
*                         #      #####   #######                       *
*                        # #    #     #     #                          *
*                       #   #   #           #                          *
*                      #     #  #  ####     #                          *
*                      #######  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #   #####      #                          *
*                                                                      *
* AGT        ALPHABETIC COMPARISION WITH UPPER AND LOWER EQUAL         *
*                                                                      *
************************************************************************
*
* AGT.lss
*
<<AGT>>
*
* CE: .MSNOBOL4;
@
<h1>AI - Apply Index</h1>

[[AI(A,I)]] where [[A]] and [[I]] are arrays will regard [[I]] as a
set of indices to be applied to the array [[A]]. The result is a new
array of the selected elements. If [[I]] is a scalar, the result is
[[A&lt;I&gt;]].

[[AI()]] creates a new array. Each element of the new array is
populated by the [[I&lt;N&gt;]] element of [[A]]. [[AI()]] uses
[[SEQ()]] to step through [[A]] and [[I]].

If [[I]] is not an array, simply returns [[A&lt;I&gt;]].

<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>= 
-INCLUDE 'SEQ.INC'
@

<<AI>>=
-PUBLIC AI()
*
         DEFINE('AI(A,I)J')                                    :(AI_END)
*
AI       IDENT(DATATYPE(I), 'ARRAY')                            :F(AI_1)
         AI = ARRAY(PROTOTYPE(I))
         SEQ(' AI<J> = A<I<J>> ', .J)                          :(RETURN)
AI_1     AI = A<I>                                  :S(RETURN)F(FRETURN)
*
AI_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'AI.INC'
-INCLUDE 'CRACK.INC'
         &CODE = 1
         A = %'5,6,7'
         I = %'3,2,1'
         A2 = AI(A, I)
         EQ(A2<1>, 7)                                            :F(END)
         EQ(A2<2>, 6)                                            :F(END)
         EQ(A2<3>, 5)                                            :F(END)
         EQ(AI(A, 1), 5)                                         :F(END)
         AI(A, 4)                                                :S(END)
         &CODE = 0
END
@

<<>>=
-MODULE AI
-IN72
<<INCLUDES>>
-STITL AI
-EJECT
*
************************************************************************
*                                                                      *
*                                #     ###                             *
*                               # #     #                              *
*                              #   #    #                              *
*                             #     #   #                              *
*                             #######   #                              *
*                             #     #   #                              *
*                             #     #  ###                             *
*                                                                      *
* AI                          APPLY INDEX                              *
*                                                                      *
************************************************************************
*
* AI.lss
*
<<AI>>
*
* CE: .MSNOBOL4;
@
-MODULE AI
-IN72
-LINE 18 "AI.lss"
-INCLUDE 'SEQ.INC'
-LINE 56 "AI.lss"
-STITL AI
-EJECT
*
************************************************************************
*                                                                      *
*                                #     ###                             *
*                               # #     #                              *
*                              #   #    #                              *
*                             #     #   #                              *
*                             #######   #                              *
*                             #     #   #                              *
*                             #     #  ###                             *
*                                                                      *
* AI                          APPLY INDEX                              *
*                                                                      *
************************************************************************
*
* AI.lss
*
-LINE 22 "AI.lss"
-PUBLIC AI()
*
         DEFINE('AI(A,I)J')                                    :(AI_END)
*
AI       IDENT(DATATYPE(I), 'ARRAY')                            :F(AI_1)
         AI = ARRAY(PROTOTYPE(I))
         SEQ(' AI<J> = A<I<J>> ', .J)                          :(RETURN)
AI_1     AI = A<I>                                  :S(RETURN)F(FRETURN)
*
AI_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>AI - Apply Index</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">AI(A,I)</font> where <font face="Source Code Pro">A</font> and <font face="Source Code Pro">I</font> are arrays will regard <font face="Source Code Pro">I</font> as a
set of indices to be applied to the array <font face="Source Code Pro">A</font>. The result is a new
array of the selected elements. If <font face="Source Code Pro">I</font> is a scalar, the result is
<font face="Source Code Pro">A&lt;I&gt;</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">AI()</font> creates a new array. Each element of the new array is
populated by the <font face="Source Code Pro">I&lt;N&gt;</font> element of <font face="Source Code Pro">A</font>. <font face="Source Code Pro">AI()</font> uses
<font face="Source Code Pro">SEQ()</font> to step through <font face="Source Code Pro">A</font> and <font face="Source Code Pro">I</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If <font face="Source Code Pro">I</font> is not an array, simply returns <font face="Source Code Pro">A&lt;I&gt;</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;AI&raquo;&equiv;</b>
-PUBLIC AI()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;AI(A,I)J&#39;)                                    <b>:(AI_END)</b>
<font color="#818181"><i>*</i></font>
AI       IDENT(DATATYPE(I), &#39;ARRAY&#39;)                            <b>:F(AI_1)</b>
         AI = ARRAY(PROTOTYPE(I))
         SEQ(&#39; AI&lt;J&gt; = A&lt;I&lt;J&gt;&gt; &#39;, .J)                          <b>:(RETURN)</b>
AI_1     AI = A&lt;I&gt;                                  <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
AI_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;AI.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
         &amp;CODE = 1
         A = %&#39;5,6,7&#39;
         I = %&#39;3,2,1&#39;
         A2 = AI(A, I)
         EQ(A2&lt;1&gt;, 7)                                            <b>:F(END)</b>
         EQ(A2&lt;2&gt;, 6)                                            <b>:F(END)</b>
         EQ(A2&lt;3&gt;, 5)                                            <b>:F(END)</b>
         EQ(AI(A, 1), 5)                                         <b>:F(END)</b>
         AI(A, 4)                                                <b>:S(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE AI
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL AI
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                #     ###                             *</i></font>
<font color="#818181"><i>*                               # #     #                              *</i></font>
<font color="#818181"><i>*                              #   #    #                              *</i></font>
<font color="#818181"><i>*                             #     #   #                              *</i></font>
<font color="#818181"><i>*                             #######   #                              *</i></font>
<font color="#818181"><i>*                             #     #   #                              *</i></font>
<font color="#818181"><i>*                             #     #  ###                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* AI                          APPLY INDEX                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* AI.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;AI&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:23 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'AI.INC'
-LINE 38 "AI.lss"
-INCLUDE 'CRACK.INC'
         &CODE = 1
         A = %'5,6,7'
         I = %'3,2,1'
         A2 = AI(A, I)
         EQ(A2<1>, 7)                                            :F(END)
         EQ(A2<2>, 6)                                            :F(END)
         EQ(A2<3>, 5)                                            :F(END)
         EQ(AI(A, 1), 5)                                         :F(END)
         AI(A, 4)                                                :S(END)
         &CODE = 0
END
<h1>ALL - Include all library components</h1>

Include all library components. This is used for ad-hoc programming,
and tests to ensure that library components are compatible (for
example, no label collisions), and to determine load time.

This also gives us the compilation (load) time for the library. It
takes around 50 milliseconds to compile all of the library routines;
80 milliseconds if producing a listing file. This would (for example)
limit the number of CGI transactions to 200 per second on my netbook.

[[
[fred@dejah snolib]$ snobol4 -s -M -n ALL.INC ENDCARD
The Macro Implementation of SNOBOL4 in C (CSNOBOL4) Version 1.5
    by Philip L. Budne, October 1, 2013
    Patch Fridtjof Weigel
SNOBOL4 (Version 3.11, May 19, 1975)
    Bell Telephone Laboratories, Incorporated

No errors detected in source program

Normal termination at level 0
ENDCARD.lss:6: Last statement executed was 0
SNOBOL4 statistics summary-
         51.840 ms. Compilation time
          0.000 ms. Execution time
              0 Statements executed, 0 failed
              0 Arithmetic operations performed
              0 Pattern matches performed
              0 Regenerations of dynamic storage
          0.000 ms. Execution time in GC
              0 Reads performed
              0 Writes performed
          0.000 ns. Average per statement executed
[fred@dejah snolib]$ 
]]

It taskes 36 milliseconds to compile ALL.INC on my Intel i3 (1.4Ghz).

<i>Building</i> the library from lss source takes a long time.

[[
[fred@dejah snolib] touch *.lss
[fred@dejah snolib] time make

... lots of output removed ...

real    3m15.685s
user    2m53.908s
sys     0m50.229s
[fred@dejah snolib]$ 

1m52s to build on the i3.

The majority of the time in generating the library is spent generating
the html documentation (mostly in the <i>ditaa</i> utility.
]]

<<INCS>>=
-INCLUDE 'AGT.INC'
-INCLUDE 'AI.INC'
-INCLUDE 'AOPA.INC'
-INCLUDE 'ATOL.INC'
-INCLUDE 'BALREV.INC'
-INCLUDE 'BALX.INC'
-INCLUDE 'BLEND.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CATA.INC'
-INCLUDE 'CGI.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'CH.INC'
-INCLUDE 'COMB.INC'
-INCLUDE 'COMPLEX.INC'
-INCLUDE 'COOKIE.INC'
-INCLUDE 'COPYL.INC'
-INCLUDE 'COUNT.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'CVAR.INC'
-INCLUDE 'DAY.INC'
-INCLUDE 'DDT.INC'
-INCLUDE 'DEDUPA.INC'
-INCLUDE 'DEXP.INC'
-INCLUDE 'DISPLAY.INC'
-INCLUDE 'DSERVE.INC'
-INCLUDE 'DYNAMIC.INC'
-INCLUDE 'FASTBAL.INC'
-INCLUDE 'FCGI.INC'
-INCLUDE 'FENCE.INC'
-INCLUDE 'FFI.INC'
-INCLUDE 'FIND.INC'
-INCLUDE 'FLOOR.INC'
-INCLUDE 'FOREACH.INC'
-INCLUDE 'FOR.INC'
-INCLUDE 'FREEZE.INC'
-INCLUDE 'GCD.INC'
-INCLUDE 'GDDT.INC'
-INCLUDE 'GETKEY.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'HEX.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'HTMLESC.INC'
-INCLUDE 'HTMLTMPL.INC'
-INCLUDE 'INFINIP.INC'
-INCLUDE 'ITERDIR.INC'
-INCLUDE 'JIT.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'LAST.INC'
-INCLUDE 'LIKE.INC'
-INCLUDE 'LINK.INC'
-INCLUDE 'LOGIC.INC'
-INCLUDE 'LOG.INC'
-INCLUDE 'LPROG.INC'
-INCLUDE 'MAX.INC'
-INCLUDE 'MDY.INC'
-INCLUDE 'NDBM.INC'
-INCLUDE 'NOTP.INC'
-INCLUDE 'ONCE.INC'
-INCLUDE 'ORDER.INC'
-INCLUDE 'P64.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'QUOTE.INC'
-INCLUDE 'RANDOM.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'READL.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'REDEFINE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'RESOL.INC'
-INCLUDE 'REVL.INC'
-INCLUDE 'ROMAN.INC'
-INCLUDE 'ROTATER.INC'
-INCLUDE 'ROUTING.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SDIFF.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SESSION.INC'
-INCLUDE 'SIZEA.INC'
-INCLUDE 'SKIM.INC'
-INCLUDE 'SLOAD.INC'
-INCLUDE 'SOUNDEX.INC'
-INCLUDE 'SPELL.INC'
-INCLUDE 'STACK.INC'
-INCLUDE 'STCL.INC'
-INCLUDE 'STROUT.INC'
-INCLUDE 'SWAP.INC'
-INCLUDE 'SYSLOG.INC'
-INCLUDE 'SYSTEM.INC'
-INCLUDE 'TEST.INC'
-INCLUDE 'TIMEGC.INC'
-INCLUDE 'TIME.INC'
-INCLUDE 'TIMER.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'TRUNC.INC'
-INCLUDE 'UNIQUE.INC'
-INCLUDE 'UTF8.INC'
-INCLUDE 'VDIFFER.INC'
-INCLUDE 'WRAPPER.INC'
@

<<>>=
-MODULE ALL
-IN72
<<INCS>>
-STITL ALL
-EJECT
*
************************************************************************
*                                                                      *
*                         #     #        #                             *
*                        # #    #        #                             *
*                       #   #   #        #                             *
*                      #     #  #        #                             *
*                      #######  #        #                             *
*                      #     #  #        #                             *
*                      #     #  #######  #######                       *
*                                                                      *
*                                                                      *
* ALL                      INCLUDE ALL                                 *
*                                                                      *
************************************************************************
*
* ALL.lss
*
* CE: .MSNOBOL4;
@
-MODULE ALL
-IN72
-LINE 60 "ALL.lss"
-INCLUDE 'AGT.INC'
-INCLUDE 'AI.INC'
-INCLUDE 'AOPA.INC'
-INCLUDE 'ATOL.INC'
-INCLUDE 'BALREV.INC'
-INCLUDE 'BALX.INC'
-INCLUDE 'BLEND.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CATA.INC'
-INCLUDE 'CGI.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'CH.INC'
-INCLUDE 'COMB.INC'
-INCLUDE 'COMPLEX.INC'
-INCLUDE 'COOKIE.INC'
-INCLUDE 'COPYL.INC'
-INCLUDE 'COUNT.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'CVAR.INC'
-INCLUDE 'DAY.INC'
-INCLUDE 'DDT.INC'
-INCLUDE 'DEDUPA.INC'
-INCLUDE 'DEXP.INC'
-INCLUDE 'DISPLAY.INC'
-INCLUDE 'DSERVE.INC'
-INCLUDE 'DYNAMIC.INC'
-INCLUDE 'FASTBAL.INC'
-INCLUDE 'FCGI.INC'
-INCLUDE 'FENCE.INC'
-INCLUDE 'FFI.INC'
-INCLUDE 'FIND.INC'
-INCLUDE 'FLOOR.INC'
-INCLUDE 'FOREACH.INC'
-INCLUDE 'FOR.INC'
-INCLUDE 'FREEZE.INC'
-INCLUDE 'GCD.INC'
-INCLUDE 'GDDT.INC'
-INCLUDE 'GETKEY.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'HEX.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'HTMLESC.INC'
-INCLUDE 'HTMLTMPL.INC'
-INCLUDE 'INFINIP.INC'
-INCLUDE 'ITERDIR.INC'
-INCLUDE 'JIT.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'LAST.INC'
-INCLUDE 'LIKE.INC'
-INCLUDE 'LINK.INC'
-INCLUDE 'LOGIC.INC'
-INCLUDE 'LOG.INC'
-INCLUDE 'LPROG.INC'
-INCLUDE 'MAX.INC'
-INCLUDE 'MDY.INC'
-INCLUDE 'NDBM.INC'
-INCLUDE 'NOTP.INC'
-INCLUDE 'ONCE.INC'
-INCLUDE 'ORDER.INC'
-INCLUDE 'P64.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'QUOTE.INC'
-INCLUDE 'RANDOM.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'READL.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'REDEFINE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'RESOL.INC'
-INCLUDE 'REVL.INC'
-INCLUDE 'ROMAN.INC'
-INCLUDE 'ROTATER.INC'
-INCLUDE 'ROUTING.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SDIFF.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SESSION.INC'
-INCLUDE 'SIZEA.INC'
-INCLUDE 'SKIM.INC'
-INCLUDE 'SLOAD.INC'
-INCLUDE 'SOUNDEX.INC'
-INCLUDE 'SPELL.INC'
-INCLUDE 'STACK.INC'
-INCLUDE 'STCL.INC'
-INCLUDE 'STROUT.INC'
-INCLUDE 'SWAP.INC'
-INCLUDE 'SYSLOG.INC'
-INCLUDE 'SYSTEM.INC'
-INCLUDE 'TEST.INC'
-INCLUDE 'TIMEGC.INC'
-INCLUDE 'TIME.INC'
-INCLUDE 'TIMER.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'TRUNC.INC'
-INCLUDE 'UNIQUE.INC'
-INCLUDE 'UTF8.INC'
-INCLUDE 'VDIFFER.INC'
-INCLUDE 'WRAPPER.INC'
-LINE 166 "ALL.lss"
-STITL ALL
-EJECT
*
************************************************************************
*                                                                      *
*                         #     #        #                             *
*                        # #    #        #                             *
*                       #   #   #        #                             *
*                      #     #  #        #                             *
*                      #######  #        #                             *
*                      #     #  #        #                             *
*                      #     #  #######  #######                       *
*                                                                      *
*                                                                      *
* ALL                      INCLUDE ALL                                 *
*                                                                      *
************************************************************************
*
* ALL.lss
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ALL - Include all library components</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Include all library components. This is used for ad-hoc programming,
and tests to ensure that library components are compatible (for
example, no label collisions), and to determine load time.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This also gives us the compilation (load) time for the library. It
takes around 50 milliseconds to compile all of the library routines;
80 milliseconds if producing a listing file. This would (for example)
limit the number of CGI transactions to 200 per second on my netbook.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| [fred@dejah snolib]$ snobol4 -s -M -n ALL.INC ENDCARD
| The Macro Implementation of SNOBOL4 in C (CSNOBOL4) Version 1.5
|     by Philip L. Budne, October 1, 2013
|     Patch Fridtjof Weigel
| SNOBOL4 (Version 3.11, May 19, 1975)
|     Bell Telephone Laboratories, Incorporated
| 
| No errors detected in source program
| 
| Normal termination at level 0
| ENDCARD.lss:6: Last statement executed was 0
| SNOBOL4 statistics summary-
|          51.840 ms. Compilation time
|           0.000 ms. Execution time
|               0 Statements executed, 0 failed
|               0 Arithmetic operations performed
|               0 Pattern matches performed
|               0 Regenerations of dynamic storage
|           0.000 ms. Execution time in GC
|               0 Reads performed
|               0 Writes performed
|           0.000 ns. Average per statement executed
| [fred@dejah snolib]$
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
It taskes 36 milliseconds to compile ALL.INC on my Intel i3 (1.4Ghz).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<i>Building</i> the library from lss source takes a long time.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| [fred@dejah snolib] touch *.lss
| [fred@dejah snolib] time make
| 
| ... lots of output removed ...
| 
| real    3m15.685s
| user    2m53.908s
| sys     0m50.229s
| [fred@dejah snolib]$
| 
| 1m52s to build on the i3.
| 
| The majority of the time in generating the library is spent generating
| the html documentation (mostly in the <i>ditaa</i> utility.
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCS&raquo;&equiv;</b>
-INCLUDE &#39;AGT.INC&#39;
-INCLUDE &#39;AI.INC&#39;
-INCLUDE &#39;AOPA.INC&#39;
-INCLUDE &#39;ATOL.INC&#39;
-INCLUDE &#39;BALREV.INC&#39;
-INCLUDE &#39;BALX.INC&#39;
-INCLUDE &#39;BLEND.INC&#39;
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;BRKREM.INC&#39;
-INCLUDE &#39;CATA.INC&#39;
-INCLUDE &#39;CGI.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;CH.INC&#39;
-INCLUDE &#39;COMB.INC&#39;
-INCLUDE &#39;COMPLEX.INC&#39;
-INCLUDE &#39;COOKIE.INC&#39;
-INCLUDE &#39;COPYL.INC&#39;
-INCLUDE &#39;COUNT.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;CSNOBOL4.INC&#39;
-INCLUDE &#39;CVAR.INC&#39;
-INCLUDE &#39;DAY.INC&#39;
-INCLUDE &#39;DDT.INC&#39;
-INCLUDE &#39;DEDUPA.INC&#39;
-INCLUDE &#39;DEXP.INC&#39;
-INCLUDE &#39;DISPLAY.INC&#39;
-INCLUDE &#39;DSERVE.INC&#39;
-INCLUDE &#39;DYNAMIC.INC&#39;
-INCLUDE &#39;FASTBAL.INC&#39;
-INCLUDE &#39;FCGI.INC&#39;
-INCLUDE &#39;FENCE.INC&#39;
-INCLUDE &#39;FFI.INC&#39;
-INCLUDE &#39;FIND.INC&#39;
-INCLUDE &#39;FLOOR.INC&#39;
-INCLUDE &#39;FOREACH.INC&#39;
-INCLUDE &#39;FOR.INC&#39;
-INCLUDE &#39;FREEZE.INC&#39;
-INCLUDE &#39;GCD.INC&#39;
-INCLUDE &#39;GDDT.INC&#39;
-INCLUDE &#39;GETKEY.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;HEX.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;HTMLESC.INC&#39;
-INCLUDE &#39;HTMLTMPL.INC&#39;
-INCLUDE &#39;INFINIP.INC&#39;
-INCLUDE &#39;ITERDIR.INC&#39;
-INCLUDE &#39;JIT.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;LAST.INC&#39;
-INCLUDE &#39;LIKE.INC&#39;
-INCLUDE &#39;LINK.INC&#39;
-INCLUDE &#39;LOGIC.INC&#39;
-INCLUDE &#39;LOG.INC&#39;
-INCLUDE &#39;LPROG.INC&#39;
-INCLUDE &#39;MAX.INC&#39;
-INCLUDE &#39;MDY.INC&#39;
-INCLUDE &#39;NDBM.INC&#39;
-INCLUDE &#39;NOTP.INC&#39;
-INCLUDE &#39;ONCE.INC&#39;
-INCLUDE &#39;ORDER.INC&#39;
-INCLUDE &#39;P64.INC&#39;
-INCLUDE &#39;PSQL.INC&#39;
-INCLUDE &#39;QUOTE.INC&#39;
-INCLUDE &#39;RANDOM.INC&#39;
-INCLUDE &#39;READFILE.INC&#39;
-INCLUDE &#39;READL.INC&#39;
-INCLUDE &#39;READLINE.INC&#39;
-INCLUDE &#39;REDEFINE.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
-INCLUDE &#39;RESOL.INC&#39;
-INCLUDE &#39;REVL.INC&#39;
-INCLUDE &#39;ROMAN.INC&#39;
-INCLUDE &#39;ROTATER.INC&#39;
-INCLUDE &#39;ROUTING.INC&#39;
-INCLUDE &#39;SCOOP.INC&#39;
-INCLUDE &#39;SDIFF.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;SESSION.INC&#39;
-INCLUDE &#39;SIZEA.INC&#39;
-INCLUDE &#39;SKIM.INC&#39;
-INCLUDE &#39;SLOAD.INC&#39;
-INCLUDE &#39;SOUNDEX.INC&#39;
-INCLUDE &#39;SPELL.INC&#39;
-INCLUDE &#39;STACK.INC&#39;
-INCLUDE &#39;STCL.INC&#39;
-INCLUDE &#39;STROUT.INC&#39;
-INCLUDE &#39;SWAP.INC&#39;
-INCLUDE &#39;SYSLOG.INC&#39;
-INCLUDE &#39;SYSTEM.INC&#39;
-INCLUDE &#39;TEST.INC&#39;
-INCLUDE &#39;TIMEGC.INC&#39;
-INCLUDE &#39;TIME.INC&#39;
-INCLUDE &#39;TIMER.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
-INCLUDE &#39;TRUNC.INC&#39;
-INCLUDE &#39;UNIQUE.INC&#39;
-INCLUDE &#39;UTF8.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
-INCLUDE &#39;WRAPPER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE ALL
-IN72
<b>&laquo;INCS&raquo;</b>
-STITL ALL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                         #     #        #                             *</i></font>
<font color="#818181"><i>*                        # #    #        #                             *</i></font>
<font color="#818181"><i>*                       #   #   #        #                             *</i></font>
<font color="#818181"><i>*                      #     #  #        #                             *</i></font>
<font color="#818181"><i>*                      #######  #        #                             *</i></font>
<font color="#818181"><i>*                      #     #  #        #                             *</i></font>
<font color="#818181"><i>*                      #     #  #######  #######                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ALL                      INCLUDE ALL                                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ALL.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:23 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>AOPA - Apply Infix Operator to Array</h1>

[[AOPA(A1,OP,A2)]] will apply the infix operator [[OP]] to
corresponding pairs of [[A1]] and [[A2]], returning an array unless
both are scalars.

For example, [[AOPA(A,'+',1)]] will add [[1]] to each element of [[A]].

[[AOPA()]] has four cases: array operation array, array operation
scalar, scalar operation array, and finally scalar operation scalar.

<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>=
-INCLUDE 'SEQ.INC'
@

<<AOPA>>=
-PUBLIC AOPA()
*
         DEFINE('AOPA(A1,OP,A2)S1,I,S2,S')                   :(AOPA_END)
*
AOPA     IDENT(DATATYPE(A1), 'ARRAY')                         :S(AOPA_1)
         IDENT(DATATYPE(A2), 'ARRAY')                         :S(AOPA_2)
         AOPA = EVAL('A1 ' OP ' A2')                           :(RETURN)
AOPA_1   S1 = '<I>'
         S2 = IDENT(DATATYPE(A2), 'ARRAY')  '<I>'
         AOPA = ARRAY(PROTOTYPE(A1))                      :(AOPA_COMMON)
AOPA_2   S2 = '<I>'
         AOPA = ARRAY(PROTOTYPE(A2))
AOPA_COMMON
         S = ' AOPA<I> = A1' S1 ' ' OP ' A2' S2
         SEQ(S, .I)                                            :(RETURN)
*
AOPA_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'AOPA.INC'
-INCLUDE 'CRACK.INC'
         &CODE = 1
         A = %'1,2,3'
         B = %'10,20,30'
* ARRAY OPERATION ARRAY
         C = AOPA(A, '+', B)
         EQ(C<1>, 11)                                            :F(END)
         EQ(C<2>, 22)                                            :F(END)
         EQ(C<3>, 33)                                            :F(END)
* ARRAY OPERATION SCALAR
         C = AOPA(A, '-', 1)
         EQ(C<1>, 0)                                             :F(END)
         EQ(C<2>, 1)                                             :F(END)
         EQ(C<3>, 2)                                             :F(END)
* SCALAR OPERATION SCALAR
         C = AOPA(3, '*', B)
         EQ(C<1>, 30)                                            :F(END)
         EQ(C<2>, 60)                                            :F(END)
         EQ(C<3>, 90)                                            :F(END)
* SCALAR OPERATION SCALAR
         EQ(AOPA(6, '/', 3), 2)                                  :F(END)
         &CODE = 0
END
@

<<>>=
-MODULE AOPA
-IN72
<<INCLUDES>>
-STITL AOPA
-EJECT
*
************************************************************************
*                                                                      *
*                    #     #######  ######      #                      *
*                   # #    #     #  #     #    # #                     *
*                  #   #   #     #  #     #   #   #                    *
*                 #     #  #     #  ######   #     #                   *
*                 #######  #     #  #        #######                   *
*                 #     #  #     #  #        #     #                   *
*                 #     #  #######  #        #     #                   *
*                                                                      *
* AOPA                 APPLY OPERATOR TO ARRAY                         *
*                                                                      *
************************************************************************
*
* AOPA.lss
*
<<AOPA>>
*
* CE: .MSNOBOL4;
@
-MODULE AOPA
-IN72
-LINE 16 "AOPA.lss"
-INCLUDE 'SEQ.INC'
-LINE 72 "AOPA.lss"
-STITL AOPA
-EJECT
*
************************************************************************
*                                                                      *
*                    #     #######  ######      #                      *
*                   # #    #     #  #     #    # #                     *
*                  #   #   #     #  #     #   #   #                    *
*                 #     #  #     #  ######   #     #                   *
*                 #######  #     #  #        #######                   *
*                 #     #  #     #  #        #     #                   *
*                 #     #  #######  #        #     #                   *
*                                                                      *
* AOPA                 APPLY OPERATOR TO ARRAY                         *
*                                                                      *
************************************************************************
*
* AOPA.lss
*
-LINE 20 "AOPA.lss"
-PUBLIC AOPA()
*
         DEFINE('AOPA(A1,OP,A2)S1,I,S2,S')                   :(AOPA_END)
*
AOPA     IDENT(DATATYPE(A1), 'ARRAY')                         :S(AOPA_1)
         IDENT(DATATYPE(A2), 'ARRAY')                         :S(AOPA_2)
         AOPA = EVAL('A1 ' OP ' A2')                           :(RETURN)
AOPA_1   S1 = '<I>'
         S2 = IDENT(DATATYPE(A2), 'ARRAY')  '<I>'
         AOPA = ARRAY(PROTOTYPE(A1))                      :(AOPA_COMMON)
AOPA_2   S2 = '<I>'
         AOPA = ARRAY(PROTOTYPE(A2))
AOPA_COMMON
         S = ' AOPA<I> = A1' S1 ' ' OP ' A2' S2
         SEQ(S, .I)                                            :(RETURN)
*
AOPA_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>AOPA - Apply Infix Operator to Array</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">AOPA(A1,OP,A2)</font> will apply the infix operator <font face="Source Code Pro">OP</font> to
corresponding pairs of <font face="Source Code Pro">A1</font> and <font face="Source Code Pro">A2</font>, returning an array unless
both are scalars.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
For example, <font face="Source Code Pro">AOPA(A,'+',1)</font> will add <font face="Source Code Pro">1</font> to each element of <font face="Source Code Pro">A</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">AOPA()</font> has four cases: array operation array, array operation
scalar, scalar operation array, and finally scalar operation scalar.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;AOPA&raquo;&equiv;</b>
-PUBLIC AOPA()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;AOPA(A1,OP,A2)S1,I,S2,S&#39;)                   <b>:(AOPA_END)</b>
<font color="#818181"><i>*</i></font>
AOPA     IDENT(DATATYPE(A1), &#39;ARRAY&#39;)                         <b>:S(AOPA_1)</b>
         IDENT(DATATYPE(A2), &#39;ARRAY&#39;)                         <b>:S(AOPA_2)</b>
         AOPA = EVAL(&#39;A1 &#39; OP &#39; A2&#39;)                           <b>:(RETURN)</b>
AOPA_1   S1 = &#39;&lt;I&gt;&#39;
         S2 = IDENT(DATATYPE(A2), &#39;ARRAY&#39;)  &#39;&lt;I&gt;&#39;
         AOPA = ARRAY(PROTOTYPE(A1))                      <b>:(AOPA_COMMON)</b>
AOPA_2   S2 = &#39;&lt;I&gt;&#39;
         AOPA = ARRAY(PROTOTYPE(A2))
AOPA_COMMON
         S = &#39; AOPA&lt;I&gt; = A1&#39; S1 &#39; &#39; OP &#39; A2&#39; S2
         SEQ(S, .I)                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
AOPA_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;AOPA.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
         &amp;CODE = 1
         A = %&#39;1,2,3&#39;
         B = %&#39;10,20,30&#39;
<font color="#818181"><i>* ARRAY OPERATION ARRAY</i></font>
         C = AOPA(A, &#39;+&#39;, B)
         EQ(C&lt;1&gt;, 11)                                            <b>:F(END)</b>
         EQ(C&lt;2&gt;, 22)                                            <b>:F(END)</b>
         EQ(C&lt;3&gt;, 33)                                            <b>:F(END)</b>
<font color="#818181"><i>* ARRAY OPERATION SCALAR</i></font>
         C = AOPA(A, &#39;-&#39;, 1)
         EQ(C&lt;1&gt;, 0)                                             <b>:F(END)</b>
         EQ(C&lt;2&gt;, 1)                                             <b>:F(END)</b>
         EQ(C&lt;3&gt;, 2)                                             <b>:F(END)</b>
<font color="#818181"><i>* SCALAR OPERATION SCALAR</i></font>
         C = AOPA(3, &#39;*&#39;, B)
         EQ(C&lt;1&gt;, 30)                                            <b>:F(END)</b>
         EQ(C&lt;2&gt;, 60)                                            <b>:F(END)</b>
         EQ(C&lt;3&gt;, 90)                                            <b>:F(END)</b>
<font color="#818181"><i>* SCALAR OPERATION SCALAR</i></font>
         EQ(AOPA(6, &#39;/&#39;, 3), 2)                                  <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE AOPA
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL AOPA
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #     #######  ######      #                      *</i></font>
<font color="#818181"><i>*                   # #    #     #  #     #    # #                     *</i></font>
<font color="#818181"><i>*                  #   #   #     #  #     #   #   #                    *</i></font>
<font color="#818181"><i>*                 #     #  #     #  ######   #     #                   *</i></font>
<font color="#818181"><i>*                 #######  #     #  #        #######                   *</i></font>
<font color="#818181"><i>*                 #     #  #     #  #        #     #                   *</i></font>
<font color="#818181"><i>*                 #     #  #######  #        #     #                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* AOPA                 APPLY OPERATOR TO ARRAY                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* AOPA.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;AOPA&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:24 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'AOPA.INC'
-LINE 43 "AOPA.lss"
-INCLUDE 'CRACK.INC'
         &CODE = 1
         A = %'1,2,3'
         B = %'10,20,30'
* ARRAY OPERATION ARRAY
         C = AOPA(A, '+', B)
         EQ(C<1>, 11)                                            :F(END)
         EQ(C<2>, 22)                                            :F(END)
         EQ(C<3>, 33)                                            :F(END)
* ARRAY OPERATION SCALAR
         C = AOPA(A, '-', 1)
         EQ(C<1>, 0)                                             :F(END)
         EQ(C<2>, 1)                                             :F(END)
         EQ(C<3>, 2)                                             :F(END)
* SCALAR OPERATION SCALAR
         C = AOPA(3, '*', B)
         EQ(C<1>, 30)                                            :F(END)
         EQ(C<2>, 60)                                            :F(END)
         EQ(C<3>, 90)                                            :F(END)
* SCALAR OPERATION SCALAR
         EQ(AOPA(6, '/', 3), 2)                                  :F(END)
         &CODE = 0
END
<h1>APPENDA - Append element to array</h1>

Array append. Append V onto the end of array A. Extends a by one
element. Not an efficient way to build an array, but it is
convenient.

<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>= 
-INCLUDE 'SEQ.INC'
-INCLUDE 'SIZEA.INC'
@

<<AI>>=
-PUBLIC APPENDA
*
         DEFINE('APPENDA(A,V)I')                          :(END_APPENDA)
*
APPENDA  APPENDA = ARRAY(SIZEA(A) + 1)
         SEQ(' APPENDA<I> = A<I>', .I)
         APPENDA<I> = V                                        :(RETURN)
*
END_APPENDA
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'APPENDA.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE APPENDA
-IN72
<<INCLUDES>>
-STITL AI
-EJECT
*
************************************************************************
*                                                                      *
*       #     ######   ######   #######  #     #  ######      #        *
*      # #    #     #  #     #  #        ##    #  #     #    # #       *
*     #   #   #     #  #     #  #        # #   #  #     #   #   #      *
*    #     #  ######   ######   #####    #  #  #  #     #  #     #     *
*    #######  #        #        #        #   # #  #     #  #######     *
*    #     #  #        #        #        #    ##  #     #  #     #     *
*    #     #  #        #        #######  #     #  ######   #     #     *
*                                                                      *
* APPENDA              APPEND ELEMENT TO ARRRAY                        *
*                                                                      *
************************************************************************
*
* APPENDA.lss
*
<<AI>>
*
* CE: .MSNOBOL4;
@
-MODULE APPENDA
-IN72
-LINE 11 "APPENDA.lss"
-INCLUDE 'SEQ.INC'
-INCLUDE 'SIZEA.INC'
-LINE 40 "APPENDA.lss"
-STITL AI
-EJECT
*
************************************************************************
*                                                                      *
*       #     ######   ######   #######  #     #  ######      #        *
*      # #    #     #  #     #  #        ##    #  #     #    # #       *
*     #   #   #     #  #     #  #        # #   #  #     #   #   #      *
*    #     #  ######   ######   #####    #  #  #  #     #  #     #     *
*    #######  #        #        #        #   # #  #     #  #######     *
*    #     #  #        #        #        #    ##  #     #  #     #     *
*    #     #  #        #        #######  #     #  ######   #     #     *
*                                                                      *
* APPENDA              APPEND ELEMENT TO ARRRAY                        *
*                                                                      *
************************************************************************
*
* APPENDA.lss
*
-LINE 16 "APPENDA.lss"
-PUBLIC APPENDA
*
         DEFINE('APPENDA(A,V)I')                          :(END_APPENDA)
*
APPENDA  APPENDA = ARRAY(SIZEA(A) + 1)
         SEQ(' APPENDA<I> = A<I>', .I)
         APPENDA<I> = V                                        :(RETURN)
*
END_APPENDA
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>APPENDA - Append element to array</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Array append. Append V onto the end of array A. Extends a by one
element. Not an efficient way to build an array, but it is
convenient.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;SIZEA.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;AI&raquo;&equiv;</b>
-PUBLIC APPENDA
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;APPENDA(A,V)I&#39;)                          <b>:(END_APPENDA)</b>
<font color="#818181"><i>*</i></font>
APPENDA  APPENDA = ARRAY(SIZEA(A) + 1)
         SEQ(&#39; APPENDA&lt;I&gt; = A&lt;I&gt;&#39;, .I)
         APPENDA&lt;I&gt; = V                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_APPENDA
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;APPENDA.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE APPENDA
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL AI
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*       #     ######   ######   #######  #     #  ######      #        *</i></font>
<font color="#818181"><i>*      # #    #     #  #     #  #        ##    #  #     #    # #       *</i></font>
<font color="#818181"><i>*     #   #   #     #  #     #  #        # #   #  #     #   #   #      *</i></font>
<font color="#818181"><i>*    #     #  ######   ######   #####    #  #  #  #     #  #     #     *</i></font>
<font color="#818181"><i>*    #######  #        #        #        #   # #  #     #  #######     *</i></font>
<font color="#818181"><i>*    #     #  #        #        #        #    ##  #     #  #     #     *</i></font>
<font color="#818181"><i>*    #     #  #        #        #######  #     #  ######   #     #     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* APPENDA              APPEND ELEMENT TO ARRRAY                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* APPENDA.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;AI&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:27 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'APPENDA.INC'
-LINE 31 "APPENDA.lss"
         &CODE = 1
         &CODE = 0
END
<h1>ATOL - Array to List</h1>

[[ATOL(A)]] returns a list of the elements of array [[A]].

<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="REVL.html">REVL</a><br>

<<INCLUDES>>= 
-INCLUDE 'LINK.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'REVL.INC'
@

<<ATOL>>=
-PUBLIC ATOL()
*
         DEFINE('ATOL(A)I')                                  :(END_ATOL)
*
ATOL     SEQ(' ATOL = LINK(A<I>, ATOL)', .I)
         ATOL = REVL(ATOL)                                     :(RETURN)
*
END_ATOL
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ATOL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE ATOL
-USES LINK()
<<INCLUDES>>
-IN72
-STITL ATOL
-EJECT
*
************************************************************************
*                                                                      *
*                     #     #######  #######  #                        *
*                    # #       #     #     #  #                        *
*                   #   #      #     #     #  #                        *
*                  #     #     #     #     #  #                        *
*                  #######     #     #     #  #                        *
*                  #     #     #     #     #  #                        *
*                  #     #     #     #######  #######                  *
*                                                                      *
* ATOL                      ARRAY TO LIST                              *
*                                                                      *
************************************************************************
*
* ATOL.lss
*
<<ATOL>>
*
* CE: .MSNOBOL4;
@
-MODULE ATOL
-USES LINK()
-LINE 11 "ATOL.lss"
-INCLUDE 'LINK.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'REVL.INC'
-LINE 40 "ATOL.lss"
-IN72
-STITL ATOL
-EJECT
*
************************************************************************
*                                                                      *
*                     #     #######  #######  #                        *
*                    # #       #     #     #  #                        *
*                   #   #      #     #     #  #                        *
*                  #     #     #     #     #  #                        *
*                  #######     #     #     #  #                        *
*                  #     #     #     #     #  #                        *
*                  #     #     #     #######  #######                  *
*                                                                      *
* ATOL                      ARRAY TO LIST                              *
*                                                                      *
************************************************************************
*
* ATOL.lss
*
-LINE 17 "ATOL.lss"
-PUBLIC ATOL()
*
         DEFINE('ATOL(A)I')                                  :(END_ATOL)
*
ATOL     SEQ(' ATOL = LINK(A<I>, ATOL)', .I)
         ATOL = REVL(ATOL)                                     :(RETURN)
*
END_ATOL
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ATOL - Array to List</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ATOL(A)</font> returns a list of the elements of array <font face="Source Code Pro">A</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="REVL.html">REVL</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LINK.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;REVL.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ATOL&raquo;&equiv;</b>
-PUBLIC ATOL()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;ATOL(A)I&#39;)                                  <b>:(END_ATOL)</b>
<font color="#818181"><i>*</i></font>
ATOL     SEQ(&#39; ATOL = LINK(A&lt;I&gt;, ATOL)&#39;, .I)
         ATOL = REVL(ATOL)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_ATOL
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ATOL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE ATOL
-USES LINK()
<b>&laquo;INCLUDES&raquo;</b>
-IN72
-STITL ATOL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                     #     #######  #######  #                        *</i></font>
<font color="#818181"><i>*                    # #       #     #     #  #                        *</i></font>
<font color="#818181"><i>*                   #   #      #     #     #  #                        *</i></font>
<font color="#818181"><i>*                  #     #     #     #     #  #                        *</i></font>
<font color="#818181"><i>*                  #######     #     #     #  #                        *</i></font>
<font color="#818181"><i>*                  #     #     #     #     #  #                        *</i></font>
<font color="#818181"><i>*                  #     #     #     #######  #######                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ATOL                      ARRAY TO LIST                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ATOL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ATOL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:26 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ATOL.INC'
-LINE 31 "ATOL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>BALREV - Balanced Reverse</h1>

[[BALREV(S)]] returns the balanced reversal of the string
[[S]]: characters of [[S]] are reversed and parentheses are
interchanged. [[BALREV('F(X)')]] returns [['(X)F']] instead of
[[')X(F']] like a simple reversal.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<BALREV>>=
-MODULE BALREV
-PUBLIC BALREV()
         DEFINE('BALREV(S)')                               :(BALREV_END)
*
BALREV   BALREV = REPLACE(REVERSE(S), ')(', '()')              :(RETURN)
*
BALREV_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BALREV.INC'
         &CODE = 1
         IDENT(BALREV('F(X)'), '(X)F')                           :F(END)
         &CODE = 0
END
@

<<>>=
-STITL BALREV
-EJECT
*
************************************************************************
*                                                                      *
*           ######      #     #        ######   #######  #     #       *
*           #     #    # #    #        #     #  #        #     #       *
*           #     #   #   #   #        #     #  #        #     #       *
*           ######   #     #  #        ######   #####    #     #       *
*           #     #  #######  #        #   #    #         #   #        *
*           #     #  #     #  #        #    #   #          # #         *
*           ######   #     #  #######  #     #  #######     #          *
*                                                                      *
* BALREV                   BALANCED REVERSE                            *
*                                                                      *
************************************************************************
*
* BALREV.lss
*
<<BALREV>>
*
* CE: .MSNOBOL4;
@
-STITL BALREV
-EJECT
*
-LINE 37 "BALREV.lss"
************************************************************************
*                                                                      *
*           ######      #     #        ######   #######  #     #       *
*           #     #    # #    #        #     #  #        #     #       *
*           #     #   #   #   #        #     #  #        #     #       *
*           ######   #     #  #        ######   #####    #     #       *
*           #     #  #######  #        #   #    #         #   #        *
*           #     #  #     #  #        #    #   #          # #         *
*           ######   #     #  #######  #     #  #######     #          *
*                                                                      *
* BALREV                   BALANCED REVERSE                            *
*                                                                      *
************************************************************************
*
* BALREV.lss
*
-LINE 14 "BALREV.lss"
-MODULE BALREV
-PUBLIC BALREV()
         DEFINE('BALREV(S)')                               :(BALREV_END)
*
BALREV   BALREV = REPLACE(REVERSE(S), ')(', '()')              :(RETURN)
*
BALREV_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>BALREV - Balanced Reverse</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">BALREV(S)</font> returns the balanced reversal of the string
<font face="Source Code Pro">S</font>: characters of <font face="Source Code Pro">S</font> are reversed and parentheses are
interchanged. <font face="Source Code Pro">BALREV('F(X)')</font> returns <font face="Source Code Pro">'(X)F'</font> instead of
<font face="Source Code Pro">')X(F'</font> like a simple reversal.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BALREV&raquo;&equiv;</b>
-MODULE BALREV
-PUBLIC BALREV()
         DEFINE(&#39;BALREV(S)&#39;)                               <b>:(BALREV_END)</b>
<font color="#818181"><i>*</i></font>
BALREV   BALREV = REPLACE(REVERSE(S), &#39;)(&#39;, &#39;()&#39;)              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
BALREV_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;BALREV.INC&#39;
         &amp;CODE = 1
         IDENT(BALREV(&#39;F(X)&#39;), &#39;(X)F&#39;)                           <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL BALREV
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*           ######      #     #        ######   #######  #     #       *</i></font>
<font color="#818181"><i>*           #     #    # #    #        #     #  #        #     #       *</i></font>
<font color="#818181"><i>*           #     #   #   #   #        #     #  #        #     #       *</i></font>
<font color="#818181"><i>*           ######   #     #  #        ######   #####    #     #       *</i></font>
<font color="#818181"><i>*           #     #  #######  #        #   #    #         #   #        *</i></font>
<font color="#818181"><i>*           #     #  #     #  #        #    #   #          # #         *</i></font>
<font color="#818181"><i>*           ######   #     #  #######  #     #  #######     #          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* BALREV                   BALANCED REVERSE                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BALREV.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;BALREV&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:46 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BALREV.INC'
-LINE 27 "BALREV.lss"
         &CODE = 1
         IDENT(BALREV('F(X)'), '(X)F')                           :F(END)
         &CODE = 0
END
<h1>BALX - BAL Extended</h1>

[[BALX(PARENS,QTS)]] will return a pattern which will match all
non-null balanced strings where [[PARENS]] is used to specify paired
brackets in nested fashion and [[QTS]] specifies characters to be
used as quotes.  Bracket characters within quotes are ignored for
balancing purposes.

[[BALX('(<[]>)', "'" '"')]] will match a balanced string in SNOBOL4
source.

<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>

<h2>See Also</h2>
<a href="FASTBAL.html">FASTBAL</a>

<<INCLUDES>>=
-INCLUDE 'UNIQUE.INC'
@

<<BALX>>=
-MODULE BALX
-PUBLIC BALX()
         DEFINE('BALX(PARENS,QTS)Q,GBAL,NAME,STAR,LP,RP')    :(BALX_END)
*
BALX     NAME = UNIQUE()
         STAR = CONVERT(NAME, 'EXPRESSION')
         GBAL = NOTANY(PARENS QTS)
BALX_1   QTS LEN(1) . Q =                                     :F(BALX_2)
         GBAL = Q BREAK(Q) Q | GBAL                            :(BALX_1)
BALX_2   PARENS LEN(1) . LP  RTAB(1) . PARENS  LEN(1) . RP    :F(BALX_3)
         GBAL = LP  (STAR | NULL) RP  |  GBAL                  :(BALX_2)
BALX_3   BALX = GBAL ARBNO(GBAL)
         $NAME = BALX                                          :(RETURN)
*
BALX_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BALX.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL BALX
-EJECT
*
************************************************************************
*                                                                      *
*                  ######      #     #        #     #                  *
*                  #     #    # #    #         #   #                   *
*                  #     #   #   #   #          # #                    *
*                  ######   #     #  #           #                     *
*                  #     #  #######  #          # #                    *
*                  #     #  #     #  #         #   #                   *
*                  ######   #     #  #######  #     #                  *
*                                                                      *
* BALX                      BAL EXTENDED                               *
*                                                                      *
************************************************************************
*
* BALX.lss
*
<<BALX>>
*
* CE: .MSNOBOL4;
@
-LINE 19 "BALX.lss"
-INCLUDE 'UNIQUE.INC'
-STITL BALX
-EJECT
-LINE 53 "BALX.lss"
*
************************************************************************
*                                                                      *
*                  ######      #     #        #     #                  *
*                  #     #    # #    #         #   #                   *
*                  #     #   #   #   #          # #                    *
*                  ######   #     #  #           #                     *
*                  #     #  #######  #          # #                    *
*                  #     #  #     #  #         #   #                   *
*                  ######   #     #  #######  #     #                  *
*                                                                      *
* BALX                      BAL EXTENDED                               *
*                                                                      *
************************************************************************
*
* BALX.lss
*
-LINE 23 "BALX.lss"
-MODULE BALX
-PUBLIC BALX()
         DEFINE('BALX(PARENS,QTS)Q,GBAL,NAME,STAR,LP,RP')    :(BALX_END)
*
BALX     NAME = UNIQUE()
         STAR = CONVERT(NAME, 'EXPRESSION')
         GBAL = NOTANY(PARENS QTS)
BALX_1   QTS LEN(1) . Q =                                     :F(BALX_2)
         GBAL = Q BREAK(Q) Q | GBAL                            :(BALX_1)
BALX_2   PARENS LEN(1) . LP  RTAB(1) . PARENS  LEN(1) . RP    :F(BALX_3)
         GBAL = LP  (STAR | NULL) RP  |  GBAL                  :(BALX_2)
BALX_3   BALX = GBAL ARBNO(GBAL)
         $NAME = BALX                                          :(RETURN)
*
BALX_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>BALX - BAL Extended</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">BALX(PARENS,QTS)</font> will return a pattern which will match all
non-null balanced strings where <font face="Source Code Pro">PARENS</font> is used to specify paired
brackets in nested fashion and <font face="Source Code Pro">QTS</font> specifies characters to be
used as quotes.  Bracket characters within quotes are ignored for
balancing purposes.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">BALX('(<[]>)', "'" '"')</font> will match a balanced string in SNOBOL4
source.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="FASTBAL.html">FASTBAL</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BALX&raquo;&equiv;</b>
-MODULE BALX
-PUBLIC BALX()
         DEFINE(&#39;BALX(PARENS,QTS)Q,GBAL,NAME,STAR,LP,RP&#39;)    <b>:(BALX_END)</b>
<font color="#818181"><i>*</i></font>
BALX     NAME = UNIQUE()
         STAR = CONVERT(NAME, &#39;EXPRESSION&#39;)
         GBAL = NOTANY(PARENS QTS)
BALX_1   QTS LEN(1) . Q =                                     <b>:F(BALX_2)</b>
         GBAL = Q BREAK(Q) Q | GBAL                            <b>:(BALX_1)</b>
BALX_2   PARENS LEN(1) . LP  RTAB(1) . PARENS  LEN(1) . RP    <b>:F(BALX_3)</b>
         GBAL = LP  (STAR | NULL) RP  |  GBAL                  <b>:(BALX_2)</b>
BALX_3   BALX = GBAL ARBNO(GBAL)
         $NAME = BALX                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
BALX_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;BALX.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL BALX
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  ######      #     #        #     #                  *</i></font>
<font color="#818181"><i>*                  #     #    # #    #         #   #                   *</i></font>
<font color="#818181"><i>*                  #     #   #   #   #          # #                    *</i></font>
<font color="#818181"><i>*                  ######   #     #  #           #                     *</i></font>
<font color="#818181"><i>*                  #     #  #######  #          # #                    *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #         #   #                   *</i></font>
<font color="#818181"><i>*                  ######   #     #  #######  #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* BALX                      BAL EXTENDED                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BALX.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;BALX&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:46 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BALX.INC'
-LINE 44 "BALX.lss"
         &CODE = 1
         &CODE = 0
END
<h1>BLEND - Blend two strings</h1>

[[BLEND(S1,S2)]] will blend the two (equi-length) strings [[S1]] and
[[S2]] such that every other character is taken from each string. Thus,
[[BLEND('ABC','123')]] will return [['A1B2C3']].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<BLEND>>=
-MODULE BLEND
-PUBLIC BLEND()
         DEFINE('BLEND(S1,S2)T1,T2,ABC,XYZ,L1,L2')
         &ALPHABET LEN(128) . ABC LEN(128) . XYZ
BLE_1    ABC LEN(1) . T1 =                                 :F(BLEND_END)
         XYZ LEN(1) . T2 =
         BLENDED_ALPHABET = BLENDED_ALPHABET T1 T2              :(BLE_1)
*
BLEND    L1 = SIZE(S1)
         GT(L1, 128)                                         :F(BLEND_1)
         EQ(L1, 0)                                            :S(RETURN)
         S1 LEN(128) . S1 REM . T1
         S2 LEN(128) . S2 REM . T2
         BLEND = REPLACE(BLENDED_ALPHABET, &ALPHABET, S1 S2)
         BLEND(T1, T2)                                         :(RETURN)
BLEND_1  L2 = SIZE(S2)
         &ALPHABET LEN(*L1) . ABC TAB(128) LEN(*L2) . XYZ
         BLENDED_ALPHABET LEN(*(L1 + L2)) . AXBYCZ
         BLEND = REPLACE(AXBYCZ, ABC XYZ, S1 S2)               :(RETURN)
*
BLEND_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BLEND.INC'
         &CODE = 1
         IDENT(BLEND('ABC', '123'), 'A1B2C3')                    :F(END)
         &CODE = 0
END
@

<<>>=
-STITL BLEND
-EJECT
*
************************************************************************
*                                                                      *
*              ######   #        #######  #     #  ######              *
*              #     #  #        #        ##    #  #     #             *
*              #     #  #        #        # #   #  #     #             *
*              ######   #        #####    #  #  #  #     #             *
*              #     #  #        #        #   # #  #     #             *
*              #     #  #        #        #    ##  #     #             *
*              ######   #######  #######  #     #  ######              *
*                                                                      *
* BLEND                      BLEND STRINGS                             *
*                                                                      *
************************************************************************
*
* BLEND.lss
*
<<BLEND>>
*
* CE: .MSNOBOL4;
@
-STITL BLEND
-EJECT
*
-LINE 50 "BLEND.lss"
************************************************************************
*                                                                      *
*              ######   #        #######  #     #  ######              *
*              #     #  #        #        ##    #  #     #             *
*              #     #  #        #        # #   #  #     #             *
*              ######   #        #####    #  #  #  #     #             *
*              #     #  #        #        #   # #  #     #             *
*              #     #  #        #        #    ##  #     #             *
*              ######   #######  #######  #     #  ######              *
*                                                                      *
* BLEND                      BLEND STRINGS                             *
*                                                                      *
************************************************************************
*
* BLEND.lss
*
-LINE 13 "BLEND.lss"
-MODULE BLEND
-PUBLIC BLEND()
         DEFINE('BLEND(S1,S2)T1,T2,ABC,XYZ,L1,L2')
         &ALPHABET LEN(128) . ABC LEN(128) . XYZ
BLE_1    ABC LEN(1) . T1 =                                 :F(BLEND_END)
         XYZ LEN(1) . T2 =
         BLENDED_ALPHABET = BLENDED_ALPHABET T1 T2              :(BLE_1)
*
BLEND    L1 = SIZE(S1)
         GT(L1, 128)                                         :F(BLEND_1)
         EQ(L1, 0)                                            :S(RETURN)
         S1 LEN(128) . S1 REM . T1
         S2 LEN(128) . S2 REM . T2
         BLEND = REPLACE(BLENDED_ALPHABET, &ALPHABET, S1 S2)
         BLEND(T1, T2)                                         :(RETURN)
BLEND_1  L2 = SIZE(S2)
         &ALPHABET LEN(*L1) . ABC TAB(128) LEN(*L2) . XYZ
         BLENDED_ALPHABET LEN(*(L1 + L2)) . AXBYCZ
         BLEND = REPLACE(AXBYCZ, ABC XYZ, S1 S2)               :(RETURN)
*
BLEND_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>BLEND - Blend two strings</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">BLEND(S1,S2)</font> will blend the two (equi-length) strings <font face="Source Code Pro">S1</font> and
<font face="Source Code Pro">S2</font> such that every other character is taken from each string. Thus,
<font face="Source Code Pro">BLEND('ABC','123')</font> will return <font face="Source Code Pro">'A1B2C3'</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BLEND&raquo;&equiv;</b>
-MODULE BLEND
-PUBLIC BLEND()
         DEFINE(&#39;BLEND(S1,S2)T1,T2,ABC,XYZ,L1,L2&#39;)
         &amp;ALPHABET LEN(128) . ABC LEN(128) . XYZ
BLE_1    ABC LEN(1) . T1 =                                 <b>:F(BLEND_END)</b>
         XYZ LEN(1) . T2 =
         BLENDED_ALPHABET = BLENDED_ALPHABET T1 T2              <b>:(BLE_1)</b>
<font color="#818181"><i>*</i></font>
BLEND    L1 = SIZE(S1)
         GT(L1, 128)                                         <b>:F(BLEND_1)</b>
         EQ(L1, 0)                                            <b>:S(RETURN)</b>
         S1 LEN(128) . S1 REM . T1
         S2 LEN(128) . S2 REM . T2
         BLEND = REPLACE(BLENDED_ALPHABET, &amp;ALPHABET, S1 S2)
         BLEND(T1, T2)                                         <b>:(RETURN)</b>
BLEND_1  L2 = SIZE(S2)
         &amp;ALPHABET LEN(*L1) . ABC TAB(128) LEN(*L2) . XYZ
         BLENDED_ALPHABET LEN(*(L1 + L2)) . AXBYCZ
         BLEND = REPLACE(AXBYCZ, ABC XYZ, S1 S2)               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
BLEND_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;BLEND.INC&#39;
         &amp;CODE = 1
         IDENT(BLEND(&#39;ABC&#39;, &#39;123&#39;), &#39;A1B2C3&#39;)                    <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL BLEND
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*              ######   #        #######  #     #  ######              *</i></font>
<font color="#818181"><i>*              #     #  #        #        ##    #  #     #             *</i></font>
<font color="#818181"><i>*              #     #  #        #        # #   #  #     #             *</i></font>
<font color="#818181"><i>*              ######   #        #####    #  #  #  #     #             *</i></font>
<font color="#818181"><i>*              #     #  #        #        #   # #  #     #             *</i></font>
<font color="#818181"><i>*              #     #  #        #        #    ##  #     #             *</i></font>
<font color="#818181"><i>*              ######   #######  #######  #     #  ######              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* BLEND                      BLEND STRINGS                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BLEND.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;BLEND&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:47 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BLEND.INC'
-LINE 40 "BLEND.lss"
         &CODE = 1
         IDENT(BLEND('ABC', '123'), 'A1B2C3')                    :F(END)
         &CODE = 0
END
<h1>BQ - Execute a shell command line and capture stdout</h1>

Like [[SHELL]] backquotes (hence the name).  Optional second arg is
string to use to separate lines.

This doesn't work when [[DDT()]] is used. The [[INPUT()]] fails
when traced.  Previously, it failed when garbage collect occurred,
but that has been fixed. To fix this, [[BQ()]] is a wrapper which
disables [[DDT()]] and then calls the 'real' function [[BQ2()]].

<h2>Uses</h2>

<h2>See Also</h2>
<a href="DDT.html">DDT</a>

<<INCLUDES>>=
@

<<BQ>>=
-MODULE BQ
-WEAK DDT_ACTIVE, DDT_SUSPEND(), DDT_RESUME()
-PUBLIC BQ()
         DEFINE('BQ(COMMAND,OFS)DDTF')
         DEFINE('BQ2(COMMAND,OFS)X,UNIT')                      :(BQ_END)
*
@

[[DDT_ACTIVE]] is set if [[DDT()]] is active. If [[DDT()]] is not
active, or hasn't been loaded at all, [[DDT_ACTIVE]] will evaluate to
[[NULL]].  Note that SNOBOL4 will not complain about a missing function
unless we actually try to execute it. Thus, this works whether or not
[[DDT()]] is actually in use. [[BQ2()]] may succeed or fail. In both
cases, we want to re-enable [[DDT()]] if it was loaded and active,
and pass the success or failure to the caller of [[BQ()]].

<<BQ>>=
BQ       DDTF = DDT_ACTIVE
         NE(DDTF) DDT_SUSPEND()
         BQ = BQ2(COMMAND, OFS)                                  :F(BQ3)
         NE(DDTF) DDT_RESUME()                                 :(RETURN)
BQ3      NE(DDTF) DDT_RESUME()                                :(FRETURN)
@

The actual [[BQ]] implementation. Open the command using [[PIPE open]].
Read lines and assemble the response. Use space [[' ']] as a separator
if no explicit separator was provided.

<<BQ>>=
BQ2      UNIT = IO_FINDUNIT()                                :F(FRETURN)
         INPUT(.X, UNIT,, '|' COMMAND)                       :F(FRETURN)
         OFS = IDENT(OFS) ' '
         BQ2 = X                                                 :S(BQ4)
         ENDFILE(UNIT)
         DETACH(.X)                                           :(FRETURN)
BQ4      BQ2 = BQ2 OFS X                                         :S(BQ4)
         ENDFILE(UNIT)
         DETACH(.X)                                            :(RETURN) 
*
BQ_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BQ.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL BQ
-EJECT
*
************************************************************************
*                                                                      *
*                          ######    #####                             *
*                          #     #  #     #                            *
*                          #     #  #     #                            *
*                          ######   #     #                            *
*                          #     #  #   # #                            *
*                          #     #  #    #                             *
*                          ######    #### #                            *
*                                                                      *
* BQ          EXECUTE A SHELL COMMAND LINE AND CAPTURE STDOUT          *
*                                                                      *
* P BUDNE, JUNE 20, 1994                                               *
*                                                                      *
************************************************************************
*
* BQ.lss
*
<<BQ>>
*
* CE: .MSNOBOL4;
@
-STITL BQ
-EJECT
*
-LINE 75 "BQ.lss"
************************************************************************
*                                                                      *
*                          ######    #####                             *
*                          #     #  #     #                            *
*                          #     #  #     #                            *
*                          ######   #     #                            *
*                          #     #  #   # #                            *
*                          #     #  #    #                             *
*                          ######    #### #                            *
*                                                                      *
* BQ          EXECUTE A SHELL COMMAND LINE AND CAPTURE STDOUT          *
*                                                                      *
* P BUDNE, JUNE 20, 1994                                               *
*                                                                      *
************************************************************************
*
* BQ.lss
*
-LINE 20 "BQ.lss"
-MODULE BQ
-WEAK DDT_ACTIVE, DDT_SUSPEND(), DDT_RESUME()
-PUBLIC BQ()
         DEFINE('BQ(COMMAND,OFS)DDTF')
         DEFINE('BQ2(COMMAND,OFS)X,UNIT')                      :(BQ_END)
*
-LINE 37 "BQ.lss"
BQ       DDTF = DDT_ACTIVE
         NE(DDTF) DDT_SUSPEND()
         BQ = BQ2(COMMAND, OFS)                                  :F(BQ3)
         NE(DDTF) DDT_RESUME()                                 :(RETURN)
BQ3      NE(DDTF) DDT_RESUME()                                :(FRETURN)
-LINE 49 "BQ.lss"
BQ2      UNIT = IO_FINDUNIT()                                :F(FRETURN)
         INPUT(.X, UNIT,, '|' COMMAND)                       :F(FRETURN)
         OFS = IDENT(OFS) ' '
         BQ2 = X                                                 :S(BQ4)
         ENDFILE(UNIT)
         DETACH(.X)                                           :(FRETURN)
BQ4      BQ2 = BQ2 OFS X                                         :S(BQ4)
         ENDFILE(UNIT)
         DETACH(.X)                                            :(RETURN)
*
BQ_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>BQ - Execute a shell command line and capture stdout</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Like <font face="Source Code Pro">SHELL</font> backquotes (hence the name).  Optional second arg is
string to use to separate lines.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This doesn't work when <font face="Source Code Pro">DDT()</font> is used. The <font face="Source Code Pro">INPUT()</font> fails
when traced.  Previously, it failed when garbage collect occurred,
but that has been fixed. To fix this, <font face="Source Code Pro">BQ()</font> is a wrapper which
disables <font face="Source Code Pro">DDT()</font> and then calls the 'real' function <font face="Source Code Pro">BQ2()</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="DDT.html">DDT</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BQ&raquo;&equiv;</b>
-MODULE BQ
-WEAK DDT_ACTIVE, DDT_SUSPEND(), DDT_RESUME()
-PUBLIC BQ()
         DEFINE(&#39;BQ(COMMAND,OFS)DDTF&#39;)
         DEFINE(&#39;BQ2(COMMAND,OFS)X,UNIT&#39;)                      <b>:(BQ_END)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DDT_ACTIVE</font> is set if <font face="Source Code Pro">DDT()</font> is active. If <font face="Source Code Pro">DDT()</font> is not
active, or hasn't been loaded at all, <font face="Source Code Pro">DDT_ACTIVE</font> will evaluate to
<font face="Source Code Pro">NULL</font>.  Note that SNOBOL4 will not complain about a missing function
unless we actually try to execute it. Thus, this works whether or not
<font face="Source Code Pro">DDT()</font> is actually in use. <font face="Source Code Pro">BQ2()</font> may succeed or fail. In both
cases, we want to re-enable <font face="Source Code Pro">DDT()</font> if it was loaded and active,
and pass the success or failure to the caller of <font face="Source Code Pro">BQ()</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BQ&raquo;&equiv;</b>
BQ       DDTF = DDT_ACTIVE
         NE(DDTF) DDT_SUSPEND()
         BQ = BQ2(COMMAND, OFS)                                  <b>:F(BQ3)</b>
         NE(DDTF) DDT_RESUME()                                 <b>:(RETURN)</b>
BQ3      NE(DDTF) DDT_RESUME()                                <b>:(FRETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
The actual <font face="Source Code Pro">BQ</font> implementation. Open the command using <font face="Source Code Pro">PIPE open</font>.
Read lines and assemble the response. Use space <font face="Source Code Pro">' '</font> as a separator
if no explicit separator was provided.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BQ&raquo;&equiv;</b>
BQ2      UNIT = IO_FINDUNIT()                                <b>:F(FRETURN)</b>
         INPUT(.X, UNIT,, &#39;|&#39; COMMAND)                       <b>:F(FRETURN)</b>
         OFS = IDENT(OFS) &#39; &#39;
         BQ2 = X                                                 <b>:S(BQ4)</b>
         ENDFILE(UNIT)
         DETACH(.X)                                           <b>:(FRETURN)</b>
BQ4      BQ2 = BQ2 OFS X                                         <b>:S(BQ4)</b>
         ENDFILE(UNIT)
         DETACH(.X)                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
BQ_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;BQ.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL BQ
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                          ######    #####                             *</i></font>
<font color="#818181"><i>*                          #     #  #     #                            *</i></font>
<font color="#818181"><i>*                          #     #  #     #                            *</i></font>
<font color="#818181"><i>*                          ######   #     #                            *</i></font>
<font color="#818181"><i>*                          #     #  #   # #                            *</i></font>
<font color="#818181"><i>*                          #     #  #    #                             *</i></font>
<font color="#818181"><i>*                          ######    #### #                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* BQ          EXECUTE A SHELL COMMAND LINE AND CAPTURE STDOUT          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* P BUDNE, JUNE 20, 1994                                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BQ.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;BQ&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:47 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BQ.INC'
-LINE 66 "BQ.lss"
         &CODE = 1
         &CODE = 0
END
<h1>BRKREM - BREAK(S) or REM</h1>

[[BRKREM(S)]] returns a pattern that will behave like BREAK(S)
if that pattern would succeed and will match the remainder of the
subject otherwise.

<h2>Uses</h2>
<a href="SDIFF.html">SDIFF</a><br>

<<INCLUDES>>=
-INCLUDE 'SDIFF.INC'
@

<<BRKREM>>=
-MODULE BRKREM
-PUBLIC BRKREM()
         DEFINE('BRKREM(S)CS')                             :(BRKREM_END)
*
BRKREM   BRKREM = IDENT(S) REM                                :S(RETURN)
         CS = SDIFF(&ALPHABET, S)
         IDENT(CS)                                            :S(RETURN)
         BRKREM = RPOS(0) | SPAN(CS) RPOS(0) | BREAK(S)
                                                               :(RETURN)
*
BRKREM_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BRKREM.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL BRKREM
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*         ######   ######   #    #  ######   #######  #     #          *
*         #     #  #     #  #   #   #     #  #        ##   ##          *
*         #     #  #     #  #  #    #     #  #        # # # #          *
*         ######   ######   ###     ######   #####    #  #  #          *
*         #     #  #   #    #  #    #   #    #        #     #          *
*         #     #  #    #   #   #   #    #   #        #     #          *
*         ######   #     #  #    #  #     #  #######  #     #          *
*                                                                      *
* BRKREM                   BREAK(S) OR REM                             *
*                                                                      *
************************************************************************
*
* BRKREM.lss
*
<<BRKREM>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "BRKREM.lss"
-INCLUDE 'SDIFF.INC'
-STITL BRKREM
-EJECT
-LINE 41 "BRKREM.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*         ######   ######   #    #  ######   #######  #     #          *
*         #     #  #     #  #   #   #     #  #        ##   ##          *
*         #     #  #     #  #  #    #     #  #        # # # #          *
*         ######   ######   ###     ######   #####    #  #  #          *
*         #     #  #   #    #  #    #   #    #        #     #          *
*         #     #  #    #   #   #   #    #   #        #     #          *
*         ######   #     #  #    #  #     #  #######  #     #          *
*                                                                      *
* BRKREM                   BREAK(S) OR REM                             *
*                                                                      *
************************************************************************
*
* BRKREM.lss
*
-LINE 15 "BRKREM.lss"
-MODULE BRKREM
-PUBLIC BRKREM()
         DEFINE('BRKREM(S)CS')                             :(BRKREM_END)
*
BRKREM   BRKREM = IDENT(S) REM                                :S(RETURN)
         CS = SDIFF(&ALPHABET, S)
         IDENT(CS)                                            :S(RETURN)
         BRKREM = RPOS(0) | SPAN(CS) RPOS(0) | BREAK(S)
                                                               :(RETURN)
*
BRKREM_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>BRKREM - BREAK(S) or REM</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">BRKREM(S)</font> returns a pattern that will behave like BREAK(S)
if that pattern would succeed and will match the remainder of the
subject otherwise.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SDIFF.html">SDIFF</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SDIFF.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;BRKREM&raquo;&equiv;</b>
-MODULE BRKREM
-PUBLIC BRKREM()
         DEFINE(&#39;BRKREM(S)CS&#39;)                             <b>:(BRKREM_END)</b>
<font color="#818181"><i>*</i></font>
BRKREM   BRKREM = IDENT(S) REM                                <b>:S(RETURN)</b>
         CS = SDIFF(&amp;ALPHABET, S)
         IDENT(CS)                                            <b>:S(RETURN)</b>
         BRKREM = RPOS(0) | SPAN(CS) RPOS(0) | BREAK(S)
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
BRKREM_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;BRKREM.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL BRKREM
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         ######   ######   #    #  ######   #######  #     #          *</i></font>
<font color="#818181"><i>*         #     #  #     #  #   #   #     #  #        ##   ##          *</i></font>
<font color="#818181"><i>*         #     #  #     #  #  #    #     #  #        # # # #          *</i></font>
<font color="#818181"><i>*         ######   ######   ###     ######   #####    #  #  #          *</i></font>
<font color="#818181"><i>*         #     #  #   #    #  #    #   #    #        #     #          *</i></font>
<font color="#818181"><i>*         #     #  #    #   #   #   #    #   #        #     #          *</i></font>
<font color="#818181"><i>*         ######   #     #  #    #  #     #  #######  #     #          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* BRKREM                   BREAK(S) OR REM                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BRKREM.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;BRKREM&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:36 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'BRKREM.INC'
-LINE 32 "BRKREM.lss"
         &CODE = 1
         &CODE = 0
END
<h1>bundle</h1>

Bundle application with its includes.

<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="HOST.html">HOST</a><br>
<a href="TRIMB.html">TRIMB</a><br>

<<INCLUDES>>=
-INCLUDE 'CRACK.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'TRIMB.INC'
@

<<bundle>>=
-PROGRAM BUNDLE
         TERMINAL = 'BUNDLE (THU DEC  5 12:09:11 EST 2013)'
*
         DEFINE('INCLUDE(FILENAME)PATH,POSITION,UNIT,LIB,X')
         QQ = '"'
         Q = "'"
         INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                           (ANY('Cc') ('OPY' | 'opy')))
+                BREAK(QQ Q) LEN(1) BREAK(QQ Q) . X
         &TRIM =  1
         LOADED = TABLE()
         INCLUDE('/dev/stdin')                                    :(END)
*
INCLUDE  PATH = FILENAME
         LOADED<FILENAME> = 1
         UNIT = IO_FINDUNIT()
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, 'SNOPATH')                    :S(DOINC_8)
         X = HOST(HOST_GETENV, 'SNOLIB')                     :S(DOINC_8)
         X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
DOINC_8  A = CRACK(X, PS)
         I = 1
DOINC_10 P = TRIMB(A<I>)                                     :F(FRETURN)
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         I = I + 1                                           :(DOINC_10)
*
TOP      L = LIB                                             :F(DOINC_2)
         L INPAT                                               :S(DOINC)
*
         OUTPUT = L                                               :(TOP)
*
DOINC    DIFFER(LOADED<X>)                                       :S(TOP)
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
*
         INCLUDE(X)                                          :F(FRETURN)
*
         INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
         LOADED<X> = 1
         FILENAME FENCE '/dev/'                                  :S(TOP)
         EQ(SET(UNIT, POSITION, 0), POSITION)          :S(TOP)F(FRETURN)
*
DOINC_2  ENDFILE(UNIT)
         DETACH(.LIB)                                          :(RETURN)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-TITLE BUNDLE
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*         ######   #     #  #     #  ######   #        #######         *
*         #     #  #     #  ##    #  #     #  #        #               *
*         #     #  #     #  # #   #  #     #  #        #               *
*         ######   #     #  #  #  #  #     #  #        #####           *
*         #     #  #     #  #   # #  #     #  #        #               *
*         #     #  #     #  #    ##  #     #  #        #               *
*         ######    #####   #     #  ######   #######  #######         *
*                                                                      *
* BUNDLE          BUNDLE INCLUDES FOR APPLICATION                      *
*                                                                      *
************************************************************************
*
* bundle.lss
*
<<bundle>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-TITLE BUNDLE
-LINE 73 "bundle.lss"
START
-LINE 11 "bundle.lss"
-INCLUDE 'CRACK.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'TRIMB.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*         ######   #     #  #     #  ######   #        #######         *
*         #     #  #     #  ##    #  #     #  #        #               *
*         #     #  #     #  # #   #  #     #  #        #               *
*         ######   #     #  #  #  #  #     #  #        #####           *
*         #     #  #     #  #   # #  #     #  #        #               *
*         #     #  #     #  #    ##  #     #  #        #               *
*         ######    #####   #     #  ######   #######  #######         *
*                                                                      *
* BUNDLE          BUNDLE INCLUDES FOR APPLICATION                      *
*                                                                      *
************************************************************************
*
* bundle.lss
*
-LINE 17 "bundle.lss"
-PROGRAM BUNDLE
         TERMINAL = 'BUNDLE (THU DEC  5 12:09:11 EST 2013)'
*
         DEFINE('INCLUDE(FILENAME)PATH,POSITION,UNIT,LIB,X')
         QQ = '"'
         Q = "'"
         INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                           (ANY('Cc') ('OPY' | 'opy')))
+                BREAK(QQ Q) LEN(1) BREAK(QQ Q) . X
         &TRIM =  1
         LOADED = TABLE()
         INCLUDE('/dev/stdin')                                    :(END)
*
INCLUDE  PATH = FILENAME
         LOADED<FILENAME> = 1
         UNIT = IO_FINDUNIT()
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, 'SNOPATH')                    :S(DOINC_8)
         X = HOST(HOST_GETENV, 'SNOLIB')                     :S(DOINC_8)
         X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
DOINC_8  A = CRACK(X, PS)
         I = 1
DOINC_10 P = TRIMB(A<I>)                                     :F(FRETURN)
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         I = I + 1                                           :(DOINC_10)
*
TOP      L = LIB                                             :F(DOINC_2)
         L INPAT                                               :S(DOINC)
*
         OUTPUT = L                                               :(TOP)
*
DOINC    DIFFER(LOADED<X>)                                       :S(TOP)
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
*
         INCLUDE(X)                                          :F(FRETURN)
*
         INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
         LOADED<X> = 1
         FILENAME FENCE '/dev/'                                  :S(TOP)
         EQ(SET(UNIT, POSITION, 0), POSITION)          :S(TOP)F(FRETURN)
*
DOINC_2  ENDFILE(UNIT)
         DETACH(.LIB)                                          :(RETURN)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>bundle</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Bundle application with its includes.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="HOST.html">HOST</a><br>
<a href="TRIMB.html">TRIMB</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;bundle&raquo;&equiv;</b>
-PROGRAM BUNDLE
         TERMINAL = &#39;BUNDLE (THU DEC  5 12:09:11 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;INCLUDE(FILENAME)PATH,POSITION,UNIT,LIB,X&#39;)
         QQ = &#39;&quot;&#39;
         Q = &quot;&#39;&quot;
         INPAT = FENCE &#39;-&#39; ((ANY(&#39;Ii&#39;) (&#39;NCLUDE&#39; | &#39;nclude&#39;)) |
+                           (ANY(&#39;Cc&#39;) (&#39;OPY&#39; | &#39;opy&#39;)))
+                BREAK(QQ Q) LEN(1) BREAK(QQ Q) . X
         &amp;TRIM =  1
         LOADED = TABLE()
         INCLUDE(&#39;/dev/stdin&#39;)                                    <b>:(END)</b>
<font color="#818181"><i>*</i></font>
INCLUDE  PATH = FILENAME
         LOADED&lt;FILENAME&gt; = 1
         UNIT = IO_FINDUNIT()
         INPUT(.LIB, UNIT,, PATH)                                <b>:S(TOP)</b>
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, &#39;SNOPATH&#39;)                    <b>:S(DOINC_8)</b>
         X = HOST(HOST_GETENV, &#39;SNOLIB&#39;)                     <b>:S(DOINC_8)</b>
         X = HOST(HOST_SNOLIB_DIR)                           <b>:F(FRETURN)</b>
DOINC_8  A = CRACK(X, PS)
         I = 1
DOINC_10 P = TRIMB(A&lt;I&gt;)                                     <b>:F(FRETURN)</b>
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                                <b>:S(TOP)</b>
         I = I + 1                                           <b>:(DOINC_10)</b>
<font color="#818181"><i>*</i></font>
TOP      L = LIB                                             <b>:F(DOINC_2)</b>
         L INPAT                                               <b>:S(DOINC)</b>
<font color="#818181"><i>*</i></font>
         OUTPUT = L                                               <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
DOINC    DIFFER(LOADED&lt;X&gt;)                                       <b>:S(TOP)</b>
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
<font color="#818181"><i>*</i></font>
         INCLUDE(X)                                          <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         INPUT(.LIB, UNIT,, PATH)                            <b>:F(FRETURN)</b>
         LOADED&lt;X&gt; = 1
         FILENAME FENCE &#39;/dev/&#39;                                  <b>:S(TOP)</b>
         EQ(SET(UNIT, POSITION, 0), POSITION)          <b>:S(TOP)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
DOINC_2  ENDFILE(UNIT)
         DETACH(.LIB)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-TITLE BUNDLE
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         ######   #     #  #     #  ######   #        #######         *</i></font>
<font color="#818181"><i>*         #     #  #     #  ##    #  #     #  #        #               *</i></font>
<font color="#818181"><i>*         #     #  #     #  # #   #  #     #  #        #               *</i></font>
<font color="#818181"><i>*         ######   #     #  #  #  #  #     #  #        #####           *</i></font>
<font color="#818181"><i>*         #     #  #     #  #   # #  #     #  #        #               *</i></font>
<font color="#818181"><i>*         #     #  #     #  #    ##  #     #  #        #               *</i></font>
<font color="#818181"><i>*         ######    #####   #     #  ######   #######  #######         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* BUNDLE          BUNDLE INCLUDES FOR APPLICATION                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* bundle.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;bundle&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:48 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>CATA - Concatenate Arrays</h1>

[[CATA(A1,A2)]] will concatenate the two singly-dimensioned arrays
[[A1]] and [[A2]]. The arrays must be defined as [['size']] and not
[['low:high']] or this routine will not work.

<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>=
-INCLUDE 'SEQ.INC'
@

<<CATA>>=
-MODULE CATA
-PUBLIC CATA()
         DEFINE('CATA(A1,A2)I,N1')                           :(CATA_END)
*
CATA     N1 = PROTOTYPE(A1)
         CATA = ARRAY(N1 + PROTOTYPE(A2))
         SEQ(' CATA<I> = A1<I> ', .I)
         SEQ(' CATA<N1 + I> = A2<I> ', .I)                     :(RETURN)
*
CATA_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CATA.INC'
-INCLUDE 'CRACK.INC'
         &CODE = 1
         A = %'5,6,7'
         B = %'3,2,1'
         C = CATA(A, B)
         EQ(C<1>, 5)                                             :F(END)
         EQ(C<2>, 6)                                             :F(END)
         EQ(C<3>, 7)                                             :F(END)
         EQ(C<4>, 3)                                             :F(END)
         EQ(C<5>, 2)                                             :F(END)
         EQ(C<6>, 1)                                             :F(END)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL CATA
-EJECT
*
************************************************************************
*                                                                      *
*                    #####      #     #######     #                    *
*                   #     #    # #       #       # #                   *
*                   #         #   #      #      #   #                  *
*                   #        #     #     #     #     #                 *
*                   #        #######     #     #######                 *
*                   #     #  #     #     #     #     #                 *
*                    #####   #     #     #     #     #                 *
*                                                                      *
* CATA                     CONCATENATE ARRAYS                          *
*                                                                      *
************************************************************************
*
* CATA.lss
*
<<CATA>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "CATA.lss"
-INCLUDE 'SEQ.INC'
-STITL CATA
-EJECT
-LINE 50 "CATA.lss"
*
************************************************************************
*                                                                      *
*                    #####      #     #######     #                    *
*                   #     #    # #       #       # #                   *
*                   #         #   #      #      #   #                  *
*                   #        #     #     #     #     #                 *
*                   #        #######     #     #######                 *
*                   #     #  #     #     #     #     #                 *
*                    #####   #     #     #     #     #                 *
*                                                                      *
* CATA                     CONCATENATE ARRAYS                          *
*                                                                      *
************************************************************************
*
* CATA.lss
*
-LINE 15 "CATA.lss"
-MODULE CATA
-PUBLIC CATA()
         DEFINE('CATA(A1,A2)I,N1')                           :(CATA_END)
*
CATA     N1 = PROTOTYPE(A1)
         CATA = ARRAY(N1 + PROTOTYPE(A2))
         SEQ(' CATA<I> = A1<I> ', .I)
         SEQ(' CATA<N1 + I> = A2<I> ', .I)                     :(RETURN)
*
CATA_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CATA - Concatenate Arrays</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CATA(A1,A2)</font> will concatenate the two singly-dimensioned arrays
<font face="Source Code Pro">A1</font> and <font face="Source Code Pro">A2</font>. The arrays must be defined as <font face="Source Code Pro">'size'</font> and not
<font face="Source Code Pro">'low:high'</font> or this routine will not work.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CATA&raquo;&equiv;</b>
-MODULE CATA
-PUBLIC CATA()
         DEFINE(&#39;CATA(A1,A2)I,N1&#39;)                           <b>:(CATA_END)</b>
<font color="#818181"><i>*</i></font>
CATA     N1 = PROTOTYPE(A1)
         CATA = ARRAY(N1 + PROTOTYPE(A2))
         SEQ(&#39; CATA&lt;I&gt; = A1&lt;I&gt; &#39;, .I)
         SEQ(&#39; CATA&lt;N1 + I&gt; = A2&lt;I&gt; &#39;, .I)                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CATA_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CATA.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
         &amp;CODE = 1
         A = %&#39;5,6,7&#39;
         B = %&#39;3,2,1&#39;
         C = CATA(A, B)
         EQ(C&lt;1&gt;, 5)                                             <b>:F(END)</b>
         EQ(C&lt;2&gt;, 6)                                             <b>:F(END)</b>
         EQ(C&lt;3&gt;, 7)                                             <b>:F(END)</b>
         EQ(C&lt;4&gt;, 3)                                             <b>:F(END)</b>
         EQ(C&lt;5&gt;, 2)                                             <b>:F(END)</b>
         EQ(C&lt;6&gt;, 1)                                             <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL CATA
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #####      #     #######     #                    *</i></font>
<font color="#818181"><i>*                   #     #    # #       #       # #                   *</i></font>
<font color="#818181"><i>*                   #         #   #      #      #   #                  *</i></font>
<font color="#818181"><i>*                   #        #     #     #     #     #                 *</i></font>
<font color="#818181"><i>*                   #        #######     #     #######                 *</i></font>
<font color="#818181"><i>*                   #     #  #     #     #     #     #                 *</i></font>
<font color="#818181"><i>*                    #####   #     #     #     #     #                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CATA                     CONCATENATE ARRAYS                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CATA.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CATA&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:48 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CATA.INC'
-LINE 31 "CATA.lss"
-INCLUDE 'CRACK.INC'
         &CODE = 1
         A = %'5,6,7'
         B = %'3,2,1'
         C = CATA(A, B)
         EQ(C<1>, 5)                                             :F(END)
         EQ(C<2>, 6)                                             :F(END)
         EQ(C<3>, 7)                                             :F(END)
         EQ(C<4>, 3)                                             :F(END)
         EQ(C<5>, 2)                                             :F(END)
         EQ(C<6>, 1)                                             :F(END)
         &CODE = 0
END
<h1>CGI - CGI Support Functions</h1>

[[CGI]] support functions. [[SCOOP]] is used to create a [[CGI]]
object.  This object contains data and methods needed to support
[[CGI]] activities.  In turn, [[CGI]] uses [[COOKIE]] to support
[[HTTP]] cookies. The [[WEB]] application can use [[SESSION]] to
support persistant server-side sessions. [[HTMLTMPL]] to support
templates, [[PSQL]] to provide database for filling in templates.

Logging is supported in the [[CGI]] class. This is not decoupled
because there are very few ways to debug [[CGI]] applications.

USE_FCGI is set to true in FCGI.lss if Fast CGI is in use. So,
include FCGI.INC before CGI.INC to prepare for Fast CGI.

Still need: Response codes, Headers/Responses

[[
Last-modified:
Content-type: application/octet-stream; name="filename"
Content-disposition: attachment; filename="genome.jpg"

Content-length: 3002
Location:
Status: 200 OK
302 Found (301 302 303)
400 Bad Request
501 Not Implemented
local redirect - just respond with Location:
absolute URI redirect same
with doc, respond 302 Location and doc returned
]]

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="COOKIE.html">COOKIE</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="HASH.html">HASH</a><br>
<a href="HTMLESC.html">HTMLESC</a><br>
<a href="JSON.html">JSON</a><br>
<a href="SCOOP.html">SCOOP</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<h2>See Also</h2>
<a href="SESSION.html">SESSION</a><br>
<a href="HTMLTMPL.html">HTMLTMPL</a><br>
<a href="PSQL.html">PSQL</a>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'COOKIE.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'HTMLESC.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'UNIQUE.INC'
-INCLUDE 'VDIFFER.INC'
@

<<CGI>>=
-MODULE CGI
-USES CRACK(), HOST(), URL_DECODE(), COOKIE_FIX_NAME()
-WEAK USE_FCGI, FCGI_ENV, FCGI_IN, FCGI_REQUEST_COMPLETE
-WEAK FCGI_SEND(), FCGI_END()
-PUBLIC CLASS:CGI_CLASS
         CGI_CLASS = SEND(CLASS, 'NEW_CLASS', 'CGI_CLASS')
         DEFINE('CGI_INIT()A,C')
-PUBLIC CGI_CLASS:'INIT'
         SEND(CGI_CLASS, 'ADD_METHOD', 'INIT', 'CGI_INIT')
-PUBLIC CGI_CLASS:'GET_COOKIE_JAR'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_COOKIE_JAR', CODE(
+           ' SEND = |.COOKIE_JAR :(RETURN)'))
-PUBLIC CGI_CLASS:'GET_HEADER'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_HEADER', CODE(
+           ' SEND = |.HEADER :(RETURN)'))
         DEFINE('CGI_SEND()S')
-PUBLIC CGI_CLASS:'SEND'
         SEND(CGI_CLASS, 'ADD_METHOD', 'SEND', 'CGI_SEND')
-PUBLIC CGI_CLASS:'GET_LOG'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_LOG', CODE(
+           ' SEND = |.LOG :(RETURN)'))
-PUBLIC CGI_CLASS:'GET_CONTENT'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_CONTENT', CODE(
+           ' SEND = |.CONTENT :(RETURN)')) 
-PUBLIC CGI_CLASS:'SET_CONTENT'
         SEND(CGI_CLASS, 'ADD_METHOD', 'SET_CONTENT', CODE(
+           ' |.CONTENT = A1 :(RETURN)')) 
         DEFINE('CGI_CLOSE()A')
-PUBLIC CGI_CLASS:'CLOSE'
         SEND(CGI_CLASS, 'ADD_METHOD', 'CLOSE', 'CGI_CLOSE')
-PUBLIC CGI_CLASS:'GET_ENV'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_ENV', CODE(
+           ' SEND = |.ENV :(RETURN)'))
-PUBLIC CGI_CLASS:'GET_QUERY'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_QUERY', CODE(
+           ' SEND = |.QUERY :(RETURN)'))
*
                                                       :(CGI_OBJECT_END)
*
* CLOSE CGI OBJECT
*
CGI_CLOSE
         ENDFILE(|.OUT_UNIT)
         DETACH(|.OUT)
         ENDFILE(|.LOG_UNIT)
         DETACH(|.LOG)                                         :(RETURN)
*
* INITIALIZE CGI OBJECT
*
CGI_INIT CGI_INIT = SUPER('INIT')
*
* CREATE LOG CHANNEL
*
         |.LOG_UNIT = IO_FINDUNIT()                          :F(FRETURN)
         |.LOG = UNIQUE()
*
* WITH ALL THE CHANGES GOING TO SYSTEMD, LOGGING APPEARS TO HAVE
* SUFFERED. SPECIFICALLY, IF THE LOGGING IS ONLY FORWARDED TO
* RSYSLOG, LOGGER LOCAL DOESN'T WORK. WE ENABLE RSYSLOG TO LISTEN TO
* THE NETWORK, AND THEN LOGGER CAN LOG TO LOCALHOST. STRANGE, AND
* PROBABLY NOT SUITABLE FOR PRODUCTION.
*
* IF USING SYSTEMD LOGGER, DON'T USE -n localhost
*
         OUTPUT(|.LOG, |.LOG_UNIT, 'W',
+               '|/usr/bin/logger -n localhost -t CGI')      :F(FRETURN)
*+              '|/usr/bin/logger -t CGI')                   :F(FRETURN)
*
* CREATE OUT CHANNEL
*
         |.OUT_UNIT = IO_FINDUNIT()                          :F(FRETURN)
         |.OUT = UNIQUE()
         OUTPUT(|.OUT, |.OUT_UNIT, 'B', '/dev/stdout')       :F(FRETURN)
*
* COLLECT ENVIRONMENT VARIABLES INTO INSTANCE VARIABLE ENV. WE ONLY
* GATHER UP "KNOWN" ENVIRONMENT VARIABLES.
*
         |.ENV = DIFFER(USE_FCGI) FCGI_ENV                 :S(CGI_ENV_2)
*
         |.ENV = TABLE(38)
         A = %('AUTH_TYPE,CONTENT_LENGTH,CONTENT_TYPE,'
+              'CONTEXT_DOCUMENT_ROOT,CONTEXT_PREFIX,DOCUMENT_ROOT,'
+              'GATEWAY_INTERFACE,HTTP_ACCEPT,HTTP_ACCEPT_CHARSET,'
+              'HTTP_ACCEPT_ENCODING,HTTP_ACCEPT_LANGUAGE,'
+              'HTTP_CACHE_CONTROL,HTTP_CONNECTION,HTTP_COOKIE,'
+              'HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,LIB_PATH,PATH,'
+              'PATH_INFO,PATH_TRANSLATED,QUERY_STRING,REMOTE_ADDR,'
+              'REMOTE_HOST,REMOTE_IDENT,REMOTE_PORT,REQUEST_METHOD,'
+              'REQUEST_SCHEME,REQUEST_URI,SCRIPT_FILENAME,SCRIPT_NAME,'
+              'SERVER_ADDR,SERVER_ADMIN,SERVER_NAME,SERVER_PORT,'
+              'SERVER_PROTOCOL,SERVER_SIGNATURE,SERVER_SOFTWARE')
         SEQ(' (|.ENV)<A<I>> = HOST(HOST_GETENV, A<I>); A<I> ', .I)
CGI_ENV_2
         $|.LOG = 'FCGI_ENV IN CGI'
         $|.LOG = JSON_ENCODE(FCGI_ENV)
         $|.LOG = 'QUERY_STRING: ' (|.ENV)<'QUERY_STRING'>
*
* FOR POST METHOD, READ (|.ENV)<'CONTENT_LENGTH'>. READ THAT NUMBER OF
* BYTES, AND ONLY THAT NUMBER. NOTE THAT THIS MAY BE VERY LARGE. THIS
* MAY FAIL DUE TO MEMORY EXHAUSTION. WE KNOW THAT WE CAN READ A LARGE
* NUMBER OF BYTES, BUT I HAVE TO DETERMINE THE LIMIT.
*
* FOR FCGI, USE FCGI_IN. FIXME: SHOULD TEST CONTENT_LENGTH
*
         (|.ENV)<'QUERY_STRING'> = DIFFER(USE_FCGI) VDIFFER(FCGI_IN)
+                                                         :S(CGI_INIT_3)
         T3 = (|.ENV)<'CONTENT_LENGTH'>
         IDENT(T3)                                        :S(CGI_INIT_3)
         (INTEGER(T3) GT(T3))                             :F(CGI_INIT_3)
         T1 = IO_FINDUNIT()                                  :F(FRETURN)
         INPUT('T2', T1, 'B,' T3, '/dev/stdin')              :F(FRETURN)
         (|.ENV)<'QUERY_STRING'> = T2
         ENDFILE(T1)
         DETACH('T2')
CGI_INIT_3
*
* PARSE QUERY_STRING INTO QUERY TABLE. HASH() IS USED TO PARSE
* QUERY_STRING, BREAKING INTO NAME=VALUE SEPARATED BY &. EACH VALUE IS
* PROCESSED WITH URL_DECODE().
*
* MULTI-VALUE FIELDS ARE SEPARATED BY 0. USED BY CHECKBOXES
*
         |.QUERY = HASH((|.ENV)<'QUERY_STRING'>, '=', '&',,,,
+                        'URL_DECODE', CHARS_NUL)
         $|.LOG = 'QUERY TABLE'
         $|.LOG = JSON_ENCODE(|.QUERY)
*
* PARSE HTTP_COOKIE INTO A COOKIE JAR. THERE MAY NOT BE ANY COOKIES,
* IN WHICH CASE WE CREATE AN EMPTY COOKIE JAR. THE VALUES OF THE
* COOKIES ARE NOT VALIDATED. HASH() PARSES THE COOKIE STRING. AFTER
* THE TABLE IS GENERATED, IT IS CONVERTED TO AN ARRAY. SEQ() ADDS
* EACH ELEMENT INTO THE COOKIE JAR.
*
         |.COOKIE_JAR = NEW_COOKIE_JAR()
         A = HASH((|.ENV)<'HTTP_COOKIE'>, '=', ';',,,
+                  'COOKIE_FIX_NAME', 'URL_DECODE')
         A = CONVERT(A, 'ARRAY')                          :F(CGI_INIT_2)
         SEQ(' PUT_COOKIE_IN_JAR(|.COOKIE_JAR,'
+                               'A<I,1>, NEW_COOKIE(A<I,2>)) ', .I)
CGI_INIT_2
*
* INITIALIZE HEADER. THE HEADER IS A TABLE() WITH AT LEAST CONTENT_TYPE
* ENTRY.
*
         |.HEADER = #'CONTENT_TYPE=TEXT/HTML,CHARSET='
*
* INITIALIZE CONTENT
*
         |.CONTENT =
*
* WE NEED ROUTING IMPLEMENTED.
*
* WE NEED TO DO FURTHER PROCESSING ON THE FOLLOWING CGI ENVIRONMENT
* VARIABLES. 
*
* <ISINDEX> value1+value2+..
* HTTP_ACCEPT
*   ='TEXT/HTML,APPLICATION/XHTML+XML,APPLICATION/XML;Q=0.9,*/*;Q=0.8'
* HTTP_ACCEPT_ENCODING='GZIP, DEFLATE'
* HTTP_ACCEPT_LANGUAGE='EN-US,EN;Q=0.5'
*
                                                               :(RETURN)
*
* OUTPUT THE HEADER AND CONTENT
*
CGI_SEND
*
* FIRST, OUTPUT THE CONTENT-TYPE. IF CHARSET HAS BEEN SPECIFIED,
* ADD THIS TO THE CONTENT-TYPE.
*
         S = 'Content-type: ' (|.HEADER)<'CONTENT_TYPE'>
         S = S '; charset=' VDIFFER((|.HEADER)<'CHARSET'>)
         S = S CHARS_CR CHARS_NL
*
* GENERATE THE COOKIE STRING AND OUTPUT IF WE HAVE COOKIES TO SEND.
*
         S = S VDIFFER(COOKIE_STRING(|.COOKIE_JAR))
*
* THE HEADER FINISHES WITH A CR/LF
*
         S = S CHARS_CR CHARS_NL
         $|.OUT = IDENT(USE_FCGI) S
         DIFFER(USE_FCGI) FCGI_SEND(S)
*
* SEND CONTENT
*
         $|.OUT = IDENT(USE_FCGI) |.CONTENT
         DIFFER(USE_FCGI) FCGI_SEND(|.CONTENT)
         DIFFER(USE_FCGI) FCGI_SEND('')
         DIFFER(USE_FCGI) FCGI_END(0, FCGI_REQUEST_COMPLETE)
                                                               :(RETURN)
*
CGI_OBJECT_END
*
@

The startup of a CGI script should explicitly set the library directory
(if needed). As well, the path to the interpreter should be absolute.
These are basic security measures.

This unit test will test basic CGI object creation. Cookie jars and
cookies. The session cookie and sessions. Simple logging. Templates.

Template sample has jQuery lashed in. Need AJAJ (AJAX with JSON)
server support and some sample web page stuff.

Performance Notes

Caching compiled templates (in a separate process), pooling database
connections, fastcgi would all help. This code can be 50% faster with
these techniques.

Then Session verification.

Pick a simple application, write and deploy: fog the mirror would be
fine. Signon, message board.

CGI and PSQL use SCOOP. HTMLTMPL, SESSION and COOKIE could as well,
but predate SCOOP.

<<unit_test>>=
#!/usr/bin/bash
         export "SNOLIB=/home/fred/snolib"; export "SNOPATH=/home/fred/snolib"; export "LD_LIBRARY_PATH=/home/fred/snolib"
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'FCGI.INC'
-INCLUDE 'CGI.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'HTMLTMPL.INC'
-INCLUDE 'SESSION.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'DSERVE.INC'
-INCLUDE 'ROUTING.INC'
*
-CMNT EMBED THE TEMPLATES NEEDED. FOR NORMAL USE, THE TEMPLATES WOULD
-CMNT BE MAINTAINED SEPARATELY, BUT THIS IS THE TEST SAMPLE.
-EMBED FILE 'CGI.tmpl'
<!doctype html>
<!-- A simple template -->
<html>
  <head>
    <meta charset="UTF-8" />
    <title>CGI test</title>
    <style>
      a.test {
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <a href="http://jquery.com/">jQuery</a>
    <script src="/jquery-1.11.1.js"></script>
    <script>
      // js code goes here
//      $( document ).ready(function() {
//        // Your code here.
//        $( "a" ).click(function( event ) {
//          alert( "The link will no longer take you to jquery.com" );
//          event.preventDefault();
//          $( this ).hide( "slow" );
//        });
//        $( "a" ).addClass( "test" );
        //removeClass()
//        });
    </script>
    <!-- Text with some variables to be filled in -->
    <p>
      HTML OUTPUT
    <p>
      cookie counter <tmpl_var COOKIE_COUNTER>
    <p>
      session counter <tmpl_var SESSION_COUNTER>
    <p>
      request method <tmpl_var REQUEST_METHOD>
    <p>
      first name <tmpl_var FIRST_NAME>
    <p>
      vehicle <tmpl_var VEHICLE>
    <p>
      request uri <tmpl_var REQUEST_URI>
    <p>
      path info <tmpl_var PATH_INFO>
    <ul>
      <li><a href="cgi-bin/cgi.fcgi/showname/Adrian">Hello World</a>
      <li><a href="cgi-bin/cgi.fcgi/showsum/22/11">Calculator</a>
    </ul>
    <p>
      <form name="input" action="cgi.fcgi" method="GET">
        First name: <input type="text" name="firstname"><br>
        Last name: <input type="text" name="lastname"><br>
        Password: <input type="password" name="pwd"><br>
        <input type="radio" name="sex" value="male">Male<br>
        <input type="radio" name="sex" value="female">Female<br>
        <input type="checkbox" name="vehicle" value="car">
          I have a car<br>
        <input type="checkbox" name="vehicle" value="bike">
          I have a bike<br>
        <input type="submit" value="submit get"><br>
        <input type="reset" value="reset"><br>
        <input type="hidden" name="key" value="whatiwant">
      </form>
    <p>
      <form name="input" action="cgi.fcgi" method="POST">
        First name: <input type="text" name="firstname"><br>
        Last name: <input type="text" name="lastname"><br>
        Password: <input type="password" name="pwd"><br>
        <input type="radio" name="sex" value="male">Male<br>
        <input type="radio" name="sex" value="female">Female<br>
        <input type="checkbox" name="vehicle" value="car">
          I have a car<br>
        <input type="checkbox" name="vehicle" value="bike">
          I have a bike<br>
        <input type="submit" value="submit post"><br>
        <input type="reset" value="reset"><br>
        <input type="hidden" name="key" value="whatiwant">
      </form>
  </body>
</html>
-END
         &CODE = 1
*
* A CGI APPLICATION IS EITHER A SINGLE-RUN CGI SCRIPT, OR AN FCGI
* (FAST CGI) APPLICATION. AN FCGI APPLICATION WAITS WITH ACCEPT(),
* GATHERS DATA USING PACKETS, AND THEN EXECUTES THE CGI PART. RESPONSES
* ARE SENT WITH PACKETS. THIS IS HANDLED IN THE CGI CLASS, SO AS NOT
* TO REQUIRE WEB APPLICATION CHANGES. FCGI_ACCEPT() WILL HANDLE EITHER
* CGI OR FCGI APPLICATIONS, BUT, IF IT IS KNOWN THAT FCGI WON'T BE
* DEPLOYED, IT CAN BE OMMITED IN THAT CASE.
*
CGI_TOP  FCGI_ACCEPT()
         DSERVE()
*
         BASE_TIME = TIME()
         BASE_ST = &STEXEC
*
* CREATE NEW CGI OBJECT
*
* NOTE THAT THIS IS IN AN ACCEPT LOOP IF FCGI IS IN USE. DATABASE
* ACCESS CAN BE HOISTED OUTSIDE THIS LOOP AS WELL, IN THAT CASE.
*
         CGI = SEND(CGI_CLASS, 'NEW')
*
* GET LOGGING CHANNEL
*
         LOG = SEND(CGI, 'GET_LOG')
*
* LOG ENTRY
*
         $LOG = 'CGI ENTERED'
         $LOG = 'CURRENT DIRECTORY IS ' BQ('pwd')
         $LOG = DIFFER(USE_FCGI) 'FAST CGI'
         $LOG = IDENT(USE_FCGI) 'CGI'
*
* GET THE COOKIE JAR
*
         JAR = SEND(CGI, 'GET_COOKIE_JAR')
*
* LOAD THE SESSION. SESSION ID IS TAKEN FROM COOKIE 'SESSION'. AFTER
* USING THE SESSION COOKIE, DESTROY IT (IT WILL GET RECREATED IF
* NEEDED WHEN THE SESSION IS PERSISTED).
*
         SESSION =
         C = GET_COOKIE_FROM_JAR(JAR, 'SESSION')
         PUT_COOKIE_IN_JAR(JAR, 'SESSION', )
         SESSION = SESSION_LOAD(COOKIE_VALUE(VDIFFER(C)))
*
* CREATE SESSION IF IT DOESN'T EXIST.
*
         SESSION = IDENT(SESSION) SESSION_CREATE(600)
*
* CREATE A PSQL OBJECT. OPEN THE DATABASE, AND GET THE PIPE HANDLE.
* WE WILL LEAVE THE DATABASE OBJECT AROUND, FOR EFFICIENCY WITH
* FCGI.
*
         DIFFER(PSQL)                                      :S(PSQL_CONN)
         PSQL = SEND(PSQL_CLASS, 'NEW')
         &ERRLIMIT = 1
         SEND(PSQL, 'OPEN')
         &ERRLIMIT = 0
         DB = SEND(PSQL, 'GET_PIPE')
PSQL_CONN
*
* SET HEADER
*
         H = SEND(CGI, 'GET_HEADER') 
         H<'CONTENT_TYPE'> = 'text/html'
         H<'CHARSET'> = 'UTF-8'
*
* RETRIEVE THE COUNTER COOKIE. IF IT DOESN'T EXIST, CREATE IT.
*
         C = GET_COOKIE_FROM_JAR(JAR, 'COUNTER')
         IDENT(C) PUT_COOKIE_IN_JAR(JAR, 'COUNTER', NEW_COOKIE(0))
*
* CREATE ANOTHER COOKIE 'TESTER' WITH VALUE 'SNOBOL4'
*
         PUT_COOKIE_IN_JAR(JAR, 'TESTER', NEW_COOKIE('SNOBOL4'))
*
* INCREMENT THE VALUE OF THE COUNTER COOKIE. WE VALIDATE THAT THE
* VALUE OF COUNTER IS AN INTEGER.
*
         C = GET_COOKIE_FROM_JAR(JAR, 'COUNTER')
         V = COOKIE_VALUE(C)
         V = ~INTEGER(V) 0
         COOKIE_SET_VALUE(C,  V + 1)
*
* A SESSION VARIABLE
*
         SESSION<'NAME'> = 'FRED'
*
* INCREMENT THE COUNTER SESSION VARIABLE
*
         V = SESSION<'COUNTER'>
         V = ~INTEGER(V) 0
         SESSION<'COUNTER'> = V + 1
*
* PERSIST THE SESSION. THIS SAVES THE SESSION TO DISK AND CREATES
* THE BROWSER COOKIE TO ALLOW THE RETRIEVAL OF THE SESSION LATER.
*
         SESSION_PERSIST(SESSION)                            :F(FRETURN)
         T = SESSION<'EXPIRE_TIME'>
         C = NEW_COOKIE(SESSION<'UUID'>)
         PUT_COOKIE_IN_JAR(JAR, 'SESSION', C)
         COOKIE_SET_CRUMB(C, 'EXPIRES', COOKIE_EXPIRY(T))
*
* READ AND COMPILE THE HTML TEMPLATE. WE CACHE THIS FOR FCGI.
*
         DIFFER(P_TM)                                         :S(NO_T_C)
         S_TM = READFILE('CGI.tmpl')
         P_TM = TMPL_COMPILE(S_TM)
NO_T_C
*
* BUILD TABLE OF VARIABLES TO SUBSTITUTE INTO THE TEMPLATE
* THIS HAS THE RAW COOKIE STRING, THE VALUE OF COUNTER FROM THE
* COOKIE JAR AND THE VALUE OF COUNTER FROM THE SESSION.
*
         A = TABLE()
*
* FROM THE ENV
*
         E = SEND(CGI, 'GET_ENV')
         A<'REQUEST_METHOD'> = E<'REQUEST_METHOD'>
*
* REQUEST URI http://localhost/cgi-bin/cgi.fcgi/x/y?...
* ON GET, APPENDS '/' ACTION TO THE END BEFORE THE ? PART.
*
         A<'REQUEST_URI'> = E<'REQUEST_URI'>
         A<'PATH_INFO'> = E<'PATH_INFO'>
*
* TAKE REQUEST_METHOD, PATH_INFO AND MATCH AGAINST ROUTING PATTERN
*
* V = TABLE()
* R = ROUTING_INIT()
* M = ROUTING(METHOD, PATH, .V)
* A = ACTION
* R = ROUTING_ADD(R, M, A)
*
* (METHOD '\' PATH_INFO) R
* IF SUCCESS, ACTION IS SET, V<> IS FILLED IN
*
* FROM THE COOKIE JAR
*
         A<'COOKIE_COUNTER'> =
+           COOKIE_VALUE(GET_COOKIE_FROM_JAR(JAR, 'COUNTER'))
*
* SESSION VARIABLE
*
         A<'SESSION_COUNTER'> =  SESSION<'COUNTER'>
*
* QUERY VARIABLES
*
         Q = SEND(CGI, 'GET_QUERY')
         A<'FIRST_NAME'> = Q<'firstname'>
         A<'VEHICLE'> = Q<'vehicle'>
*
* INTERPRET THE TEMPLATE WITH THE SUPPLIED VARIABLES
*
         S = TMPL_INTERPRET(P_TM, A)
*
* TRANSMIT THE EXPANDED PAGE TO THE CLIENT
*
         SEND(CGI, 'SET_CONTENT', S)
*
         SEND(CGI, 'SEND')
*
* CLOSE THE DATABASE
*
*        SEND(PSQL, 'CLOSE')
*
* LOG COMPLETION AND SHOW PERFORMANCE DATA
*
         $LOG = 'CGI COMPLETE'
         $LOG = TIME() - BASE_TIME ' MILLISECONDS FOR REQUEST'
         $LOG = &GCTIME  ' IN GARBAGE COLLECTOR (TOTAL)'
         $LOG = &STEXEC - BASE_ST ' STATEMENTS EXECUTED'
*
         SEND(CGI, 'CLOSE')
         &CODE = 0
*
* IF USING FCGI, LOOP BACK TO THE ACCEPT() CALL RATHER THAN EXIT THE
* PROCESS.
*
         DIFFER(USE_FCGI)                                    :S(CGI_TOP)
END
@

<<>>=
<<INCLUDES>>
-STITL CGI
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                         #####    #####   ###                         *
*                        #     #  #     #   #                          *
*                        #        #         #                          *
*                        #        #  ####   #                          *
*                        #        #     #   #                          *
*                        #     #  #     #   #                          *
*                         #####    #####   ###                         *
*                                                                      *
* CGI                    CGI SUPPORT FUNCTIONS                         *
*                                                                      *
************************************************************************
*
* CGI.lss
*
<<CGI>>
*
* CE: .F.MSNOBOL4;
@
-LINE 52 "CGI.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'COOKIE.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'HTMLESC.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'UNIQUE.INC'
-INCLUDE 'VDIFFER.INC'
-STITL CGI
-EJECT
-LINE 575 "CGI.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*                         #####    #####   ###                         *
*                        #     #  #     #   #                          *
*                        #        #         #                          *
*                        #        #  ####   #                          *
*                        #        #     #   #                          *
*                        #     #  #     #   #                          *
*                         #####    #####   ###                         *
*                                                                      *
* CGI                    CGI SUPPORT FUNCTIONS                         *
*                                                                      *
************************************************************************
*
* CGI.lss
*
-LINE 65 "CGI.lss"
-MODULE CGI
-USES CRACK(), HOST(), URL_DECODE(), COOKIE_FIX_NAME()
-WEAK USE_FCGI, FCGI_ENV, FCGI_IN, FCGI_REQUEST_COMPLETE
-WEAK FCGI_SEND(), FCGI_END()
-PUBLIC CLASS:CGI_CLASS
         CGI_CLASS = SEND(CLASS, 'NEW_CLASS', 'CGI_CLASS')
         DEFINE('CGI_INIT()A,C')
-PUBLIC CGI_CLASS:'INIT'
         SEND(CGI_CLASS, 'ADD_METHOD', 'INIT', 'CGI_INIT')
-PUBLIC CGI_CLASS:'GET_COOKIE_JAR'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_COOKIE_JAR', CODE(
+           ' SEND = |.COOKIE_JAR :(RETURN)'))
-PUBLIC CGI_CLASS:'GET_HEADER'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_HEADER', CODE(
+           ' SEND = |.HEADER :(RETURN)'))
         DEFINE('CGI_SEND()S')
-PUBLIC CGI_CLASS:'SEND'
         SEND(CGI_CLASS, 'ADD_METHOD', 'SEND', 'CGI_SEND')
-PUBLIC CGI_CLASS:'GET_LOG'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_LOG', CODE(
+           ' SEND = |.LOG :(RETURN)'))
-PUBLIC CGI_CLASS:'GET_CONTENT'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_CONTENT', CODE(
+           ' SEND = |.CONTENT :(RETURN)'))
-PUBLIC CGI_CLASS:'SET_CONTENT'
         SEND(CGI_CLASS, 'ADD_METHOD', 'SET_CONTENT', CODE(
+           ' |.CONTENT = A1 :(RETURN)'))
         DEFINE('CGI_CLOSE()A')
-PUBLIC CGI_CLASS:'CLOSE'
         SEND(CGI_CLASS, 'ADD_METHOD', 'CLOSE', 'CGI_CLOSE')
-PUBLIC CGI_CLASS:'GET_ENV'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_ENV', CODE(
+           ' SEND = |.ENV :(RETURN)'))
-PUBLIC CGI_CLASS:'GET_QUERY'
         SEND(CGI_CLASS, 'ADD_METHOD', 'GET_QUERY', CODE(
+           ' SEND = |.QUERY :(RETURN)'))
*
                                                       :(CGI_OBJECT_END)
*
* CLOSE CGI OBJECT
*
CGI_CLOSE
         ENDFILE(|.OUT_UNIT)
         DETACH(|.OUT)
         ENDFILE(|.LOG_UNIT)
         DETACH(|.LOG)                                         :(RETURN)
*
* INITIALIZE CGI OBJECT
*
CGI_INIT CGI_INIT = SUPER('INIT')
*
* CREATE LOG CHANNEL
*
         |.LOG_UNIT = IO_FINDUNIT()                          :F(FRETURN)
         |.LOG = UNIQUE()
*
* WITH ALL THE CHANGES GOING TO SYSTEMD, LOGGING APPEARS TO HAVE
* SUFFERED. SPECIFICALLY, IF THE LOGGING IS ONLY FORWARDED TO
* RSYSLOG, LOGGER LOCAL DOESN'T WORK. WE ENABLE RSYSLOG TO LISTEN TO
* THE NETWORK, AND THEN LOGGER CAN LOG TO LOCALHOST. STRANGE, AND
* PROBABLY NOT SUITABLE FOR PRODUCTION.
*
* IF USING SYSTEMD LOGGER, DON'T USE -n localhost
*
         OUTPUT(|.LOG, |.LOG_UNIT, 'W',
+               '|/usr/bin/logger -n localhost -t CGI')      :F(FRETURN)
*+              '|/usr/bin/logger -t CGI')                   :F(FRETURN)
*
* CREATE OUT CHANNEL
*
         |.OUT_UNIT = IO_FINDUNIT()                          :F(FRETURN)
         |.OUT = UNIQUE()
         OUTPUT(|.OUT, |.OUT_UNIT, 'B', '/dev/stdout')       :F(FRETURN)
*
* COLLECT ENVIRONMENT VARIABLES INTO INSTANCE VARIABLE ENV. WE ONLY
* GATHER UP "KNOWN" ENVIRONMENT VARIABLES.
*
         |.ENV = DIFFER(USE_FCGI) FCGI_ENV                 :S(CGI_ENV_2)
*
         |.ENV = TABLE(38)
         A = %('AUTH_TYPE,CONTENT_LENGTH,CONTENT_TYPE,'
+              'CONTEXT_DOCUMENT_ROOT,CONTEXT_PREFIX,DOCUMENT_ROOT,'
+              'GATEWAY_INTERFACE,HTTP_ACCEPT,HTTP_ACCEPT_CHARSET,'
+              'HTTP_ACCEPT_ENCODING,HTTP_ACCEPT_LANGUAGE,'
+              'HTTP_CACHE_CONTROL,HTTP_CONNECTION,HTTP_COOKIE,'
+              'HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,LIB_PATH,PATH,'
+              'PATH_INFO,PATH_TRANSLATED,QUERY_STRING,REMOTE_ADDR,'
+              'REMOTE_HOST,REMOTE_IDENT,REMOTE_PORT,REQUEST_METHOD,'
+              'REQUEST_SCHEME,REQUEST_URI,SCRIPT_FILENAME,SCRIPT_NAME,'
+              'SERVER_ADDR,SERVER_ADMIN,SERVER_NAME,SERVER_PORT,'
+              'SERVER_PROTOCOL,SERVER_SIGNATURE,SERVER_SOFTWARE')
         SEQ(' (|.ENV)<A<I>> = HOST(HOST_GETENV, A<I>); A<I> ', .I)
CGI_ENV_2
         $|.LOG = 'FCGI_ENV IN CGI'
         $|.LOG = JSON_ENCODE(FCGI_ENV)
         $|.LOG = 'QUERY_STRING: ' (|.ENV)<'QUERY_STRING'>
*
* FOR POST METHOD, READ (|.ENV)<'CONTENT_LENGTH'>. READ THAT NUMBER OF
* BYTES, AND ONLY THAT NUMBER. NOTE THAT THIS MAY BE VERY LARGE. THIS
* MAY FAIL DUE TO MEMORY EXHAUSTION. WE KNOW THAT WE CAN READ A LARGE
* NUMBER OF BYTES, BUT I HAVE TO DETERMINE THE LIMIT.
*
* FOR FCGI, USE FCGI_IN. FIXME: SHOULD TEST CONTENT_LENGTH
*
         (|.ENV)<'QUERY_STRING'> = DIFFER(USE_FCGI) VDIFFER(FCGI_IN)
+                                                         :S(CGI_INIT_3)
         T3 = (|.ENV)<'CONTENT_LENGTH'>
         IDENT(T3)                                        :S(CGI_INIT_3)
         (INTEGER(T3) GT(T3))                             :F(CGI_INIT_3)
         T1 = IO_FINDUNIT()                                  :F(FRETURN)
         INPUT('T2', T1, 'B,' T3, '/dev/stdin')              :F(FRETURN)
         (|.ENV)<'QUERY_STRING'> = T2
         ENDFILE(T1)
         DETACH('T2')
CGI_INIT_3
*
* PARSE QUERY_STRING INTO QUERY TABLE. HASH() IS USED TO PARSE
* QUERY_STRING, BREAKING INTO NAME=VALUE SEPARATED BY &. EACH VALUE IS
* PROCESSED WITH URL_DECODE().
*
* MULTI-VALUE FIELDS ARE SEPARATED BY 0. USED BY CHECKBOXES
*
         |.QUERY = HASH((|.ENV)<'QUERY_STRING'>, '=', '&',,,,
+                        'URL_DECODE', CHARS_NUL)
         $|.LOG = 'QUERY TABLE'
         $|.LOG = JSON_ENCODE(|.QUERY)
*
* PARSE HTTP_COOKIE INTO A COOKIE JAR. THERE MAY NOT BE ANY COOKIES,
* IN WHICH CASE WE CREATE AN EMPTY COOKIE JAR. THE VALUES OF THE
* COOKIES ARE NOT VALIDATED. HASH() PARSES THE COOKIE STRING. AFTER
* THE TABLE IS GENERATED, IT IS CONVERTED TO AN ARRAY. SEQ() ADDS
* EACH ELEMENT INTO THE COOKIE JAR.
*
         |.COOKIE_JAR = NEW_COOKIE_JAR()
         A = HASH((|.ENV)<'HTTP_COOKIE'>, '=', ';',,,
+                  'COOKIE_FIX_NAME', 'URL_DECODE')
         A = CONVERT(A, 'ARRAY')                          :F(CGI_INIT_2)
         SEQ(' PUT_COOKIE_IN_JAR(|.COOKIE_JAR,'
+                               'A<I,1>, NEW_COOKIE(A<I,2>)) ', .I)
CGI_INIT_2
*
* INITIALIZE HEADER. THE HEADER IS A TABLE() WITH AT LEAST CONTENT_TYPE
* ENTRY.
*
         |.HEADER = #'CONTENT_TYPE=TEXT/HTML,CHARSET='
*
* INITIALIZE CONTENT
*
         |.CONTENT =
*
* WE NEED ROUTING IMPLEMENTED.
*
* WE NEED TO DO FURTHER PROCESSING ON THE FOLLOWING CGI ENVIRONMENT
* VARIABLES.
*
* <ISINDEX> value1+value2+..
* HTTP_ACCEPT
*   ='TEXT/HTML,APPLICATION/XHTML+XML,APPLICATION/XML;Q=0.9,*/*;Q=0.8'
* HTTP_ACCEPT_ENCODING='GZIP, DEFLATE'
* HTTP_ACCEPT_LANGUAGE='EN-US,EN;Q=0.5'
*
                                                               :(RETURN)
*
* OUTPUT THE HEADER AND CONTENT
*
CGI_SEND
*
* FIRST, OUTPUT THE CONTENT-TYPE. IF CHARSET HAS BEEN SPECIFIED,
* ADD THIS TO THE CONTENT-TYPE.
*
         S = 'Content-type: ' (|.HEADER)<'CONTENT_TYPE'>
         S = S '; charset=' VDIFFER((|.HEADER)<'CHARSET'>)
         S = S CHARS_CR CHARS_NL
*
* GENERATE THE COOKIE STRING AND OUTPUT IF WE HAVE COOKIES TO SEND.
*
         S = S VDIFFER(COOKIE_STRING(|.COOKIE_JAR))
*
* THE HEADER FINISHES WITH A CR/LF
*
         S = S CHARS_CR CHARS_NL
         $|.OUT = IDENT(USE_FCGI) S
         DIFFER(USE_FCGI) FCGI_SEND(S)
*
* SEND CONTENT
*
         $|.OUT = IDENT(USE_FCGI) |.CONTENT
         DIFFER(USE_FCGI) FCGI_SEND(|.CONTENT)
         DIFFER(USE_FCGI) FCGI_SEND('')
         DIFFER(USE_FCGI) FCGI_END(0, FCGI_REQUEST_COMPLETE)
                                                               :(RETURN)
*
CGI_OBJECT_END
*
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CGI - CGI Support Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CGI</font> support functions. <font face="Source Code Pro">SCOOP</font> is used to create a <font face="Source Code Pro">CGI</font>
object.  This object contains data and methods needed to support
<font face="Source Code Pro">CGI</font> activities.  In turn, <font face="Source Code Pro">CGI</font> uses <font face="Source Code Pro">COOKIE</font> to support
<font face="Source Code Pro">HTTP</font> cookies. The <font face="Source Code Pro">WEB</font> application can use <font face="Source Code Pro">SESSION</font> to
support persistant server-side sessions. <font face="Source Code Pro">HTMLTMPL</font> to support
templates, <font face="Source Code Pro">PSQL</font> to provide database for filling in templates.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Logging is supported in the <font face="Source Code Pro">CGI</font> class. This is not decoupled
because there are very few ways to debug <font face="Source Code Pro">CGI</font> applications.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
USE_FCGI is set to true in FCGI.lss if Fast CGI is in use. So,
include FCGI.INC before CGI.INC to prepare for Fast CGI.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Still need: Response codes, Headers/Responses
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| Last-modified:
| Content-type: application/octet-stream; name="filename"
| Content-disposition: attachment; filename="genome.jpg"
| 
| Content-length: 3002
| Location:
| Status: 200 OK
| 302 Found (301 302 303)
| 400 Bad Request
| 501 Not Implemented
| local redirect - just respond with Location:
| absolute URI redirect same
| with doc, respond 302 Location and doc returned
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="COOKIE.html">COOKIE</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="HASH.html">HASH</a><br>
<a href="HTMLESC.html">HTMLESC</a><br>
<a href="JSON.html">JSON</a><br>
<a href="SCOOP.html">SCOOP</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="SESSION.html">SESSION</a><br>
<a href="HTMLTMPL.html">HTMLTMPL</a><br>
<a href="PSQL.html">PSQL</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;COOKIE.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;HTMLESC.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;SCOOP.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;UNIQUE.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CGI&raquo;&equiv;</b>
-MODULE CGI
-USES CRACK(), HOST(), URL_DECODE(), COOKIE_FIX_NAME()
-WEAK USE_FCGI, FCGI_ENV, FCGI_IN, FCGI_REQUEST_COMPLETE
-WEAK FCGI_SEND(), FCGI_END()
-PUBLIC CLASS:CGI_CLASS
         CGI_CLASS = SEND(CLASS, &#39;NEW_CLASS&#39;, &#39;CGI_CLASS&#39;)
         DEFINE(&#39;CGI_INIT()A,C&#39;)
-PUBLIC CGI_CLASS:&#39;INIT&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;INIT&#39;, &#39;CGI_INIT&#39;)
-PUBLIC CGI_CLASS:&#39;GET_COOKIE_JAR&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_COOKIE_JAR&#39;, CODE(
+           &#39; SEND = |.COOKIE_JAR :(RETURN)&#39;))
-PUBLIC CGI_CLASS:&#39;GET_HEADER&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_HEADER&#39;, CODE(
+           &#39; SEND = |.HEADER :(RETURN)&#39;))
         DEFINE(&#39;CGI_SEND()S&#39;)
-PUBLIC CGI_CLASS:&#39;SEND&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;SEND&#39;, &#39;CGI_SEND&#39;)
-PUBLIC CGI_CLASS:&#39;GET_LOG&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_LOG&#39;, CODE(
+           &#39; SEND = |.LOG :(RETURN)&#39;))
-PUBLIC CGI_CLASS:&#39;GET_CONTENT&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_CONTENT&#39;, CODE(
+           &#39; SEND = |.CONTENT :(RETURN)&#39;))
-PUBLIC CGI_CLASS:&#39;SET_CONTENT&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;SET_CONTENT&#39;, CODE(
+           &#39; |.CONTENT = A1 :(RETURN)&#39;))
         DEFINE(&#39;CGI_CLOSE()A&#39;)
-PUBLIC CGI_CLASS:&#39;CLOSE&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;CLOSE&#39;, &#39;CGI_CLOSE&#39;)
-PUBLIC CGI_CLASS:&#39;GET_ENV&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_ENV&#39;, CODE(
+           &#39; SEND = |.ENV :(RETURN)&#39;))
-PUBLIC CGI_CLASS:&#39;GET_QUERY&#39;
         SEND(CGI_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_QUERY&#39;, CODE(
+           &#39; SEND = |.QUERY :(RETURN)&#39;))
<font color="#818181"><i>*</i></font>
                                                       <b>:(CGI_OBJECT_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CLOSE CGI OBJECT</i></font>
<font color="#818181"><i>*</i></font>
CGI_CLOSE
         ENDFILE(|.OUT_UNIT)
         DETACH(|.OUT)
         ENDFILE(|.LOG_UNIT)
         DETACH(|.LOG)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INITIALIZE CGI OBJECT</i></font>
<font color="#818181"><i>*</i></font>
CGI_INIT CGI_INIT = SUPER(&#39;INIT&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE LOG CHANNEL</i></font>
<font color="#818181"><i>*</i></font>
         |.LOG_UNIT = IO_FINDUNIT()                          <b>:F(FRETURN)</b>
         |.LOG = UNIQUE()
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WITH ALL THE CHANGES GOING TO SYSTEMD, LOGGING APPEARS TO HAVE</i></font>
<font color="#818181"><i>* SUFFERED. SPECIFICALLY, IF THE LOGGING IS ONLY FORWARDED TO</i></font>
<font color="#818181"><i>* RSYSLOG, LOGGER LOCAL DOESN&#39;T WORK. WE ENABLE RSYSLOG TO LISTEN TO</i></font>
<font color="#818181"><i>* THE NETWORK, AND THEN LOGGER CAN LOG TO LOCALHOST. STRANGE, AND</i></font>
<font color="#818181"><i>* PROBABLY NOT SUITABLE FOR PRODUCTION.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF USING SYSTEMD LOGGER, DON&#39;T USE -n localhost</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT(|.LOG, |.LOG_UNIT, &#39;W&#39;,
+               &#39;|/usr/bin/logger -n localhost -t CGI&#39;)      <b>:F(FRETURN)</b>
<font color="#818181"><i>*+              &#39;|/usr/bin/logger -t CGI&#39;)                   <b>:F(FRETURN)</b></i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE OUT CHANNEL</i></font>
<font color="#818181"><i>*</i></font>
         |.OUT_UNIT = IO_FINDUNIT()                          <b>:F(FRETURN)</b>
         |.OUT = UNIQUE()
         OUTPUT(|.OUT, |.OUT_UNIT, &#39;B&#39;, &#39;/dev/stdout&#39;)       <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COLLECT ENVIRONMENT VARIABLES INTO INSTANCE VARIABLE ENV. WE ONLY</i></font>
<font color="#818181"><i>* GATHER UP &quot;KNOWN&quot; ENVIRONMENT VARIABLES.</i></font>
<font color="#818181"><i>*</i></font>
         |.ENV = DIFFER(USE_FCGI) FCGI_ENV                 <b>:S(CGI_ENV_2)</b>
<font color="#818181"><i>*</i></font>
         |.ENV = TABLE(38)
         A = %(&#39;AUTH_TYPE,CONTENT_LENGTH,CONTENT_TYPE,&#39;
+              &#39;CONTEXT_DOCUMENT_ROOT,CONTEXT_PREFIX,DOCUMENT_ROOT,&#39;
+              &#39;GATEWAY_INTERFACE,HTTP_ACCEPT,HTTP_ACCEPT_CHARSET,&#39;
+              &#39;HTTP_ACCEPT_ENCODING,HTTP_ACCEPT_LANGUAGE,&#39;
+              &#39;HTTP_CACHE_CONTROL,HTTP_CONNECTION,HTTP_COOKIE,&#39;
+              &#39;HTTP_HOST,HTTP_REFERER,HTTP_USER_AGENT,LIB_PATH,PATH,&#39;
+              &#39;PATH_INFO,PATH_TRANSLATED,QUERY_STRING,REMOTE_ADDR,&#39;
+              &#39;REMOTE_HOST,REMOTE_IDENT,REMOTE_PORT,REQUEST_METHOD,&#39;
+              &#39;REQUEST_SCHEME,REQUEST_URI,SCRIPT_FILENAME,SCRIPT_NAME,&#39;
+              &#39;SERVER_ADDR,SERVER_ADMIN,SERVER_NAME,SERVER_PORT,&#39;
+              &#39;SERVER_PROTOCOL,SERVER_SIGNATURE,SERVER_SOFTWARE&#39;)
         SEQ(&#39; (|.ENV)&lt;A&lt;I&gt;&gt; = HOST(HOST_GETENV, A&lt;I&gt;); A&lt;I&gt; &#39;, .I)
CGI_ENV_2
         $|.LOG = &#39;FCGI_ENV IN CGI&#39;
         $|.LOG = JSON_ENCODE(FCGI_ENV)
         $|.LOG = &#39;QUERY_STRING: &#39; (|.ENV)&lt;&#39;QUERY_STRING&#39;&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FOR POST METHOD, READ (|.ENV)&lt;&#39;CONTENT_LENGTH&#39;&gt;. READ THAT NUMBER OF</i></font>
<font color="#818181"><i>* BYTES, AND ONLY THAT NUMBER. NOTE THAT THIS MAY BE VERY LARGE. THIS</i></font>
<font color="#818181"><i>* MAY FAIL DUE TO MEMORY EXHAUSTION. WE KNOW THAT WE CAN READ A LARGE</i></font>
<font color="#818181"><i>* NUMBER OF BYTES, BUT I HAVE TO DETERMINE THE LIMIT.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FOR FCGI, USE FCGI_IN. FIXME: SHOULD TEST CONTENT_LENGTH</i></font>
<font color="#818181"><i>*</i></font>
         (|.ENV)&lt;&#39;QUERY_STRING&#39;&gt; = DIFFER(USE_FCGI) VDIFFER(FCGI_IN)
+                                                         <b>:S(CGI_INIT_3)</b>
         T3 = (|.ENV)&lt;&#39;CONTENT_LENGTH&#39;&gt;
         IDENT(T3)                                        <b>:S(CGI_INIT_3)</b>
         (INTEGER(T3) GT(T3))                             <b>:F(CGI_INIT_3)</b>
         T1 = IO_FINDUNIT()                                  <b>:F(FRETURN)</b>
         INPUT(&#39;T2&#39;, T1, &#39;B,&#39; T3, &#39;/dev/stdin&#39;)              <b>:F(FRETURN)</b>
         (|.ENV)&lt;&#39;QUERY_STRING&#39;&gt; = T2
         ENDFILE(T1)
         DETACH(&#39;T2&#39;)
CGI_INIT_3
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PARSE QUERY_STRING INTO QUERY TABLE. HASH() IS USED TO PARSE</i></font>
<font color="#818181"><i>* QUERY_STRING, BREAKING INTO NAME=VALUE SEPARATED BY &amp;. EACH VALUE IS</i></font>
<font color="#818181"><i>* PROCESSED WITH URL_DECODE().</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MULTI-VALUE FIELDS ARE SEPARATED BY 0. USED BY CHECKBOXES</i></font>
<font color="#818181"><i>*</i></font>
         |.QUERY = HASH((|.ENV)&lt;&#39;QUERY_STRING&#39;&gt;, &#39;=&#39;, &#39;&amp;&#39;,,,,
+                        &#39;URL_DECODE&#39;, CHARS_NUL)
         $|.LOG = &#39;QUERY TABLE&#39;
         $|.LOG = JSON_ENCODE(|.QUERY)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PARSE HTTP_COOKIE INTO A COOKIE JAR. THERE MAY NOT BE ANY COOKIES,</i></font>
<font color="#818181"><i>* IN WHICH CASE WE CREATE AN EMPTY COOKIE JAR. THE VALUES OF THE</i></font>
<font color="#818181"><i>* COOKIES ARE NOT VALIDATED. HASH() PARSES THE COOKIE STRING. AFTER</i></font>
<font color="#818181"><i>* THE TABLE IS GENERATED, IT IS CONVERTED TO AN ARRAY. SEQ() ADDS</i></font>
<font color="#818181"><i>* EACH ELEMENT INTO THE COOKIE JAR.</i></font>
<font color="#818181"><i>*</i></font>
         |.COOKIE_JAR = NEW_COOKIE_JAR()
         A = HASH((|.ENV)&lt;&#39;HTTP_COOKIE&#39;&gt;, &#39;=&#39;, &#39;;&#39;,,,
+                  &#39;COOKIE_FIX_NAME&#39;, &#39;URL_DECODE&#39;)
         A = CONVERT(A, &#39;ARRAY&#39;)                          <b>:F(CGI_INIT_2)</b>
         SEQ(&#39; PUT_COOKIE_IN_JAR(|.COOKIE_JAR,&#39;
+                               &#39;A&lt;I,1&gt;, NEW_COOKIE(A&lt;I,2&gt;)) &#39;, .I)
CGI_INIT_2
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INITIALIZE HEADER. THE HEADER IS A TABLE() WITH AT LEAST CONTENT_TYPE</i></font>
<font color="#818181"><i>* ENTRY.</i></font>
<font color="#818181"><i>*</i></font>
         |.HEADER = #&#39;CONTENT_TYPE=TEXT/HTML,CHARSET=&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INITIALIZE CONTENT</i></font>
<font color="#818181"><i>*</i></font>
         |.CONTENT =
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE NEED ROUTING IMPLEMENTED.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE NEED TO DO FURTHER PROCESSING ON THE FOLLOWING CGI ENVIRONMENT</i></font>
<font color="#818181"><i>* VARIABLES.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* &lt;ISINDEX&gt; value1+value2+..</i></font>
<font color="#818181"><i>* HTTP_ACCEPT</i></font>
<font color="#818181"><i>*   =&#39;TEXT/HTML,APPLICATION/XHTML+XML,APPLICATION/XML;Q=0.9,*/*;Q=0.8&#39;</i></font>
<font color="#818181"><i>* HTTP_ACCEPT_ENCODING=&#39;GZIP, DEFLATE&#39;</i></font>
<font color="#818181"><i>* HTTP_ACCEPT_LANGUAGE=&#39;EN-US,EN;Q=0.5&#39;</i></font>
<font color="#818181"><i>*</i></font>
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OUTPUT THE HEADER AND CONTENT</i></font>
<font color="#818181"><i>*</i></font>
CGI_SEND
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIRST, OUTPUT THE CONTENT-TYPE. IF CHARSET HAS BEEN SPECIFIED,</i></font>
<font color="#818181"><i>* ADD THIS TO THE CONTENT-TYPE.</i></font>
<font color="#818181"><i>*</i></font>
         S = &#39;Content-type: &#39; (|.HEADER)&lt;&#39;CONTENT_TYPE&#39;&gt;
         S = S &#39;; charset=&#39; VDIFFER((|.HEADER)&lt;&#39;CHARSET&#39;&gt;)
         S = S CHARS_CR CHARS_NL
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GENERATE THE COOKIE STRING AND OUTPUT IF WE HAVE COOKIES TO SEND.</i></font>
<font color="#818181"><i>*</i></font>
         S = S VDIFFER(COOKIE_STRING(|.COOKIE_JAR))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THE HEADER FINISHES WITH A CR/LF</i></font>
<font color="#818181"><i>*</i></font>
         S = S CHARS_CR CHARS_NL
         $|.OUT = IDENT(USE_FCGI) S
         DIFFER(USE_FCGI) FCGI_SEND(S)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SEND CONTENT</i></font>
<font color="#818181"><i>*</i></font>
         $|.OUT = IDENT(USE_FCGI) |.CONTENT
         DIFFER(USE_FCGI) FCGI_SEND(|.CONTENT)
         DIFFER(USE_FCGI) FCGI_SEND(&#39;&#39;)
         DIFFER(USE_FCGI) FCGI_END(0, FCGI_REQUEST_COMPLETE)
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CGI_OBJECT_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
The startup of a CGI script should explicitly set the library directory
(if needed). As well, the path to the interpreter should be absolute.
These are basic security measures.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This unit test will test basic CGI object creation. Cookie jars and
cookies. The session cookie and sessions. Simple logging. Templates.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Template sample has jQuery lashed in. Need AJAJ (AJAX with JSON)
server support and some sample web page stuff.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Performance Notes
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Caching compiled templates (in a separate process), pooling database
connections, fastcgi would all help. This code can be 50% faster with
these techniques.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Then Session verification.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Pick a simple application, write and deploy: fog the mirror would be
fine. Signon, message board.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
CGI and PSQL use SCOOP. HTMLTMPL, SESSION and COOKIE could as well,
but predate SCOOP.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         export &quot;SNOLIB=/home/fred/snolib&quot;; export &quot;SNOPATH=/home/fred/snolib&quot;; export &quot;LD_LIBRARY_PATH=/home/fred/snolib&quot;
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FCGI.INC&#39;
-INCLUDE &#39;CGI.INC&#39;
-INCLUDE &#39;READFILE.INC&#39;
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;PSQL.INC&#39;
-INCLUDE &#39;HTMLTMPL.INC&#39;
-INCLUDE &#39;SESSION.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;DSERVE.INC&#39;
-INCLUDE &#39;ROUTING.INC&#39;
<font color="#818181"><i>*</i></font>
-CMNT EMBED THE TEMPLATES NEEDED. FOR NORMAL USE, THE TEMPLATES WOULD
-CMNT BE MAINTAINED SEPARATELY, BUT THIS IS THE TEST SAMPLE.
-EMBED FILE &#39;CGI.tmpl&#39;
&lt;!doctype html&gt;
&lt;!-- A simple template --&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot; /&gt;
    &lt;title&gt;CGI test&lt;/title&gt;
    &lt;style&gt;
      a.test {
        font-weight: bold;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;a href=&quot;http://jquery.com/&quot;&gt;jQuery&lt;/a&gt;
    &lt;script src=&quot;/jquery-1.11.1.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      // js code goes here
//      $( document ).ready(function() {
//        // Your code here.
//        $( &quot;a&quot; ).click(function( event ) {
//          alert( &quot;The link will no longer take you to jquery.com&quot; );
//          event.preventDefault();
//          $( this ).hide( &quot;slow&quot; );
//        });
//        $( &quot;a&quot; ).addClass( &quot;test&quot; );
        //removeClass()
//        });
    &lt;/script&gt;
    &lt;!-- Text with some variables to be filled in --&gt;
    &lt;p&gt;
      HTML OUTPUT
    &lt;p&gt;
      cookie counter &lt;tmpl_var COOKIE_COUNTER&gt;
    &lt;p&gt;
      session counter &lt;tmpl_var SESSION_COUNTER&gt;
    &lt;p&gt;
      request method &lt;tmpl_var REQUEST_METHOD&gt;
    &lt;p&gt;
      first name &lt;tmpl_var FIRST_NAME&gt;
    &lt;p&gt;
      vehicle &lt;tmpl_var VEHICLE&gt;
    &lt;p&gt;
      request uri &lt;tmpl_var REQUEST_URI&gt;
    &lt;p&gt;
      path info &lt;tmpl_var PATH_INFO&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;cgi-bin/cgi.fcgi/showname/Adrian&quot;&gt;Hello World&lt;/a&gt;
      &lt;li&gt;&lt;a href=&quot;cgi-bin/cgi.fcgi/showsum/22/11&quot;&gt;Calculator&lt;/a&gt;
    &lt;/ul&gt;
    &lt;p&gt;
      &lt;form name=&quot;input&quot; action=&quot;cgi.fcgi&quot; method=&quot;GET&quot;&gt;
        First name<b>: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;</b>
        Last name<b>: &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;br&gt;</b>
        Password<b>: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt;</b>
        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;
        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female&lt;br&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;car&quot;&gt;
          I have a car&lt;br&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;bike&quot;&gt;
          I have a bike&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;submit get&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;reset&quot; value=&quot;reset&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;key&quot; value=&quot;whatiwant&quot;&gt;
      &lt;/form&gt;
    &lt;p&gt;
      &lt;form name=&quot;input&quot; action=&quot;cgi.fcgi&quot; method=&quot;POST&quot;&gt;
        First name<b>: &lt;input type=&quot;text&quot; name=&quot;firstname&quot;&gt;&lt;br&gt;</b>
        Last name<b>: &lt;input type=&quot;text&quot; name=&quot;lastname&quot;&gt;&lt;br&gt;</b>
        Password<b>: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;br&gt;</b>
        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;
        &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female&lt;br&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;car&quot;&gt;
          I have a car&lt;br&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;bike&quot;&gt;
          I have a bike&lt;br&gt;
        &lt;input type=&quot;submit&quot; value=&quot;submit post&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;reset&quot; value=&quot;reset&quot;&gt;&lt;br&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;key&quot; value=&quot;whatiwant&quot;&gt;
      &lt;/form&gt;
  &lt;/body&gt;
&lt;/html&gt;
-END
         &amp;CODE = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A CGI APPLICATION IS EITHER A SINGLE-RUN CGI SCRIPT, OR AN FCGI</i></font>
<font color="#818181"><i>* (FAST CGI) APPLICATION. AN FCGI APPLICATION WAITS WITH ACCEPT(),</i></font>
<font color="#818181"><i>* GATHERS DATA USING PACKETS, AND THEN EXECUTES THE CGI PART. RESPONSES</i></font>
<font color="#818181"><i>* ARE SENT WITH PACKETS. THIS IS HANDLED IN THE CGI CLASS, SO AS NOT</i></font>
<font color="#818181"><i>* TO REQUIRE WEB APPLICATION CHANGES. FCGI_ACCEPT() WILL HANDLE EITHER</i></font>
<font color="#818181"><i>* CGI OR FCGI APPLICATIONS, BUT, IF IT IS KNOWN THAT FCGI WON&#39;T BE</i></font>
<font color="#818181"><i>* DEPLOYED, IT CAN BE OMMITED IN THAT CASE.</i></font>
<font color="#818181"><i>*</i></font>
CGI_TOP  FCGI_ACCEPT()
         DSERVE()
<font color="#818181"><i>*</i></font>
         BASE_TIME = TIME()
         BASE_ST = &amp;STEXEC
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE NEW CGI OBJECT</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NOTE THAT THIS IS IN AN ACCEPT LOOP IF FCGI IS IN USE. DATABASE</i></font>
<font color="#818181"><i>* ACCESS CAN BE HOISTED OUTSIDE THIS LOOP AS WELL, IN THAT CASE.</i></font>
<font color="#818181"><i>*</i></font>
         CGI = SEND(CGI_CLASS, &#39;NEW&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GET LOGGING CHANNEL</i></font>
<font color="#818181"><i>*</i></font>
         LOG = SEND(CGI, &#39;GET_LOG&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOG ENTRY</i></font>
<font color="#818181"><i>*</i></font>
         $LOG = &#39;CGI ENTERED&#39;
         $LOG = &#39;CURRENT DIRECTORY IS &#39; BQ(&#39;pwd&#39;)
         $LOG = DIFFER(USE_FCGI) &#39;FAST CGI&#39;
         $LOG = IDENT(USE_FCGI) &#39;CGI&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GET THE COOKIE JAR</i></font>
<font color="#818181"><i>*</i></font>
         JAR = SEND(CGI, &#39;GET_COOKIE_JAR&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOAD THE SESSION. SESSION ID IS TAKEN FROM COOKIE &#39;SESSION&#39;. AFTER</i></font>
<font color="#818181"><i>* USING THE SESSION COOKIE, DESTROY IT (IT WILL GET RECREATED IF</i></font>
<font color="#818181"><i>* NEEDED WHEN THE SESSION IS PERSISTED).</i></font>
<font color="#818181"><i>*</i></font>
         SESSION =
         C = GET_COOKIE_FROM_JAR(JAR, &#39;SESSION&#39;)
         PUT_COOKIE_IN_JAR(JAR, &#39;SESSION&#39;, )
         SESSION = SESSION_LOAD(COOKIE_VALUE(VDIFFER(C)))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE SESSION IF IT DOESN&#39;T EXIST.</i></font>
<font color="#818181"><i>*</i></font>
         SESSION = IDENT(SESSION) SESSION_CREATE(600)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE A PSQL OBJECT. OPEN THE DATABASE, AND GET THE PIPE HANDLE.</i></font>
<font color="#818181"><i>* WE WILL LEAVE THE DATABASE OBJECT AROUND, FOR EFFICIENCY WITH</i></font>
<font color="#818181"><i>* FCGI.</i></font>
<font color="#818181"><i>*</i></font>
         DIFFER(PSQL)                                      <b>:S(PSQL_CONN)</b>
         PSQL = SEND(PSQL_CLASS, &#39;NEW&#39;)
         &amp;ERRLIMIT = 1
         SEND(PSQL, &#39;OPEN&#39;)
         &amp;ERRLIMIT = 0
         DB = SEND(PSQL, &#39;GET_PIPE&#39;)
PSQL_CONN
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SET HEADER</i></font>
<font color="#818181"><i>*</i></font>
         H = SEND(CGI, &#39;GET_HEADER&#39;)
         H&lt;&#39;CONTENT_TYPE&#39;&gt; = &#39;text/html&#39;
         H&lt;&#39;CHARSET&#39;&gt; = &#39;UTF-8&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETRIEVE THE COUNTER COOKIE. IF IT DOESN&#39;T EXIST, CREATE IT.</i></font>
<font color="#818181"><i>*</i></font>
         C = GET_COOKIE_FROM_JAR(JAR, &#39;COUNTER&#39;)
         IDENT(C) PUT_COOKIE_IN_JAR(JAR, &#39;COUNTER&#39;, NEW_COOKIE(0))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE ANOTHER COOKIE &#39;TESTER&#39; WITH VALUE &#39;SNOBOL4&#39;</i></font>
<font color="#818181"><i>*</i></font>
         PUT_COOKIE_IN_JAR(JAR, &#39;TESTER&#39;, NEW_COOKIE(&#39;SNOBOL4&#39;))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INCREMENT THE VALUE OF THE COUNTER COOKIE. WE VALIDATE THAT THE</i></font>
<font color="#818181"><i>* VALUE OF COUNTER IS AN INTEGER.</i></font>
<font color="#818181"><i>*</i></font>
         C = GET_COOKIE_FROM_JAR(JAR, &#39;COUNTER&#39;)
         V = COOKIE_VALUE(C)
         V = ~INTEGER(V) 0
         COOKIE_SET_VALUE(C,  V + 1)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A SESSION VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
         SESSION&lt;&#39;NAME&#39;&gt; = &#39;FRED&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INCREMENT THE COUNTER SESSION VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
         V = SESSION&lt;&#39;COUNTER&#39;&gt;
         V = ~INTEGER(V) 0
         SESSION&lt;&#39;COUNTER&#39;&gt; = V + 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PERSIST THE SESSION. THIS SAVES THE SESSION TO DISK AND CREATES</i></font>
<font color="#818181"><i>* THE BROWSER COOKIE TO ALLOW THE RETRIEVAL OF THE SESSION LATER.</i></font>
<font color="#818181"><i>*</i></font>
         SESSION_PERSIST(SESSION)                            <b>:F(FRETURN)</b>
         T = SESSION&lt;&#39;EXPIRE_TIME&#39;&gt;
         C = NEW_COOKIE(SESSION&lt;&#39;UUID&#39;&gt;)
         PUT_COOKIE_IN_JAR(JAR, &#39;SESSION&#39;, C)
         COOKIE_SET_CRUMB(C, &#39;EXPIRES&#39;, COOKIE_EXPIRY(T))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READ AND COMPILE THE HTML TEMPLATE. WE CACHE THIS FOR FCGI.</i></font>
<font color="#818181"><i>*</i></font>
         DIFFER(P_TM)                                         <b>:S(NO_T_C)</b>
         S_TM = READFILE(&#39;CGI.tmpl&#39;)
         P_TM = TMPL_COMPILE(S_TM)
NO_T_C
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BUILD TABLE OF VARIABLES TO SUBSTITUTE INTO THE TEMPLATE</i></font>
<font color="#818181"><i>* THIS HAS THE RAW COOKIE STRING, THE VALUE OF COUNTER FROM THE</i></font>
<font color="#818181"><i>* COOKIE JAR AND THE VALUE OF COUNTER FROM THE SESSION.</i></font>
<font color="#818181"><i>*</i></font>
         A = TABLE()
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FROM THE ENV</i></font>
<font color="#818181"><i>*</i></font>
         E = SEND(CGI, &#39;GET_ENV&#39;)
         A&lt;&#39;REQUEST_METHOD&#39;&gt; = E&lt;&#39;REQUEST_METHOD&#39;&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REQUEST URI http://localhost/cgi-bin/cgi.fcgi/x/y?...</i></font>
<font color="#818181"><i>* ON GET, APPENDS &#39;/&#39; ACTION TO THE END BEFORE THE ? PART.</i></font>
<font color="#818181"><i>*</i></font>
         A&lt;&#39;REQUEST_URI&#39;&gt; = E&lt;&#39;REQUEST_URI&#39;&gt;
         A&lt;&#39;PATH_INFO&#39;&gt; = E&lt;&#39;PATH_INFO&#39;&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TAKE REQUEST_METHOD, PATH_INFO AND MATCH AGAINST ROUTING PATTERN</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* V = TABLE()</i></font>
<font color="#818181"><i>* R = ROUTING_INIT()</i></font>
<font color="#818181"><i>* M = ROUTING(METHOD, PATH, .V)</i></font>
<font color="#818181"><i>* A = ACTION</i></font>
<font color="#818181"><i>* R = ROUTING_ADD(R, M, A)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* (METHOD &#39;\&#39; PATH_INFO) R</i></font>
<font color="#818181"><i>* IF SUCCESS, ACTION IS SET, V&lt;&gt; IS FILLED IN</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FROM THE COOKIE JAR</i></font>
<font color="#818181"><i>*</i></font>
         A&lt;&#39;COOKIE_COUNTER&#39;&gt; =
+           COOKIE_VALUE(GET_COOKIE_FROM_JAR(JAR, &#39;COUNTER&#39;))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SESSION VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
         A&lt;&#39;SESSION_COUNTER&#39;&gt; =  SESSION&lt;&#39;COUNTER&#39;&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* QUERY VARIABLES</i></font>
<font color="#818181"><i>*</i></font>
         Q = SEND(CGI, &#39;GET_QUERY&#39;)
         A&lt;&#39;FIRST_NAME&#39;&gt; = Q&lt;&#39;firstname&#39;&gt;
         A&lt;&#39;VEHICLE&#39;&gt; = Q&lt;&#39;vehicle&#39;&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INTERPRET THE TEMPLATE WITH THE SUPPLIED VARIABLES</i></font>
<font color="#818181"><i>*</i></font>
         S = TMPL_INTERPRET(P_TM, A)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TRANSMIT THE EXPANDED PAGE TO THE CLIENT</i></font>
<font color="#818181"><i>*</i></font>
         SEND(CGI, &#39;SET_CONTENT&#39;, S)
<font color="#818181"><i>*</i></font>
         SEND(CGI, &#39;SEND&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CLOSE THE DATABASE</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*        SEND(PSQL, &#39;CLOSE&#39;)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOG COMPLETION AND SHOW PERFORMANCE DATA</i></font>
<font color="#818181"><i>*</i></font>
         $LOG = &#39;CGI COMPLETE&#39;
         $LOG = TIME() - BASE_TIME &#39; MILLISECONDS FOR REQUEST&#39;
         $LOG = &amp;GCTIME  &#39; IN GARBAGE COLLECTOR (TOTAL)&#39;
         $LOG = &amp;STEXEC - BASE_ST &#39; STATEMENTS EXECUTED&#39;
<font color="#818181"><i>*</i></font>
         SEND(CGI, &#39;CLOSE&#39;)
         &amp;CODE = 0
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF USING FCGI, LOOP BACK TO THE ACCEPT() CALL RATHER THAN EXIT THE</i></font>
<font color="#818181"><i>* PROCESS.</i></font>
<font color="#818181"><i>*</i></font>
         DIFFER(USE_FCGI)                                    <b>:S(CGI_TOP)</b>
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL CGI
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                         #####    #####   ###                         *</i></font>
<font color="#818181"><i>*                        #     #  #     #   #                          *</i></font>
<font color="#818181"><i>*                        #        #         #                          *</i></font>
<font color="#818181"><i>*                        #        #  ####   #                          *</i></font>
<font color="#818181"><i>*                        #        #     #   #                          *</i></font>
<font color="#818181"><i>*                        #     #  #     #   #                          *</i></font>
<font color="#818181"><i>*                         #####    #####   ###                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CGI                    CGI SUPPORT FUNCTIONS                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CGI.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CGI&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:40 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         export "SNOLIB=/home/fred/snolib"; export "SNOPATH=/home/fred/snolib"; export "LD_LIBRARY_PATH=/home/fred/snolib"
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-LINE 289 "CGI.lss"
-INCLUDE 'FCGI.INC'
-INCLUDE 'CGI.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'HTMLTMPL.INC'
-INCLUDE 'SESSION.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'DSERVE.INC'
-INCLUDE 'ROUTING.INC'
*
         CGI.tmpl = 'CGI.tmpl'
         &CODE = 1
*
* A CGI APPLICATION IS EITHER A SINGLE-RUN CGI SCRIPT, OR AN FCGI
* (FAST CGI) APPLICATION. AN FCGI APPLICATION WAITS WITH ACCEPT(),
* GATHERS DATA USING PACKETS, AND THEN EXECUTES THE CGI PART. RESPONSES
* ARE SENT WITH PACKETS. THIS IS HANDLED IN THE CGI CLASS, SO AS NOT
* TO REQUIRE WEB APPLICATION CHANGES. FCGI_ACCEPT() WILL HANDLE EITHER
* CGI OR FCGI APPLICATIONS, BUT, IF IT IS KNOWN THAT FCGI WON'T BE
* DEPLOYED, IT CAN BE OMMITED IN THAT CASE.
*
CGI_TOP  FCGI_ACCEPT()
         DSERVE()
*
         BASE_TIME = TIME()
         BASE_ST = &STEXEC
*
* CREATE NEW CGI OBJECT
*
* NOTE THAT THIS IS IN AN ACCEPT LOOP IF FCGI IS IN USE. DATABASE
* ACCESS CAN BE HOISTED OUTSIDE THIS LOOP AS WELL, IN THAT CASE.
*
         CGI = SEND(CGI_CLASS, 'NEW')
*
* GET LOGGING CHANNEL
*
         LOG = SEND(CGI, 'GET_LOG')
*
* LOG ENTRY
*
         $LOG = 'CGI ENTERED'
         $LOG = 'CURRENT DIRECTORY IS ' BQ('pwd')
         $LOG = DIFFER(USE_FCGI) 'FAST CGI'
         $LOG = IDENT(USE_FCGI) 'CGI'
*
* GET THE COOKIE JAR
*
         JAR = SEND(CGI, 'GET_COOKIE_JAR')
*
* LOAD THE SESSION. SESSION ID IS TAKEN FROM COOKIE 'SESSION'. AFTER
* USING THE SESSION COOKIE, DESTROY IT (IT WILL GET RECREATED IF
* NEEDED WHEN THE SESSION IS PERSISTED).
*
         SESSION =
         C = GET_COOKIE_FROM_JAR(JAR, 'SESSION')
         PUT_COOKIE_IN_JAR(JAR, 'SESSION', )
         SESSION = SESSION_LOAD(COOKIE_VALUE(VDIFFER(C)))
*
* CREATE SESSION IF IT DOESN'T EXIST.
*
         SESSION = IDENT(SESSION) SESSION_CREATE(600)
*
* CREATE A PSQL OBJECT. OPEN THE DATABASE, AND GET THE PIPE HANDLE.
* WE WILL LEAVE THE DATABASE OBJECT AROUND, FOR EFFICIENCY WITH
* FCGI.
*
         DIFFER(PSQL)                                      :S(PSQL_CONN)
         PSQL = SEND(PSQL_CLASS, 'NEW')
         &ERRLIMIT = 1
         SEND(PSQL, 'OPEN')
         &ERRLIMIT = 0
         DB = SEND(PSQL, 'GET_PIPE')
PSQL_CONN
*
* SET HEADER
*
         H = SEND(CGI, 'GET_HEADER')
         H<'CONTENT_TYPE'> = 'text/html'
         H<'CHARSET'> = 'UTF-8'
*
* RETRIEVE THE COUNTER COOKIE. IF IT DOESN'T EXIST, CREATE IT.
*
         C = GET_COOKIE_FROM_JAR(JAR, 'COUNTER')
         IDENT(C) PUT_COOKIE_IN_JAR(JAR, 'COUNTER', NEW_COOKIE(0))
*
* CREATE ANOTHER COOKIE 'TESTER' WITH VALUE 'SNOBOL4'
*
         PUT_COOKIE_IN_JAR(JAR, 'TESTER', NEW_COOKIE('SNOBOL4'))
*
* INCREMENT THE VALUE OF THE COUNTER COOKIE. WE VALIDATE THAT THE
* VALUE OF COUNTER IS AN INTEGER.
*
         C = GET_COOKIE_FROM_JAR(JAR, 'COUNTER')
         V = COOKIE_VALUE(C)
         V = ~INTEGER(V) 0
         COOKIE_SET_VALUE(C,  V + 1)
*
* A SESSION VARIABLE
*
         SESSION<'NAME'> = 'FRED'
*
* INCREMENT THE COUNTER SESSION VARIABLE
*
         V = SESSION<'COUNTER'>
         V = ~INTEGER(V) 0
         SESSION<'COUNTER'> = V + 1
*
* PERSIST THE SESSION. THIS SAVES THE SESSION TO DISK AND CREATES
* THE BROWSER COOKIE TO ALLOW THE RETRIEVAL OF THE SESSION LATER.
*
         SESSION_PERSIST(SESSION)                            :F(FRETURN)
         T = SESSION<'EXPIRE_TIME'>
         C = NEW_COOKIE(SESSION<'UUID'>)
         PUT_COOKIE_IN_JAR(JAR, 'SESSION', C)
         COOKIE_SET_CRUMB(C, 'EXPIRES', COOKIE_EXPIRY(T))
*
* READ AND COMPILE THE HTML TEMPLATE. WE CACHE THIS FOR FCGI.
*
         DIFFER(P_TM)                                         :S(NO_T_C)
         S_TM = READFILE('CGI.tmpl')
         P_TM = TMPL_COMPILE(S_TM)
NO_T_C
*
* BUILD TABLE OF VARIABLES TO SUBSTITUTE INTO THE TEMPLATE
* THIS HAS THE RAW COOKIE STRING, THE VALUE OF COUNTER FROM THE
* COOKIE JAR AND THE VALUE OF COUNTER FROM THE SESSION.
*
         A = TABLE()
*
* FROM THE ENV
*
         E = SEND(CGI, 'GET_ENV')
         A<'REQUEST_METHOD'> = E<'REQUEST_METHOD'>
*
* REQUEST URI http://localhost/cgi-bin/cgi.fcgi/x/y?...
* ON GET, APPENDS '/' ACTION TO THE END BEFORE THE ? PART.
*
         A<'REQUEST_URI'> = E<'REQUEST_URI'>
         A<'PATH_INFO'> = E<'PATH_INFO'>
*
* TAKE REQUEST_METHOD, PATH_INFO AND MATCH AGAINST ROUTING PATTERN
*
* V = TABLE()
* R = ROUTING_INIT()
* M = ROUTING(METHOD, PATH, .V)
* A = ACTION
* R = ROUTING_ADD(R, M, A)
*
* (METHOD '\' PATH_INFO) R
* IF SUCCESS, ACTION IS SET, V<> IS FILLED IN
*
* FROM THE COOKIE JAR
*
         A<'COOKIE_COUNTER'> =
+           COOKIE_VALUE(GET_COOKIE_FROM_JAR(JAR, 'COUNTER'))
*
* SESSION VARIABLE
*
         A<'SESSION_COUNTER'> =  SESSION<'COUNTER'>
*
* QUERY VARIABLES
*
         Q = SEND(CGI, 'GET_QUERY')
         A<'FIRST_NAME'> = Q<'firstname'>
         A<'VEHICLE'> = Q<'vehicle'>
*
* INTERPRET THE TEMPLATE WITH THE SUPPLIED VARIABLES
*
         S = TMPL_INTERPRET(P_TM, A)
*
* TRANSMIT THE EXPANDED PAGE TO THE CLIENT
*
         SEND(CGI, 'SET_CONTENT', S)
*
         SEND(CGI, 'SEND')
*
* CLOSE THE DATABASE
*
*        SEND(PSQL, 'CLOSE')
*
* LOG COMPLETION AND SHOW PERFORMANCE DATA
*
         $LOG = 'CGI COMPLETE'
         $LOG = TIME() - BASE_TIME ' MILLISECONDS FOR REQUEST'
         $LOG = &GCTIME  ' IN GARBAGE COLLECTOR (TOTAL)'
         $LOG = &STEXEC - BASE_ST ' STATEMENTS EXECUTED'
*
         SEND(CGI, 'CLOSE')
         &CODE = 0
*
* IF USING FCGI, LOOP BACK TO THE ACCEPT() CALL RATHER THAN EXIT THE
* PROCESS.
*
         DIFFER(USE_FCGI)                                    :S(CGI_TOP)
END
<h1>CHARS - Symbolic names for some characters</h1>

Define symbolic names for (normally) unprintable characters. Useful for
defining whitespace, etc.

<h2>Uses</h2>

<h2>See Also</h2>
<a href="UTF8.html">UTF8</a>

<<INCLUDES>>=
@

<<CHARS>>=
-MODULE CHARS
-PUBLIC CHARS_NUL, CHARS_SOH, CHARS_STX, CHARS_ETX, CHARS_EOT, CHARS_ENQ
-PUBLIC CHARS_ACK, CHARS_BEL, CHARS_HT, CHARS_BS, CHARS_NL, CHARS_VT
-PUBLIC CHARS_NP, CHARS_CR, CHARS_SO, CHARS_SI, CHARS_DLE, CHARS_DC1
-PUBLIC CHARS_DC2, CHARS_DC3, CHARS_DC4, CHARS_NAK, CHARS_SYN, CHARS_ETB
-PUBLIC CHARS_CAN, CHARS_EM, CHARS_SUB, CHARS_ESC, CHARS_FS, CHARS_GS
-PUBLIC CHARS_RS, CHARS_US, CHARS_SP, CHARS_DEL, CHARS_TAB, CHARS_SPACE
-PUBLIC CHARS_FF, CHARS_LF, CHARS_CONTROL, CHARS_PRINTABLE, CHARS_HIGH
*
CHARS    CHARS_NUL = CHAR( 0)
         CHARS_SOH = CHAR( 1)
         CHARS_STX = CHAR( 2)
         CHARS_ETX = CHAR( 3)
         CHARS_EOT = CHAR( 4)
         CHARS_ENQ = CHAR( 5)
         CHARS_ACK = CHAR( 6)
         CHARS_BEL = CHAR( 7)
         CHARS_BS  = CHAR( 8)
         CHARS_HT  = CHAR( 9)
         CHARS_NL  = CHAR(10)
         CHARS_VT  = CHAR(11)
         CHARS_NP  = CHAR(12)
         CHARS_CR  = CHAR(13)
         CHARS_SO  = CHAR(14)
         CHARS_SI  = CHAR(15)
         CHARS_DLE = CHAR(16)
         CHARS_DC1 = CHAR(17)
         CHARS_DC2 = CHAR(18)
         CHARS_DC3 = CHAR(19)
         CHARS_DC4 = CHAR(20)
         CHARS_NAK = CHAR(21)
         CHARS_SYN = CHAR(22)
         CHARS_ETB = CHAR(23)
         CHARS_CAN = CHAR(24)
         CHARS_EM  = CHAR(25)
         CHARS_SUB = CHAR(26)
         CHARS_ESC = CHAR(27)
         CHARS_FS  = CHAR(28)
         CHARS_GS  = CHAR(29)
         CHARS_RS  = CHAR(30)
         CHARS_US  = CHAR(31)
         CHARS_SP  = CHAR(32)
         CHARS_DEL = CHAR(127)
@

Don't define [[CHARS_CR]] as [[CHARS_NL]], even on a Unix style
OS. [[CR]] and [[NL]] have distinctly different meanings in some
circumstances (for example, on a printer).

CHARS_PRINTABLE is set to the printable characters (' '..'~'). UTF-8
is not included (single byte only). CHARS_CONTROL are the control
characters, and CHARS_HIGH are 129..255.

<<CHARS>>=
*
         CHARS_TAB   = CHARS_HT
         CHARS_SPACE = CHARS_SP
         CHARS_FF    = CHARS_NP
         CHARS_LF    = CHARS_NL
@

Break up &ALPHABET into three classes: control, printable and high.

<<CHARS>>=
*
         &ALPHABET LEN(32) .  CHARS_CONTROL
+                  LEN(95) .  CHARS_PRINTABLE
+                  LEN(129) . CHARS_HIGH
*
         CODE('CHARS')
*
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CHARS.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL CHARS
-EJECT
*
************************************************************************
*                                                                      *
*              #####   #     #     #     ######    #####               *
*             #     #  #     #    # #    #     #  #     #              *
*             #        #     #   #   #   #     #  #                    *
*             #        #######  #     #  ######    #####               *
*             #        #     #  #######  #   #          #              *
*             #     #  #     #  #     #  #    #   #     #              *
*              #####   #     #  #     #  #     #   #####               *
*                                                                      *
* CHARS             SYMBOLIC NAMES FOR CHARACTERS                      *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* DECEMBER 2001                                                        *
*                                                                      *
************************************************************************
*
* CHARS.lss
*
<<CHARS>>
*
* CE: .MSNOBOL4;
@
-STITL CHARS
-EJECT
*
-LINE 101 "CHARS.lss"
************************************************************************
*                                                                      *
*              #####   #     #     #     ######    #####               *
*             #     #  #     #    # #    #     #  #     #              *
*             #        #     #   #   #   #     #  #                    *
*             #        #######  #     #  ######    #####               *
*             #        #     #  #######  #   #          #              *
*             #     #  #     #  #     #  #    #   #     #              *
*              #####   #     #  #     #  #     #   #####               *
*                                                                      *
* CHARS             SYMBOLIC NAMES FOR CHARACTERS                      *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* DECEMBER 2001                                                        *
*                                                                      *
************************************************************************
*
* CHARS.lss
*
-LINE 15 "CHARS.lss"
-MODULE CHARS
-PUBLIC CHARS_NUL, CHARS_SOH, CHARS_STX, CHARS_ETX, CHARS_EOT, CHARS_ENQ
-PUBLIC CHARS_ACK, CHARS_BEL, CHARS_HT, CHARS_BS, CHARS_NL, CHARS_VT
-PUBLIC CHARS_NP, CHARS_CR, CHARS_SO, CHARS_SI, CHARS_DLE, CHARS_DC1
-PUBLIC CHARS_DC2, CHARS_DC3, CHARS_DC4, CHARS_NAK, CHARS_SYN, CHARS_ETB
-PUBLIC CHARS_CAN, CHARS_EM, CHARS_SUB, CHARS_ESC, CHARS_FS, CHARS_GS
-PUBLIC CHARS_RS, CHARS_US, CHARS_SP, CHARS_DEL, CHARS_TAB, CHARS_SPACE
-PUBLIC CHARS_FF, CHARS_LF, CHARS_CONTROL, CHARS_PRINTABLE, CHARS_HIGH
*
CHARS    CHARS_NUL = CHAR( 0)
         CHARS_SOH = CHAR( 1)
         CHARS_STX = CHAR( 2)
         CHARS_ETX = CHAR( 3)
         CHARS_EOT = CHAR( 4)
         CHARS_ENQ = CHAR( 5)
         CHARS_ACK = CHAR( 6)
         CHARS_BEL = CHAR( 7)
         CHARS_BS  = CHAR( 8)
         CHARS_HT  = CHAR( 9)
         CHARS_NL  = CHAR(10)
         CHARS_VT  = CHAR(11)
         CHARS_NP  = CHAR(12)
         CHARS_CR  = CHAR(13)
         CHARS_SO  = CHAR(14)
         CHARS_SI  = CHAR(15)
         CHARS_DLE = CHAR(16)
         CHARS_DC1 = CHAR(17)
         CHARS_DC2 = CHAR(18)
         CHARS_DC3 = CHAR(19)
         CHARS_DC4 = CHAR(20)
         CHARS_NAK = CHAR(21)
         CHARS_SYN = CHAR(22)
         CHARS_ETB = CHAR(23)
         CHARS_CAN = CHAR(24)
         CHARS_EM  = CHAR(25)
         CHARS_SUB = CHAR(26)
         CHARS_ESC = CHAR(27)
         CHARS_FS  = CHAR(28)
         CHARS_GS  = CHAR(29)
         CHARS_RS  = CHAR(30)
         CHARS_US  = CHAR(31)
         CHARS_SP  = CHAR(32)
         CHARS_DEL = CHAR(127)
-LINE 69 "CHARS.lss"
*
         CHARS_TAB   = CHARS_HT
         CHARS_SPACE = CHARS_SP
         CHARS_FF    = CHARS_NP
         CHARS_LF    = CHARS_NL
-LINE 79 "CHARS.lss"
*
         &ALPHABET LEN(32) .  CHARS_CONTROL
+                  LEN(95) .  CHARS_PRINTABLE
+                  LEN(129) . CHARS_HIGH
*
         CODE('CHARS')
*
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CHARS - Symbolic names for some characters</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Define symbolic names for (normally) unprintable characters. Useful for
defining whitespace, etc.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="UTF8.html">UTF8</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CHARS&raquo;&equiv;</b>
-MODULE CHARS
-PUBLIC CHARS_NUL, CHARS_SOH, CHARS_STX, CHARS_ETX, CHARS_EOT, CHARS_ENQ
-PUBLIC CHARS_ACK, CHARS_BEL, CHARS_HT, CHARS_BS, CHARS_NL, CHARS_VT
-PUBLIC CHARS_NP, CHARS_CR, CHARS_SO, CHARS_SI, CHARS_DLE, CHARS_DC1
-PUBLIC CHARS_DC2, CHARS_DC3, CHARS_DC4, CHARS_NAK, CHARS_SYN, CHARS_ETB
-PUBLIC CHARS_CAN, CHARS_EM, CHARS_SUB, CHARS_ESC, CHARS_FS, CHARS_GS
-PUBLIC CHARS_RS, CHARS_US, CHARS_SP, CHARS_DEL, CHARS_TAB, CHARS_SPACE
-PUBLIC CHARS_FF, CHARS_LF, CHARS_CONTROL, CHARS_PRINTABLE, CHARS_HIGH
<font color="#818181"><i>*</i></font>
CHARS    CHARS_NUL = CHAR( 0)
         CHARS_SOH = CHAR( 1)
         CHARS_STX = CHAR( 2)
         CHARS_ETX = CHAR( 3)
         CHARS_EOT = CHAR( 4)
         CHARS_ENQ = CHAR( 5)
         CHARS_ACK = CHAR( 6)
         CHARS_BEL = CHAR( 7)
         CHARS_BS  = CHAR( 8)
         CHARS_HT  = CHAR( 9)
         CHARS_NL  = CHAR(10)
         CHARS_VT  = CHAR(11)
         CHARS_NP  = CHAR(12)
         CHARS_CR  = CHAR(13)
         CHARS_SO  = CHAR(14)
         CHARS_SI  = CHAR(15)
         CHARS_DLE = CHAR(16)
         CHARS_DC1 = CHAR(17)
         CHARS_DC2 = CHAR(18)
         CHARS_DC3 = CHAR(19)
         CHARS_DC4 = CHAR(20)
         CHARS_NAK = CHAR(21)
         CHARS_SYN = CHAR(22)
         CHARS_ETB = CHAR(23)
         CHARS_CAN = CHAR(24)
         CHARS_EM  = CHAR(25)
         CHARS_SUB = CHAR(26)
         CHARS_ESC = CHAR(27)
         CHARS_FS  = CHAR(28)
         CHARS_GS  = CHAR(29)
         CHARS_RS  = CHAR(30)
         CHARS_US  = CHAR(31)
         CHARS_SP  = CHAR(32)
         CHARS_DEL = CHAR(127)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Don't define <font face="Source Code Pro">CHARS_CR</font> as <font face="Source Code Pro">CHARS_NL</font>, even on a Unix style
OS. <font face="Source Code Pro">CR</font> and <font face="Source Code Pro">NL</font> have distinctly different meanings in some
circumstances (for example, on a printer).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
CHARS_PRINTABLE is set to the printable characters (' '..'~'). UTF-8
is not included (single byte only). CHARS_CONTROL are the control
characters, and CHARS_HIGH are 129..255.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CHARS&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
         CHARS_TAB   = CHARS_HT
         CHARS_SPACE = CHARS_SP
         CHARS_FF    = CHARS_NP
         CHARS_LF    = CHARS_NL
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Break up &ALPHABET into three classes: control, printable and high.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CHARS&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
         &amp;ALPHABET LEN(32) .  CHARS_CONTROL
+                  LEN(95) .  CHARS_PRINTABLE
+                  LEN(129) . CHARS_HIGH
<font color="#818181"><i>*</i></font>
         CODE(&#39;CHARS&#39;)
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CHARS.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL CHARS
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*              #####   #     #     #     ######    #####               *</i></font>
<font color="#818181"><i>*             #     #  #     #    # #    #     #  #     #              *</i></font>
<font color="#818181"><i>*             #        #     #   #   #   #     #  #                    *</i></font>
<font color="#818181"><i>*             #        #######  #     #  ######    #####               *</i></font>
<font color="#818181"><i>*             #        #     #  #######  #   #          #              *</i></font>
<font color="#818181"><i>*             #     #  #     #  #     #  #    #   #     #              *</i></font>
<font color="#818181"><i>*              #####   #     #  #     #  #     #   #####               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CHARS             SYMBOLIC NAMES FOR CHARACTERS                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                       *</i></font>
<font color="#818181"><i>* DECEMBER 2001                                                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CHARS.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CHARS&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:49 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CHARS.INC'
-LINE 92 "CHARS.lss"
         &CODE = 1
         &CODE = 0
END
<h1>CH - Hex to String</h1>

CH(H) will convert the sequence of hexadecimal digits into the
corresponding character string. [[CH]] is the inverse of [[HEX]].

<h2>Uses</h2>
<a href="HEX.html">HEX</a><br>

<<INCLUDES>>=
-INCLUDE 'HEX.INC'
@

<<CH>>=
-MODULE CH
-PUBLIC CH()
         DEFINE('CH(H)C,P')
*
         CH_H_ = ' ' HEX(&ALPHABET)
CH_2     CH_H_ ' ' LEN(2) . C1
+          (ANY('0123456789ABCDEF') LEN(1)) . C2 = ' ' C1 ' ' C2
+                                                      :S(CH_2)F(CH_END)
*
CH       H = REPLACE(H, &LCASE, &UCASE)
CH_3     H LEN(2) . C =                                       :F(RETURN)
         CH_H_ ' ' C @P                                      :F(FRETURN)
         P = (P - 1) / 3
         &ALPHABET LEN(P) LEN(1) . C
         CH = CH C                                               :(CH_3)
*
CH_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CH.INC'
         &CODE = 1
         IDENT(CH('414243'), 'ABC')                              :F(END)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL CH
-EJECT
*
************************************************************************
*                                                                      *
*                            #####   #     #                           *
*                           #     #  #     #                           *
*                           #        #     #                           *
*                           #        #######                           *
*                           #        #     #                           *
*                           #     #  #     #                           *
*                            #####   #     #                           *
*                                                                      *
* CH                         HEX TO STRING                             *
*                                                                      *
************************************************************************
*
* CH.lss
*
<<CH>>
*
* CE: .MSNOBOL4;
@
-LINE 10 "CH.lss"
-INCLUDE 'HEX.INC'
-STITL CH
-EJECT
-LINE 47 "CH.lss"
*
************************************************************************
*                                                                      *
*                            #####   #     #                           *
*                           #     #  #     #                           *
*                           #        #     #                           *
*                           #        #######                           *
*                           #        #     #                           *
*                           #     #  #     #                           *
*                            #####   #     #                           *
*                                                                      *
* CH                         HEX TO STRING                             *
*                                                                      *
************************************************************************
*
* CH.lss
*
-LINE 14 "CH.lss"
-MODULE CH
-PUBLIC CH()
         DEFINE('CH(H)C,P')
*
         CH_H_ = ' ' HEX(&ALPHABET)
CH_2     CH_H_ ' ' LEN(2) . C1
+          (ANY('0123456789ABCDEF') LEN(1)) . C2 = ' ' C1 ' ' C2
+                                                      :S(CH_2)F(CH_END)
*
CH       H = REPLACE(H, &LCASE, &UCASE)
CH_3     H LEN(2) . C =                                       :F(RETURN)
         CH_H_ ' ' C @P                                      :F(FRETURN)
         P = (P - 1) / 3
         &ALPHABET LEN(P) LEN(1) . C
         CH = CH C                                               :(CH_3)
*
CH_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CH - Hex to String</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
CH(H) will convert the sequence of hexadecimal digits into the
corresponding character string. <font face="Source Code Pro">CH</font> is the inverse of <font face="Source Code Pro">HEX</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="HEX.html">HEX</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;HEX.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CH&raquo;&equiv;</b>
-MODULE CH
-PUBLIC CH()
         DEFINE(&#39;CH(H)C,P&#39;)
<font color="#818181"><i>*</i></font>
         CH_H_ = &#39; &#39; HEX(&amp;ALPHABET)
CH_2     CH_H_ &#39; &#39; LEN(2) . C1
+          (ANY(&#39;0123456789ABCDEF&#39;) LEN(1)) . C2 = &#39; &#39; C1 &#39; &#39; C2
+                                                      <b>:S(CH_2)F(CH_END)</b>
<font color="#818181"><i>*</i></font>
CH       H = REPLACE(H, &amp;LCASE, &amp;UCASE)
CH_3     H LEN(2) . C =                                       <b>:F(RETURN)</b>
         CH_H_ &#39; &#39; C @P                                      <b>:F(FRETURN)</b>
         P = (P - 1) / 3
         &amp;ALPHABET LEN(P) LEN(1) . C
         CH = CH C                                               <b>:(CH_3)</b>
<font color="#818181"><i>*</i></font>
CH_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CH.INC&#39;
         &amp;CODE = 1
         IDENT(CH(&#39;414243&#39;), &#39;ABC&#39;)                              <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL CH
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                            #####   #     #                           *</i></font>
<font color="#818181"><i>*                           #     #  #     #                           *</i></font>
<font color="#818181"><i>*                           #        #     #                           *</i></font>
<font color="#818181"><i>*                           #        #######                           *</i></font>
<font color="#818181"><i>*                           #        #     #                           *</i></font>
<font color="#818181"><i>*                           #     #  #     #                           *</i></font>
<font color="#818181"><i>*                            #####   #     #                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CH                         HEX TO STRING                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CH.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CH&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:49 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CH.INC'
-LINE 37 "CH.lss"
         &CODE = 1
         IDENT(CH('414243'), 'ABC')                              :F(END)
         &CODE = 0
END
<h1>code</h1>

Enter SNOBOL4 statements for immediate execution. Also supports a
primitive programming environment with line numbered statements.

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HOST.html">HOST</a><br>
<a href="READLINE.html">READLINE</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="SLOAD.html">SLOAD</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SLOAD.INC'
-INCLUDE 'VDIFFER.INC'
@

<<code>>=
<<signon>>
<<manifest>>
<<readline>>
<<patterns>>
<<functions>>
<<main>>
<<parse>>
<<commands>>
<<error function>>
<<exit trap>>
<<exit>>
@

Patterns used to parse commands.

<<patterns>>=
         QQ_ = '"'
         Q_  = "'"
         WHITE_SPACE_ = CHARS_HT ' '
         OWS_         = SPAN(WHITE_SPACE_) | ''
         SF_PAT_      = FENCE ANY('SsFfEe')
+                       (ANY(WHITE_SPACE_) | RPOS(0))
         CMNT_PAT_    = FENCE ANY('*;|#!-')
         INPAT_       = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                                  (ANY('Cc') ('OPY' | 'opy')))
+                       BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
*
         RETNPAT_  = FENCE (SPAN(&DIGITS) . LN_)
+                    ((ANY(WHITE_SPACE_) REM . CODE) | '') RPOS(0)
         SAVEPAT_  = FENCE ANY('Ss') ('AVE' | 'ave')
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN_ LEN(1))
+                     | '')
+                    RPOS(0)
         LOADPAT_  = FENCE ANY('Ll') ('OAD' | 'oad')
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN_ LEN(1))
+                     | '')
+                    RPOS(0)
         NAMEPAT_  = FENCE ANY('Nn') ('AME' | 'ame')
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN2_ LEN(1))
+                     | '')
+                    RPOS(0)
         LISTPAT_  = FENCE ANY('Ll') ('IST' | 'ist')
+                    ((ANY(WHITE_SPACE_)
+                       ((OWS_ SPAN(&DIGITS) . N1_) | '')
+                       ((OWS_ ',' OWS_ SPAN(&DIGITS) . N2_) | '')
+                    ) | '') RPOS(0)
         RUNPAT_   = FENCE ANY('Rr') ('UN' | 'un')
+                    (ANY(WHITE_SPACE_) SPAN(&DIGITS) . LN_ | '')
+                    RPOS(0)
         EDITPAT_  = FENCE ANY('Ee') ('DIT' | 'dit')
+                    (ANY(WHITE_SPACE_) SPAN(&DIGITS) . LN_ | '')
+                    RPOS(0)
         RENUMPAT_ = FENCE ANY('Rr') ('ENUM' | 'enum')
+                    (ANY(WHITE_SPACE_) SPAN(&DIGITS) . LN_ | '')
+                    RPOS(0)
         QUITPAT_  = FENCE ANY('Qq') ('UIT' | 'uit') RPOS(0)
         NEWPAT_   = FENCE ANY('Ss') ('CRATCH' | 'cratch') RPOS(0)
         DDTPAT_   = FENCE ANY('Dd') ('DT' | 'dt') RPOS(0)
         EVALPAT_  = FENCE '=' REM . CODE
         EXECPAT_  = FENCE '!' REM . CODE
         HELPPAT_  = FENCE '?'
@

Clear the retained program. Create the last label [[NMAX_ + 1]]
and have that branch to label [[E]]. Then, fill in the rest of the
statements [[L__1]] to [[L__&lt;NMAX_&gt;]].

This is an expensive operation. With [[NMAX_]] at its default (9999),
10,000 statements are compiled here.

On a scratch, the default filename is set back to [[SCRATCH]].

[[
CODE: SCRATCH
]]

<<clear>>=
CLEAR_   FN_ = 'SCRATCH'
         CODE('L__' NMAX_ + 1 ' :(E)')
         SRC_ = ARRAY(NMAX_)
         SEQ(" CODE(SRC_<N> 'L__' N ' :(L__' N + 1 ')')", .N)  :(RETURN)
@

Command processors for [[code]]. The first handler must be
[[immediate]] because the parser will fall through on any command
not otherwise parseable.

<<commands>>=
<<immediate>>
<<retained>>
<<edit>>
<<ddt>>
<<run>>
<<list>>
<<save>>
<<load>>
<<name>>
<<renum>>
<<complete>>
<<eval>>
<<shell>>
<<help>>
@

Default is immediate execution. Compile and execute the line entered.

[[
CODE:  X = 12
]]

<<immediate>>=
         INPT_ SF_PAT_                                       :S(SF_ERR_)
         CODE = CODE(INPT_ ' :S(S) F(F)')                       :S<CODE>
CPLERR_  TERMINAL = 'COMPILATION ERROR: ' &ERRTEXT
         TERMINAL = 'REENTER STATEMENT OR EDIT ' LN_           :(RETURN)
S        TERMINAL = 'SUCCESS'                                  :(RETURN)
F        TERMINAL = 'FAILURE'                                  :(RETURN)
SF_ERR_  TERMINAL = "CANNOT USE 'S', 'F', OR 'E' AS A LABEL WITH CODE"
+                                                              :(RETURN)
@

Compile in retained statement ([[1..NMAX_]]). The statement can
be empty to delete the statement previously entered. Compiled
statements are surroundeD by [[L__10; STATEMENT; :(L__11)]] to allow
control to proceed from one statement to the next. The final label is
[[L__&lt;MAX&gt;]] which is defined as the program exit. Each statement
is preceeded by a statement setting [[LN_]] to the current statement
number - this is used to display the retained program line if break
or an error occurs.

Source text is retained in array [[SRC_]].

[[
CODE: 1 X = 12             ADD OR REPLACE LINE 1
CODE: 1                    REMOVE LINE 1
CODE: 2 -INCLUDE 'SEQ'     INCLUDE SEQ. NOTE THAT INCLUDE IS
                           DONE ON ENTRY (WHICH IS WHEN THE COMPILE
                           IS DONE).
CODE: 3 * COMMENT          COMMENTS ARE COMPILED TO EMPTY, BUT ARE
                           RETAINED. (IN SRC_<>)
]]

Continuation lines are not supported. The way a continuation is
expressed means that we can't compile until we know that no further
continuation lines will be given. But our basic flow is to compile
the new source immediately, and retain the source line. For this
reason, the SAVE format is not directly compatible with the compiler.
We add the line number and a space (5 characters) to the front. The <a
href="deretn_processed.html">deretn (de-retain)</a> utility strips
this. [[code]] is not meant to be used to edit or test existing
programs - simply to try ideas and perhaps produce the basics of
new programs.

{{
Statement numbers (&amp;STNO) are assigned as increasing integers. This
could also be recorded (may be useful for STCOUNT traps and
profiling). We don't yet record statement numbers.

Simple line number breakpoints can be implemented by trapping on
variable [[LN_]]. If it matched the desired line number, we could
break.
}}

Before the actual code, a statement is compiled which tracks the
line number, assigning it to [[LN_]]. This is reported on errors, in
order to track the error to the offending statement.


<<retained>>=
RETN_    CHECKLN_(LN_)                                        :F(RETURN)
         SRC_<LN_> = CODE
         CODE CMNT_PAT_                                        :S(CMNT_)
         CODE('L__' +LN_ ' LN_ = ' +LN_ ';' CODE '; :(L__' LN_ + 1 ')')
+                                                   :S(RETURN)F(CPLERR_)
CMNT_    CODE INPAT_                                          :F(CMNT2_)
         SLOAD(X)
CMNT2_   CODE('L__' LN_ ' :(L__' LN_ + 1 ')')                  :(RETURN)
@

Edit a line in the retained program, or the entire retained program.

When the entire retained program is edited, the editor is presented
with a source with no line numbers. When editing is complete, this is
read in, and line numbers assigned beginning with 1 and stepping by
1. [[RENUM]] may then be used. This loses the line number information
originally in the retained program, but allows syntax highlighting
and other features of the external editor to be exploited.

The external editor could be (horribly) misused to import source into
[[code]] (edit, and then read the source in, and save/exit back to
[[code]]).  This also provides export (but see [[deretn]]).

[[
CODE: EDIT 1               EDIT LINE 30 (USING READLINE)
CODE: EDIT                 EDIT USING EXTERNAL EDITOR
]]

<<edit>>=
EDIT_    DIFFER(LN_)                                          :S(EDIT2_)
         TEMP_ = BQ('mktemp')
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, TEMP_)                            :F(FILERR_)
         SEQ(' F = VDIFFER(SRC_<N>); SRC_<N> ', .N)
         ENDFILE(UNIT)
         DETACH(.F)
         UNIT = IO_FINDUNIT()
         INPUT(.F, UNIT,, TEMP_)                             :F(FILERR_)
         HOST(HOST_SYSCMD, EDITOR ' ' TEMP_)
         FN2_ = FN_
         CLEAR_()
         FN_ = FN2_
         LN_ = 1
EDIT3_   INPT_ = LN_ ' ' F                                    :F(EDIT4_)
         PRSLIN_()
         LN_ = LN_ + 1                                         :(EDIT3_)
EDIT4_   ENDFILE(UNIT)
         DETACH(.F)
         DELETE(TEMP_)                                         :(RETURN)
EDIT2_   CHECKLN_(LN_)                                        :F(RETURN)
         INPT_ = EDITLINE('EDIT: ', LPAD(LN_, 4, '0') ' ' SRC_<LN_>)
+                                                             :(PRSLIN_)
@

Use [[DDT]] to debug the retained program.

Saves file with an entry to [[DDT()]] jammed in as the first lines.
An [[END]] label is added at the end. The file is compiled with
a listing, and then spawned as a separate process. We assume that
the subprocess wilL be ok with the standard options - but we do add
[[-b]] to suppress the normal banner. Label [[CODE_RETAINED_PROGRAM]]
is inserted to allow [[DDT]]'s [[LABEL+OFFSET]] to make sense
on initial entry. Label [[E]] is added to the end, because it is
possible that [[:(E)]] is used in the retained program (instead of
[[:(END)]]). [[END]] is typically not used in the retained program
because it is being prepared interactively.

[[
CODE: DDT
]]

We copy all lines beginning with -INCLUDE before inserting the
DDT codes.  This allows debugging retained programs with -INCLUDE
directives. Because of single inclusion, we don't bother removing
the lines from the rest of the source. They won't do anything.

<<ddt>>=
DDT__    TERMINAL = 'STARTING DDT'
         TEMPSRC_ = BQ('mktemp')
         TEMPLST_ = BQ('mktemp')
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, TEMPSRC_)                         :F(FILERR_)
         F = "-INCLUDE 'DDT.INC'"
         SEQ(' F = ?(SRC_<N> ? INPAT_) SRC_<N>; SRC_<N> ', .N)
         F = ' DDT()'
         F = 'CODE_RETAINED_PROGRAM'
         SEQ(' F = VDIFFER(SRC_<N>); SRC_<N> ', .N)
         F = 'E'
         F = 'END'
         ENDFILE(UNIT)
         DETACH(.F)
         HOST(HOST_SYSCMD, 'snobol4 -n -b -l ' TEMPLST_ ' ' TEMPSRC_)
         HOST(HOST_SYSCMD, 'LIST=' TEMPLST_ ' snobol4 -B -b ' TEMPSRC_)
         TERMINAL = 'DDT COMPLETED'
         DELETE(TEMPSRC_)
         DELETE(TEMPLST_)                                      :(RETURN)
@

Run retained program. Transfer control to first line [[L__1]], or
specified line.

[[
CODE: RUN                  RUN FROM LINE 1
CODE: RUN 50               RUN FROM LINE 50
]]

<<run>>=
RUN_     LN_ = IDENT(LN_) 1
         CHECKLN_(LN_)                                        :F(RETURN)
         &TRACE = 0                                      :($('L__' LN_))
@

List retained program.

[[
CODE: LIST                 LIST ALL LINES
CODE: LIST 10              LIST LINE 10
CODE: LIST 10,50           LIST LINES BETWEEN 10 AND 50
CODE: LIST ,50             LIST ALL LINES UP TO 50
]]

<<list>>=
LIST_    N2_ = IDENT(N2_) VDIFFER(N1_)
         SEQ(' TERMINAL = LPAD(N, 4, "0") " " VDIFFER(SRC_<N>); '
+            ' SRC_<N> ', .N, N1_, N2_)                        :(RETURN)
@

Save retained program. Default file is [[SCRATCH]].

[[
CODE: SAVE                 SAVE TO LAST FILENAME
CODE: SAVE 'MYFILE'        SAVE TO MYFILE
]]

<<save>>=
SAVE_    TERMINAL = 'SAVING TO ' FN_
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, FN_)                              :F(FILERR_)
         SEQ(' F = LPAD(N, 4, "0") " " VDIFFER(SRC_<N>); '
+            ' SRC_<N> ', .N)
         ENDFILE(UNIT)
         DETACH(.F)                                            :(RETURN)
@

Load retained program. Default file is [[SCRATCH]]. If another name
is given, remember for future [[SAVE]] (or [[LOAD]]). Doesn't clear
the retained program, allowing programs to be merged. Use [[SCRATCH]]
before [[LOAD]] if required.

[[
CODE: LOAD                 LOAD FROM LAST FILENAME
CODE: LOAD 'MYFILE'        LOAD FROM MYFILE
]]

<<load>>=
LOAD_    TERMINAL = 'LOADING FROM ' FN_
         UNIT = IO_FINDUNIT()
         INPUT(.F, UNIT,, FN_)                               :F(FILERR_)
LOAD2_   INPT_ = F                                            :F(LOAD3_)
         PRSLIN_()                                             :(LOAD2_)
LOAD3_   ENDFILE(UNIT)
         DETACH(.F)                                            :(RETURN)
FILERR_  TERMINAL = 'CANNOT OPEN FILE'                         :(RETURN)
@

[[NAME]] displays current name, or sets new name

[[
CODE: NAME                 DISPLAY FILENAME
CODE: NAME 'MYFILE'        SET FILENAME
]]

<<name>>=
NAME_    TERMINAL = IDENT(FN2_) 'FILE: ' FN_                  :S(RETURN)
         FN_ = FN2_                                            :(RETURN)
@

[[RENUM]] (assign new line numbers) to retained program. Uses 10 as the
increment, unless there are too many lines, in which case 5 (4, 3,
or even 2) may be used as increments (5 is preferred).

[[
CODE: RENUM                RENUMBER FROM 10 BY 10
CODE: RENUM 1000           RENUMBER FROM 1000 BY 10
]]

<<renum>>=
RENUM_   LN_ = IDENT(LN_) 10
         CHECKLN_(LN_)                                        :F(RETURN)
         SC = 0
         SEQ(' SC = DIFFER(SRC_<N>) SC + 1; SRC_<N> ', .N)
         EQ(SC)                                               :S(RETURN)
         Q = (NMAX_ - LN_) / SC
         TERMINAL =  LE(Q, 1) 'TOO MANY LINES TO RENUMBER'    :S(RETURN)
         INCR = 10
         INCR = GE(Q, 5) LT(Q, 10) 5
         INCR = GT(Q, 1) LT(Q, 5) Q
         TERMINAL = 'RENUMBERING BY ' INCR ' FROM ' LN_
         UNIT = IO_FINDUNIT()
         INPUT(.IN, UNIT, 'U', '/dev/tmpfile')
         OUTPUT(.OUT, UNIT, 'W')
         SEQ(' OUT = LN_ " " VDIFFER(SRC_<N>); '
+            ' LN_ = DIFFER(SRC_<N>) LN_ + INCR; SRC_<N> ', .N)
         FN2_ = FN_
         CLEAR_()
         FN_ = FN2_
         FN_ = VDIFFER(FN2_)
RENUM2_  INPT_ = IN                                          :F(RENUM3_)
         PRSLIN_()                                            :(RENUM2_)
RENUM3_  ENDFILE(UNIT)
         DETACH(.OUT)
         DETACH(.IN)                                           :(RETURN)
@

Label [[E]] for program completion.

<<complete>>=
E        TERMINAL = 'PROGRAM COMPLETE'                         :(RETURN)
@

Evaluate and print expression

[[
CODE: =1 + 3
]]

<<eval>>=
EVAL_    TERMINAL = EVAL(CODE)                                 :S(S)F(F)
@

Shell to external program

[[
CODE: !ls
]]

<<shell>>=
EXEC_    HOST(HOST_SYSCMD, CODE)                               :(RETURN)
@

Give help for the [[code]] program.

[[
CODE: ?
]]

<<help>>=
HELP_    TERMINAL = '=EXPRESSION    DISPLAY VALUE OF EXPRESSION'
         TERMINAL = '!COMMAND       SHELL OUT TO COMMAND'
         TERMINAL = '?              THIS HELP'
         TERMINAL = 'STATEMENT      EXECUTE STATEMENT'
         TERMINAL =
         TERMINAL = 'N STATEMENT    ENTER/REPLACE/DELETE PROGRAM LINE'
         TERMINAL = 'RUN [N]        RUN RETAINED PROGRAM'
         TERMINAL = 'DDT            DDT ON RETAINED PROGRAM'
         TERMINAL = 'LIST [[N][,M]] LIST RETAINED PROGRAM'
         TERMINAL = 'EDIT [N]       EDIT RETAINED PROGRAM'
         TERMINAL = "SAVE ['FILE']  SAVE RETAINED PROGRAM"
         TERMINAL = "LOAD ['FILE']  LOAD RETAINED PROGRAM"
         TERMINAL = "NAME ['FILE']  CHANGE OR DISPLAY NAME"
         TERMINAL = 'SCRATCH        CLEAR RETAINED PROGRAM'
         TERMINAL = 'RENUM [N]      RENUMBER RETAINED PROGRAM'
         TERMINAL = 'QUIT           EXIT CODE'
         TERMINAL =
         TERMINAL =
+ '-INCLUDE IS PROCESSED IMMEDIATELY ON ENTRY. CONTINUATION LINES ARE'
         TERMINAL =
+ 'NOT AVAILABLE. LINES ARE IN THE RANGE 1..' NMAX_
         TERMINAL =
         TERMINAL = 'S, F, AND E LABELS AVAILABLE'
         TERMINAL = 'SLOAD(' Q_ 'FILE' Q_ ') AVAILABLE'        :(RETURN)
@

Hoary interactions between [[ERRFUN_]] and [[BRKFUN_]]. We need
[[ERRFUN_]] in some conditions, but the [[EXIT]] trap may be triggered
anyway on return from [[ERRFUN_]].

<<error function>>=
ERRFUN_
         (NE(&ERRTYPE, 34) SETEXIT())
         EQ(&ERRTYPE, 34)                                     :S(RETURN)
         TERMINAL = 'EXECUTION ERROR #' &ERRTYPE ', ' &ERRTEXT
         TERMINAL = 'RETAINED PROGRAM LINE:' DIFFER(LN_)
         TERMINAL = LPAD(VDIFFER(LN_), 4, 0) ' ' SRC_<LN_>     :(RETURN)
@

If [[BRKFUN_]] (exit trap) is entered, we need to know if we should
simply resume from the command prompt, or return (again, probably to
the prompt). Our heuristic is to test [[&amp;FNCLEVEL]], and return
if it is 1. If it is 0, a simple branch suffices. If &gt; 0, we also
branch, and (lose) the stack. [[DDT]] has a similar problem. Here,
we keep track of [[&amp;FNCLEVEL]] in [[FL_]], for reporting and
making return/branch decision.

The issue is that we cannot simply pop the function stack and
bindings. After getting input, and executing [[RUN]], we are one
function deep ([[NEWLIN_ -&gt; PRSLIN_()]]). If we see one level
here, we know that we can simply return and this brings us back to
[[NEWLIN_]].  But, since the only thing we *can* do is return, if
the level is 2 or greater, we cannot return (we would wind up back
in the faulty code).

I would like to be able to pop levels off, until only one remains,
(or zero) and then return, or branch. But I can't! Each function
level will also lock parameters and locals. To get around that
memory leakage, [[PRSLIN_()]] has no parameters, and no locals.

<<exit trap>>=
BRKFUN_  ERRTYPE_ = &ERRTYPE
         ERRTEXT_ = &ERRTEXT
@

Getting to [[END]] triggers [[&amp;ERRTYPE 0]]. We don't display
anything, but want to get back to the prompt. An expected [[END]]
will have removed the [[SETEXIT()]] trap, and we won't wind up here.

Unfortunately, FATAL errors are not trapped. For example

[[
CODE:  :(NO_SUCH_LABEL) ;
]]

will immediately bail code. So, [[SAVE]] before [[RUN]]. Just prudent.
Note that labels are not checked until run-time and not compile-time.

<<exit trap>>=
         EQ(ERRTYPE_, 0) EQ(&FNCLEVEL, FL_ + 1)               :S(RETURN)
         EQ(ERRTYPE_, 0)                                     :S(NEWLIN_)
         SETEXIT('BRKFUN_')
         &ERRLIMIT = 999999999
         TERMINAL = 'ERROR ' ERRTYPE_ ' (' ERRTEXT_ ')'
+           ' AT LEVEL ' &FNCLEVEL - FL_ - 1
         TERMINAL = 'RETAINED PROGRAM LINE:' DIFFER(LN_)
         TERMINAL = LPAD(VDIFFER(LN_), 4, 0) ' ' SRC_<LN_>
         EQ(&FNCLEVEL, FL_ + 1)                     :S(RETURN)F(NEWLIN_)
@

Main program. Re-establish EXIT handler, input a line, parse and
execute it, and then get the next line. Note that history expansion
is done, but lines that begin with ! are considered special. Those
lines are assumed to be external shell execution. The leading ! is
stripped, then history expansion is done, and the ! is added back.

Empty lines are not added to the history. The current FNCLEVEL is
recorded for error handling.

<<main>>=
<<initialize>>
NEWLIN_  SETEXIT('BRKFUN_')
         &TRACE = 999999999
         &ERRLIMIT = 999999999
         INPT_ = READLINE('CODE:')                             :F(EXIT_)
         INPT_ FENCE '!' REM . CODE                           :F(NEWL2_)
         CODE = HISTORY_EXPAND(CODE)
         INPT_ = '!' CODE                                      :(NEWL3_)
NEWL2_   INPT_ = HISTORY_EXPAND(INPT_)
NEWL3_   INPT_ = TRIM(INPT_)
         ADD_HISTORY(VDIFFER(INPT_))
         FL_ = &FNCLEVEL
         PRSLIN_()                                            :(NEWLIN_)
@

Parse the input line, branching to the execution routine.

<<parse>>=
PRSLIN_  N1_ =
         N2_ =
         CODE =
         LN_ =
         FN2_ =
         INPT_ EVALPAT_                                        :S(EVAL_)
         INPT_ EXECPAT_                                        :S(EXEC_)
         INPT_ HELPPAT_                                        :S(HELP_)
         INPT_ LISTPAT_                                        :S(LIST_)
         INPT_ RUNPAT_                                          :S(RUN_)
         INPT_ EDITPAT_                                        :S(EDIT_)
         INPT_ QUITPAT_                                        :S(EXIT_)
         INPT_ NEWPAT_                                        :S(CLEAR_)
         INPT_ RENUMPAT_                                      :S(RENUM_)
         INPT_ SAVEPAT_                                        :S(SAVE_)
         INPT_ LOADPAT_                                        :S(LOAD_)
         INPT_ NAMEPAT_                                        :S(NAME_)
         INPT_ DDTPAT_                                         :S(DDT__)
         INPT_ RETNPAT_                                        :S(RETN_)
@

<<functions>>=
*
         DEFINE('ERRFUN_()')
         DEFINE('PRSLIN_()')
         DEFINE('CHECKLN_(N)')
         DEFINE('CLEAR_()')                                   :(FN_END_)
*
<<checkln>>
<<clear>>
*
FN_END_
@

<<checkln>>=
CHECKLN_ GT(N) LE(N, NMAX_)                                   :S(RETURN)
         TERMINAL = 'LINE NUMBER MUST BE 1 TO ' NMAX_         :(FRETURN)
@

Trap and report conditionally fatal execution errors in user's code.

<<initialize>>=
         &TRACE = 999999999
         TRACE('ERRTYPE', 'KEYWORD',, 'ERRFUN_')
         CLEAR_()
@

<<signon>>=
         TERMINAL = 'CODE (TUE NOV 26 12:25:23 EST 2013)'
         TERMINAL = 'ENTER SNOBOL4 STATEMENTS (TRY ? FOR HELP)'
@

<<manifest>>=
         NMAX_ = 9999
         EDITOR = 'ED'
@

<<readline>>=
         RLAPPNAME('CODE')
         READ_HISTORY('.CODE')
         STIFLE_HISTORY(50)
@

<<exit>>=
EXIT_    WRITE_HISTORY('.CODE')
         SETEXIT()
@

We have thousands of statements chained together with gotos. These
are traced during COLLECT() and the stack must be large enough.
10,000 empty statements take around 2.5MB of memory, leaving over
5MB for user (with 8MB default).

A stack size [[-S]] of 40000 seems to be fine.

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-B" "-s" "-S 40000" "$0" "$@"
*
-PROGRAM CODE
-TITLE CODE
START_
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                  #####   #######  ######   #######                   *
*                 #     #  #     #  #     #  #                         *
*                 #        #     #  #     #  #                         *
*                 #        #     #  #     #  #####                     *
*                 #        #     #  #     #  #                         *
*                 #     #  #     #  #     #  #                         *
*                  #####   #######  ######   #######                   *
*                                                                      *
* CODE              ENTER TEST SNOBOL4 STATEMENTS                      *
*                                                                      *
* (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *
*                                                                      *
* "THIS IS MY GRANDFATHER'S AXE. MY FATHER REPLACED THE HAFT, AND I    *
*  PUT A NEW HEAD ON IT. IT'S MY GRANDFATHER'S AXE."                   *
*                                                                      *
* ALSO PROVIDES A SIMPLISTIC RETAINED PROGRAM ENVIRONMENT (SIMILAR TO  *
* BASIC -- INSPIRED BY MTS)                                            *
*                                                                      *
************************************************************************
*
* code.lss
*
<<code>>
END START_
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-B" "-s" "-S 40000" "$0" "$@"
*
-LINE 639 "code.lss"
-PROGRAM CODE
-TITLE CODE
START_
-LINE 16 "code.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SLOAD.INC'
-INCLUDE 'VDIFFER.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                  #####   #######  ######   #######                   *
*                 #     #  #     #  #     #  #                         *
*                 #        #     #  #     #  #                         *
*                 #        #     #  #     #  #####                     *
*                 #        #     #  #     #  #                         *
*                 #     #  #     #  #     #  #                         *
*                  #####   #######  ######   #######                   *
*                                                                      *
* CODE              ENTER TEST SNOBOL4 STATEMENTS                      *
*                                                                      *
* (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *
*                                                                      *
* "THIS IS MY GRANDFATHER'S AXE. MY FATHER REPLACED THE HAFT, AND I    *
*  PUT A NEW HEAD ON IT. IT'S MY GRANDFATHER'S AXE."                   *
*                                                                      *
* ALSO PROVIDES A SIMPLISTIC RETAINED PROGRAM ENVIRONMENT (SIMILAR TO  *
* BASIC -- INSPIRED BY MTS)                                            *
*                                                                      *
************************************************************************
*
* code.lss
*
-LINE 26 "code.lss"
-LINE 608 "code.lss"
         TERMINAL = 'CODE (TUE NOV 26 12:25:23 EST 2013)'
         TERMINAL = 'ENTER SNOBOL4 STATEMENTS (TRY ? FOR HELP)'
-LINE 613 "code.lss"
         NMAX_ = 9999
         EDITOR = 'ED'
-LINE 618 "code.lss"
         RLAPPNAME('CODE')
         READ_HISTORY('.CODE')
         STIFLE_HISTORY(50)
-LINE 42 "code.lss"
         QQ_ = '"'
         Q_  = "'"
         WHITE_SPACE_ = CHARS_HT ' '
         OWS_         = SPAN(WHITE_SPACE_) | ''
         SF_PAT_      = FENCE ANY('SsFfEe')
+                       (ANY(WHITE_SPACE_) | RPOS(0))
         CMNT_PAT_    = FENCE ANY('*;|#!-')
         INPAT_       = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                                  (ANY('Cc') ('OPY' | 'opy')))
+                       BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
*
         RETNPAT_  = FENCE (SPAN(&DIGITS) . LN_)
+                    ((ANY(WHITE_SPACE_) REM . CODE) | '') RPOS(0)
         SAVEPAT_  = FENCE ANY('Ss') ('AVE' | 'ave')
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN_ LEN(1))
+                     | '')
+                    RPOS(0)
         LOADPAT_  = FENCE ANY('Ll') ('OAD' | 'oad')
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN_ LEN(1))
+                     | '')
+                    RPOS(0)
         NAMEPAT_  = FENCE ANY('Nn') ('AME' | 'ame')
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN2_ LEN(1))
+                     | '')
+                    RPOS(0)
         LISTPAT_  = FENCE ANY('Ll') ('IST' | 'ist')
+                    ((ANY(WHITE_SPACE_)
+                       ((OWS_ SPAN(&DIGITS) . N1_) | '')
+                       ((OWS_ ',' OWS_ SPAN(&DIGITS) . N2_) | '')
+                    ) | '') RPOS(0)
         RUNPAT_   = FENCE ANY('Rr') ('UN' | 'un')
+                    (ANY(WHITE_SPACE_) SPAN(&DIGITS) . LN_ | '')
+                    RPOS(0)
         EDITPAT_  = FENCE ANY('Ee') ('DIT' | 'dit')
+                    (ANY(WHITE_SPACE_) SPAN(&DIGITS) . LN_ | '')
+                    RPOS(0)
         RENUMPAT_ = FENCE ANY('Rr') ('ENUM' | 'enum')
+                    (ANY(WHITE_SPACE_) SPAN(&DIGITS) . LN_ | '')
+                    RPOS(0)
         QUITPAT_  = FENCE ANY('Qq') ('UIT' | 'uit') RPOS(0)
         NEWPAT_   = FENCE ANY('Ss') ('CRATCH' | 'cratch') RPOS(0)
         DDTPAT_   = FENCE ANY('Dd') ('DT' | 'dt') RPOS(0)
         EVALPAT_  = FENCE '=' REM . CODE
         EXECPAT_  = FENCE '!' REM . CODE
         HELPPAT_  = FENCE '?'
-LINE 582 "code.lss"
*
         DEFINE('ERRFUN_()')
         DEFINE('PRSLIN_()')
         DEFINE('CHECKLN_(N)')
         DEFINE('CLEAR_()')                                   :(FN_END_)
*
-LINE 595 "code.lss"
CHECKLN_ GT(N) LE(N, NMAX_)                                   :S(RETURN)
         TERMINAL = 'LINE NUMBER MUST BE 1 TO ' NMAX_         :(FRETURN)
-LINE 103 "code.lss"
CLEAR_   FN_ = 'SCRATCH'
         CODE('L__' NMAX_ + 1 ' :(E)')
         SRC_ = ARRAY(NMAX_)
         SEQ(" CODE(SRC_<N> 'L__' N ' :(L__' N + 1 ')')", .N)  :(RETURN)
*
FN_END_
-LINE 542 "code.lss"
-LINE 602 "code.lss"
         &TRACE = 999999999
         TRACE('ERRTYPE', 'KEYWORD',, 'ERRFUN_')
         CLEAR_()
NEWLIN_  SETEXIT('BRKFUN_')
         &TRACE = 999999999
         &ERRLIMIT = 999999999
         INPT_ = READLINE('CODE:')                             :F(EXIT_)
         INPT_ FENCE '!' REM . CODE                           :F(NEWL2_)
         CODE = HISTORY_EXPAND(CODE)
         INPT_ = '!' CODE                                      :(NEWL3_)
NEWL2_   INPT_ = HISTORY_EXPAND(INPT_)
NEWL3_   INPT_ = TRIM(INPT_)
         ADD_HISTORY(VDIFFER(INPT_))
         FL_ = &FNCLEVEL
         PRSLIN_()                                            :(NEWLIN_)
-LINE 560 "code.lss"
PRSLIN_  N1_ =
         N2_ =
         CODE =
         LN_ =
         FN2_ =
         INPT_ EVALPAT_                                        :S(EVAL_)
         INPT_ EXECPAT_                                        :S(EXEC_)
         INPT_ HELPPAT_                                        :S(HELP_)
         INPT_ LISTPAT_                                        :S(LIST_)
         INPT_ RUNPAT_                                          :S(RUN_)
         INPT_ EDITPAT_                                        :S(EDIT_)
         INPT_ QUITPAT_                                        :S(EXIT_)
         INPT_ NEWPAT_                                        :S(CLEAR_)
         INPT_ RENUMPAT_                                      :S(RENUM_)
         INPT_ SAVEPAT_                                        :S(SAVE_)
         INPT_ LOADPAT_                                        :S(LOAD_)
         INPT_ NAMEPAT_                                        :S(NAME_)
         INPT_ DDTPAT_                                         :S(DDT__)
         INPT_ RETNPAT_                                        :S(RETN_)
-LINE 114 "code.lss"
-LINE 137 "code.lss"
         INPT_ SF_PAT_                                       :S(SF_ERR_)
         CODE = CODE(INPT_ ' :S(S) F(F)')                       :S<CODE>
CPLERR_  TERMINAL = 'COMPILATION ERROR: ' &ERRTEXT
         TERMINAL = 'REENTER STATEMENT OR EDIT ' LN_           :(RETURN)
S        TERMINAL = 'SUCCESS'                                  :(RETURN)
F        TERMINAL = 'FAILURE'                                  :(RETURN)
SF_ERR_  TERMINAL = "CANNOT USE 'S', 'F', OR 'E' AS A LABEL WITH CODE"
+                                                              :(RETURN)
-LINE 195 "code.lss"
RETN_    CHECKLN_(LN_)                                        :F(RETURN)
         SRC_<LN_> = CODE
         CODE CMNT_PAT_                                        :S(CMNT_)
         CODE('L__' +LN_ ' LN_ = ' +LN_ ';' CODE '; :(L__' LN_ + 1 ')')
+                                                   :S(RETURN)F(CPLERR_)
CMNT_    CODE INPAT_                                          :F(CMNT2_)
         SLOAD(X)
CMNT2_   CODE('L__' LN_ ' :(L__' LN_ + 1 ')')                  :(RETURN)
-LINE 224 "code.lss"
EDIT_    DIFFER(LN_)                                          :S(EDIT2_)
         TEMP_ = BQ('mktemp')
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, TEMP_)                            :F(FILERR_)
         SEQ(' F = VDIFFER(SRC_<N>); SRC_<N> ', .N)
         ENDFILE(UNIT)
         DETACH(.F)
         UNIT = IO_FINDUNIT()
         INPUT(.F, UNIT,, TEMP_)                             :F(FILERR_)
         HOST(HOST_SYSCMD, EDITOR ' ' TEMP_)
         FN2_ = FN_
         CLEAR_()
         FN_ = FN2_
         LN_ = 1
EDIT3_   INPT_ = LN_ ' ' F                                    :F(EDIT4_)
         PRSLIN_()
         LN_ = LN_ + 1                                         :(EDIT3_)
EDIT4_   ENDFILE(UNIT)
         DETACH(.F)
         DELETE(TEMP_)                                         :(RETURN)
EDIT2_   CHECKLN_(LN_)                                        :F(RETURN)
         INPT_ = EDITLINE('EDIT: ', LPAD(LN_, 4, '0') ' ' SRC_<LN_>)
+                                                             :(PRSLIN_)
-LINE 272 "code.lss"
DDT__    TERMINAL = 'STARTING DDT'
         TEMPSRC_ = BQ('mktemp')
         TEMPLST_ = BQ('mktemp')
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, TEMPSRC_)                         :F(FILERR_)
         F = "-INCLUDE 'DDT.INC'"
         SEQ(' F = ?(SRC_<N> ? INPAT_) SRC_<N>; SRC_<N> ', .N)
         F = ' DDT()'
         F = 'CODE_RETAINED_PROGRAM'
         SEQ(' F = VDIFFER(SRC_<N>); SRC_<N> ', .N)
         F = 'E'
         F = 'END'
         ENDFILE(UNIT)
         DETACH(.F)
         HOST(HOST_SYSCMD, 'snobol4 -n -b -l ' TEMPLST_ ' ' TEMPSRC_)
         HOST(HOST_SYSCMD, 'LIST=' TEMPLST_ ' snobol4 -B -b ' TEMPSRC_)
         TERMINAL = 'DDT COMPLETED'
         DELETE(TEMPSRC_)
         DELETE(TEMPLST_)                                      :(RETURN)
-LINE 302 "code.lss"
RUN_     LN_ = IDENT(LN_) 1
         CHECKLN_(LN_)                                        :F(RETURN)
         &TRACE = 0                                      :($('L__' LN_))
-LINE 317 "code.lss"
LIST_    N2_ = IDENT(N2_) VDIFFER(N1_)
         SEQ(' TERMINAL = LPAD(N, 4, "0") " " VDIFFER(SRC_<N>); '
+            ' SRC_<N> ', .N, N1_, N2_)                        :(RETURN)
-LINE 330 "code.lss"
SAVE_    TERMINAL = 'SAVING TO ' FN_
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, FN_)                              :F(FILERR_)
         SEQ(' F = LPAD(N, 4, "0") " " VDIFFER(SRC_<N>); '
+            ' SRC_<N> ', .N)
         ENDFILE(UNIT)
         DETACH(.F)                                            :(RETURN)
-LINE 350 "code.lss"
LOAD_    TERMINAL = 'LOADING FROM ' FN_
         UNIT = IO_FINDUNIT()
         INPUT(.F, UNIT,, FN_)                               :F(FILERR_)
LOAD2_   INPT_ = F                                            :F(LOAD3_)
         PRSLIN_()                                             :(LOAD2_)
LOAD3_   ENDFILE(UNIT)
         DETACH(.F)                                            :(RETURN)
FILERR_  TERMINAL = 'CANNOT OPEN FILE'                         :(RETURN)
-LINE 368 "code.lss"
NAME_    TERMINAL = IDENT(FN2_) 'FILE: ' FN_                  :S(RETURN)
         FN_ = FN2_                                            :(RETURN)
-LINE 382 "code.lss"
RENUM_   LN_ = IDENT(LN_) 10
         CHECKLN_(LN_)                                        :F(RETURN)
         SC = 0
         SEQ(' SC = DIFFER(SRC_<N>) SC + 1; SRC_<N> ', .N)
         EQ(SC)                                               :S(RETURN)
         Q = (NMAX_ - LN_) / SC
         TERMINAL =  LE(Q, 1) 'TOO MANY LINES TO RENUMBER'    :S(RETURN)
         INCR = 10
         INCR = GE(Q, 5) LT(Q, 10) 5
         INCR = GT(Q, 1) LT(Q, 5) Q
         TERMINAL = 'RENUMBERING BY ' INCR ' FROM ' LN_
         UNIT = IO_FINDUNIT()
         INPUT(.IN, UNIT, 'U', '/dev/tmpfile')
         OUTPUT(.OUT, UNIT, 'W')
         SEQ(' OUT = LN_ " " VDIFFER(SRC_<N>); '
+            ' LN_ = DIFFER(SRC_<N>) LN_ + INCR; SRC_<N> ', .N)
         FN2_ = FN_
         CLEAR_()
         FN_ = FN2_
         FN_ = VDIFFER(FN2_)
RENUM2_  INPT_ = IN                                          :F(RENUM3_)
         PRSLIN_()                                            :(RENUM2_)
RENUM3_  ENDFILE(UNIT)
         DETACH(.OUT)
         DETACH(.IN)                                           :(RETURN)
-LINE 412 "code.lss"
E        TERMINAL = 'PROGRAM COMPLETE'                         :(RETURN)
-LINE 422 "code.lss"
EVAL_    TERMINAL = EVAL(CODE)                                 :S(S)F(F)
-LINE 432 "code.lss"
EXEC_    HOST(HOST_SYSCMD, CODE)                               :(RETURN)
-LINE 442 "code.lss"
HELP_    TERMINAL = '=EXPRESSION    DISPLAY VALUE OF EXPRESSION'
         TERMINAL = '!COMMAND       SHELL OUT TO COMMAND'
         TERMINAL = '?              THIS HELP'
         TERMINAL = 'STATEMENT      EXECUTE STATEMENT'
         TERMINAL =
         TERMINAL = 'N STATEMENT    ENTER/REPLACE/DELETE PROGRAM LINE'
         TERMINAL = 'RUN [N]        RUN RETAINED PROGRAM'
         TERMINAL = 'DDT            DDT ON RETAINED PROGRAM'
         TERMINAL = 'LIST [[N][,M]] LIST RETAINED PROGRAM'
         TERMINAL = 'EDIT [N]       EDIT RETAINED PROGRAM'
         TERMINAL = "SAVE ['FILE']  SAVE RETAINED PROGRAM"
         TERMINAL = "LOAD ['FILE']  LOAD RETAINED PROGRAM"
         TERMINAL = "NAME ['FILE']  CHANGE OR DISPLAY NAME"
         TERMINAL = 'SCRATCH        CLEAR RETAINED PROGRAM'
         TERMINAL = 'RENUM [N]      RENUMBER RETAINED PROGRAM'
         TERMINAL = 'QUIT           EXIT CODE'
         TERMINAL =
         TERMINAL =
+ '-INCLUDE IS PROCESSED IMMEDIATELY ON ENTRY. CONTINUATION LINES ARE'
         TERMINAL =
+ 'NOT AVAILABLE. LINES ARE IN THE RANGE 1..' NMAX_
         TERMINAL =
         TERMINAL = 'S, F, AND E LABELS AVAILABLE'
         TERMINAL = 'SLOAD(' Q_ 'FILE' Q_ ') AVAILABLE'        :(RETURN)
-LINE 473 "code.lss"
ERRFUN_
         (NE(&ERRTYPE, 34) SETEXIT())
         EQ(&ERRTYPE, 34)                                     :S(RETURN)
         TERMINAL = 'EXECUTION ERROR #' &ERRTYPE ', ' &ERRTEXT
         TERMINAL = 'RETAINED PROGRAM LINE:' DIFFER(LN_)
         TERMINAL = LPAD(VDIFFER(LN_), 4, 0) ' ' SRC_<LN_>     :(RETURN)
-LINE 503 "code.lss"
BRKFUN_  ERRTYPE_ = &ERRTYPE
         ERRTEXT_ = &ERRTEXT
-LINE 521 "code.lss"
         EQ(ERRTYPE_, 0) EQ(&FNCLEVEL, FL_ + 1)               :S(RETURN)
         EQ(ERRTYPE_, 0)                                     :S(NEWLIN_)
         SETEXIT('BRKFUN_')
         &ERRLIMIT = 999999999
         TERMINAL = 'ERROR ' ERRTYPE_ ' (' ERRTEXT_ ')'
+           ' AT LEVEL ' &FNCLEVEL - FL_ - 1
         TERMINAL = 'RETAINED PROGRAM LINE:' DIFFER(LN_)
         TERMINAL = LPAD(VDIFFER(LN_), 4, 0) ' ' SRC_<LN_>
         EQ(&FNCLEVEL, FL_ + 1)                     :S(RETURN)F(NEWLIN_)
-LINE 624 "code.lss"
EXIT_    WRITE_HISTORY('.CODE')
         SETEXIT()
END START_
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>code</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Enter SNOBOL4 statements for immediate execution. Also supports a
primitive programming environment with line numbered statements.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HOST.html">HOST</a><br>
<a href="READLINE.html">READLINE</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="SLOAD.html">SLOAD</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;READLINE.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;SLOAD.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;code&raquo;&equiv;</b>
<b>&laquo;signon&raquo;</b>
<b>&laquo;manifest&raquo;</b>
<b>&laquo;readline&raquo;</b>
<b>&laquo;patterns&raquo;</b>
<b>&laquo;functions&raquo;</b>
<b>&laquo;main&raquo;</b>
<b>&laquo;parse&raquo;</b>
<b>&laquo;commands&raquo;</b>
<b>&laquo;error function&raquo;</b>
<b>&laquo;exit trap&raquo;</b>
<b>&laquo;exit&raquo;</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Patterns used to parse commands.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;patterns&raquo;&equiv;</b>
         QQ_ = &#39;&quot;&#39;
         Q_  = &quot;&#39;&quot;
         WHITE_SPACE_ = CHARS_HT &#39; &#39;
         OWS_         = SPAN(WHITE_SPACE_) | &#39;&#39;
         SF_PAT_      = FENCE ANY(&#39;SsFfEe&#39;)
+                       (ANY(WHITE_SPACE_) | RPOS(0))
         CMNT_PAT_    = FENCE ANY(&#39;*;|#!-&#39;)
         INPAT_       = FENCE &#39;-&#39; ((ANY(&#39;Ii&#39;) (&#39;NCLUDE&#39; | &#39;nclude&#39;)) |
+                                  (ANY(&#39;Cc&#39;) (&#39;OPY&#39; | &#39;opy&#39;)))
+                       BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
<font color="#818181"><i>*</i></font>
         RETNPAT_  = FENCE (SPAN(&amp;DIGITS) . LN_)
+                    ((ANY(WHITE_SPACE_) REM . CODE) | &#39;&#39;) RPOS(0)
         SAVEPAT_  = FENCE ANY(&#39;Ss&#39;) (&#39;AVE&#39; | &#39;ave&#39;)
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN_ LEN(1))
+                     | &#39;&#39;)
+                    RPOS(0)
         LOADPAT_  = FENCE ANY(&#39;Ll&#39;) (&#39;OAD&#39; | &#39;oad&#39;)
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN_ LEN(1))
+                     | &#39;&#39;)
+                    RPOS(0)
         NAMEPAT_  = FENCE ANY(&#39;Nn&#39;) (&#39;AME&#39; | &#39;ame&#39;)
+                    ((BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . FN2_ LEN(1))
+                     | &#39;&#39;)
+                    RPOS(0)
         LISTPAT_  = FENCE ANY(&#39;Ll&#39;) (&#39;IST&#39; | &#39;ist&#39;)
+                    ((ANY(WHITE_SPACE_)
+                       ((OWS_ SPAN(&amp;DIGITS) . N1_) | &#39;&#39;)
+                       ((OWS_ &#39;,&#39; OWS_ SPAN(&amp;DIGITS) . N2_) | &#39;&#39;)
+                    ) | &#39;&#39;) RPOS(0)
         RUNPAT_   = FENCE ANY(&#39;Rr&#39;) (&#39;UN&#39; | &#39;un&#39;)
+                    (ANY(WHITE_SPACE_) SPAN(&amp;DIGITS) . LN_ | &#39;&#39;)
+                    RPOS(0)
         EDITPAT_  = FENCE ANY(&#39;Ee&#39;) (&#39;DIT&#39; | &#39;dit&#39;)
+                    (ANY(WHITE_SPACE_) SPAN(&amp;DIGITS) . LN_ | &#39;&#39;)
+                    RPOS(0)
         RENUMPAT_ = FENCE ANY(&#39;Rr&#39;) (&#39;ENUM&#39; | &#39;enum&#39;)
+                    (ANY(WHITE_SPACE_) SPAN(&amp;DIGITS) . LN_ | &#39;&#39;)
+                    RPOS(0)
         QUITPAT_  = FENCE ANY(&#39;Qq&#39;) (&#39;UIT&#39; | &#39;uit&#39;) RPOS(0)
         NEWPAT_   = FENCE ANY(&#39;Ss&#39;) (&#39;CRATCH&#39; | &#39;cratch&#39;) RPOS(0)
         DDTPAT_   = FENCE ANY(&#39;Dd&#39;) (&#39;DT&#39; | &#39;dt&#39;) RPOS(0)
         EVALPAT_  = FENCE &#39;=&#39; REM . CODE
         EXECPAT_  = FENCE &#39;!&#39; REM . CODE
         HELPPAT_  = FENCE &#39;?&#39;
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Clear the retained program. Create the last label <font face="Source Code Pro">NMAX_ + 1</font>
and have that branch to label <font face="Source Code Pro">E</font>. Then, fill in the rest of the
statements <font face="Source Code Pro">L__1</font> to <font face="Source Code Pro">L__&lt;NMAX_&gt;</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This is an expensive operation. With <font face="Source Code Pro">NMAX_</font> at its default (9999),
10,000 statements are compiled here.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
On a scratch, the default filename is set back to <font face="Source Code Pro">SCRATCH</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: SCRATCH
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;clear&raquo;&equiv;</b>
CLEAR_   FN_ = &#39;SCRATCH&#39;
         CODE(&#39;L__&#39; NMAX_ + 1 &#39; :(E)&#39;)
         SRC_ = ARRAY(NMAX_)
         SEQ(&quot; CODE(SRC_&lt;N&gt; &#39;L__&#39; N &#39; :(L__&#39; N + 1 &#39;)&#39;)&quot;, .N)  <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Command processors for <font face="Source Code Pro">code</font>. The first handler must be
<font face="Source Code Pro">immediate</font> because the parser will fall through on any command
not otherwise parseable.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;commands&raquo;&equiv;</b>
<b>&laquo;immediate&raquo;</b>
<b>&laquo;retained&raquo;</b>
<b>&laquo;edit&raquo;</b>
<b>&laquo;ddt&raquo;</b>
<b>&laquo;run&raquo;</b>
<b>&laquo;list&raquo;</b>
<b>&laquo;save&raquo;</b>
<b>&laquo;load&raquo;</b>
<b>&laquo;name&raquo;</b>
<b>&laquo;renum&raquo;</b>
<b>&laquo;complete&raquo;</b>
<b>&laquo;eval&raquo;</b>
<b>&laquo;shell&raquo;</b>
<b>&laquo;help&raquo;</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Default is immediate execution. Compile and execute the line entered.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE:  X = 12
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;immediate&raquo;&equiv;</b>
         INPT_ SF_PAT_                                       <b>:S(SF_ERR_)</b>
         CODE = CODE(INPT_ &#39; :S(S) F(F)&#39;)                       <b>:S&lt;CODE&gt;</b>
CPLERR_  TERMINAL = &#39;COMPILATION ERROR: &#39; &amp;ERRTEXT
         TERMINAL = &#39;REENTER STATEMENT OR EDIT &#39; LN_           <b>:(RETURN)</b>
S        TERMINAL = &#39;SUCCESS&#39;                                  <b>:(RETURN)</b>
F        TERMINAL = &#39;FAILURE&#39;                                  <b>:(RETURN)</b>
SF_ERR_  TERMINAL = &quot;CANNOT USE &#39;S&#39;, &#39;F&#39;, OR &#39;E&#39; AS A LABEL WITH CODE&quot;
+                                                              <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Compile in retained statement (<font face="Source Code Pro">1..NMAX_</font>). The statement can
be empty to delete the statement previously entered. Compiled
statements are surroundeD by <font face="Source Code Pro">L__10; STATEMENT; :(L__11)</font> to allow
control to proceed from one statement to the next. The final label is
<font face="Source Code Pro">L__&lt;MAX&gt;</font> which is defined as the program exit. Each statement
is preceeded by a statement setting <font face="Source Code Pro">LN_</font> to the current statement
number - this is used to display the retained program line if break
or an error occurs.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Source text is retained in array <font face="Source Code Pro">SRC_</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: 1 X = 12             ADD OR REPLACE LINE 1
| CODE: 1                    REMOVE LINE 1
| CODE: 2 -INCLUDE 'SEQ'     INCLUDE SEQ. NOTE THAT INCLUDE IS
|                            DONE ON ENTRY (WHICH IS WHEN THE COMPILE
|                            IS DONE).
| CODE: 3 * COMMENT          COMMENTS ARE COMPILED TO EMPTY, BUT ARE
|                            RETAINED. (IN SRC_<>)
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Continuation lines are not supported. The way a continuation is
expressed means that we can't compile until we know that no further
continuation lines will be given. But our basic flow is to compile
the new source immediately, and retain the source line. For this
reason, the SAVE format is not directly compatible with the compiler.
We add the line number and a space (5 characters) to the front. The <a
href="deretn_processed.html">deretn (de-retain)</a> utility strips
this. <font face="Source Code Pro">code</font> is not meant to be used to edit or test existing
programs - simply to try ideas and perhaps produce the basics of
new programs.
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
Statement numbers (&amp;STNO) are assigned as increasing integers. This
could also be recorded (may be useful for STCOUNT traps and
profiling). We don't yet record statement numbers.

Simple line number breakpoints can be implemented by trapping on
variable <font face="Source Code Pro">LN_</font>. If it matched the desired line number, we could
break.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
Before the actual code, a statement is compiled which tracks the
line number, assigning it to <font face="Source Code Pro">LN_</font>. This is reported on errors, in
order to track the error to the offending statement.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;retained&raquo;&equiv;</b>
RETN_    CHECKLN_(LN_)                                        <b>:F(RETURN)</b>
         SRC_&lt;LN_&gt; = CODE
         CODE CMNT_PAT_                                        <b>:S(CMNT_)</b>
         CODE(&#39;L__&#39; +LN_ &#39; LN_ = &#39; +LN_ &#39;;&#39; CODE &#39;; :(L__&#39; LN_ + 1 &#39;)&#39;)
+                                                   <b>:S(RETURN)F(CPLERR_)</b>
CMNT_    CODE INPAT_                                          <b>:F(CMNT2_)</b>
         SLOAD(X)
CMNT2_   CODE(&#39;L__&#39; LN_ &#39; :(L__&#39; LN_ + 1 &#39;)&#39;)                  <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Edit a line in the retained program, or the entire retained program.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
When the entire retained program is edited, the editor is presented
with a source with no line numbers. When editing is complete, this is
read in, and line numbers assigned beginning with 1 and stepping by
1. <font face="Source Code Pro">RENUM</font> may then be used. This loses the line number information
originally in the retained program, but allows syntax highlighting
and other features of the external editor to be exploited.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The external editor could be (horribly) misused to import source into
<font face="Source Code Pro">code</font> (edit, and then read the source in, and save/exit back to
<font face="Source Code Pro">code</font>).  This also provides export (but see <font face="Source Code Pro">deretn</font>).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: EDIT 1               EDIT LINE 30 (USING READLINE)
| CODE: EDIT                 EDIT USING EXTERNAL EDITOR
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;edit&raquo;&equiv;</b>
EDIT_    DIFFER(LN_)                                          <b>:S(EDIT2_)</b>
         TEMP_ = BQ(&#39;mktemp&#39;)
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, TEMP_)                            <b>:F(FILERR_)</b>
         SEQ(&#39; F = VDIFFER(SRC_&lt;N&gt;); SRC_&lt;N&gt; &#39;, .N)
         ENDFILE(UNIT)
         DETACH(.F)
         UNIT = IO_FINDUNIT()
         INPUT(.F, UNIT,, TEMP_)                             <b>:F(FILERR_)</b>
         HOST(HOST_SYSCMD, EDITOR &#39; &#39; TEMP_)
         FN2_ = FN_
         CLEAR_()
         FN_ = FN2_
         LN_ = 1
EDIT3_   INPT_ = LN_ &#39; &#39; F                                    <b>:F(EDIT4_)</b>
         PRSLIN_()
         LN_ = LN_ + 1                                         <b>:(EDIT3_)</b>
EDIT4_   ENDFILE(UNIT)
         DETACH(.F)
         DELETE(TEMP_)                                         <b>:(RETURN)</b>
EDIT2_   CHECKLN_(LN_)                                        <b>:F(RETURN)</b>
         INPT_ = EDITLINE(&#39;EDIT: &#39;, LPAD(LN_, 4, &#39;0&#39;) &#39; &#39; SRC_&lt;LN_&gt;)
+                                                             <b>:(PRSLIN_)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Use <font face="Source Code Pro">DDT</font> to debug the retained program.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Saves file with an entry to <font face="Source Code Pro">DDT()</font> jammed in as the first lines.
An <font face="Source Code Pro">END</font> label is added at the end. The file is compiled with
a listing, and then spawned as a separate process. We assume that
the subprocess wilL be ok with the standard options - but we do add
<font face="Source Code Pro">-b</font> to suppress the normal banner. Label <font face="Source Code Pro">CODE_RETAINED_PROGRAM</font>
is inserted to allow <font face="Source Code Pro">DDT</font>'s <font face="Source Code Pro">LABEL+OFFSET</font> to make sense
on initial entry. Label <font face="Source Code Pro">E</font> is added to the end, because it is
possible that <font face="Source Code Pro">:(E)</font> is used in the retained program (instead of
<font face="Source Code Pro">:(END)</font>). <font face="Source Code Pro">END</font> is typically not used in the retained program
because it is being prepared interactively.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: DDT
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
We copy all lines beginning with -INCLUDE before inserting the
DDT codes.  This allows debugging retained programs with -INCLUDE
directives. Because of single inclusion, we don't bother removing
the lines from the rest of the source. They won't do anything.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ddt&raquo;&equiv;</b>
DDT__    TERMINAL = &#39;STARTING DDT&#39;
         TEMPSRC_ = BQ(&#39;mktemp&#39;)
         TEMPLST_ = BQ(&#39;mktemp&#39;)
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, TEMPSRC_)                         <b>:F(FILERR_)</b>
         F = &quot;-INCLUDE &#39;DDT.INC&#39;&quot;
         SEQ(&#39; F = ?(SRC_&lt;N&gt; ? INPAT_) SRC_&lt;N&gt;; SRC_&lt;N&gt; &#39;, .N)
         F = &#39; DDT()&#39;
         F = &#39;CODE_RETAINED_PROGRAM&#39;
         SEQ(&#39; F = VDIFFER(SRC_&lt;N&gt;); SRC_&lt;N&gt; &#39;, .N)
         F = &#39;E&#39;
         F = &#39;END&#39;
         ENDFILE(UNIT)
         DETACH(.F)
         HOST(HOST_SYSCMD, &#39;snobol4 -n -b -l &#39; TEMPLST_ &#39; &#39; TEMPSRC_)
         HOST(HOST_SYSCMD, &#39;LIST=&#39; TEMPLST_ &#39; snobol4 -B -b &#39; TEMPSRC_)
         TERMINAL = &#39;DDT COMPLETED&#39;
         DELETE(TEMPSRC_)
         DELETE(TEMPLST_)                                      <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Run retained program. Transfer control to first line <font face="Source Code Pro">L__1</font>, or
specified line.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: RUN                  RUN FROM LINE 1
| CODE: RUN 50               RUN FROM LINE 50
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;run&raquo;&equiv;</b>
RUN_     LN_ = IDENT(LN_) 1
         CHECKLN_(LN_)                                        <b>:F(RETURN)</b>
         &amp;TRACE = 0                                      <b>:($(&#39;L__&#39; LN_))</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
List retained program.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: LIST                 LIST ALL LINES
| CODE: LIST 10              LIST LINE 10
| CODE: LIST 10,50           LIST LINES BETWEEN 10 AND 50
| CODE: LIST ,50             LIST ALL LINES UP TO 50
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;list&raquo;&equiv;</b>
LIST_    N2_ = IDENT(N2_) VDIFFER(N1_)
         SEQ(&#39; TERMINAL = LPAD(N, 4, &quot;0&quot;) &quot; &quot; VDIFFER(SRC_&lt;N&gt;); &#39;
+            &#39; SRC_&lt;N&gt; &#39;, .N, N1_, N2_)                        <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Save retained program. Default file is <font face="Source Code Pro">SCRATCH</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: SAVE                 SAVE TO LAST FILENAME
| CODE: SAVE 'MYFILE'        SAVE TO MYFILE
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;save&raquo;&equiv;</b>
SAVE_    TERMINAL = &#39;SAVING TO &#39; FN_
         UNIT = IO_FINDUNIT()
         OUTPUT(.F, UNIT,, FN_)                              <b>:F(FILERR_)</b>
         SEQ(&#39; F = LPAD(N, 4, &quot;0&quot;) &quot; &quot; VDIFFER(SRC_&lt;N&gt;); &#39;
+            &#39; SRC_&lt;N&gt; &#39;, .N)
         ENDFILE(UNIT)
         DETACH(.F)                                            <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Load retained program. Default file is <font face="Source Code Pro">SCRATCH</font>. If another name
is given, remember for future <font face="Source Code Pro">SAVE</font> (or <font face="Source Code Pro">LOAD</font>). Doesn't clear
the retained program, allowing programs to be merged. Use <font face="Source Code Pro">SCRATCH</font>
before <font face="Source Code Pro">LOAD</font> if required.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: LOAD                 LOAD FROM LAST FILENAME
| CODE: LOAD 'MYFILE'        LOAD FROM MYFILE
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;load&raquo;&equiv;</b>
LOAD_    TERMINAL = &#39;LOADING FROM &#39; FN_
         UNIT = IO_FINDUNIT()
         INPUT(.F, UNIT,, FN_)                               <b>:F(FILERR_)</b>
LOAD2_   INPT_ = F                                            <b>:F(LOAD3_)</b>
         PRSLIN_()                                             <b>:(LOAD2_)</b>
LOAD3_   ENDFILE(UNIT)
         DETACH(.F)                                            <b>:(RETURN)</b>
FILERR_  TERMINAL = &#39;CANNOT OPEN FILE&#39;                         <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">NAME</font> displays current name, or sets new name
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: NAME                 DISPLAY FILENAME
| CODE: NAME 'MYFILE'        SET FILENAME
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;name&raquo;&equiv;</b>
NAME_    TERMINAL = IDENT(FN2_) &#39;FILE: &#39; FN_                  <b>:S(RETURN)</b>
         FN_ = FN2_                                            <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">RENUM</font> (assign new line numbers) to retained program. Uses 10 as the
increment, unless there are too many lines, in which case 5 (4, 3,
or even 2) may be used as increments (5 is preferred).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: RENUM                RENUMBER FROM 10 BY 10
| CODE: RENUM 1000           RENUMBER FROM 1000 BY 10
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;renum&raquo;&equiv;</b>
RENUM_   LN_ = IDENT(LN_) 10
         CHECKLN_(LN_)                                        <b>:F(RETURN)</b>
         SC = 0
         SEQ(&#39; SC = DIFFER(SRC_&lt;N&gt;) SC + 1; SRC_&lt;N&gt; &#39;, .N)
         EQ(SC)                                               <b>:S(RETURN)</b>
         Q = (NMAX_ - LN_) / SC
         TERMINAL =  LE(Q, 1) &#39;TOO MANY LINES TO RENUMBER&#39;    <b>:S(RETURN)</b>
         INCR = 10
         INCR = GE(Q, 5) LT(Q, 10) 5
         INCR = GT(Q, 1) LT(Q, 5) Q
         TERMINAL = &#39;RENUMBERING BY &#39; INCR &#39; FROM &#39; LN_
         UNIT = IO_FINDUNIT()
         INPUT(.IN, UNIT, &#39;U&#39;, &#39;/dev/tmpfile&#39;)
         OUTPUT(.OUT, UNIT, &#39;W&#39;)
         SEQ(&#39; OUT = LN_ &quot; &quot; VDIFFER(SRC_&lt;N&gt;); &#39;
+            &#39; LN_ = DIFFER(SRC_&lt;N&gt;) LN_ + INCR; SRC_&lt;N&gt; &#39;, .N)
         FN2_ = FN_
         CLEAR_()
         FN_ = FN2_
         FN_ = VDIFFER(FN2_)
RENUM2_  INPT_ = IN                                          <b>:F(RENUM3_)</b>
         PRSLIN_()                                            <b>:(RENUM2_)</b>
RENUM3_  ENDFILE(UNIT)
         DETACH(.OUT)
         DETACH(.IN)                                           <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Label <font face="Source Code Pro">E</font> for program completion.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;complete&raquo;&equiv;</b>
E        TERMINAL = &#39;PROGRAM COMPLETE&#39;                         <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Evaluate and print expression
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: =1 + 3
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;eval&raquo;&equiv;</b>
EVAL_    TERMINAL = EVAL(CODE)                                 <b>:S(S)F(F)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Shell to external program
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: !ls
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;shell&raquo;&equiv;</b>
EXEC_    HOST(HOST_SYSCMD, CODE)                               <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Give help for the <font face="Source Code Pro">code</font> program.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE: ?
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;help&raquo;&equiv;</b>
HELP_    TERMINAL = &#39;=EXPRESSION    DISPLAY VALUE OF EXPRESSION&#39;
         TERMINAL = &#39;!COMMAND       SHELL OUT TO COMMAND&#39;
         TERMINAL = &#39;?              THIS HELP&#39;
         TERMINAL = &#39;STATEMENT      EXECUTE STATEMENT&#39;
         TERMINAL =
         TERMINAL = &#39;N STATEMENT    ENTER/REPLACE/DELETE PROGRAM LINE&#39;
         TERMINAL = &#39;RUN [N]        RUN RETAINED PROGRAM&#39;
         TERMINAL = &#39;DDT            DDT ON RETAINED PROGRAM&#39;
         TERMINAL = &#39;LIST [[N][,M]] LIST RETAINED PROGRAM&#39;
         TERMINAL = &#39;EDIT [N]       EDIT RETAINED PROGRAM&#39;
         TERMINAL = &quot;SAVE [&#39;FILE&#39;]  SAVE RETAINED PROGRAM&quot;
         TERMINAL = &quot;LOAD [&#39;FILE&#39;]  LOAD RETAINED PROGRAM&quot;
         TERMINAL = &quot;NAME [&#39;FILE&#39;]  CHANGE OR DISPLAY NAME&quot;
         TERMINAL = &#39;SCRATCH        CLEAR RETAINED PROGRAM&#39;
         TERMINAL = &#39;RENUM [N]      RENUMBER RETAINED PROGRAM&#39;
         TERMINAL = &#39;QUIT           EXIT CODE&#39;
         TERMINAL =
         TERMINAL =
+ &#39;-INCLUDE IS PROCESSED IMMEDIATELY ON ENTRY. CONTINUATION LINES ARE&#39;
         TERMINAL =
+ &#39;NOT AVAILABLE. LINES ARE IN THE RANGE 1..&#39; NMAX_
         TERMINAL =
         TERMINAL = &#39;S, F, AND E LABELS AVAILABLE&#39;
         TERMINAL = &#39;SLOAD(&#39; Q_ &#39;FILE&#39; Q_ &#39;) AVAILABLE&#39;        <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Hoary interactions between <font face="Source Code Pro">ERRFUN_</font> and <font face="Source Code Pro">BRKFUN_</font>. We need
<font face="Source Code Pro">ERRFUN_</font> in some conditions, but the <font face="Source Code Pro">EXIT</font> trap may be triggered
anyway on return from <font face="Source Code Pro">ERRFUN_</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;error function&raquo;&equiv;</b>
ERRFUN_
         (NE(&amp;ERRTYPE, 34) SETEXIT())
         EQ(&amp;ERRTYPE, 34)                                     <b>:S(RETURN)</b>
         TERMINAL = &#39;EXECUTION ERROR #&#39; &amp;ERRTYPE &#39;, &#39; &amp;ERRTEXT
         TERMINAL = &#39;RETAINED PROGRAM LINE:&#39; DIFFER(LN_)
         TERMINAL = LPAD(VDIFFER(LN_), 4, 0) &#39; &#39; SRC_&lt;LN_&gt;     <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
If <font face="Source Code Pro">BRKFUN_</font> (exit trap) is entered, we need to know if we should
simply resume from the command prompt, or return (again, probably to
the prompt). Our heuristic is to test <font face="Source Code Pro">&amp;FNCLEVEL</font>, and return
if it is 1. If it is 0, a simple branch suffices. If &gt; 0, we also
branch, and (lose) the stack. <font face="Source Code Pro">DDT</font> has a similar problem. Here,
we keep track of <font face="Source Code Pro">&amp;FNCLEVEL</font> in <font face="Source Code Pro">FL_</font>, for reporting and
making return/branch decision.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The issue is that we cannot simply pop the function stack and
bindings. After getting input, and executing <font face="Source Code Pro">RUN</font>, we are one
function deep (<font face="Source Code Pro">NEWLIN_ -&gt; PRSLIN_()</font>). If we see one level
here, we know that we can simply return and this brings us back to
<font face="Source Code Pro">NEWLIN_</font>.  But, since the only thing we *can* do is return, if
the level is 2 or greater, we cannot return (we would wind up back
in the faulty code).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
I would like to be able to pop levels off, until only one remains,
(or zero) and then return, or branch. But I can't! Each function
level will also lock parameters and locals. To get around that
memory leakage, <font face="Source Code Pro">PRSLIN_()</font> has no parameters, and no locals.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;exit trap&raquo;&equiv;</b>
BRKFUN_  ERRTYPE_ = &amp;ERRTYPE
         ERRTEXT_ = &amp;ERRTEXT
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Getting to <font face="Source Code Pro">END</font> triggers <font face="Source Code Pro">&amp;ERRTYPE 0</font>. We don't display
anything, but want to get back to the prompt. An expected <font face="Source Code Pro">END</font>
will have removed the <font face="Source Code Pro">SETEXIT()</font> trap, and we won't wind up here.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Unfortunately, FATAL errors are not trapped. For example
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| CODE:  :(NO_SUCH_LABEL) ;
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
will immediately bail code. So, <font face="Source Code Pro">SAVE</font> before <font face="Source Code Pro">RUN</font>. Just prudent.
Note that labels are not checked until run-time and not compile-time.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;exit trap&raquo;&equiv;</b>
         EQ(ERRTYPE_, 0) EQ(&amp;FNCLEVEL, FL_ + 1)               <b>:S(RETURN)</b>
         EQ(ERRTYPE_, 0)                                     <b>:S(NEWLIN_)</b>
         SETEXIT(&#39;BRKFUN_&#39;)
         &amp;ERRLIMIT = 999999999
         TERMINAL = &#39;ERROR &#39; ERRTYPE_ &#39; (&#39; ERRTEXT_ &#39;)&#39;
+           &#39; AT LEVEL &#39; &amp;FNCLEVEL - FL_ - 1
         TERMINAL = &#39;RETAINED PROGRAM LINE:&#39; DIFFER(LN_)
         TERMINAL = LPAD(VDIFFER(LN_), 4, 0) &#39; &#39; SRC_&lt;LN_&gt;
         EQ(&amp;FNCLEVEL, FL_ + 1)                     <b>:S(RETURN)F(NEWLIN_)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Main program. Re-establish EXIT handler, input a line, parse and
execute it, and then get the next line. Note that history expansion
is done, but lines that begin with ! are considered special. Those
lines are assumed to be external shell execution. The leading ! is
stripped, then history expansion is done, and the ! is added back.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Empty lines are not added to the history. The current FNCLEVEL is
recorded for error handling.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;main&raquo;&equiv;</b>
<b>&laquo;initialize&raquo;</b>
NEWLIN_  SETEXIT(&#39;BRKFUN_&#39;)
         &amp;TRACE = 999999999
         &amp;ERRLIMIT = 999999999
         INPT_ = READLINE(&#39;CODE:&#39;)                             <b>:F(EXIT_)</b>
         INPT_ FENCE &#39;!&#39; REM . CODE                           <b>:F(NEWL2_)</b>
         CODE = HISTORY_EXPAND(CODE)
         INPT_ = &#39;!&#39; CODE                                      <b>:(NEWL3_)</b>
NEWL2_   INPT_ = HISTORY_EXPAND(INPT_)
NEWL3_   INPT_ = TRIM(INPT_)
         ADD_HISTORY(VDIFFER(INPT_))
         FL_ = &amp;FNCLEVEL
         PRSLIN_()                                            <b>:(NEWLIN_)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Parse the input line, branching to the execution routine.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;parse&raquo;&equiv;</b>
PRSLIN_  N1_ =
         N2_ =
         CODE =
         LN_ =
         FN2_ =
         INPT_ EVALPAT_                                        <b>:S(EVAL_)</b>
         INPT_ EXECPAT_                                        <b>:S(EXEC_)</b>
         INPT_ HELPPAT_                                        <b>:S(HELP_)</b>
         INPT_ LISTPAT_                                        <b>:S(LIST_)</b>
         INPT_ RUNPAT_                                          <b>:S(RUN_)</b>
         INPT_ EDITPAT_                                        <b>:S(EDIT_)</b>
         INPT_ QUITPAT_                                        <b>:S(EXIT_)</b>
         INPT_ NEWPAT_                                        <b>:S(CLEAR_)</b>
         INPT_ RENUMPAT_                                      <b>:S(RENUM_)</b>
         INPT_ SAVEPAT_                                        <b>:S(SAVE_)</b>
         INPT_ LOADPAT_                                        <b>:S(LOAD_)</b>
         INPT_ NAMEPAT_                                        <b>:S(NAME_)</b>
         INPT_ DDTPAT_                                         <b>:S(DDT__)</b>
         INPT_ RETNPAT_                                        <b>:S(RETN_)</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;functions&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;ERRFUN_()&#39;)
         DEFINE(&#39;PRSLIN_()&#39;)
         DEFINE(&#39;CHECKLN_(N)&#39;)
         DEFINE(&#39;CLEAR_()&#39;)                                   <b>:(FN_END_)</b>
<font color="#818181"><i>*</i></font>
<b>&laquo;checkln&raquo;</b>
<b>&laquo;clear&raquo;</b>
<font color="#818181"><i>*</i></font>
FN_END_
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;checkln&raquo;&equiv;</b>
CHECKLN_ GT(N) LE(N, NMAX_)                                   <b>:S(RETURN)</b>
         TERMINAL = &#39;LINE NUMBER MUST BE 1 TO &#39; NMAX_         <b>:(FRETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Trap and report conditionally fatal execution errors in user's code.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;initialize&raquo;&equiv;</b>
         &amp;TRACE = 999999999
         TRACE(&#39;ERRTYPE&#39;, &#39;KEYWORD&#39;,, &#39;ERRFUN_&#39;)
         CLEAR_()
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;signon&raquo;&equiv;</b>
         TERMINAL = &#39;CODE (TUE NOV 26 12:25:23 EST 2013)&#39;
         TERMINAL = &#39;ENTER SNOBOL4 STATEMENTS (TRY ? FOR HELP)&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;manifest&raquo;&equiv;</b>
         NMAX_ = 9999
         EDITOR = &#39;ED&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;readline&raquo;&equiv;</b>
         RLAPPNAME(&#39;CODE&#39;)
         READ_HISTORY(&#39;.CODE&#39;)
         STIFLE_HISTORY(50)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;exit&raquo;&equiv;</b>
EXIT_    WRITE_HISTORY(&#39;.CODE&#39;)
         SETEXIT()
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
We have thousands of statements chained together with gotos. These
are traced during COLLECT() and the stack must be large enough.
10,000 empty statements take around 2.5MB of memory, leaving over
5MB for user (with 8MB default).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
A stack size <font face="Source Code Pro">-S</font> of 40000 seems to be fine.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-B&quot; &quot;-s&quot; &quot;-S 40000&quot; &quot;$0&quot; &quot;$@&quot;
<font color="#818181"><i>*</i></font>
-PROGRAM CODE
-TITLE CODE
START_
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #####   #######  ######   #######                   *</i></font>
<font color="#818181"><i>*                 #     #  #     #  #     #  #                         *</i></font>
<font color="#818181"><i>*                 #        #     #  #     #  #                         *</i></font>
<font color="#818181"><i>*                 #        #     #  #     #  #####                     *</i></font>
<font color="#818181"><i>*                 #        #     #  #     #  #                         *</i></font>
<font color="#818181"><i>*                 #     #  #     #  #     #  #                         *</i></font>
<font color="#818181"><i>*                  #####   #######  ######   #######                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CODE              ENTER TEST SNOBOL4 STATEMENTS                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* &quot;THIS IS MY GRANDFATHER&#39;S AXE. MY FATHER REPLACED THE HAFT, AND I    *</i></font>
<font color="#818181"><i>*  PUT A NEW HEAD ON IT. IT&#39;S MY GRANDFATHER&#39;S AXE.&quot;                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ALSO PROVIDES A SIMPLISTIC RETAINED PROGRAM ENVIRONMENT (SIMILAR TO  *</i></font>
<font color="#818181"><i>* BASIC -- INSPIRED BY MTS)                                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* code.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;code&raquo;</b>
END START_
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:50 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>COMB - Number of combinations</h1>

[[COMB(N,M)]] returns the number of combinations of [[N]] things,
taken [[M]] at a time.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<COMB>>=
-MODULE COMB
-PUBLIC COMB()
         DEFINE('COMB(N,M)')                                 :(COMB_END)
*
COMB     COMB = EQ(M, 0) 1                                    :S(RETURN)
         COMB = COMB(N - 1, M - 1) * N / M                     :(RETURN)
*
COMB_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COMB.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL COMB
-EJECT
*
************************************************************************
*                                                                      *
*                     #####   #######  #     #  ######                 *
*                    #     #  #     #  ##   ##  #     #                *
*                    #        #     #  # # # #  #     #                *
*                    #        #     #  #  #  #  ######                 *
*                    #        #     #  #     #  #     #                *
*                    #     #  #     #  #     #  #     #                *
*                     #####   #######  #     #  ######                 *
*                                                                      *
* COMB                        COMBINATIONS                             *
*                                                                      *
************************************************************************
*
* COMB.lss
*
<<COMB>>
*
* CE: .MSNOBOL4;
@
-STITL COMB
-EJECT
*
-LINE 35 "COMB.lss"
************************************************************************
*                                                                      *
*                     #####   #######  #     #  ######                 *
*                    #     #  #     #  ##   ##  #     #                *
*                    #        #     #  # # # #  #     #                *
*                    #        #     #  #  #  #  ######                 *
*                    #        #     #  #     #  #     #                *
*                    #     #  #     #  #     #  #     #                *
*                     #####   #######  #     #  ######                 *
*                                                                      *
* COMB                        COMBINATIONS                             *
*                                                                      *
************************************************************************
*
* COMB.lss
*
-LINE 12 "COMB.lss"
-MODULE COMB
-PUBLIC COMB()
         DEFINE('COMB(N,M)')                                 :(COMB_END)
*
COMB     COMB = EQ(M, 0) 1                                    :S(RETURN)
         COMB = COMB(N - 1, M - 1) * N / M                     :(RETURN)
*
COMB_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>COMB - Number of combinations</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">COMB(N,M)</font> returns the number of combinations of <font face="Source Code Pro">N</font> things,
taken <font face="Source Code Pro">M</font> at a time.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;COMB&raquo;&equiv;</b>
-MODULE COMB
-PUBLIC COMB()
         DEFINE(&#39;COMB(N,M)&#39;)                                 <b>:(COMB_END)</b>
<font color="#818181"><i>*</i></font>
COMB     COMB = EQ(M, 0) 1                                    <b>:S(RETURN)</b>
         COMB = COMB(N - 1, M - 1) * N / M                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
COMB_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;COMB.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL COMB
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                     #####   #######  #     #  ######                 *</i></font>
<font color="#818181"><i>*                    #     #  #     #  ##   ##  #     #                *</i></font>
<font color="#818181"><i>*                    #        #     #  # # # #  #     #                *</i></font>
<font color="#818181"><i>*                    #        #     #  #  #  #  ######                 *</i></font>
<font color="#818181"><i>*                    #        #     #  #     #  #     #                *</i></font>
<font color="#818181"><i>*                    #     #  #     #  #     #  #     #                *</i></font>
<font color="#818181"><i>*                     #####   #######  #     #  ######                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COMB                        COMBINATIONS                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMB.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;COMB&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:51 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COMB.INC'
-LINE 26 "COMB.lss"
         &CODE = 1
         &CODE = 0
END
<h1>compile - Compile a SNOBOL4 program into a real executable</h1>

Compile an application into a custom SNOBOL4 executable. For a complete
stand-alone application, includes must be gathered using <i>bundle</i>.
This utility discards comments, blank lines and non-essential control
cards. Each line is quoted as a C string. Spaces and tabs not in
SNOBOL4 quoted strings are compressed to a single space.

The result is written into the CSNOBOL4 source directory as prog.inc.
CSNOBOL4 is the configured with MEM_IO and memory sizing. CSNOBOL4
is then rebuilt, and the resulting executable which now incorporates
the given SNOBOL4 program is copied to the output.

<b>This utility is considered experimental</b>. Not much testing has
been done. Squeezing the code should be factored out into a separate
<i>squeeze</i> utility. It is possible that even interpreted programs
would benefit (from reduced loading, tokenization and parsing). This
would reduce the function of <i>compile</i> to C quoting and running
the build itself. Continuation lines should be merged by squeezing as
well.

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="HOST.html">HOST</a><br>
<a href="REPL.html">REPL</a><br>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'REPL.INC'
@

<<compile>>=
         TERMINAL = 'COMPILE (THU DEC  5 12:10:58 EST 2013)'
*
         DEFINE('SQUISH(S)')
         DEFINE('PROCESS()')
         SNOBOL_LOC = '/export/home/fred/Projects/snobol4-1.5'
         QQ = '"'
         Q = "'"
         CC2 = '-EJECT' | '-eject' | '-LIST' | '-list' | '-HIDE' |
+              '-hide' | '-LINE' | '-line' | '-TITLE' | '-title' |
+              '-stitl' | '-STITL'
         CCPAT = FENCE (ANY('*#!|') | CC2 | RPOS(0))
         &TRIM =  1
*
         APP_ISTACK = 4000
         APP_PMSTACK = 8000
         APP_DYNAMIC = 524288
         OPT = 2
         INFILE =
         OUTFILE =
OPTLOOP  S = HOST(HOST_ARGN, OPT = OPT + 1)                    :F(USAGE)
         SW =
         SW = ?(S ? POS(0) '-S') .APP_ISTACK
         SW = ?(S ? POS(0) '-P') .APP_PMSTACK
         SW = ?(S ? POS(0) '-d') .APP_DYNAMIC
         IDENT(SW)                                                :S(FN)
         V = HOST(HOST_ARGN, OPT = OPT + 1)                    :F(USAGE)
         $SW = V                                             :S(OPTLOOP)
FN       S POS(0) '-'                                          :S(USAGE)
         INFILE = IDENT(INFILE) S                            :S(OPTLOOP)
         OUTFILE = IDENT(OUTFILE) S
         (DIFFER(INFILE) DIFFER(OUTFILE))                         :S(GO)        
*
USAGE    TERMINAL = 'USAGE: COMPILE OPTIONS INFILE OUTFILE'
         TERMINAL =
         TERMINAL = 'OPTIONS: -S ISTACK (' APP_ISTACK ')'
         TERMINAL = '         -P PSTACK (' APP_PMSTACK ')'
         TERMINAL = '         -d DYNAMIC (' APP_DYNAMIC ')'
         TERMINAL =
         N = HOST(HOST_DESCR_BITS) / 8
         TERMINAL = 'VALUES ARE IN ' N ' BYTE DESCRIPTORS, SO THAT IS '
+                   APP_DYNAMIC * N / 1024 / 1024 'MB OF DYNAMIC SPACE'
+                                                                 :(END)
*
GO       TERMINAL = 'COMPILING ' INFILE ' TO ' OUTFILE
         TERMINAL = '  ISTACK  = ' LPAD(APP_ISTACK, 7)
         TERMINAL = '  PMSTACK = ' LPAD(APP_PMSTACK, 7)
         TERMINAL = '  DYNAMIC = ' LPAD(APP_DYNAMIC, 7)
         TERMINAL = 'PROCESSING SNOBOL4 CODE'
*
         OUNIT = IO_FINDUNIT()
         SUNIT = IO_FINDUNIT()
         OUTPUT(.OBJ, OUNIT,, SNOBOL_LOC '/lib/prog.inc')
         INPUT(.SRC, SUNIT,, INFILE)                             :S(GO2)
         TERMINAL = "CAN'T OPEN " INFILE                          :(END)
GO2      PROCESS()
         ENDFILE(OUNIT)
         ENDFILE(SUNIT)
         DETACH(.OBJ)
         DETACH(.SRC)
*
* WE SHOULD CHECK THE CONFIGURATION (IN CONFIG.H), AND IF OUR CHANGES
* ARE THERE WE CAN SKIP THE CLEAN AND CONFIG. WE SHOULD ALSO CHECK
* IF OUR PATCHED INIT.C FILE IS THERE AND PLACE IT IF NEEDED.
*
         TERMINAL = 'CONFIGURING FOR COMPILATION'
         HOST(HOST_SYSCMD, '(cd ' SNOBOL_LOC '; make clean)'
+                          ' > compile.log 2>&1')
         HOST(HOST_SYSCMD,
+              '(cd ' SNOBOL_LOC ';'
+               './configure --add-define=MEM_IO'
+                          ' --add-define=MEM_IO_TEST'
+                          ' --add-define=APP_ISTACK='  APP_ISTACK
+                          ' --add-define=APP_PMSTACK=' APP_PMSTACK
+                          ' --add-define=APP_DYNAMIC=' APP_DYNAMIC
+              ') >> compile.log 2>&1')
*
         TERMINAL = 'COMPILING'
         HOST(HOST_SYSCMD, '(cd ' SNOBOL_LOC '; make)'
+                          ' >> compile.log 2>&1')
*
         TERMINAL = 'CREATING EXECUTABLE'
         HOST(HOST_SYSCMD, '(cp ' SNOBOL_LOC '/xsnobol4 ' OUTFILE
+                ') >> compile.log 2>&1')                         
*
         TERMINAL = 'A LOG FILE IS IN compile.log'                :(END)
*
PROCESS  L = SRC                                              :F(RETURN)
*
* IGNORE COMMENTS, EMPTY LINES, MOST CONTROL CARDS
*
         L CCPAT                                             :S(PROCESS)
*
* CONVERT EACH LINE INTO A C STRING - QUOTE " AND \, ADD A NEWLINE
* AND WRAP IN "". ALSO, SQUISH SPACES/TABS THAT ARE NOT QUOTED TO
* SINGLE SPACES, SAVING SPACE FOR THE C COMPILER. I HAVE TESTED GCC
* WITH A STRING CONSTANT OF UP TO 256000 CHARACTERS, BUT WE SHOULD
* TRY TO CONSERVE THIS.
*
         L = REPL(L, '\', '\\')
         L = REPL(L, '"', '\"')
         R = L
         S =
SS       R ARB . L (Q | QQ) $ DELIM ARB . M *DELIM REM . R      :F(DONE)
         S = S SQUISH(L) DELIM M DELIM                             :(SS)
DONE     S = QQ S SQUISH(R) '\n' QQ
         OBJ = S                                              :(PROCESS)
*
SQUISH   S = REPL(S, CHARS_TAB, ' ')
SQUISH2  S '  ' = ' '                                        :S(SQUISH2)
         SQUISH = S                                            :(RETURN)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM COMPILE
-TITLE COMPILE
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*       #####   #######  #     #  ######   ###  #        #######       *
*      #     #  #     #  ##   ##  #     #   #   #        #             *
*      #        #     #  # # # #  #     #   #   #        #             *
*      #        #     #  #  #  #  ######    #   #        #####         *
*      #        #     #  #     #  #         #   #        #             *
*      #     #  #     #  #     #  #         #   #        #             *
*       #####   #######  #     #  #        ###  #######  #######       *
*                                                                      *
* COMPILE  'COMPILE' A SNOBOL4 PROGRAM INTO A REAL EXECUTABLE          *
*                                                                      *
************************************************************************
*
* compile.lss
*
<<compile>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM COMPILE
-LINE 152 "compile.lss"
-TITLE COMPILE
START
-LINE 28 "compile.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'REPL.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*       #####   #######  #     #  ######   ###  #        #######       *
*      #     #  #     #  ##   ##  #     #   #   #        #             *
*      #        #     #  # # # #  #     #   #   #        #             *
*      #        #     #  #  #  #  ######    #   #        #####         *
*      #        #     #  #     #  #         #   #        #             *
*      #     #  #     #  #     #  #         #   #        #             *
*       #####   #######  #     #  #        ###  #######  #######       *
*                                                                      *
* COMPILE  'COMPILE' A SNOBOL4 PROGRAM INTO A REAL EXECUTABLE          *
*                                                                      *
************************************************************************
*
* compile.lss
*
-LINE 34 "compile.lss"
         TERMINAL = 'COMPILE (THU DEC  5 12:10:58 EST 2013)'
*
         DEFINE('SQUISH(S)')
         DEFINE('PROCESS()')
         SNOBOL_LOC = '/export/home/fred/Projects/snobol4-1.5'
         QQ = '"'
         Q = "'"
         CC2 = '-EJECT' | '-eject' | '-LIST' | '-list' | '-HIDE' |
+              '-hide' | '-LINE' | '-line' | '-TITLE' | '-title' |
+              '-stitl' | '-STITL'
         CCPAT = FENCE (ANY('*#!|') | CC2 | RPOS(0))
         &TRIM =  1
*
         APP_ISTACK = 4000
         APP_PMSTACK = 8000
         APP_DYNAMIC = 524288
         OPT = 2
         INFILE =
         OUTFILE =
OPTLOOP  S = HOST(HOST_ARGN, OPT = OPT + 1)                    :F(USAGE)
         SW =
         SW = ?(S ? POS(0) '-S') .APP_ISTACK
         SW = ?(S ? POS(0) '-P') .APP_PMSTACK
         SW = ?(S ? POS(0) '-d') .APP_DYNAMIC
         IDENT(SW)                                                :S(FN)
         V = HOST(HOST_ARGN, OPT = OPT + 1)                    :F(USAGE)
         $SW = V                                             :S(OPTLOOP)
FN       S POS(0) '-'                                          :S(USAGE)
         INFILE = IDENT(INFILE) S                            :S(OPTLOOP)
         OUTFILE = IDENT(OUTFILE) S
         (DIFFER(INFILE) DIFFER(OUTFILE))                         :S(GO)
*
USAGE    TERMINAL = 'USAGE: COMPILE OPTIONS INFILE OUTFILE'
         TERMINAL =
         TERMINAL = 'OPTIONS: -S ISTACK (' APP_ISTACK ')'
         TERMINAL = '         -P PSTACK (' APP_PMSTACK ')'
         TERMINAL = '         -d DYNAMIC (' APP_DYNAMIC ')'
         TERMINAL =
         N = HOST(HOST_DESCR_BITS) / 8
         TERMINAL = 'VALUES ARE IN ' N ' BYTE DESCRIPTORS, SO THAT IS '
+                   APP_DYNAMIC * N / 1024 / 1024 'MB OF DYNAMIC SPACE'
+                                                                 :(END)
*
GO       TERMINAL = 'COMPILING ' INFILE ' TO ' OUTFILE
         TERMINAL = '  ISTACK  = ' LPAD(APP_ISTACK, 7)
         TERMINAL = '  PMSTACK = ' LPAD(APP_PMSTACK, 7)
         TERMINAL = '  DYNAMIC = ' LPAD(APP_DYNAMIC, 7)
         TERMINAL = 'PROCESSING SNOBOL4 CODE'
*
         OUNIT = IO_FINDUNIT()
         SUNIT = IO_FINDUNIT()
         OUTPUT(.OBJ, OUNIT,, SNOBOL_LOC '/lib/prog.inc')
         INPUT(.SRC, SUNIT,, INFILE)                             :S(GO2)
         TERMINAL = "CAN'T OPEN " INFILE                          :(END)
GO2      PROCESS()
         ENDFILE(OUNIT)
         ENDFILE(SUNIT)
         DETACH(.OBJ)
         DETACH(.SRC)
*
* WE SHOULD CHECK THE CONFIGURATION (IN CONFIG.H), AND IF OUR CHANGES
* ARE THERE WE CAN SKIP THE CLEAN AND CONFIG. WE SHOULD ALSO CHECK
* IF OUR PATCHED INIT.C FILE IS THERE AND PLACE IT IF NEEDED.
*
         TERMINAL = 'CONFIGURING FOR COMPILATION'
         HOST(HOST_SYSCMD, '(cd ' SNOBOL_LOC '; make clean)'
+                          ' > compile.log 2>&1')
         HOST(HOST_SYSCMD,
+              '(cd ' SNOBOL_LOC ';'
+               './configure --add-define=MEM_IO'
+                          ' --add-define=MEM_IO_TEST'
+                          ' --add-define=APP_ISTACK='  APP_ISTACK
+                          ' --add-define=APP_PMSTACK=' APP_PMSTACK
+                          ' --add-define=APP_DYNAMIC=' APP_DYNAMIC
+              ') >> compile.log 2>&1')
*
         TERMINAL = 'COMPILING'
         HOST(HOST_SYSCMD, '(cd ' SNOBOL_LOC '; make)'
+                          ' >> compile.log 2>&1')
*
         TERMINAL = 'CREATING EXECUTABLE'
         HOST(HOST_SYSCMD, '(cp ' SNOBOL_LOC '/xsnobol4 ' OUTFILE
+                ') >> compile.log 2>&1')
*
         TERMINAL = 'A LOG FILE IS IN compile.log'                :(END)
*
PROCESS  L = SRC                                              :F(RETURN)
*
* IGNORE COMMENTS, EMPTY LINES, MOST CONTROL CARDS
*
         L CCPAT                                             :S(PROCESS)
*
* CONVERT EACH LINE INTO A C STRING - QUOTE " AND \, ADD A NEWLINE
* AND WRAP IN "". ALSO, SQUISH SPACES/TABS THAT ARE NOT QUOTED TO
* SINGLE SPACES, SAVING SPACE FOR THE C COMPILER. I HAVE TESTED GCC
* WITH A STRING CONSTANT OF UP TO 256000 CHARACTERS, BUT WE SHOULD
* TRY TO CONSERVE THIS.
*
         L = REPL(L, '\', '\\')
         L = REPL(L, '"', '\"')
         R = L
         S =
SS       R ARB . L (Q | QQ) $ DELIM ARB . M *DELIM REM . R      :F(DONE)
         S = S SQUISH(L) DELIM M DELIM                             :(SS)
DONE     S = QQ S SQUISH(R) '\n' QQ
         OBJ = S                                              :(PROCESS)
*
SQUISH   S = REPL(S, CHARS_TAB, ' ')
SQUISH2  S '  ' = ' '                                        :S(SQUISH2)
         SQUISH = S                                            :(RETURN)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>compile - Compile a SNOBOL4 program into a real executable</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Compile an application into a custom SNOBOL4 executable. For a complete
stand-alone application, includes must be gathered using <i>bundle</i>.
This utility discards comments, blank lines and non-essential control
cards. Each line is quoted as a C string. Spaces and tabs not in
SNOBOL4 quoted strings are compressed to a single space.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The result is written into the CSNOBOL4 source directory as prog.inc.
CSNOBOL4 is the configured with MEM_IO and memory sizing. CSNOBOL4
is then rebuilt, and the resulting executable which now incorporates
the given SNOBOL4 program is copied to the output.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<b>This utility is considered experimental</b>. Not much testing has
been done. Squeezing the code should be factored out into a separate
<i>squeeze</i> utility. It is possible that even interpreted programs
would benefit (from reduced loading, tokenization and parsing). This
would reduce the function of <i>compile</i> to C quoting and running
the build itself. Continuation lines should be merged by squeezing as
well.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="HOST.html">HOST</a><br>
<a href="REPL.html">REPL</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;compile&raquo;&equiv;</b>
         TERMINAL = &#39;COMPILE (THU DEC  5 12:10:58 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;SQUISH(S)&#39;)
         DEFINE(&#39;PROCESS()&#39;)
         SNOBOL_LOC = &#39;/export/home/fred/Projects/snobol4-1.5&#39;
         QQ = &#39;&quot;&#39;
         Q = &quot;&#39;&quot;
         CC2 = &#39;-EJECT&#39; | &#39;-eject&#39; | &#39;-LIST&#39; | &#39;-list&#39; | &#39;-HIDE&#39; |
+              &#39;-hide&#39; | &#39;-LINE&#39; | &#39;-line&#39; | &#39;-TITLE&#39; | &#39;-title&#39; |
+              &#39;-stitl&#39; | &#39;-STITL&#39;
         CCPAT = FENCE (ANY(&#39;*#!|&#39;) | CC2 | RPOS(0))
         &amp;TRIM =  1
<font color="#818181"><i>*</i></font>
         APP_ISTACK = 4000
         APP_PMSTACK = 8000
         APP_DYNAMIC = 524288
         OPT = 2
         INFILE =
         OUTFILE =
OPTLOOP  S = HOST(HOST_ARGN, OPT = OPT + 1)                    <b>:F(USAGE)</b>
         SW =
         SW = ?(S ? POS(0) &#39;-S&#39;) .APP_ISTACK
         SW = ?(S ? POS(0) &#39;-P&#39;) .APP_PMSTACK
         SW = ?(S ? POS(0) &#39;-d&#39;) .APP_DYNAMIC
         IDENT(SW)                                                <b>:S(FN)</b>
         V = HOST(HOST_ARGN, OPT = OPT + 1)                    <b>:F(USAGE)</b>
         $SW = V                                             <b>:S(OPTLOOP)</b>
FN       S POS(0) &#39;-&#39;                                          <b>:S(USAGE)</b>
         INFILE = IDENT(INFILE) S                            <b>:S(OPTLOOP)</b>
         OUTFILE = IDENT(OUTFILE) S
         (DIFFER(INFILE) DIFFER(OUTFILE))                         <b>:S(GO)</b>
<font color="#818181"><i>*</i></font>
USAGE    TERMINAL = &#39;USAGE: COMPILE OPTIONS INFILE OUTFILE&#39;
         TERMINAL =
         TERMINAL = &#39;OPTIONS: -S ISTACK (&#39; APP_ISTACK &#39;)&#39;
         TERMINAL = &#39;         -P PSTACK (&#39; APP_PMSTACK &#39;)&#39;
         TERMINAL = &#39;         -d DYNAMIC (&#39; APP_DYNAMIC &#39;)&#39;
         TERMINAL =
         N = HOST(HOST_DESCR_BITS) / 8
         TERMINAL = &#39;VALUES ARE IN &#39; N &#39; BYTE DESCRIPTORS, SO THAT IS &#39;
+                   APP_DYNAMIC * N / 1024 / 1024 &#39;MB OF DYNAMIC SPACE&#39;
+                                                                 <b>:(END)</b>
<font color="#818181"><i>*</i></font>
GO       TERMINAL = &#39;COMPILING &#39; INFILE &#39; TO &#39; OUTFILE
         TERMINAL = &#39;  ISTACK  = &#39; LPAD(APP_ISTACK, 7)
         TERMINAL = &#39;  PMSTACK = &#39; LPAD(APP_PMSTACK, 7)
         TERMINAL = &#39;  DYNAMIC = &#39; LPAD(APP_DYNAMIC, 7)
         TERMINAL = &#39;PROCESSING SNOBOL4 CODE&#39;
<font color="#818181"><i>*</i></font>
         OUNIT = IO_FINDUNIT()
         SUNIT = IO_FINDUNIT()
         OUTPUT(.OBJ, OUNIT,, SNOBOL_LOC &#39;/lib/prog.inc&#39;)
         INPUT(.SRC, SUNIT,, INFILE)                             <b>:S(GO2)</b>
         TERMINAL = &quot;CAN&#39;T OPEN &quot; INFILE                          <b>:(END)</b>
GO2      PROCESS()
         ENDFILE(OUNIT)
         ENDFILE(SUNIT)
         DETACH(.OBJ)
         DETACH(.SRC)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE SHOULD CHECK THE CONFIGURATION (IN CONFIG.H), AND IF OUR CHANGES</i></font>
<font color="#818181"><i>* ARE THERE WE CAN SKIP THE CLEAN AND CONFIG. WE SHOULD ALSO CHECK</i></font>
<font color="#818181"><i>* IF OUR PATCHED INIT.C FILE IS THERE AND PLACE IT IF NEEDED.</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;CONFIGURING FOR COMPILATION&#39;
         HOST(HOST_SYSCMD, &#39;(cd &#39; SNOBOL_LOC &#39;; make clean)&#39;
+                          &#39; &gt; compile.log 2&gt;&amp;1&#39;)
         HOST(HOST_SYSCMD,
+              &#39;(cd &#39; SNOBOL_LOC &#39;;&#39;
+               &#39;./configure --add-define=MEM_IO&#39;
+                          &#39; --add-define=MEM_IO_TEST&#39;
+                          &#39; --add-define=APP_ISTACK=&#39;  APP_ISTACK
+                          &#39; --add-define=APP_PMSTACK=&#39; APP_PMSTACK
+                          &#39; --add-define=APP_DYNAMIC=&#39; APP_DYNAMIC
+              &#39;) &gt;&gt; compile.log 2&gt;&amp;1&#39;)
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;COMPILING&#39;
         HOST(HOST_SYSCMD, &#39;(cd &#39; SNOBOL_LOC &#39;; make)&#39;
+                          &#39; &gt;&gt; compile.log 2&gt;&amp;1&#39;)
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;CREATING EXECUTABLE&#39;
         HOST(HOST_SYSCMD, &#39;(cp &#39; SNOBOL_LOC &#39;/xsnobol4 &#39; OUTFILE
+                &#39;) &gt;&gt; compile.log 2&gt;&amp;1&#39;)
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;A LOG FILE IS IN compile.log&#39;                <b>:(END)</b>
<font color="#818181"><i>*</i></font>
PROCESS  L = SRC                                              <b>:F(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IGNORE COMMENTS, EMPTY LINES, MOST CONTROL CARDS</i></font>
<font color="#818181"><i>*</i></font>
         L CCPAT                                             <b>:S(PROCESS)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONVERT EACH LINE INTO A C STRING - QUOTE &quot; AND \, ADD A NEWLINE</i></font>
<font color="#818181"><i>* AND WRAP IN &quot;&quot;. ALSO, SQUISH SPACES/TABS THAT ARE NOT QUOTED TO</i></font>
<font color="#818181"><i>* SINGLE SPACES, SAVING SPACE FOR THE C COMPILER. I HAVE TESTED GCC</i></font>
<font color="#818181"><i>* WITH A STRING CONSTANT OF UP TO 256000 CHARACTERS, BUT WE SHOULD</i></font>
<font color="#818181"><i>* TRY TO CONSERVE THIS.</i></font>
<font color="#818181"><i>*</i></font>
         L = REPL(L, &#39;\&#39;, &#39;\\&#39;)
         L = REPL(L, &#39;&quot;&#39;, &#39;\&quot;&#39;)
         R = L
         S =
SS       R ARB . L (Q | QQ) $ DELIM ARB . M *DELIM REM . R      <b>:F(DONE)</b>
         S = S SQUISH(L) DELIM M DELIM                             <b>:(SS)</b>
DONE     S = QQ S SQUISH(R) &#39;\n&#39; QQ
         OBJ = S                                              <b>:(PROCESS)</b>
<font color="#818181"><i>*</i></font>
SQUISH   S = REPL(S, CHARS_TAB, &#39; &#39;)
SQUISH2  S &#39;  &#39; = &#39; &#39;                                        <b>:S(SQUISH2)</b>
         SQUISH = S                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM COMPILE
-TITLE COMPILE
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*       #####   #######  #     #  ######   ###  #        #######       *</i></font>
<font color="#818181"><i>*      #     #  #     #  ##   ##  #     #   #   #        #             *</i></font>
<font color="#818181"><i>*      #        #     #  # # # #  #     #   #   #        #             *</i></font>
<font color="#818181"><i>*      #        #     #  #  #  #  ######    #   #        #####         *</i></font>
<font color="#818181"><i>*      #        #     #  #     #  #         #   #        #             *</i></font>
<font color="#818181"><i>*      #     #  #     #  #     #  #         #   #        #             *</i></font>
<font color="#818181"><i>*       #####   #######  #     #  #        ###  #######  #######       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COMPILE  &#39;COMPILE&#39; A SNOBOL4 PROGRAM INTO A REAL EXECUTABLE          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* compile.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;compile&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:51 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>COMPLEX - Complex numbers</h1>

Basic arithmetic on complex numbers. Not complete yet.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<COMPLEX>>=
-MODULE COMPLEX
-PUBLIC COMPLEX(), R(), I()
         DATA('COMPLEX(R,I)')
*
-PUBLIC ADD_COMPLEX(), MUL_COMPLEX(), NEG_COMPLEX(), INV_COMPLEX()
-PUBLIC PRINT_COMPLEX()
         DEFINE('ADD_COMPLEX(X,Y)')
         DEFINE('MUL_COMPLEX(X,Y)A,B,C,D')
         DEFINE('NEG_COMPLEX(X)')
         DEFINE('INV_COMPLEX(X)D')
         DEFINE('PRINT_COMPLEX(X)SIGN')                   :(COMPLEX_END)
*
ADD_COMPLEX
         ADD_COMPLEX = COMPLEX(R(X) + R(Y), I(X) + I(Y))       :(RETURN)
*
MUL_COMPLEX
         A = R(X); B = I(X); C = R(Y); D = I(Y)
         MUL_COMPLEX = COMPLEX(A * C - B * D, B * C + A * D)   :(RETURN)
*
NEG_COMPLEX
         NEG_COMPLEX = COMPLEX(-R(X), -I(X))                   :(RETURN)
*
INV_COMPLEX
         D = (R(X) * R(X)) + (I(X) * I(X))
         INV_COMPLEX = COMPLEX(1.0 * R(X) / D, 1.0 * -I(X) / D)
+                                                              :(RETURN)
* 
PRINT_COMPLEX
         SIGN = GE(I(X)) '+'
         PRINT_COMPLEX = R(X) SIGN I(X) 'i'                    :(RETURN)
*
COMPLEX_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COMPLEX.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL COMPLEX
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*     #####   #######  #     #  ######   #        #######  #     #     *
*    #     #  #     #  ##   ##  #     #  #        #         #   #      *
*    #        #     #  # # # #  #     #  #        #          # #       *
*    #        #     #  #  #  #  ######   #        #####       #        *
*    #        #     #  #     #  #        #        #          # #       *
*    #     #  #     #  #     #  #        #        #         #   #      *
*     #####   #######  #     #  #        #######  #######  #     #     *
*                                                                      *
*                                                                      *
* COMPLEX                   COMPLEX NUMBERS                            *
*                                                                      *
************************************************************************
*
* COMPLEX.lss
*
<<COMPLEX>>
*
* CE: .MSNOBOL4;
@
-STITL COMPLEX
-EJECT
*
-LINE 58 "COMPLEX.lss"
************************************************************************
*                                                                      *
*                                                                      *
*     #####   #######  #     #  ######   #        #######  #     #     *
*    #     #  #     #  ##   ##  #     #  #        #         #   #      *
*    #        #     #  # # # #  #     #  #        #          # #       *
*    #        #     #  #  #  #  ######   #        #####       #        *
*    #        #     #  #     #  #        #        #          # #       *
*    #     #  #     #  #     #  #        #        #         #   #      *
*     #####   #######  #     #  #        #######  #######  #     #     *
*                                                                      *
*                                                                      *
* COMPLEX                   COMPLEX NUMBERS                            *
*                                                                      *
************************************************************************
*
* COMPLEX.lss
*
-LINE 11 "COMPLEX.lss"
-MODULE COMPLEX
-PUBLIC COMPLEX(), R(), I()
         DATA('COMPLEX(R,I)')
*
-PUBLIC ADD_COMPLEX(), MUL_COMPLEX(), NEG_COMPLEX(), INV_COMPLEX()
-PUBLIC PRINT_COMPLEX()
         DEFINE('ADD_COMPLEX(X,Y)')
         DEFINE('MUL_COMPLEX(X,Y)A,B,C,D')
         DEFINE('NEG_COMPLEX(X)')
         DEFINE('INV_COMPLEX(X)D')
         DEFINE('PRINT_COMPLEX(X)SIGN')                   :(COMPLEX_END)
*
ADD_COMPLEX
         ADD_COMPLEX = COMPLEX(R(X) + R(Y), I(X) + I(Y))       :(RETURN)
*
MUL_COMPLEX
         A = R(X); B = I(X); C = R(Y); D = I(Y)
         MUL_COMPLEX = COMPLEX(A * C - B * D, B * C + A * D)   :(RETURN)
*
NEG_COMPLEX
         NEG_COMPLEX = COMPLEX(-R(X), -I(X))                   :(RETURN)
*
INV_COMPLEX
         D = (R(X) * R(X)) + (I(X) * I(X))
         INV_COMPLEX = COMPLEX(1.0 * R(X) / D, 1.0 * -I(X) / D)
+                                                              :(RETURN)
*
PRINT_COMPLEX
         SIGN = GE(I(X)) '+'
         PRINT_COMPLEX = R(X) SIGN I(X) 'i'                    :(RETURN)
*
COMPLEX_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>COMPLEX - Complex numbers</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Basic arithmetic on complex numbers. Not complete yet.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;COMPLEX&raquo;&equiv;</b>
-MODULE COMPLEX
-PUBLIC COMPLEX(), R(), I()
         DATA(&#39;COMPLEX(R,I)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC ADD_COMPLEX(), MUL_COMPLEX(), NEG_COMPLEX(), INV_COMPLEX()
-PUBLIC PRINT_COMPLEX()
         DEFINE(&#39;ADD_COMPLEX(X,Y)&#39;)
         DEFINE(&#39;MUL_COMPLEX(X,Y)A,B,C,D&#39;)
         DEFINE(&#39;NEG_COMPLEX(X)&#39;)
         DEFINE(&#39;INV_COMPLEX(X)D&#39;)
         DEFINE(&#39;PRINT_COMPLEX(X)SIGN&#39;)                   <b>:(COMPLEX_END)</b>
<font color="#818181"><i>*</i></font>
ADD_COMPLEX
         ADD_COMPLEX = COMPLEX(R(X) + R(Y), I(X) + I(Y))       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MUL_COMPLEX
         A = R(X); B = I(X); C = R(Y); D = I(Y)
         MUL_COMPLEX = COMPLEX(A * C - B * D, B * C + A * D)   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
NEG_COMPLEX
         NEG_COMPLEX = COMPLEX(-R(X), -I(X))                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
INV_COMPLEX
         D = (R(X) * R(X)) + (I(X) * I(X))
         INV_COMPLEX = COMPLEX(1.0 * R(X) / D, 1.0 * -I(X) / D)
+                                                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
PRINT_COMPLEX
         SIGN = GE(I(X)) &#39;+&#39;
         PRINT_COMPLEX = R(X) SIGN I(X) &#39;i&#39;                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
COMPLEX_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;COMPLEX.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL COMPLEX
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*     #####   #######  #     #  ######   #        #######  #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #  ##   ##  #     #  #        #         #   #      *</i></font>
<font color="#818181"><i>*    #        #     #  # # # #  #     #  #        #          # #       *</i></font>
<font color="#818181"><i>*    #        #     #  #  #  #  ######   #        #####       #        *</i></font>
<font color="#818181"><i>*    #        #     #  #     #  #        #        #          # #       *</i></font>
<font color="#818181"><i>*    #     #  #     #  #     #  #        #        #         #   #      *</i></font>
<font color="#818181"><i>*     #####   #######  #     #  #        #######  #######  #     #     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COMPLEX                   COMPLEX NUMBERS                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMPLEX.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;COMPLEX&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:42 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COMPLEX.INC'
-LINE 49 "COMPLEX.lss"
         &CODE = 1
         &CODE = 0
END
<h1>COOKIE - COOKIE Support Functions</h1>

Cookie support functions. Cookies are saved in a cookie jar, which is
a table. In turn, each cookie has a value, and may have attributes
(cookie and attributes are crumbs). The cookie is itself stored as a
table.

Thus a cookie jar resembles an SQL table.

Browsers support 5 crumbs: Expires, Path, Secure, HttpOnly and the
default (value) crumb. Some browsers may support Max-Age.

[[RFC2965]] (and [[RFC2616]]) indicates that attribute names are
case in-sensitive. Space may be added between tokens. [[Max-Age=0]]
effectively ends a session.

Set-Cookie2:
Comment= CommentURL= Discard Domain= Max-Age= Path= Port=".." Secure
Version=1

Cache-control: no-cache="set-cookie2"
Cache-control: private

Cookie: $Version = v ;|,... name=value; $Path= v; $Domain= v; $Port="..."
Names beginning with $ are attributes

Names and values should be in the character set !..~. ',' and ';'
are not allowed. '=' is not allowed in a name.

Attributes are not returned when the cookie is returned from the
browser.

[[COOKIE_EXPIRY(N)]] returns the expiry string for [[N]] seconds in
the future. [[COOKIE_STRING(JAR)]] returns a string with all cookie
definitions ready to be sent to the browser. There is no attempt to
restrict attributes or characters used. That is left to the caller.
If a cookie with a bad name is crafted by the browser, it will simply
be returned (probably as a session cookie).

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="DEXP.html">DEXP</a><br>
<a href="HASH.html">HASH</a><br>
<a href="TIME.html">TIME</a><br>
<a href="TRIMB.html">TRIMB</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'DEXP.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'TIME.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
@

<<COOKIE>>=
-PUBLIC NEW_COOKIE_JAR(), NEW_COOKIE(), COOKIE_SET_VALUE()
-PUBLIC COOKIE_VALUE(), COOKIE_SET_CRUMB(), COOKIE_GET_CRUMB()
-PUBLIC PUT_COOKIE_IN_JAR(), GET_COOKIE_FROM_JAR(), COOKIES_IN_JAR()
-PUBLIC CRUMBS_IN_COOKIE(), COOKIE_EXPIRY(), COOKIE_STRING()
-PuBLIC COOKIE_FIX_NAME()
*
         DEFINE('NEW_COOKIE_JAR()')
         DEFINE('NEW_COOKIE(VALUE)')
         DEFINE('COOKIE_SET_VALUE(COOKIE,VALUE)')
         DEFINE('COOKIE_VALUE(COOKIE)')
         DEFINE('COOKIE_SET_CRUMB(COOKIE,CRUMB_NAME,VALUE)')
         DEFINE('COOKIE_GET_CRUMB(COOKIE,CRUMB_NAME)')
         DEFINE('PUT_COOKIE_IN_JAR(COOKIE_JAR,COOKIE_NAME,COOKIE)')
         DEFINE('GET_COOKIE_FROM_JAR(COOKIE_JAR,COOKIE_NAME)')
         DEFINE('COOKIES_IN_JAR(COOKIE_JAR)')
         DEFINE('CRUMBS_IN_COOKIE(COOKIE)')
         DEFINE('COOKIE_EXPIRY(N)T,D,M,S')
         DEXP('L20_(S) = LPAD(S, 2, "0")')
         DEFINE('COOKIE_STRING(COOKIE_JAR)A,B,C,I,J,S,V')
         DEFINE('COOKIE_FIX_NAME(S)')
                                                           :(COOKIE_END)
*
* RETURN COOKIE STRING 
*
COOKIE_STRING
         A = COOKIES_IN_JAR(COOKIE_JAR)                       :F(RETURN)
COOKIE_STRING_2
         I = I + 1
         C = GET_COOKIE_FROM_JAR(COOKIE_JAR, A<I>)   :F(COOKIE_STRING_5)
         B = CRUMBS_IN_COOKIE(C)                     :F(COOKIE_STRING_2)
         S = S 'Set-Cookie: ' A<I> '=' COOKIE_VALUE(C)
         J = 1
COOKIE_STRING_3
         J = J + 1
         V = COOKIE_GET_CRUMB(C, B<J>)               :F(COOKIE_STRING_4)
         S = S '; ' B<J>
         S = S '=' VDIFFER(V)                         :(COOKIE_STRING_3)
COOKIE_STRING_4
         S = S CHARS_CR CHARS_NL                      :(COOKIE_STRING_2)
COOKIE_STRING_5
         COOKIE_STRING = S                                     :(RETURN)
*
* RETURN EXPIRES STRING FOR N SECONDS IN THE FUTURE. THIS STRING IS
* IN THE FORMAT:
* Wed, 09 Jun 2021 10:18:14 GMT
* ALL COOKIE EXPIRY IS IN GMT.
*
COOKIE_EXPIRY
         T = TV_SEC(GETTIMEOFDAY()) + N
         T = GMTIME(T)
         '0Sun1Mon2Tue3Wed4Thu5Fri6Sat' TM_WDAY(T) LEN(3) . D
         '0Jan1Feb2Mar3Apr4May5Jun6Jul7Aug8Sep9Oct10Nov11Dec'
+           TM_MON(T) LEN(3) . M
         S = D ', ' L20_(TM_MDAY(T)) ' ' M ' ' (TM_YEAR(T) + 1900)
+        ' ' L20_(TM_HOUR(T)) ':' L20_(TM_MIN(T)) ':' L20_(TM_SEC(T))
+        ' GMT'
         COOKIE_EXPIRY = S                                     :(RETURN)
*
* MAKE A NEW COOKIE JAR
*
NEW_COOKIE_JAR
         NEW_COOKIE_JAR = TABLE()                              :(RETURN)
*
* MAKE A NEW COOKIE
*
NEW_COOKIE
         NEW_COOKIE = TABLE()
         NEW_COOKIE<''> = VDIFFER(VALUE)                       :(RETURN)
*
* SET THE VALUE OF THE COOKIE (ATRIBUTE '')
*
COOKIE_SET_VALUE
         COOKIE<''> = VALUE                                    :(RETURN)
*
* RETURN THE VALUE OF THE COOKIE (ATTRIBUTE '')
*
COOKIE_VALUE
         COOKIE_VALUE = COOKIE<''>                             :(RETURN)
*
COOKIE_FIX_NAME
         S = TRIMB(S)
         S POS(0) '$' REM . S
         COOKIE_FIX_NAME = S                                   :(RETURN)
*
* SET AN ATTRIBUTE ON THE COOKIE
*
COOKIE_SET_CRUMB
         CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
         COOKIE<CRUMB_NAME> = VALUE                            :(RETURN)
*
* GET VALUE OF AN ATTRIBUTE FROM THE COOKIE
*
COOKIE_GET_CRUMB
         CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
         COOKIE_GET_CRUMB = COOKIE<CRUMB_NAME>                 :(RETURN)
*
* PUT THE COOKIE INTO THE COOKIE JAR, WITH NAME COOKIE_NAME
*
PUT_COOKIE_IN_JAR
         COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
         COOKIE_JAR<COOKIE_NAME> = COOKIE                      :(RETURN)
*
* GET COOKIE NAMED COOKIE_NAME FROM THE COOKIE JAR
*
GET_COOKIE_FROM_JAR
         COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
         GET_COOKIE_FROM_JAR = COOKIE_JAR<COOKIE_NAME>         :(RETURN)
*
* RETURN ARRAY OF COOKIE NAMES IN THE COOKIE JAR, SORTED.
*
COOKIES_IN_JAR
         COOKIES_IN_JAR = KEYST(COOKIE_JAR)                  :F(FRETURN)
         COOKIES_IN_JAR = SORT(COOKIES_IN_JAR)                 :(RETURN)
*
* RETURN ARRAY OF CRUMBS IN THE COOKIE, SORTED. THE FIRST CRUMB WILL
* BE THE UNAMED VALUE OF THE COOKIE.
*
CRUMBS_IN_COOKIE
         CRUMBS_IN_COOKIE = KEYST(COOKIE)                    :F(FRETURN)
         CRUMBS_IN_COOKIE = SORT(CRUMBS_IN_COOKIE)             :(RETURN)
*
COOKIE_END
*
@

<<unit_test>>=
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'COOKIE.INC'
*
         &CODE = 1
         JAR = NEW_COOKIE_JAR()
         COOKIE1 = NEW_COOKIE()
         PUT_COOKIE_IN_JAR(JAR, 'COOKIE-1', COOKIE1)
         COOKIE_SET_VALUE(COOKIE1, 'VALUE-1')
         COOKIE2 = NEW_COOKIE('VALUE-2')
         PUT_COOKIE_IN_JAR(JAR, 'COOKIE-2', COOKIE2)
         A = COOKIES_IN_JAR(JAR)                                 :F(END)
         IDENT(A<1>, 'COOKIE-1')                                 :F(END)
         IDENT(A<2>, 'COOKIE-2')                                 :F(END)
         COOKIE = GET_COOKIE_FROM_JAR(JAR, 'COOKIE-1')
         IDENT(COOKIE, COOKIE1)                                  :F(END)
         COOKIE_SET_CRUMB(COOKIE, 'Expires', COOKIE_EXPIRY(60 * 60))
* UNFORTUNATELY, THIS RESULT IS REALLY THE ONLY ONE THAT MATTERS, AND
* IT HAS TO BE VISUALLY INSPECTED -- I WILL FIX THIS LATER.
         OUTPUT = COOKIE_STRING(JAR)
         &CODE = 0
END
@

<<>>=
-MODULE COOKIE
-IN72
<<INCLUDES>>
-STITL COOKIE
-EJECT
*
************************************************************************
*                                                                      *
*            #####   #######  #######  #    #  ###  #######            *
*           #     #  #     #  #     #  #   #    #   #                  *
*           #        #     #  #     #  #  #     #   #                  *
*           #        #     #  #     #  ###      #   #####              *
*           #        #     #  #     #  #  #     #   #                  *
*           #     #  #     #  #     #  #   #    #   #                  *
*            #####   #######  #######  #    #  ###  #######            *
*                                                                      *
* COOKIE                    HANDLE COOKIES                             *
*                                                                      *
************************************************************************
*
* COOKIE.lss
*
<<COOKIE>>
*
* CE: .F.MSNOBOL4;
@
-MODULE COOKIE
-IN72
-LINE 49 "COOKIE.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'DEXP.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'TIME.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
-LINE 212 "COOKIE.lss"
-STITL COOKIE
-EJECT
*
************************************************************************
*                                                                      *
*            #####   #######  #######  #    #  ###  #######            *
*           #     #  #     #  #     #  #   #    #   #                  *
*           #        #     #  #     #  #  #     #   #                  *
*           #        #     #  #     #  ###      #   #####              *
*           #        #     #  #     #  #  #     #   #                  *
*           #     #  #     #  #     #  #   #    #   #                  *
*            #####   #######  #######  #    #  ###  #######            *
*                                                                      *
* COOKIE                    HANDLE COOKIES                             *
*                                                                      *
************************************************************************
*
* COOKIE.lss
*
-LINE 58 "COOKIE.lss"
-PUBLIC NEW_COOKIE_JAR(), NEW_COOKIE(), COOKIE_SET_VALUE()
-PUBLIC COOKIE_VALUE(), COOKIE_SET_CRUMB(), COOKIE_GET_CRUMB()
-PUBLIC PUT_COOKIE_IN_JAR(), GET_COOKIE_FROM_JAR(), COOKIES_IN_JAR()
-PUBLIC CRUMBS_IN_COOKIE(), COOKIE_EXPIRY(), COOKIE_STRING()
-PuBLIC COOKIE_FIX_NAME()
*
         DEFINE('NEW_COOKIE_JAR()')
         DEFINE('NEW_COOKIE(VALUE)')
         DEFINE('COOKIE_SET_VALUE(COOKIE,VALUE)')
         DEFINE('COOKIE_VALUE(COOKIE)')
         DEFINE('COOKIE_SET_CRUMB(COOKIE,CRUMB_NAME,VALUE)')
         DEFINE('COOKIE_GET_CRUMB(COOKIE,CRUMB_NAME)')
         DEFINE('PUT_COOKIE_IN_JAR(COOKIE_JAR,COOKIE_NAME,COOKIE)')
         DEFINE('GET_COOKIE_FROM_JAR(COOKIE_JAR,COOKIE_NAME)')
         DEFINE('COOKIES_IN_JAR(COOKIE_JAR)')
         DEFINE('CRUMBS_IN_COOKIE(COOKIE)')
         DEFINE('COOKIE_EXPIRY(N)T,D,M,S')
         DEXP('L20_(S) = LPAD(S, 2, "0")')
         DEFINE('COOKIE_STRING(COOKIE_JAR)A,B,C,I,J,S,V')
         DEFINE('COOKIE_FIX_NAME(S)')
                                                           :(COOKIE_END)
*
* RETURN COOKIE STRING
*
COOKIE_STRING
         A = COOKIES_IN_JAR(COOKIE_JAR)                       :F(RETURN)
COOKIE_STRING_2
         I = I + 1
         C = GET_COOKIE_FROM_JAR(COOKIE_JAR, A<I>)   :F(COOKIE_STRING_5)
         B = CRUMBS_IN_COOKIE(C)                     :F(COOKIE_STRING_2)
         S = S 'Set-Cookie: ' A<I> '=' COOKIE_VALUE(C)
         J = 1
COOKIE_STRING_3
         J = J + 1
         V = COOKIE_GET_CRUMB(C, B<J>)               :F(COOKIE_STRING_4)
         S = S '; ' B<J>
         S = S '=' VDIFFER(V)                         :(COOKIE_STRING_3)
COOKIE_STRING_4
         S = S CHARS_CR CHARS_NL                      :(COOKIE_STRING_2)
COOKIE_STRING_5
         COOKIE_STRING = S                                     :(RETURN)
*
* RETURN EXPIRES STRING FOR N SECONDS IN THE FUTURE. THIS STRING IS
* IN THE FORMAT:
* Wed, 09 Jun 2021 10:18:14 GMT
* ALL COOKIE EXPIRY IS IN GMT.
*
COOKIE_EXPIRY
         T = TV_SEC(GETTIMEOFDAY()) + N
         T = GMTIME(T)
         '0Sun1Mon2Tue3Wed4Thu5Fri6Sat' TM_WDAY(T) LEN(3) . D
         '0Jan1Feb2Mar3Apr4May5Jun6Jul7Aug8Sep9Oct10Nov11Dec'
+           TM_MON(T) LEN(3) . M
         S = D ', ' L20_(TM_MDAY(T)) ' ' M ' ' (TM_YEAR(T) + 1900)
+        ' ' L20_(TM_HOUR(T)) ':' L20_(TM_MIN(T)) ':' L20_(TM_SEC(T))
+        ' GMT'
         COOKIE_EXPIRY = S                                     :(RETURN)
*
* MAKE A NEW COOKIE JAR
*
NEW_COOKIE_JAR
         NEW_COOKIE_JAR = TABLE()                              :(RETURN)
*
* MAKE A NEW COOKIE
*
NEW_COOKIE
         NEW_COOKIE = TABLE()
         NEW_COOKIE<''> = VDIFFER(VALUE)                       :(RETURN)
*
* SET THE VALUE OF THE COOKIE (ATRIBUTE '')
*
COOKIE_SET_VALUE
         COOKIE<''> = VALUE                                    :(RETURN)
*
* RETURN THE VALUE OF THE COOKIE (ATTRIBUTE '')
*
COOKIE_VALUE
         COOKIE_VALUE = COOKIE<''>                             :(RETURN)
*
COOKIE_FIX_NAME
         S = TRIMB(S)
         S POS(0) '$' REM . S
         COOKIE_FIX_NAME = S                                   :(RETURN)
*
* SET AN ATTRIBUTE ON THE COOKIE
*
COOKIE_SET_CRUMB
         CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
         COOKIE<CRUMB_NAME> = VALUE                            :(RETURN)
*
* GET VALUE OF AN ATTRIBUTE FROM THE COOKIE
*
COOKIE_GET_CRUMB
         CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
         COOKIE_GET_CRUMB = COOKIE<CRUMB_NAME>                 :(RETURN)
*
* PUT THE COOKIE INTO THE COOKIE JAR, WITH NAME COOKIE_NAME
*
PUT_COOKIE_IN_JAR
         COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
         COOKIE_JAR<COOKIE_NAME> = COOKIE                      :(RETURN)
*
* GET COOKIE NAMED COOKIE_NAME FROM THE COOKIE JAR
*
GET_COOKIE_FROM_JAR
         COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
         GET_COOKIE_FROM_JAR = COOKIE_JAR<COOKIE_NAME>         :(RETURN)
*
* RETURN ARRAY OF COOKIE NAMES IN THE COOKIE JAR, SORTED.
*
COOKIES_IN_JAR
         COOKIES_IN_JAR = KEYST(COOKIE_JAR)                  :F(FRETURN)
         COOKIES_IN_JAR = SORT(COOKIES_IN_JAR)                 :(RETURN)
*
* RETURN ARRAY OF CRUMBS IN THE COOKIE, SORTED. THE FIRST CRUMB WILL
* BE THE UNAMED VALUE OF THE COOKIE.
*
CRUMBS_IN_COOKIE
         CRUMBS_IN_COOKIE = KEYST(COOKIE)                    :F(FRETURN)
         CRUMBS_IN_COOKIE = SORT(CRUMBS_IN_COOKIE)             :(RETURN)
*
COOKIE_END
*
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>COOKIE - COOKIE Support Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Cookie support functions. Cookies are saved in a cookie jar, which is
a table. In turn, each cookie has a value, and may have attributes
(cookie and attributes are crumbs). The cookie is itself stored as a
table.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Thus a cookie jar resembles an SQL table.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Browsers support 5 crumbs: Expires, Path, Secure, HttpOnly and the
default (value) crumb. Some browsers may support Max-Age.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">RFC2965</font> (and <font face="Source Code Pro">RFC2616</font>) indicates that attribute names are
case in-sensitive. Space may be added between tokens. <font face="Source Code Pro">Max-Age=0</font>
effectively ends a session.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Set-Cookie2:
Comment= CommentURL= Discard Domain= Max-Age= Path= Port=".." Secure
Version=1
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Cache-control: no-cache="set-cookie2"
Cache-control: private
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Cookie: $Version = v ;|,... name=value; $Path= v; $Domain= v; $Port="..."
Names beginning with $ are attributes
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Names and values should be in the character set !..~. ',' and ';'
are not allowed. '=' is not allowed in a name.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Attributes are not returned when the cookie is returned from the
browser.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">COOKIE_EXPIRY(N)</font> returns the expiry string for <font face="Source Code Pro">N</font> seconds in
the future. <font face="Source Code Pro">COOKIE_STRING(JAR)</font> returns a string with all cookie
definitions ready to be sent to the browser. There is no attempt to
restrict attributes or characters used. That is left to the caller.
If a cookie with a bad name is crafted by the browser, it will simply
be returned (probably as a session cookie).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="DEXP.html">DEXP</a><br>
<a href="HASH.html">HASH</a><br>
<a href="TIME.html">TIME</a><br>
<a href="TRIMB.html">TRIMB</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;DEXP.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;TIME.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;COOKIE&raquo;&equiv;</b>
-PUBLIC NEW_COOKIE_JAR(), NEW_COOKIE(), COOKIE_SET_VALUE()
-PUBLIC COOKIE_VALUE(), COOKIE_SET_CRUMB(), COOKIE_GET_CRUMB()
-PUBLIC PUT_COOKIE_IN_JAR(), GET_COOKIE_FROM_JAR(), COOKIES_IN_JAR()
-PUBLIC CRUMBS_IN_COOKIE(), COOKIE_EXPIRY(), COOKIE_STRING()
-PuBLIC COOKIE_FIX_NAME()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;NEW_COOKIE_JAR()&#39;)
         DEFINE(&#39;NEW_COOKIE(VALUE)&#39;)
         DEFINE(&#39;COOKIE_SET_VALUE(COOKIE,VALUE)&#39;)
         DEFINE(&#39;COOKIE_VALUE(COOKIE)&#39;)
         DEFINE(&#39;COOKIE_SET_CRUMB(COOKIE,CRUMB_NAME,VALUE)&#39;)
         DEFINE(&#39;COOKIE_GET_CRUMB(COOKIE,CRUMB_NAME)&#39;)
         DEFINE(&#39;PUT_COOKIE_IN_JAR(COOKIE_JAR,COOKIE_NAME,COOKIE)&#39;)
         DEFINE(&#39;GET_COOKIE_FROM_JAR(COOKIE_JAR,COOKIE_NAME)&#39;)
         DEFINE(&#39;COOKIES_IN_JAR(COOKIE_JAR)&#39;)
         DEFINE(&#39;CRUMBS_IN_COOKIE(COOKIE)&#39;)
         DEFINE(&#39;COOKIE_EXPIRY(N)T,D,M,S&#39;)
         DEXP(&#39;L20_(S) = LPAD(S, 2, &quot;0&quot;)&#39;)
         DEFINE(&#39;COOKIE_STRING(COOKIE_JAR)A,B,C,I,J,S,V&#39;)
         DEFINE(&#39;COOKIE_FIX_NAME(S)&#39;)
                                                           <b>:(COOKIE_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETURN COOKIE STRING</i></font>
<font color="#818181"><i>*</i></font>
COOKIE_STRING
         A = COOKIES_IN_JAR(COOKIE_JAR)                       <b>:F(RETURN)</b>
COOKIE_STRING_2
         I = I + 1
         C = GET_COOKIE_FROM_JAR(COOKIE_JAR, A&lt;I&gt;)   <b>:F(COOKIE_STRING_5)</b>
         B = CRUMBS_IN_COOKIE(C)                     <b>:F(COOKIE_STRING_2)</b>
         S = S &#39;Set-Cookie: &#39; A&lt;I&gt; &#39;=&#39; COOKIE_VALUE(C)
         J = 1
COOKIE_STRING_3
         J = J + 1
         V = COOKIE_GET_CRUMB(C, B&lt;J&gt;)               <b>:F(COOKIE_STRING_4)</b>
         S = S &#39;; &#39; B&lt;J&gt;
         S = S &#39;=&#39; VDIFFER(V)                         <b>:(COOKIE_STRING_3)</b>
COOKIE_STRING_4
         S = S CHARS_CR CHARS_NL                      <b>:(COOKIE_STRING_2)</b>
COOKIE_STRING_5
         COOKIE_STRING = S                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETURN EXPIRES STRING FOR N SECONDS IN THE FUTURE. THIS STRING IS</i></font>
<font color="#818181"><i>* IN THE FORMAT:</i></font>
<font color="#818181"><i>* Wed, 09 Jun 2021 10:18:14 GMT</i></font>
<font color="#818181"><i>* ALL COOKIE EXPIRY IS IN GMT.</i></font>
<font color="#818181"><i>*</i></font>
COOKIE_EXPIRY
         T = TV_SEC(GETTIMEOFDAY()) + N
         T = GMTIME(T)
         &#39;0Sun1Mon2Tue3Wed4Thu5Fri6Sat&#39; TM_WDAY(T) LEN(3) . D
         &#39;0Jan1Feb2Mar3Apr4May5Jun6Jul7Aug8Sep9Oct10Nov11Dec&#39;
+           TM_MON(T) LEN(3) . M
         S = D &#39;, &#39; L20_(TM_MDAY(T)) &#39; &#39; M &#39; &#39; (TM_YEAR(T) + 1900)
+        &#39; &#39; L20_(TM_HOUR(T)) &#39;:&#39; L20_(TM_MIN(T)) &#39;:&#39; L20_(TM_SEC(T))
+        &#39; GMT&#39;
         COOKIE_EXPIRY = S                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAKE A NEW COOKIE JAR</i></font>
<font color="#818181"><i>*</i></font>
NEW_COOKIE_JAR
         NEW_COOKIE_JAR = TABLE()                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAKE A NEW COOKIE</i></font>
<font color="#818181"><i>*</i></font>
NEW_COOKIE
         NEW_COOKIE = TABLE()
         NEW_COOKIE&lt;&#39;&#39;&gt; = VDIFFER(VALUE)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SET THE VALUE OF THE COOKIE (ATRIBUTE &#39;&#39;)</i></font>
<font color="#818181"><i>*</i></font>
COOKIE_SET_VALUE
         COOKIE&lt;&#39;&#39;&gt; = VALUE                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETURN THE VALUE OF THE COOKIE (ATTRIBUTE &#39;&#39;)</i></font>
<font color="#818181"><i>*</i></font>
COOKIE_VALUE
         COOKIE_VALUE = COOKIE&lt;&#39;&#39;&gt;                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
COOKIE_FIX_NAME
         S = TRIMB(S)
         S POS(0) &#39;$&#39; REM . S
         COOKIE_FIX_NAME = S                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SET AN ATTRIBUTE ON THE COOKIE</i></font>
<font color="#818181"><i>*</i></font>
COOKIE_SET_CRUMB
         CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
         COOKIE&lt;CRUMB_NAME&gt; = VALUE                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GET VALUE OF AN ATTRIBUTE FROM THE COOKIE</i></font>
<font color="#818181"><i>*</i></font>
COOKIE_GET_CRUMB
         CRUMB_NAME = COOKIE_FIX_NAME(CRUMB_NAME)
         COOKIE_GET_CRUMB = COOKIE&lt;CRUMB_NAME&gt;                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PUT THE COOKIE INTO THE COOKIE JAR, WITH NAME COOKIE_NAME</i></font>
<font color="#818181"><i>*</i></font>
PUT_COOKIE_IN_JAR
         COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
         COOKIE_JAR&lt;COOKIE_NAME&gt; = COOKIE                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GET COOKIE NAMED COOKIE_NAME FROM THE COOKIE JAR</i></font>
<font color="#818181"><i>*</i></font>
GET_COOKIE_FROM_JAR
         COOKIE_NAME = COOKIE_FIX_NAME(COOKIE_NAME)
         GET_COOKIE_FROM_JAR = COOKIE_JAR&lt;COOKIE_NAME&gt;         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETURN ARRAY OF COOKIE NAMES IN THE COOKIE JAR, SORTED.</i></font>
<font color="#818181"><i>*</i></font>
COOKIES_IN_JAR
         COOKIES_IN_JAR = KEYST(COOKIE_JAR)                  <b>:F(FRETURN)</b>
         COOKIES_IN_JAR = SORT(COOKIES_IN_JAR)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETURN ARRAY OF CRUMBS IN THE COOKIE, SORTED. THE FIRST CRUMB WILL</i></font>
<font color="#818181"><i>* BE THE UNAMED VALUE OF THE COOKIE.</i></font>
<font color="#818181"><i>*</i></font>
CRUMBS_IN_COOKIE
         CRUMBS_IN_COOKIE = KEYST(COOKIE)                    <b>:F(FRETURN)</b>
         CRUMBS_IN_COOKIE = SORT(CRUMBS_IN_COOKIE)             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
COOKIE_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;COOKIE.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         JAR = NEW_COOKIE_JAR()
         COOKIE1 = NEW_COOKIE()
         PUT_COOKIE_IN_JAR(JAR, &#39;COOKIE-1&#39;, COOKIE1)
         COOKIE_SET_VALUE(COOKIE1, &#39;VALUE-1&#39;)
         COOKIE2 = NEW_COOKIE(&#39;VALUE-2&#39;)
         PUT_COOKIE_IN_JAR(JAR, &#39;COOKIE-2&#39;, COOKIE2)
         A = COOKIES_IN_JAR(JAR)                                 <b>:F(END)</b>
         IDENT(A&lt;1&gt;, &#39;COOKIE-1&#39;)                                 <b>:F(END)</b>
         IDENT(A&lt;2&gt;, &#39;COOKIE-2&#39;)                                 <b>:F(END)</b>
         COOKIE = GET_COOKIE_FROM_JAR(JAR, &#39;COOKIE-1&#39;)
         IDENT(COOKIE, COOKIE1)                                  <b>:F(END)</b>
         COOKIE_SET_CRUMB(COOKIE, &#39;Expires&#39;, COOKIE_EXPIRY(60 * 60))
<font color="#818181"><i>* UNFORTUNATELY, THIS RESULT IS REALLY THE ONLY ONE THAT MATTERS, AND</i></font>
<font color="#818181"><i>* IT HAS TO BE VISUALLY INSPECTED -- I WILL FIX THIS LATER.</i></font>
         OUTPUT = COOKIE_STRING(JAR)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE COOKIE
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL COOKIE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*            #####   #######  #######  #    #  ###  #######            *</i></font>
<font color="#818181"><i>*           #     #  #     #  #     #  #   #    #   #                  *</i></font>
<font color="#818181"><i>*           #        #     #  #     #  #  #     #   #                  *</i></font>
<font color="#818181"><i>*           #        #     #  #     #  ###      #   #####              *</i></font>
<font color="#818181"><i>*           #        #     #  #     #  #  #     #   #                  *</i></font>
<font color="#818181"><i>*           #     #  #     #  #     #  #   #    #   #                  *</i></font>
<font color="#818181"><i>*            #####   #######  #######  #    #  ###  #######            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COOKIE                    HANDLE COOKIES                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COOKIE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;COOKIE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:01:51 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'COOKIE.INC'
-LINE 187 "COOKIE.lss"
*
         &CODE = 1
         JAR = NEW_COOKIE_JAR()
         COOKIE1 = NEW_COOKIE()
         PUT_COOKIE_IN_JAR(JAR, 'COOKIE-1', COOKIE1)
         COOKIE_SET_VALUE(COOKIE1, 'VALUE-1')
         COOKIE2 = NEW_COOKIE('VALUE-2')
         PUT_COOKIE_IN_JAR(JAR, 'COOKIE-2', COOKIE2)
         A = COOKIES_IN_JAR(JAR)                                 :F(END)
         IDENT(A<1>, 'COOKIE-1')                                 :F(END)
         IDENT(A<2>, 'COOKIE-2')                                 :F(END)
         COOKIE = GET_COOKIE_FROM_JAR(JAR, 'COOKIE-1')
         IDENT(COOKIE, COOKIE1)                                  :F(END)
         COOKIE_SET_CRUMB(COOKIE, 'Expires', COOKIE_EXPIRY(60 * 60))
* UNFORTUNATELY, THIS RESULT IS REALLY THE ONLY ONE THAT MATTERS, AND
* IT HAS TO BE VISUALLY INSPECTED -- I WILL FIX THIS LATER.
         OUTPUT = COOKIE_STRING(JAR)
         &CODE = 0
END
<h1>COPYL - Copy list</h1>

[[COPYL(L)]] will copy a list of [[LINK]]s. The configuration may
have loops.

<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>

<<INCLUDES>>=
-INCLUDE 'LINK.INC'
@

<<COPYL>>=
-MODULE COPYL
-PUBLIC COPYL()
         DEFINE('COPYL(L)T')                                :(COPYL_END)
*
COPYL    DEFINE('COPYL(L)', 'COPYL_1')
         T = TABLE(100)
         COPYL = COPYL(L)
         DEFINE('COPYL(L)T')                                   :(RETURN)
COPYL_1  COPYL = L
         IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
         COPYL = T<L>
         DIFFER(COPYL, NULL)                                  :S(RETURN)
         COPYL = COPY(L)
         T<L> = COPYL
         VALUE(COPYL) = COPYL(VALUE(L))
         NEXT(COPYL) = COPYL(NEXT(L))                          :(RETURN)
*
COPYL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COPYL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL COPYL
-EJECT
*
************************************************************************
*                                                                      *
*                 #####   #######  ######   #     #  #                 *
*                #     #  #     #  #     #   #   #   #                 *
*                #        #     #  #     #    # #    #                 *
*                #        #     #  ######      #     #                 *
*                #        #     #  #           #     #                 *
*                #     #  #     #  #           #     #                 *
*                 #####   #######  #           #     #######           *
*                                                                      *
* COPYL                        COPY LIST                               *
*                                                                      *
************************************************************************
*
* COPYL.lss
*
<<COPYL>>
*
* CE: .MSNOBOL4;
@
-LINE 10 "COPYL.lss"
-INCLUDE 'LINK.INC'
-STITL COPYL
-EJECT
-LINE 47 "COPYL.lss"
*
************************************************************************
*                                                                      *
*                 #####   #######  ######   #     #  #                 *
*                #     #  #     #  #     #   #   #   #                 *
*                #        #     #  #     #    # #    #                 *
*                #        #     #  ######      #     #                 *
*                #        #     #  #           #     #                 *
*                #     #  #     #  #           #     #                 *
*                 #####   #######  #           #     #######           *
*                                                                      *
* COPYL                        COPY LIST                               *
*                                                                      *
************************************************************************
*
* COPYL.lss
*
-LINE 14 "COPYL.lss"
-MODULE COPYL
-PUBLIC COPYL()
         DEFINE('COPYL(L)T')                                :(COPYL_END)
*
COPYL    DEFINE('COPYL(L)', 'COPYL_1')
         T = TABLE(100)
         COPYL = COPYL(L)
         DEFINE('COPYL(L)T')                                   :(RETURN)
COPYL_1  COPYL = L
         IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
         COPYL = T<L>
         DIFFER(COPYL, NULL)                                  :S(RETURN)
         COPYL = COPY(L)
         T<L> = COPYL
         VALUE(COPYL) = COPYL(VALUE(L))
         NEXT(COPYL) = COPYL(NEXT(L))                          :(RETURN)
*
COPYL_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>COPYL - Copy list</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">COPYL(L)</font> will copy a list of <font face="Source Code Pro">LINK</font>s. The configuration may
have loops.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LINK.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;COPYL&raquo;&equiv;</b>
-MODULE COPYL
-PUBLIC COPYL()
         DEFINE(&#39;COPYL(L)T&#39;)                                <b>:(COPYL_END)</b>
<font color="#818181"><i>*</i></font>
COPYL    DEFINE(&#39;COPYL(L)&#39;, &#39;COPYL_1&#39;)
         T = TABLE(100)
         COPYL = COPYL(L)
         DEFINE(&#39;COPYL(L)T&#39;)                                   <b>:(RETURN)</b>
COPYL_1  COPYL = L
         IDENT(DATATYPE(L), &#39;LINK&#39;)                           <b>:F(RETURN)</b>
         COPYL = T&lt;L&gt;
         DIFFER(COPYL, NULL)                                  <b>:S(RETURN)</b>
         COPYL = COPY(L)
         T&lt;L&gt; = COPYL
         VALUE(COPYL) = COPYL(VALUE(L))
         NEXT(COPYL) = COPYL(NEXT(L))                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
COPYL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;COPYL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL COPYL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 #####   #######  ######   #     #  #                 *</i></font>
<font color="#818181"><i>*                #     #  #     #  #     #   #   #   #                 *</i></font>
<font color="#818181"><i>*                #        #     #  #     #    # #    #                 *</i></font>
<font color="#818181"><i>*                #        #     #  ######      #     #                 *</i></font>
<font color="#818181"><i>*                #        #     #  #           #     #                 *</i></font>
<font color="#818181"><i>*                #     #  #     #  #           #     #                 *</i></font>
<font color="#818181"><i>*                 #####   #######  #           #     #######           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COPYL                        COPY LIST                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COPYL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;COPYL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:52 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COPYL.INC'
-LINE 38 "COPYL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>COUNT - Count string occurences</h1>

[[COUNT(S1,S2)]] counts the number of times [[S2]] occurs in [[S1]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<COUNT>>=
-MODULE COUNT
-PUBLIC COUNT()
         DEFINE('COUNT(S1,S2)FIRST,REST,P')                 :(COUNT_END)
*
COUNT    COUNT = 0
         S2 LEN(1) . FIRST REM . REST                         :F(RETURN)
         P = POS(0) BREAKX(FIRST) S2
COUNT_1  S1 P = REST                                          :F(RETURN)
         COUNT = COUNT + 1                                    :(COUNT_1)
*
COUNT_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COUNT.INC'
         &CODE = 1
         EQ(COUNT('ABCABCABC', 'AB'), 3)                         :F(END)
         &CODE = 0
END
@

<<>>=
-STITL COUNT
-EJECT
*
************************************************************************
*                                                                      *
*               #####   #######  #     #  #     #  #######             *
*              #     #  #     #  #     #  ##    #     #                *
*              #        #     #  #     #  # #   #     #                *
*              #        #     #  #     #  #  #  #     #                *
*              #        #     #  #     #  #   # #     #                *
*              #     #  #     #  #     #  #    ##     #                *
*               #####   #######   #####   #     #     #                *
*                                                                      *
* COUNT              COUNT STRING OCCURRENCES                          *
*                                                                      *
* COUNT(S1,S2) COUNTS THE NUMBER OF OCCURRENCES OF STRING S2 IN STRING *
* S1.                                                                  *
*                                                                      *
************************************************************************
*
* COUNT.lss
*
<<COUNT>>
*
* CE: .MSNOBOL4;
@
-STITL COUNT
-EJECT
*
-LINE 38 "COUNT.lss"
************************************************************************
*                                                                      *
*               #####   #######  #     #  #     #  #######             *
*              #     #  #     #  #     #  ##    #     #                *
*              #        #     #  #     #  # #   #     #                *
*              #        #     #  #     #  #  #  #     #                *
*              #        #     #  #     #  #   # #     #                *
*              #     #  #     #  #     #  #    ##     #                *
*               #####   #######   #####   #     #     #                *
*                                                                      *
* COUNT              COUNT STRING OCCURRENCES                          *
*                                                                      *
* COUNT(S1,S2) COUNTS THE NUMBER OF OCCURRENCES OF STRING S2 IN STRING *
* S1.                                                                  *
*                                                                      *
************************************************************************
*
* COUNT.lss
*
-LINE 11 "COUNT.lss"
-MODULE COUNT
-PUBLIC COUNT()
         DEFINE('COUNT(S1,S2)FIRST,REST,P')                 :(COUNT_END)
*
COUNT    COUNT = 0
         S2 LEN(1) . FIRST REM . REST                         :F(RETURN)
         P = POS(0) BREAKX(FIRST) S2
COUNT_1  S1 P = REST                                          :F(RETURN)
         COUNT = COUNT + 1                                    :(COUNT_1)
*
COUNT_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>COUNT - Count string occurences</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">COUNT(S1,S2)</font> counts the number of times <font face="Source Code Pro">S2</font> occurs in <font face="Source Code Pro">S1</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;COUNT&raquo;&equiv;</b>
-MODULE COUNT
-PUBLIC COUNT()
         DEFINE(&#39;COUNT(S1,S2)FIRST,REST,P&#39;)                 <b>:(COUNT_END)</b>
<font color="#818181"><i>*</i></font>
COUNT    COUNT = 0
         S2 LEN(1) . FIRST REM . REST                         <b>:F(RETURN)</b>
         P = POS(0) BREAKX(FIRST) S2
COUNT_1  S1 P = REST                                          <b>:F(RETURN)</b>
         COUNT = COUNT + 1                                    <b>:(COUNT_1)</b>
<font color="#818181"><i>*</i></font>
COUNT_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;COUNT.INC&#39;
         &amp;CODE = 1
         EQ(COUNT(&#39;ABCABCABC&#39;, &#39;AB&#39;), 3)                         <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL COUNT
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #####   #######  #     #  #     #  #######             *</i></font>
<font color="#818181"><i>*              #     #  #     #  #     #  ##    #     #                *</i></font>
<font color="#818181"><i>*              #        #     #  #     #  # #   #     #                *</i></font>
<font color="#818181"><i>*              #        #     #  #     #  #  #  #     #                *</i></font>
<font color="#818181"><i>*              #        #     #  #     #  #   # #     #                *</i></font>
<font color="#818181"><i>*              #     #  #     #  #     #  #    ##     #                *</i></font>
<font color="#818181"><i>*               #####   #######   #####   #     #     #                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COUNT              COUNT STRING OCCURRENCES                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* COUNT(S1,S2) COUNTS THE NUMBER OF OCCURRENCES OF STRING S2 IN STRING *</i></font>
<font color="#818181"><i>* S1.                                                                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COUNT.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;COUNT&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:52 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'COUNT.INC'
-LINE 28 "COUNT.lss"
         &CODE = 1
         EQ(COUNT('ABCABCABC', 'AB'), 3)                         :F(END)
         &CODE = 0
END
<h1>CRACK - String to array</h1>

[[CRACK(S,B)]] cracks string [[S]] at break character [[B]] into
an array.

As well, unary operator <code>%</code> is defined to produce arrays
from strings: <code>%'A,B,C'</code> creates a three-element array.

<h2>Uses</h2>
<a href="COUNT.html">COUNT</a><br>

<h2>See Also</h2>
<a href="STROUT.html">STROUT</a>

<<INCLUDES>>=
-INCLUDE 'COUNT.INC'
-INCLUDE 'SEQ.INC'
@

<<CRACK>>=
-PUBLIC CRACK(), %1
-PUBLIC COPYA()
*
         DEFINE('COPYA(A)I')
         DEFINE('CRACK_1(S)P')
         DEFINE('CRACK(S,B,F)I,PAT,N')
         DEFINE('CRACK_4(S)')
         OPSYN('%', 'CRACK_1', 1)                           :(CRACK_END)
*
COPYA    COPYA = ARRAY(PROTOTYPE(A))
         SEQ(' COPYA<I> = A<I>', .I)                           :(RETURN)
*
CRACK_1  P = IDENT(P) ','
         CRACK_1 = CRACK(S, P)                                 :(RETURN)
*
CRACK    F = IDENT(F) 'CRACK_4'
         IDENT(B, NULL)                                      :S(CRACK_3)
         S RTAB(1) B ABORT | REM . S = S B
         N = COUNT(S, B)
         EQ(N, 0)                                             :S(RETURN)
         CRACK = ARRAY(N)
         PAT = BREAK(B) . *CRACK<I> LEN(1)
CRACK_2  I = I + 1
         S PAT =                                              :F(RETURN)
         CRACK<I> = APPLY(F, CRACK<I>)             :S(CRACK_2)F(FRETURN)
CRACK_3  N = SIZE(S)
         EQ(N, 0)                                             :S(RETURN)
         CRACK = ARRAY(N)
         PAT = LEN(1) . *CRACK<I>                             :(CRACK_2)
*
CRACK_4  CRACK_4 = S                                           :(RETURN)
*
CRACK_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CRACK.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE CRACK
-IN72
<<INCLUDES>>
-STITL CRACK
-EJECT
*
************************************************************************
*                                                                      *
*               #####   ######      #      #####   #    #              *
*              #     #  #     #    # #    #     #  #   #               *
*              #        #     #   #   #   #        #  #                *
*              #        ######   #     #  #        ###                 *
*              #        #   #    #######  #        #  #                *
*              #     #  #    #   #     #  #     #  #   #               *
*               #####   #     #  #     #   #####   #    #              *
*                                                                      *
* CRACK                    STRING TO ARRAY                             *
*                                                                      *
************************************************************************
*
* CRACK.lss
*
<<CRACK>>
*
* CE: .MSNOBOL4;
@
-MODULE CRACK
-IN72
-LINE 16 "CRACK.lss"
-INCLUDE 'COUNT.INC'
-INCLUDE 'SEQ.INC'
-LINE 69 "CRACK.lss"
-STITL CRACK
-EJECT
*
************************************************************************
*                                                                      *
*               #####   ######      #      #####   #    #              *
*              #     #  #     #    # #    #     #  #   #               *
*              #        #     #   #   #   #        #  #                *
*              #        ######   #     #  #        ###                 *
*              #        #   #    #######  #        #  #                *
*              #     #  #    #   #     #  #     #  #   #               *
*               #####   #     #  #     #   #####   #    #              *
*                                                                      *
* CRACK                    STRING TO ARRAY                             *
*                                                                      *
************************************************************************
*
* CRACK.lss
*
-LINE 21 "CRACK.lss"
-PUBLIC CRACK(), %1
-PUBLIC COPYA()
*
         DEFINE('COPYA(A)I')
         DEFINE('CRACK_1(S)P')
         DEFINE('CRACK(S,B,F)I,PAT,N')
         DEFINE('CRACK_4(S)')
         OPSYN('%', 'CRACK_1', 1)                           :(CRACK_END)
*
COPYA    COPYA = ARRAY(PROTOTYPE(A))
         SEQ(' COPYA<I> = A<I>', .I)                           :(RETURN)
*
CRACK_1  P = IDENT(P) ','
         CRACK_1 = CRACK(S, P)                                 :(RETURN)
*
CRACK    F = IDENT(F) 'CRACK_4'
         IDENT(B, NULL)                                      :S(CRACK_3)
         S RTAB(1) B ABORT | REM . S = S B
         N = COUNT(S, B)
         EQ(N, 0)                                             :S(RETURN)
         CRACK = ARRAY(N)
         PAT = BREAK(B) . *CRACK<I> LEN(1)
CRACK_2  I = I + 1
         S PAT =                                              :F(RETURN)
         CRACK<I> = APPLY(F, CRACK<I>)             :S(CRACK_2)F(FRETURN)
CRACK_3  N = SIZE(S)
         EQ(N, 0)                                             :S(RETURN)
         CRACK = ARRAY(N)
         PAT = LEN(1) . *CRACK<I>                             :(CRACK_2)
*
CRACK_4  CRACK_4 = S                                           :(RETURN)
*
CRACK_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CRACK - String to array</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CRACK(S,B)</font> cracks string <font face="Source Code Pro">S</font> at break character <font face="Source Code Pro">B</font> into
an array.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
As well, unary operator <code>%</code> is defined to produce arrays
from strings: <code>%'A,B,C'</code> creates a three-element array.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="COUNT.html">COUNT</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="STROUT.html">STROUT</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;COUNT.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CRACK&raquo;&equiv;</b>
-PUBLIC CRACK(), %1
-PUBLIC COPYA()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;COPYA(A)I&#39;)
         DEFINE(&#39;CRACK_1(S)P&#39;)
         DEFINE(&#39;CRACK(S,B,F)I,PAT,N&#39;)
         DEFINE(&#39;CRACK_4(S)&#39;)
         OPSYN(&#39;%&#39;, &#39;CRACK_1&#39;, 1)                           <b>:(CRACK_END)</b>
<font color="#818181"><i>*</i></font>
COPYA    COPYA = ARRAY(PROTOTYPE(A))
         SEQ(&#39; COPYA&lt;I&gt; = A&lt;I&gt;&#39;, .I)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CRACK_1  P = IDENT(P) &#39;,&#39;
         CRACK_1 = CRACK(S, P)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CRACK    F = IDENT(F) &#39;CRACK_4&#39;
         IDENT(B, NULL)                                      <b>:S(CRACK_3)</b>
         S RTAB(1) B ABORT | REM . S = S B
         N = COUNT(S, B)
         EQ(N, 0)                                             <b>:S(RETURN)</b>
         CRACK = ARRAY(N)
         PAT = BREAK(B) . *CRACK&lt;I&gt; LEN(1)
CRACK_2  I = I + 1
         S PAT =                                              <b>:F(RETURN)</b>
         CRACK&lt;I&gt; = APPLY(F, CRACK&lt;I&gt;)             <b>:S(CRACK_2)F(FRETURN)</b>
CRACK_3  N = SIZE(S)
         EQ(N, 0)                                             <b>:S(RETURN)</b>
         CRACK = ARRAY(N)
         PAT = LEN(1) . *CRACK&lt;I&gt;                             <b>:(CRACK_2)</b>
<font color="#818181"><i>*</i></font>
CRACK_4  CRACK_4 = S                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CRACK_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CRACK.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE CRACK
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL CRACK
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #####   ######      #      #####   #    #              *</i></font>
<font color="#818181"><i>*              #     #  #     #    # #    #     #  #   #               *</i></font>
<font color="#818181"><i>*              #        #     #   #   #   #        #  #                *</i></font>
<font color="#818181"><i>*              #        ######   #     #  #        ###                 *</i></font>
<font color="#818181"><i>*              #        #   #    #######  #        #  #                *</i></font>
<font color="#818181"><i>*              #     #  #    #   #     #  #     #  #   #               *</i></font>
<font color="#818181"><i>*               #####   #     #  #     #   #####   #    #              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CRACK                    STRING TO ARRAY                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CRACK.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CRACK&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:07:55 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CRACK.INC'
-LINE 60 "CRACK.lss"
         &CODE = 1
         &CODE = 0
END
<h1>CSNOBOL4 - Functions specific to CSNOBOL4</h1>

These are functions specific to [[CSNOBOL4]] and Unix or Unix-like
systems.

We use FFI to access io_getfp() to retrieve the FILE * for a unit.
This allows proper implementation of pipe i/o where CSNOBOL4 1.5
has problems.

[[FORK()]], [[WAIT()]], and [[SPRINTF()]] are in the CSNOBOL4 image.
[[FTN_FORMAT()]] is in an external module. [[IO_GETFP()]] is also in
the image, and [[FILENO()]] is available in [[clib]].

Added more functions here to create pipes, close file handles,
handle fd sets -- these should be in a [[UNIX]] component. fileno()
actually belongs there as well, as does fork() and wait(). Arguably
MALLOC, FREE, STRDUP and STRLEN should be there too.

<h2>Uses</h2>
<a href="FFI.html">FFI</a><br>
<a href="P64.html">P64</a><br>

<<INCLUDES>>=
-INCLUDE 'FFI.INC'
-INCLUDE 'P64.INC'
@

<<CSNOBOL4>>=
-SNOBOL SLOAD('BQ.INC')
-SNOBOL SLOAD('DYNAMIC.INC')
-SNOBOL SLOAD('WRAPPER.INC')
-SNOBOL SLOAD('CRACK.INC')
-SNOBOL SLOAD('SEQ.INC')
-SNOBOL TERMINAL = 'CSNOBOL4 (MON NOV 11 12:50:40 EST 2013)'
@

<<CSNOBOL4>>=
-EMBED C 'format'
@

<<CSNOBOL4,TYPE=C>>=
-SNOBOL WRAPPER_STARTFILE(.EMBED)

/* Adds FORTRAN IV FORMAT to CSNOBOL4 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

static int status;

static int pipefds[2];

static int createpipe(void)
{
    return pipe(pipefds);
}

-SNOBOL C_WRAPPER_PROTO('CREATEPIPE()INTEGER', .EMBED)

static int getpipefd(int n)
{
    if ((n < 0) || (n > 1))
        return -1;
    return pipefds[n];
}

-SNOBOL C_WRAPPER_PROTO('GETPIPEFD(INTEGER)INTEGER', .EMBED)

static int get_errno(void)
{
    return errno;
}

-SNOBOL C_WRAPPER_PROTO('GET_ERRNO()INTEGER', .EMBED)

/* fd_set holds a set of file descriptors. On 64 bit Linux, this is
 * a 128 byte object. This may be as little as 4 bytes on some systems
 * (which would limit the number of fd's to 32).
 */

static int sizeof_timeval(void)
{
    return sizeof (struct timeval);
}

-SNOBOL C_WRAPPER_PROTO('SIZEOF_TIMEVAL()INTEGER', .EMBED)

static int set_timeval(long p, int sec, int usec)
{
    struct timeval *tv = (void *)p;
    tv->tv_sec = sec;
    tv->tv_usec = usec;
}

-SNOBOL C_WRAPPER_PROTO('SET_TIMEVAL(LONG,INTEGER,INTEGER)', .EMBED)

static int sizeof_fd_set(void)
{
    return sizeof (fd_set);
}

-SNOBOL C_WRAPPER_PROTO('SIZEOF_FD_SET()INTEGER', .EMBED)

static int fd_isset_(int fd, long p)
{
    return FD_ISSET(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_ISSET_(INTEGER,LONG)INTEGER', .EMBED)

static void fd_zero_(long p)
{
    FD_ZERO((fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_ZERO_(LONG)', .EMBED)

static void fd_clr(int fd, long p)
{
    FD_ClR(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_CLR_(INTEGER,LONG)', .EMBED)

static void fd_set_(int fd, long p)
{
    FD_SET(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO('FD_SET_(INTEGER,LONG)', .EMBED)

static int clear_errno(void)
{
    errno = 0;
}

-SNOBOL C_WRAPPER_PROTO('CLEAR_ERRNO()', .EMBED)

static int waitpid_(int pid, int options)
{
    return waitpid(pid, &status, options);
}

-SNOBOL C_WRAPPER_PROTO('WAITPID_(INTEGER,INTEGER)INTEGER', .EMBED)

static int get_status(void)
{
    return status;
}

-SNOBOL C_WRAPPER_PROTO('GET_STATUS()INTEGER', .EMBED)

static int format(char **in_s, char **fmt, char **buf, char **limit,
           char **base, int reps, int level)
{
    int w, r;
    char *bfmt = *fmt;
    char c;
    int aseen = 0;

    for (; reps; --reps) {
	for (*fmt = bfmt; **fmt;) {
	    while ((**fmt == ',') || (**fmt == ' ')) {
		++*fmt;
	    }
	    if (isdigit(**fmt)) {
		r = 0;
		while (isdigit(**fmt)) {
		    r = r * 10 + **fmt - '0';
		    ++*fmt;
		}
		r &= 0xff;
	    } else {
		r = -1;
	    }
	    c = **fmt;
	    ++*fmt;
	    switch (c) {
		case ',': break;
		case 'X':
		    if (r < 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = ' ';
			++*buf;
		    }
		    break;
		case 'A':
		    ++aseen;
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - '0';
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (r < 0) {
			r = 1;
		    }
		    r *= w;
		    for (; r; --r) {
			if (**in_s == 0) {
			    break;
			}
			**buf = **in_s;
			++*buf;
			++*in_s;
		    }
		    for (; r; --r) {
			**buf = ' ';
			++*buf;
		    }
		    break;
		case '/':
		    if (r < 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = '\n';
			++*buf;
			*base = *buf;
		    }
		    break;
		case '\'':
		    for (;;) {
			if (**fmt == 0) {
			    fprintf(stderr,
                   "ftn_format: missing close \' in string constant\n");
			    return 1;
			}
			if (**fmt == '\'') {
			    ++*fmt;
			    if (**fmt == '\'') {
				**buf = '\'';
				++*buf;
				++*fmt;
			    } else {
				break;
			    }
			} else {
			    **buf = **fmt;
			    ++*buf;
			    ++*fmt;
			}
		    }
		    break;
		case 'H':
		    if (r == 0) {
			break;
		    }
		    for (; r; --r) {
			if (**fmt == 0) {
			    fprintf(stderr,
                          "ftn_format: Hollerith constant too short\n");
			    return 1;
			}
			**buf = **fmt;
			++*buf;
			++*fmt;
		    }
		    break;
		case 'T': /* T TL TR */
		    if (**fmt == 'R') {
			c = 'R';
			++*fmt;
		    } else if (**fmt == 'L') {
			c = 'L';
			++*fmt;
		    }
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - '0';
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (c == 'L') {
			*buf -= w;
		    } else if (c == 'R') {
			*buf += w;
		    } else {
			*buf = *base + w - 1;
		    }
		    break;
		case ')':
		    if (**in_s == 0) {
			return 0;
		    }
		    if ((level == 1) && **in_s) {
			reps = 2;
			goto btm;
		    }
		    if ((level > 1) && (reps > 1)) {
			goto btm;
		    }
		    if ((level > 1) && (reps < 0) && (aseen == 0)) {
			return 0;
		    }
		    goto btm;
		    return 0;
		case '(':
		    r = format(in_s, fmt, buf, limit, base,
			       r, level + 1);
		    if (r) {
			return r;
		    }
		    break;
		default:
		    if (c == 0) {
			fprintf(stderr,
                               "ftn_format: premature end of format\n");
		    } else {
			fprintf(stderr,
                           "ftn_format: bad format character: %c\n", c);
		    }
		    return 1;
	    }
	    if (*limit < *buf) {
		*limit = *buf;
	    }
	}
btm: ;
    }
    return 0;
}

static char *ftn_format(char *s, char *f)
{
    char *in_s, *fmt, *buf, *limit, *base, *b;
    int r;

    /* format state */
    base = malloc(4096);
    fmt = f;
    in_s = s;
    buf = base;
    limit = base;
    b = base;

    for (r = 0; r < 4096; ++r) {
	base[r] = ' ';
    }
    if (*fmt != '(') {
	fprintf(stderr, "ftn_format: missing begin (\n");
	goto err;
    }
    if (*(fmt + strlen(fmt) - 1)  != ')') {
	fprintf(stderr, "ftn_format: missing end )\n");
	goto err;
    }

    ++fmt;
    r = format(&in_s, &fmt, &buf, &limit, &b, 1, 1);
    if (r == 0) {
	*limit = 0;
	return base;
    }
err:
    free(base);
    return NULL;
}

/* FTN_FORMAT(STRING,STRING)STRING_FREE
 *
 * First STRING is the FORMAT, second is the FORMAT
 */
FTN_FORMAT( LA_ALIST ) LA_DCL
{
    char *result;
    char data[4096];
    char format[1024];
    getstring(LA_PTR(0), format, sizeof(format));
    getstring(LA_PTR(1), data, sizeof(data));
    result = ftn_format(data, format);
    if (result == NULL)
	RETFAIL;
    RETSTR_FREE(result);
}
-END
@

<<CSNOBOL4>>=
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(format) :F(ERROR) ;
-SNOBOL LIBS = '-L. -lp64'
-SNOBOL OBJECTS = format ; OBJECTS '.c' = '.o'
-SNOBOL LINK_DYNAMIC('./format', OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS format.so
-CMNT -SNOBOL A = CRACK(format ' ' OBJECTS, ' ')
-CMNT -SNOBOL SEQ(' DELETE(A<K>) ', .K)
@

[[FORK()]] copies the current process, and returns the pid (process
identifier) of the new process. In the child, it returns 0.

<<CSNOBOL4>>=
-PUBLIC FORK()
         LOAD('FORK()INTEGER')
@

[[WAIT()]] waits for the completion of a child process. It returns the
pid of the child process that has terminated, or negative on error.

<<CSNOBOL4>>=
-PUBLIC WAIT()
         LOAD('WAIT()INTEGER')
@

To exit a child process, Unix supplies [[exit()]]. However, [[EXIT()]]
causes execution of new image in [[CSNOBOL4]]. To exit a process,
assign the result status to [[&amp;CODE]] and branch to [[END]].

[[
    &amp;CODE = 0  :(END)
]]

[[SPRINTF(F,V)]] formats an [[INTEGER]] or [[REAL]] value [[V]] using
the [[C]] format [[F]] and returns the result as a string. For example:

[[
    SPRINTF("%d", I)
    SPRINTF("%g", X)
]]

<<CSNOBOL4>>=
-PUBLIC SPRINTF()
         LOAD('SPRINTF(STRING,)STRING')
@

[[FTN_FORMAT(F, S)]] formats string [[S]] using [[FORTRAN IV FORMAT]]
[[F]] and returns the result as a string. [[CSNOBOL4]] doesn't (natively)
support [[FORTRAN IV FORMAT]] but this function provides the missing
support.

FORMAT codes supported are

[[
    N H        Hollerith
    N A M      Alphanumeric
    N X        Spacing
    T N        Tab to column N
    TL N       Tab left by N
    TR N       Tab right by N
    N /        Record end
    'TEXT'     Use '' for single '
    N ( ... )  Grouping with repetition
]]

Other [[FORTRAN IV]] conversion (I, F, etc.) not supported. FORMAT and
DATA limited to 1023 characters. Z conversion is not supported.

When outputing to a printer, FORTRAN convention is that the first
character of the line controls line spacing and paging.The [[asa]]
and [[asapdf]] utilities interpret such print files. Generally, a
printer page is 132 columns by 60 lines. [[asa]] specifies 4 characters
for control:

[[
    ' '   Single line space
    '0'   Double line space
    '1'   New page
    '+'   Overprint line
]]

The [[asapdf]] utility takes an [[ASA]] file, and encodes to [[PDF]].
[[asapdf]] adds the following line controls:

[[
    '-'   Triple line space (IBM extension)
    'H'   Half line adance
    'R'   No line advance, print RED
    'G'   No line advance, print GREEN
    'B'   No line advance, print BLUE
    'r'   Advance, print RED
    'g'   Advance, print GREEN
    'b'   Advance, print BLUE
    '^'   Overprint line, adding 127 to characters
]]

MAINBOL default formats

[[
    OUTPUT  (1X,132A1)
    CARD    (80A1)
]]

<<CSNOBOL4>>=
-PUBLIC FTN_FORMAT(), CREATEPIPE(), GETPIPEFD(), GET_ERRNO()
-PUBLIC CLEAR_ERRNO(), WAITPID(), GET_STATUS(), SIZEOF_TIMEVAL()
-PUBLIC SET_TIMEVAL(), SIZEOF_FD_SET(), FD_ZERO(), FD_CLR(), FD_SET()
-PUBLIC FD_ISSET()
*
         LOAD('FTN_FORMAT(STRING,STRING)STRING', 'format.so')
         LOAD('CREATEPIPE()INTEGER', 'format.so')
         LOAD('GETPIPEFD(INTEGER)INTEGER', 'format.so')
         LOAD('GET_ERRNO()INTEGER', 'format.so')
         LOAD('CLEAR_ERRNO()', 'format.so')
         LOAD('WAITPID_(INTEGER,INTEGER)INTEGER', 'format.so')
         LOAD('GET_STATUS()INTEGER', 'format.so')
         LOAD('SIZEOF_TIMEVAL()INTEGER', 'format.so')
         LOAD('SET_TIMEVAL(INTEGER,INTEGER,INTEGER)', 'format.so')
         LOAD('SIZEOF_FD_SET()INTEGER', 'format.so')
         LOAD('FD_ZERO_(INTEGER)', 'format.so')
         LOAD('FD_CLR_(INTEGER,INTEGER)', 'format.so')
         LOAD('FD_SET_(INTEGER,INTEGER)', 'format.so')
         LOAD('FD_ISSET_(INTEGER,INTEGER)INTEGER', 'format.so')
         DEFINE('FD_ZERO(FD_SET)')
         DEFINE('FD_CLR(FD,FD_SET)')
         DEFINE('FD_ISSET(FD,FD_SET)')
         DEFINE('FD_SET(FD,FD_SET)')
@

We want to retrieve the FILE * for a unit. This can be used to perform
other forms of i/o, or to retrieve the underlying file descriptor.
Use FFI to access [[io_getfp()]] and [[fileno()]]. There may be a
bug in CSNOBOL4 1.5. When doing I/O using [[fgets()]] (normal line
oriented) to a bi-direction pipe, we get errno 29 (ESPIPE) errors,
indicating that seek on the pipe failed. Of course, we can't seek
on the pipe; this is done solely to separate read and write. But,
there may be a timing issue because there are two separate processes
involved.

<<CSNOBOL4>>=
-PUBLIC CLOSE(), SELECT(), IO_GETFP(), FILENO()
         CLOSE_FFI = FFI_NEW('I', 'I')
         FFI_SET_CALLP(CLOSE_FFI, DLSYM(0, 'close'))
         DEFINE('CLOSE(FD)')
         SELECT_FFI = FFI_NEW('I', 'I,P,P,P,P')
         FFI_SET_CALLP(SELECT_FFI, DLSYM(0, 'select'))
         DEFINE('SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)')
         IO_GETFP_FFI = FFI_NEW('P', 'I')
         FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, 'io_getfp'))
         FILENO_FFI = FFI_NEW('I', 'P')
         FFI_SET_CALLP(FILENO_FFI, DLSYM(0, 'fileno'))
         DEFINE('IO_GETFP(UNIT)')
         DEFINE('FILENO(FP)')                            :(CSNOBOL4_END)
*
CLOSE    FFI_PAR_N_INTEGER(CLOSE_FFI, 1, FD)
         CLOSE = FFI_CALL_INTEGER(CLOSE_FFI)                   :(RETURN)
*
FD_CLR   FD_CLR_(FD, FD_SET)                                   :(RETURN)
*
FD_ISSET FD_ISSET = FD_ISSET_(FD, FD_SET)                      :(RETURN)
*
FD_SET   FD_SET_(FD, FD_SET)                                   :(RETURN)
*
FD_ZERO  FD_ZERO_(FD_SET)                                      :(RETURN)
*
IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
         IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 :(RETURN)
*
FILENO   FFI_PAR_N_PTR(FILENO_FFI, 1, FP)
         FILENO = FFI_CALL_INTEGER(FILENO_FFI)                 :(RETURN)
*
SELECT   FFI_PAR_N_INTEGER(SELECT_FFI, 1, NFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 2, READFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 3, WRITEFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 4, EXCEPTFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 5, TIMEOUT)
         SELECT = FFI_CALL_INTEGER(SELECT_FFI)                 :(RETURN)
*
CSNOBOL4_END
@

Open /dev/stdout (fd 1) as unit 10. Write to new I/O variable.
Obtain the FILE * (file pointer) for unit 10. Obtain the underlying
FD for the file pointer. Display both file pointer and file number,
and confirm that FD is 1.

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CSNOBOL4.INC'
         &CODE = 1
         OUTPUT(.T_OUT, 10,, '/dev/stdout')
         T_OUT = 'HELLO, WORLD'
         FP = IO_GETFP(10)
         FD = FILENO(FP)
         OUTPUT = 'FILE * = ' FP
         OUTPUT = 'FD     = ' FD
         EQ(FD, 1)                                               :F(END)
         &CODE = 0
END
@

<<>>=
-MODULE CSNOBOL4
<<INCLUDES>>
-STITL CSNOBOL4
-EJECT
*
************************************************************************
*                                                                      *
*  #####    #####   #     #  #######  ######   #######  #        #   # *
* #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *
* #        #        # #   #  #     #  #     #  #     #  #        #   # *
* #         #####   #  #  #  #     #  ######   #     #  #        ##### *
* #              #  #   # #  #     #  #     #  #     #  #            # *
* #     #  #     #  #    ##  #     #  #     #  #     #  #            # *
*  #####    #####   #     #  #######  ######   #######  #######      # *
*                                                                      *
* CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *
*                                                                      *
************************************************************************
*
* CSNOBOL4.lss
*
<<CSNOBOL4>>
*
* CE: .MSNOBOL4;
@
-MODULE CSNOBOL4
-LINE 24 "CSNOBOL4.lss"
-INCLUDE 'FFI.INC'
-INCLUDE 'P64.INC'
-STITL CSNOBOL4
-LINE 604 "CSNOBOL4.lss"
-EJECT
*
************************************************************************
*                                                                      *
*  #####    #####   #     #  #######  ######   #######  #        #   # *
* #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *
* #        #        # #   #  #     #  #     #  #     #  #        #   # *
* #         #####   #  #  #  #     #  ######   #     #  #        ##### *
* #              #  #   # #  #     #  #     #  #     #  #            # *
* #     #  #     #  #    ##  #     #  #     #  #     #  #            # *
*  #####    #####   #     #  #######  ######   #######  #######      # *
*                                                                      *
* CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *
*                                                                      *
************************************************************************
*
* CSNOBOL4.lss
*
-LINE 29 "CSNOBOL4.lss"
-LINE 30 "CSNOBOL4.lss"
-LINE 31 "CSNOBOL4.lss"
-LINE 32 "CSNOBOL4.lss"
-LINE 33 "CSNOBOL4.lss"
-LINE 34 "CSNOBOL4.lss"
-LINE 35 "CSNOBOL4.lss"
-LINE 38 "CSNOBOL4.lss"
         format = 'format.c'
-LINE 395 "CSNOBOL4.lss"
-LINE 396 "CSNOBOL4.lss"
-LINE 397 "CSNOBOL4.lss"
-LINE 398 "CSNOBOL4.lss"
-LINE 399 "CSNOBOL4.lss"
-LINE 400 "CSNOBOL4.lss"
-LINE 411 "CSNOBOL4.lss"
-PUBLIC FORK()
         LOAD('FORK()INTEGER')
-LINE 419 "CSNOBOL4.lss"
-PUBLIC WAIT()
         LOAD('WAIT()INTEGER')
-LINE 440 "CSNOBOL4.lss"
-PUBLIC SPRINTF()
         LOAD('SPRINTF(STRING,)STRING')
-LINE 502 "CSNOBOL4.lss"
-PUBLIC FTN_FORMAT(), CREATEPIPE(), GETPIPEFD(), GET_ERRNO()
-PUBLIC CLEAR_ERRNO(), WAITPID(), GET_STATUS(), SIZEOF_TIMEVAL()
-PUBLIC SET_TIMEVAL(), SIZEOF_FD_SET(), FD_ZERO(), FD_CLR(), FD_SET()
-PUBLIC FD_ISSET()
*
         LOAD('FTN_FORMAT(STRING,STRING)STRING', 'format.so')
         LOAD('CREATEPIPE()INTEGER', 'format.so')
         LOAD('GETPIPEFD(INTEGER)INTEGER', 'format.so')
         LOAD('GET_ERRNO()INTEGER', 'format.so')
         LOAD('CLEAR_ERRNO()', 'format.so')
         LOAD('WAITPID_(INTEGER,INTEGER)INTEGER', 'format.so')
         LOAD('GET_STATUS()INTEGER', 'format.so')
         LOAD('SIZEOF_TIMEVAL()INTEGER', 'format.so')
         LOAD('SET_TIMEVAL(INTEGER,INTEGER,INTEGER)', 'format.so')
         LOAD('SIZEOF_FD_SET()INTEGER', 'format.so')
         LOAD('FD_ZERO_(INTEGER)', 'format.so')
         LOAD('FD_CLR_(INTEGER,INTEGER)', 'format.so')
         LOAD('FD_SET_(INTEGER,INTEGER)', 'format.so')
         LOAD('FD_ISSET_(INTEGER,INTEGER)INTEGER', 'format.so')
         DEFINE('FD_ZERO(FD_SET)')
         DEFINE('FD_CLR(FD,FD_SET)')
         DEFINE('FD_ISSET(FD,FD_SET)')
         DEFINE('FD_SET(FD,FD_SET)')
-LINE 538 "CSNOBOL4.lss"
-PUBLIC CLOSE(), SELECT(), IO_GETFP(), FILENO()
         CLOSE_FFI = FFI_NEW('I', 'I')
         FFI_SET_CALLP(CLOSE_FFI, DLSYM(0, 'close'))
         DEFINE('CLOSE(FD)')
         SELECT_FFI = FFI_NEW('I', 'I,P,P,P,P')
         FFI_SET_CALLP(SELECT_FFI, DLSYM(0, 'select'))
         DEFINE('SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)')
         IO_GETFP_FFI = FFI_NEW('P', 'I')
         FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, 'io_getfp'))
         FILENO_FFI = FFI_NEW('I', 'P')
         FFI_SET_CALLP(FILENO_FFI, DLSYM(0, 'fileno'))
         DEFINE('IO_GETFP(UNIT)')
         DEFINE('FILENO(FP)')                            :(CSNOBOL4_END)
*
CLOSE    FFI_PAR_N_INTEGER(CLOSE_FFI, 1, FD)
         CLOSE = FFI_CALL_INTEGER(CLOSE_FFI)                   :(RETURN)
*
FD_CLR   FD_CLR_(FD, FD_SET)                                   :(RETURN)
*
FD_ISSET FD_ISSET = FD_ISSET_(FD, FD_SET)                      :(RETURN)
*
FD_SET   FD_SET_(FD, FD_SET)                                   :(RETURN)
*
FD_ZERO  FD_ZERO_(FD_SET)                                      :(RETURN)
*
IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
         IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 :(RETURN)
*
FILENO   FFI_PAR_N_PTR(FILENO_FFI, 1, FP)
         FILENO = FFI_CALL_INTEGER(FILENO_FFI)                 :(RETURN)
*
SELECT   FFI_PAR_N_INTEGER(SELECT_FFI, 1, NFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 2, READFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 3, WRITEFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 4, EXCEPTFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 5, TIMEOUT)
         SELECT = FFI_CALL_INTEGER(SELECT_FFI)                 :(RETURN)
*
CSNOBOL4_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CSNOBOL4 - Functions specific to CSNOBOL4</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
These are functions specific to <font face="Source Code Pro">CSNOBOL4</font> and Unix or Unix-like
systems.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
We use FFI to access io_getfp() to retrieve the FILE * for a unit.
This allows proper implementation of pipe i/o where CSNOBOL4 1.5
has problems.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FORK()</font>, <font face="Source Code Pro">WAIT()</font>, and <font face="Source Code Pro">SPRINTF()</font> are in the CSNOBOL4 image.
<font face="Source Code Pro">FTN_FORMAT()</font> is in an external module. <font face="Source Code Pro">IO_GETFP()</font> is also in
the image, and <font face="Source Code Pro">FILENO()</font> is available in <font face="Source Code Pro">clib</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Added more functions here to create pipes, close file handles,
handle fd sets -- these should be in a <font face="Source Code Pro">UNIX</font> component. fileno()
actually belongs there as well, as does fork() and wait(). Arguably
MALLOC, FREE, STRDUP and STRLEN should be there too.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="FFI.html">FFI</a><br>
<a href="P64.html">P64</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;FFI.INC&#39;
-INCLUDE &#39;P64.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-SNOBOL SLOAD(&#39;BQ.INC&#39;)
-SNOBOL SLOAD(&#39;DYNAMIC.INC&#39;)
-SNOBOL SLOAD(&#39;WRAPPER.INC&#39;)
-SNOBOL SLOAD(&#39;CRACK.INC&#39;)
-SNOBOL SLOAD(&#39;SEQ.INC&#39;)
-SNOBOL TERMINAL = &#39;CSNOBOL4 (MON NOV 11 12:50:40 EST 2013)&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-EMBED C &#39;format&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4,TYPE=C&raquo;&equiv;</b>
-SNOBOL WRAPPER_STARTFILE(.EMBED)

/* Adds FORTRAN IV FORMAT to CSNOBOL4 */

<font color="#818181"><i>#include &lt;stdio.h&gt;</i></font>
<font color="#818181"><i>#include &lt;stdlib.h&gt;</i></font>
<font color="#818181"><i>#include &lt;ctype.h&gt;</i></font>
<font color="#818181"><i>#include &lt;errno.h&gt;</i></font>
<font color="#818181"><i>#include &lt;time.h&gt;</i></font>
<font color="#818181"><i>#include &lt;sys/select.h&gt;</i></font>
<font color="#818181"><i>#include &lt;sys/time.h&gt;</i></font>
<font color="#818181"><i>#include &lt;sys/types.h&gt;</i></font>
<font color="#818181"><i>#include &lt;unistd.h&gt;</i></font>

static int status;

static int pipefds[2];

static int createpipe(void)
{
    return pipe(pipefds);
}

-SNOBOL C_WRAPPER_PROTO(&#39;CREATEPIPE()INTEGER&#39;, .EMBED)

static int getpipefd(int n)
{
    if ((n &lt; 0) || (n &gt; 1))
        return -1;
    return pipefds[n];
}

-SNOBOL C_WRAPPER_PROTO(&#39;GETPIPEFD(INTEGER)INTEGER&#39;, .EMBED)

static int get_errno(void)
{
    return errno;
}

-SNOBOL C_WRAPPER_PROTO(&#39;GET_ERRNO()INTEGER&#39;, .EMBED)

/* fd_set holds a set of file descriptors. On 64 bit Linux, this is
 * a 128 byte object. This may be as little as 4 bytes on some systems
 * (which would limit the number of fd&#39;s to 32).
 */

static int sizeof_timeval(void)
{
    return sizeof (struct timeval);
}

-SNOBOL C_WRAPPER_PROTO(&#39;SIZEOF_TIMEVAL()INTEGER&#39;, .EMBED)

static int set_timeval(long p, int sec, int usec)
{
    struct timeval *tv = (void *)p;
    tv-&gt;tv_sec = sec;
    tv-&gt;tv_usec = usec;
}

-SNOBOL C_WRAPPER_PROTO(&#39;SET_TIMEVAL(LONG,INTEGER,INTEGER)&#39;, .EMBED)

static int sizeof_fd_set(void)
{
    return sizeof (fd_set);
}

-SNOBOL C_WRAPPER_PROTO(&#39;SIZEOF_FD_SET()INTEGER&#39;, .EMBED)

static int fd_isset_(int fd, long p)
{
    return FD_ISSET(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_ISSET_(INTEGER,LONG)INTEGER&#39;, .EMBED)

static void fd_zero_(long p)
{
    FD_ZERO((fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_ZERO_(LONG)&#39;, .EMBED)

static void fd_clr(int fd, long p)
{
    FD_ClR(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_CLR_(INTEGER,LONG)&#39;, .EMBED)

static void fd_set_(int fd, long p)
{
    FD_SET(fd, (fd_set *)p);
}

-SNOBOL C_WRAPPER_PROTO(&#39;FD_SET_(INTEGER,LONG)&#39;, .EMBED)

static int clear_errno(void)
{
    errno = 0;
}

-SNOBOL C_WRAPPER_PROTO(&#39;CLEAR_ERRNO()&#39;, .EMBED)

static int waitpid_(int pid, int options)
{
    return waitpid(pid, &amp;status, options);
}

-SNOBOL C_WRAPPER_PROTO(&#39;WAITPID_(INTEGER,INTEGER)INTEGER&#39;, .EMBED)

static int get_status(void)
{
    return status;
}

-SNOBOL C_WRAPPER_PROTO(&#39;GET_STATUS()INTEGER&#39;, .EMBED)

static int format(char **in_s, char **fmt, char **buf, char **limit,
           char **base, int reps, int level)
{
    int w, r;
    char *bfmt = *fmt;
    char c;
    int aseen = 0;

    for (; reps; --reps) {
	for (*fmt = bfmt; **fmt;) {
	    while ((**fmt == &#39;,&#39;) || (**fmt == &#39; &#39;)) {
		++*fmt;
	    }
	    if (isdigit(**fmt)) {
		r = 0;
		while (isdigit(**fmt)) {
		    r = r * 10 + **fmt - &#39;0&#39;;
		    ++*fmt;
		}
		r &amp;= 0xff;
	    } else {
		r = -1;
	    }
	    c = **fmt;
	    ++*fmt;
	    switch (c) {
		case &#39;,&#39;: break;
		case &#39;X&#39;:
		    if (r &lt; 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = &#39; &#39;;
			++*buf;
		    }
		    break;
		case &#39;A&#39;:
		    ++aseen;
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - &#39;0&#39;;
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (r &lt; 0) {
			r = 1;
		    }
		    r *= w;
		    for (; r; --r) {
			if (**in_s == 0) {
			    break;
			}
			**buf = **in_s;
			++*buf;
			++*in_s;
		    }
		    for (; r; --r) {
			**buf = &#39; &#39;;
			++*buf;
		    }
		    break;
		case &#39;/&#39;:
		    if (r &lt; 0) {
			r = 1;
		    }
		    for (; r; --r) {
			**buf = &#39;\n&#39;;
			++*buf;
			*base = *buf;
		    }
		    break;
		case &#39;\&#39;&#39;:
		    for (;;) {
			if (**fmt == 0) {
			    fprintf(stderr,
                   &quot;ftn_format: missing close \&#39; in string constant\n&quot;);
			    return 1;
			}
			if (**fmt == &#39;\&#39;&#39;) {
			    ++*fmt;
			    if (**fmt == &#39;\&#39;&#39;) {
				**buf = &#39;\&#39;&#39;;
				++*buf;
				++*fmt;
			    } else {
				break;
			    }
			} else {
			    **buf = **fmt;
			    ++*buf;
			    ++*fmt;
			}
		    }
		    break;
		case &#39;H&#39;:
		    if (r == 0) {
			break;
		    }
		    for (; r; --r) {
			if (**fmt == 0) {
			    fprintf(stderr,
                          &quot;ftn_format: Hollerith constant too short\n&quot;);
			    return 1;
			}
			**buf = **fmt;
			++*buf;
			++*fmt;
		    }
		    break;
		case &#39;T&#39;: /* T TL TR */
		    if (**fmt == &#39;R&#39;) {
			c = &#39;R&#39;;
			++*fmt;
		    } else if (**fmt == &#39;L&#39;) {
			c = &#39;L&#39;;
			++*fmt;
		    }
		    if (isdigit(**fmt)) {
			w = 0;
			while (isdigit(**fmt)) {
			    w = w * 10 + **fmt - &#39;0&#39;;
			    ++*fmt;
			}
		    } else {
			w = 1;
		    }
		    if (c == &#39;L&#39;) {
			*buf -= w;
		    } else if (c == &#39;R&#39;) {
			*buf += w;
		    } else {
			*buf = *base + w - 1;
		    }
		    break;
		case &#39;)&#39;:
		    if (**in_s == 0) {
			return 0;
		    }
		    if ((level == 1) &amp;&amp; **in_s) {
			reps = 2;
			goto btm;
		    }
		    if ((level &gt; 1) &amp;&amp; (reps &gt; 1)) {
			goto btm;
		    }
		    if ((level &gt; 1) &amp;&amp; (reps &lt; 0) &amp;&amp; (aseen == 0)) {
			return 0;
		    }
		    goto btm;
		    return 0;
		case &#39;(&#39;:
		    r = format(in_s, fmt, buf, limit, base,
			       r, level + 1);
		    if (r) {
			return r;
		    }
		    break;
		default:
		    if (c == 0) {
			fprintf(stderr,
                               &quot;ftn_format: premature end of format\n&quot;);
		    } else {
			fprintf(stderr,
                           &quot;ftn_format: bad format character: %c\n&quot;, c);
		    }
		    return 1;
	    }
	    if (*limit &lt; *buf) {
		*limit = *buf;
	    }
	}
btm: ;
    }
    return 0;
}

static char *ftn_format(char *s, char *f)
{
    char *in_s, *fmt, *buf, *limit, *base, *b;
    int r;

    /* format state */
    base = malloc(4096);
    fmt = f;
    in_s = s;
    buf = base;
    limit = base;
    b = base;

    for (r = 0; r &lt; 4096; ++r) {
	base[r] = &#39; &#39;;
    }
    if (*fmt != &#39;(&#39;) {
	fprintf(stderr, &quot;ftn_format: missing begin (\n&quot;);
	goto err;
    }
    if (*(fmt + strlen(fmt) - 1)  != &#39;)&#39;) {
	fprintf(stderr, &quot;ftn_format: missing end )\n&quot;);
	goto err;
    }

    ++fmt;
    r = format(&amp;in_s, &amp;fmt, &amp;buf, &amp;limit, &amp;b, 1, 1);
    if (r == 0) {
	*limit = 0;
	return base;
    }
err:
    free(base);
    return NULL;
}

/* FTN_FORMAT(STRING,STRING)STRING_FREE
 *
 * First STRING is the FORMAT, second is the FORMAT
 */
FTN_FORMAT( LA_ALIST ) LA_DCL
{
    char *result;
    char data[4096];
    char format[1024];
    getstring(LA_PTR(0), format, sizeof(format));
    getstring(LA_PTR(1), data, sizeof(data));
    result = ftn_format(data, format);
    if (result == NULL)
	RETFAIL;
    RETSTR_FREE(result);
}
-END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(format) :F(ERROR) ;
-SNOBOL LIBS = &#39;-L. -lp64&#39;
-SNOBOL OBJECTS = format ; OBJECTS &#39;.c&#39; = &#39;.o&#39;
-SNOBOL LINK_DYNAMIC(&#39;./format&#39;, OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON&#39;T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS format.so
-CMNT -SNOBOL A = CRACK(format &#39; &#39; OBJECTS, &#39; &#39;)
-CMNT -SNOBOL SEQ(&#39; DELETE(A&lt;K&gt;) &#39;, .K)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FORK()</font> copies the current process, and returns the pid (process
identifier) of the new process. In the child, it returns 0.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC FORK()
         LOAD(&#39;FORK()INTEGER&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">WAIT()</font> waits for the completion of a child process. It returns the
pid of the child process that has terminated, or negative on error.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC WAIT()
         LOAD(&#39;WAIT()INTEGER&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
To exit a child process, Unix supplies <font face="Source Code Pro">exit()</font>. However, <font face="Source Code Pro">EXIT()</font>
causes execution of new image in <font face="Source Code Pro">CSNOBOL4</font>. To exit a process,
assign the result status to <font face="Source Code Pro">&amp;CODE</font> and branch to <font face="Source Code Pro">END</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     &amp;CODE = 0  :(END)
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SPRINTF(F,V)</font> formats an <font face="Source Code Pro">INTEGER</font> or <font face="Source Code Pro">REAL</font> value <font face="Source Code Pro">V</font> using
the <font face="Source Code Pro">C</font> format <font face="Source Code Pro">F</font> and returns the result as a string. For example:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     SPRINTF("%d", I)
|     SPRINTF("%g", X)
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC SPRINTF()
         LOAD(&#39;SPRINTF(STRING,)STRING&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FTN_FORMAT(F, S)</font> formats string <font face="Source Code Pro">S</font> using <font face="Source Code Pro">FORTRAN IV FORMAT</font>
<font face="Source Code Pro">F</font> and returns the result as a string. <font face="Source Code Pro">CSNOBOL4</font> doesn't (natively)
support <font face="Source Code Pro">FORTRAN IV FORMAT</font> but this function provides the missing
support.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
FORMAT codes supported are
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     N H        Hollerith
|     N A M      Alphanumeric
|     N X        Spacing
|     T N        Tab to column N
|     TL N       Tab left by N
|     TR N       Tab right by N
|     N /        Record end
|     'TEXT'     Use '' for single '
|     N ( ... )  Grouping with repetition
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Other <font face="Source Code Pro">FORTRAN IV</font> conversion (I, F, etc.) not supported. FORMAT and
DATA limited to 1023 characters. Z conversion is not supported.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
When outputing to a printer, FORTRAN convention is that the first
character of the line controls line spacing and paging.The <font face="Source Code Pro">asa</font>
and <font face="Source Code Pro">asapdf</font> utilities interpret such print files. Generally, a
printer page is 132 columns by 60 lines. <font face="Source Code Pro">asa</font> specifies 4 characters
for control:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     ' '   Single line space
|     '0'   Double line space
|     '1'   New page
|     '+'   Overprint line
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The <font face="Source Code Pro">asapdf</font> utility takes an <font face="Source Code Pro">ASA</font> file, and encodes to <font face="Source Code Pro">PDF</font>.
<font face="Source Code Pro">asapdf</font> adds the following line controls:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     '-'   Triple line space (IBM extension)
|     'H'   Half line adance
|     'R'   No line advance, print RED
|     'G'   No line advance, print GREEN
|     'B'   No line advance, print BLUE
|     'r'   Advance, print RED
|     'g'   Advance, print GREEN
|     'b'   Advance, print BLUE
|     '^'   Overprint line, adding 127 to characters
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
MAINBOL default formats
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     OUTPUT  (1X,132A1)
|     CARD    (80A1)
</font></pre>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC FTN_FORMAT(), CREATEPIPE(), GETPIPEFD(), GET_ERRNO()
-PUBLIC CLEAR_ERRNO(), WAITPID(), GET_STATUS(), SIZEOF_TIMEVAL()
-PUBLIC SET_TIMEVAL(), SIZEOF_FD_SET(), FD_ZERO(), FD_CLR(), FD_SET()
-PUBLIC FD_ISSET()
<font color="#818181"><i>*</i></font>
         LOAD(&#39;FTN_FORMAT(STRING,STRING)STRING&#39;, &#39;format.so&#39;)
         LOAD(&#39;CREATEPIPE()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;GETPIPEFD(INTEGER)INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;GET_ERRNO()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;CLEAR_ERRNO()&#39;, &#39;format.so&#39;)
         LOAD(&#39;WAITPID_(INTEGER,INTEGER)INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;GET_STATUS()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;SIZEOF_TIMEVAL()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;SET_TIMEVAL(INTEGER,INTEGER,INTEGER)&#39;, &#39;format.so&#39;)
         LOAD(&#39;SIZEOF_FD_SET()INTEGER&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_ZERO_(INTEGER)&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_CLR_(INTEGER,INTEGER)&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_SET_(INTEGER,INTEGER)&#39;, &#39;format.so&#39;)
         LOAD(&#39;FD_ISSET_(INTEGER,INTEGER)INTEGER&#39;, &#39;format.so&#39;)
         DEFINE(&#39;FD_ZERO(FD_SET)&#39;)
         DEFINE(&#39;FD_CLR(FD,FD_SET)&#39;)
         DEFINE(&#39;FD_ISSET(FD,FD_SET)&#39;)
         DEFINE(&#39;FD_SET(FD,FD_SET)&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
We want to retrieve the FILE * for a unit. This can be used to perform
other forms of i/o, or to retrieve the underlying file descriptor.
Use FFI to access <font face="Source Code Pro">io_getfp()</font> and <font face="Source Code Pro">fileno()</font>. There may be a
bug in CSNOBOL4 1.5. When doing I/O using <font face="Source Code Pro">fgets()</font> (normal line
oriented) to a bi-direction pipe, we get errno 29 (ESPIPE) errors,
indicating that seek on the pipe failed. Of course, we can't seek
on the pipe; this is done solely to separate read and write. But,
there may be a timing issue because there are two separate processes
involved.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CSNOBOL4&raquo;&equiv;</b>
-PUBLIC CLOSE(), SELECT(), IO_GETFP(), FILENO()
         CLOSE_FFI = FFI_NEW(&#39;I&#39;, &#39;I&#39;)
         FFI_SET_CALLP(CLOSE_FFI, DLSYM(0, &#39;close&#39;))
         DEFINE(&#39;CLOSE(FD)&#39;)
         SELECT_FFI = FFI_NEW(&#39;I&#39;, &#39;I,P,P,P,P&#39;)
         FFI_SET_CALLP(SELECT_FFI, DLSYM(0, &#39;select&#39;))
         DEFINE(&#39;SELECT(NFDS,READFDS,WRITEFDS,EXCEPTFDS,TIMEOUT)&#39;)
         IO_GETFP_FFI = FFI_NEW(&#39;P&#39;, &#39;I&#39;)
         FFI_SET_CALLP(IO_GETFP_FFI, DLSYM(0, &#39;io_getfp&#39;))
         FILENO_FFI = FFI_NEW(&#39;I&#39;, &#39;P&#39;)
         FFI_SET_CALLP(FILENO_FFI, DLSYM(0, &#39;fileno&#39;))
         DEFINE(&#39;IO_GETFP(UNIT)&#39;)
         DEFINE(&#39;FILENO(FP)&#39;)                            <b>:(CSNOBOL4_END)</b>
<font color="#818181"><i>*</i></font>
CLOSE    FFI_PAR_N_INTEGER(CLOSE_FFI, 1, FD)
         CLOSE = FFI_CALL_INTEGER(CLOSE_FFI)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_CLR   FD_CLR_(FD, FD_SET)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_ISSET FD_ISSET = FD_ISSET_(FD, FD_SET)                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_SET   FD_SET_(FD, FD_SET)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FD_ZERO  FD_ZERO_(FD_SET)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
IO_GETFP FFI_PAR_N_INTEGER(IO_GETFP_FFI, 1, UNIT)
         IO_GETFP = FFI_CALL_PTR(IO_GETFP_FFI)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FILENO   FFI_PAR_N_PTR(FILENO_FFI, 1, FP)
         FILENO = FFI_CALL_INTEGER(FILENO_FFI)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SELECT   FFI_PAR_N_INTEGER(SELECT_FFI, 1, NFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 2, READFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 3, WRITEFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 4, EXCEPTFDS)
         FFI_PAR_N_PTR(SELECT_FFI, 5, TIMEOUT)
         SELECT = FFI_CALL_INTEGER(SELECT_FFI)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CSNOBOL4_END
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Open /dev/stdout (fd 1) as unit 10. Write to new I/O variable.
Obtain the FILE * (file pointer) for unit 10. Obtain the underlying
FD for the file pointer. Display both file pointer and file number,
and confirm that FD is 1.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CSNOBOL4.INC&#39;
         &amp;CODE = 1
         OUTPUT(.T_OUT, 10,, &#39;/dev/stdout&#39;)
         T_OUT = &#39;HELLO, WORLD&#39;
         FP = IO_GETFP(10)
         FD = FILENO(FP)
         OUTPUT = &#39;FILE * = &#39; FP
         OUTPUT = &#39;FD     = &#39; FD
         EQ(FD, 1)                                               <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE CSNOBOL4
<b>&laquo;INCLUDES&raquo;</b>
-STITL CSNOBOL4
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*  #####    #####   #     #  #######  ######   #######  #        #   # *</i></font>
<font color="#818181"><i>* #     #  #     #  ##    #  #     #  #     #  #     #  #        #   # *</i></font>
<font color="#818181"><i>* #        #        # #   #  #     #  #     #  #     #  #        #   # *</i></font>
<font color="#818181"><i>* #         #####   #  #  #  #     #  ######   #     #  #        ##### *</i></font>
<font color="#818181"><i>* #              #  #   # #  #     #  #     #  #     #  #            # *</i></font>
<font color="#818181"><i>* #     #  #     #  #    ##  #     #  #     #  #     #  #            # *</i></font>
<font color="#818181"><i>*  #####    #####   #     #  #######  ######   #######  #######      # *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CSNOBOL4         FUNCTIONS SPECIFIC TO CSNOBOL4                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CSNOBOL4.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CSNOBOL4&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Mon Jun  9 13:56:16 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CSNOBOL4.INC'
-LINE 588 "CSNOBOL4.lss"
         &CODE = 1
         OUTPUT(.T_OUT, 10,, '/dev/stdout')
         T_OUT = 'HELLO, WORLD'
         FP = IO_GETFP(10)
         FD = FILENO(FP)
         OUTPUT = 'FILE * = ' FP
         OUTPUT = 'FD     = ' FD
         EQ(FD, 1)                                               :F(END)
         &CODE = 0
END
<h1>CVAR - C Variable Declaration</h1>

To interface with other software, [[CSNOBOL4]] programs must exchange
data with this other software. This exchange can use files, pipes,
or calls. [[P64]] provides [[BASIC]]-like [[PEEK()]] and [[POKE()]]
functions.  [[CVAR]] provides a "named variable" access to these
external variables, layered on the [[P64]] facilities.

[[CVAR]] converts declarations into a symbol table. Keeps variable
names in table [[VTAB]]. Each variable is assigned an offset. When
all declarations are complete, [[VOFFSET]] will be the size of the
data region (possibly for [[malloc()]]).

Contrary to the valid declaration [['UNSIGNED LONG']], all 64 bit
integers are signed (because [[CSNOBOL4]] wants it that way). Still,
63 bits of integer are probably just fine, so we ignore this issue.
On 32 bit systems, 64 bit variables won't work well. Similarly,
on 32 bit systems, 32 bit integers are always signed.

Also, [[LONG DOUBLE]] is not supported (but will likely <b>never</b>
be supported by [[CSNOBOL4]]). Again, we ignore this.

All variables are aligned to the correct boundary (1 for [[CHAR]],
2 for [[SHORT]], 4 for [[INT/FLOAT]], 8 for [[LONG/DOUBLE]]). These
alignments are correct for 64 bit versions; they may require adjustment
for 32 bit targets.

A variable name begins with a letter or underscore, followed by
letters, digits or underscore. variables are case sensitive.

[[DECLAREV()]] will fail if an invalid declaration is passed.

Each variable is described by:

[[
    CV_OFFSET  Offset from base of data
    CV_SIZE    Variable size (1, 2, 4, 8) in bytes
    CV_DIM     Number of elements (1..N)
    CV_SIGN    0 = UNSIGNED, 1 = SIGNED (if integer)
    CV_ISINT   0 = FLOAT, 1 = INTEGER
]]

Example declarations:

[[
     CHAR S[20]         20 * 8 BIT SIGNED
     UNSIGNED CHAR C    UNSIGNED 8 BIT
     SHORT SH           SIGNED 16 BIT
     UNSIGNED INT U     UNSIGNED 32 BIT
     SIGNED I           SIGNED 32 BIT
     UNSIGNED U2        UNSIGNED 32 BIT
     LONG L             SIGNED 64 BIT
     UNSIGNED LONG L2   UNSIGNED 64 BIT
     POINTER P          64 BIT POINTER
     FLOAT F[10]        10 * 32 BIT FLOATS
     DOUBLE D           64 BIT DOUBLE
]]

[[
     CREATE NEW SYMBOL TABLE: NEWDECLV()
     DECLARE NEW VARIABLE:    DECLAREV(S)
     LOAD VAR FROM BASE:      LOADV(BASE, 'NAME' [, INDEX])
     STORE VAR TO BASE:       STOREV(BASE, 'NAME, [INDEX], VALUE)
]]

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="HASH.html">HASH</a><br>
<a href="P64.html">P64</a><br>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'P64.INC'
@

<<CVAR>>=
-MODULE CVAR
-USES HASH()
%SET (BITS, HOST(HOST_POINTER_BITS))
-PUBLIC CVART(), CV_OFFSET(), CV_SIZE(), CV_DIM(), CV_SIGN(), CV_ISINT()
         DATA('CVART(CV_OFFSET,CV_SIZE,CV_DIM,CV_SIGN,CV_ISINT)')
*
-PUBLIC PTRV(), LOADV(), STOREV(), NEWDECLV(), DECLAREV()
         DEFINE('PTRV(B,V,I)')
         DEFINE('LOADV(B,V,I)')
         DEFINE('STOREV(B,V,I,X)')
         DEFINE('NEWDECLV()')
         DEFINE('DECLAREV(L)SIGN,INT,FLOAT,AL,NU,SP,BS,BN,IDENT,DIM,'
+                          'INTDECL,FLOATDECL,DECL,SIZE,ALIGN,ISINT,'
+                          'S,T,I,N,SIGNED')         
                                                         :(DECLAREV_END)
*
PTRV     V = VTAB<V>
         IDENT(V)                                            :S(FRETURN)
         I = IDENT(I) 0
         PTRV = B + CV_OFFSET(V) + I * CV_SIZE(V)              :(RETURN)
*
STOREV   B = PTRV(B, V, I)                                   :F(FRETURN)
         V = VTAB<V>                          :($('STOREV_' CV_SIZE(V)))
STOREV_1 POKE_C(B, X)                                          :(RETURN)
STOREV_2 POKE_S(B, X)                                          :(RETURN)
STOREV_4 (EQ(CV_ISINT(V)) POKE_F(B, X))                       :S(RETURN)
         POKE_I(B, X)                                          :(RETURN)
STOREV_8 (EQ(CV_ISINT(V)) POKE_D(B, X))                       :S(RETURN)
         POKE_P(B, X)                                          :(RETURN)
*
LOADV    B = PTRV(B, V, I)                                   :F(FRETURN)
         V = VTAB<V>                           :($('LOADV_' CV_SIZE(V)))
LOADV_1  LOADV = PEEK_C(B)
         NE(CV_SIGN(V))                                       :S(RETURN)
         LOADV = LT(LOADV) (2 ** 8) + LOADV                    :(RETURN) 
LOADV_2  LOADV = PEEK_S(B)
                                                               :(RETURN)
         NE(CV_SIGN(V))                                       :S(RETURN)
         LOADV = LT(LOADV) (2 ** 16) + LOADV                   :(RETURN) 
LOADV_4  LOADV = EQ(CV_ISINT(V)) PEEK_F(B)                    :S(RETURN)
         LOADV = PEEK_I(B)
@

The next statement attempts to convert a negative 32 bit integer
to positive, keeping the same bit pattern. It will not work on a 32
CSNOBOL4 system. 2**32 will overflow, so only done on 64 bit system.
On a 32 bit system, all 32 bit integers are signed.

<<CVAR>>=
%IF (BITS EQ 32)
                                                               :(RETURN)
%ELSE
         NE(CV_SIGN(V))                                       :S(RETURN)
         LOADV = LT(LOADV) (2 ** 32) + LOADV                   :(RETURN)
%ENDIF
LOADV_8  LOADV = EQ(CV_ISINT(V)) PEEK_D(B)                    :S(RETURN)
         LOADV = PEEK_P(B)                                     :(RETURN)
*
NEWDECLV VTAB = TABLE()
         VOFFSET = 0                                           :(RETURN)
*
DECLAREV SIGN = ('signed' | 'SIGNED' | 'unsigned' | 'UNSIGNED') . S
         INT =  ('char' | 'CHAR' | 'short' | 'SHORT' | 'int' |
+                'INT' | 'long' | 'LONG' | 'pointer' | 'POINTER') . T
         FLOAT = ('float' | 'FLOAT' | 'double' | 'DOUBLE') . T
         AL = &UCASE &LCASE
         NU = &DIGITS
         SP = '_'
         BS = SPAN(' ' CHARS_TAB)
         BN = BS | NULL
         IDENT = (ANY(AL SP) (SPAN(AL NU SP) | NULL)) . I
         DIM = '[' BN SPAN(&DIGITS) . N BN ']'
         INTDECL = (SIGN BS INT) | SIGN | INT 
         FLOATDECL = FLOAT
         DECL = BN (INTDECL | FLOATDECL) BN IDENT BN (DIM | NULL)
*
         SIZE =
+           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
         ALIGN =
+           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
         ISINT =
+           #'CHAR=1,SHORT=1,INT=1,LONG=1,POINTER=1,FLOAT=,DOUBLE='
*
* ASSIGN PATTERN VARIABLE TO DEFAULTS - SIGNED INT [1]
*
         S = 'SIGNED'
         T = 'INT'
         I =
         N = 1
*
* SCAN THE DECLARATION, SETTING PATTERN VARIABLES S, T, I, N
*
         L DECL                                              :F(FRETURN)
*
* CONVERT T AND S TO UPPERCASE
*
         T = REPLACE(T, &LCASE, &UCASE)
         S = REPLACE(S, &LCASE, &UCASE)
*
* SIGNED = 1 IF SIGNED, 0 IF UNSIGNED
*
         SIGNED = 0
         S 'UNSIGNED'                                         :S(DECLV2)
         SIGNED = 1
*
* ADJUST OFFSET FOR ALIGNMENT
*
DECLV2   R = REMDR(VOFFSET, ALIGN<T>)
         VOFFSET = NE(R) VOFFSET + (ALIGN<T> - R)
*
* ALREADY DECLARED?
*
         V = VTAB<I>
         IDENT(V)                                            :F(FRETURN)
*
* CREATE CVART() RECORD FOR NEW VARIABLE
*
         V = CVART(VOFFSET, SIZE<T>, N, SIGNED, ISINT<T>)
*
* PUT VARIABLE INTO SYMBOL TABLE
*
         VTAB<I> = V
*
* ADJUST OFFSET BY SIZE OF NEW VARIABLE (INCLUDING DIMENSION)
*
         VOFFSET = VOFFSET + SIZE<T> * N
*
         DECLAREV = VOFFSET                                    :(RETURN)
*
DECLAREV_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CVAR.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL CVAR
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                   #####   #     #     #     ######                   *
*                  #     #  #     #    # #    #     #                  *
*                  #        #     #   #   #   #     #                  *
*                  #        #     #  #     #  ######                   *
*                  #         #   #   #######  #   #                    *
*                  #     #    # #    #     #  #    #                   *
*                   #####      #     #     #  #     #                  *
*                                                                      *
* CVAR           C VARIABLE DECLARATIONS, AND LOAD/STORE               *
*                                                                      *
************************************************************************
*
* CVAR.lss
*
<<CVAR>>
*
* CE: .MSNOBOL4;
@
-LINE 72 "CVAR.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'P64.INC'
-STITL CVAR
-EJECT
-LINE 223 "CVAR.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*                   #####   #     #     #     ######                   *
*                  #     #  #     #    # #    #     #                  *
*                  #        #     #   #   #   #     #                  *
*                  #        #     #  #     #  ######                   *
*                  #         #   #   #######  #   #                    *
*                  #     #    # #    #     #  #    #                   *
*                   #####      #     #     #  #     #                  *
*                                                                      *
* CVAR           C VARIABLE DECLARATIONS, AND LOAD/STORE               *
*                                                                      *
************************************************************************
*
* CVAR.lss
*
-LINE 78 "CVAR.lss"
-MODULE CVAR
-USES HASH()
-PUBLIC CVART(), CV_OFFSET(), CV_SIZE(), CV_DIM(), CV_SIGN(), CV_ISINT()
         DATA('CVART(CV_OFFSET,CV_SIZE,CV_DIM,CV_SIGN,CV_ISINT)')
*
-PUBLIC PTRV(), LOADV(), STOREV(), NEWDECLV(), DECLAREV()
         DEFINE('PTRV(B,V,I)')
         DEFINE('LOADV(B,V,I)')
         DEFINE('STOREV(B,V,I,X)')
         DEFINE('NEWDECLV()')
         DEFINE('DECLAREV(L)SIGN,INT,FLOAT,AL,NU,SP,BS,BN,IDENT,DIM,'
+                          'INTDECL,FLOATDECL,DECL,SIZE,ALIGN,ISINT,'
+                          'S,T,I,N,SIGNED')
                                                         :(DECLAREV_END)
*
PTRV     V = VTAB<V>
         IDENT(V)                                            :S(FRETURN)
         I = IDENT(I) 0
         PTRV = B + CV_OFFSET(V) + I * CV_SIZE(V)              :(RETURN)
*
STOREV   B = PTRV(B, V, I)                                   :F(FRETURN)
         V = VTAB<V>                          :($('STOREV_' CV_SIZE(V)))
STOREV_1 POKE_C(B, X)                                          :(RETURN)
STOREV_2 POKE_S(B, X)                                          :(RETURN)
STOREV_4 (EQ(CV_ISINT(V)) POKE_F(B, X))                       :S(RETURN)
         POKE_I(B, X)                                          :(RETURN)
STOREV_8 (EQ(CV_ISINT(V)) POKE_D(B, X))                       :S(RETURN)
         POKE_P(B, X)                                          :(RETURN)
*
LOADV    B = PTRV(B, V, I)                                   :F(FRETURN)
         V = VTAB<V>                           :($('LOADV_' CV_SIZE(V)))
LOADV_1  LOADV = PEEK_C(B)
         NE(CV_SIGN(V))                                       :S(RETURN)
         LOADV = LT(LOADV) (2 ** 8) + LOADV                    :(RETURN)
LOADV_2  LOADV = PEEK_S(B)
                                                               :(RETURN)
         NE(CV_SIGN(V))                                       :S(RETURN)
         LOADV = LT(LOADV) (2 ** 16) + LOADV                   :(RETURN)
LOADV_4  LOADV = EQ(CV_ISINT(V)) PEEK_F(B)                    :S(RETURN)
         LOADV = PEEK_I(B)
-LINE 127 "CVAR.lss"
         NE(CV_SIGN(V))                                       :S(RETURN)
         LOADV = LT(LOADV) (2 ** 32) + LOADV                   :(RETURN)
LOADV_8  LOADV = EQ(CV_ISINT(V)) PEEK_D(B)                    :S(RETURN)
         LOADV = PEEK_P(B)                                     :(RETURN)
*
NEWDECLV VTAB = TABLE()
         VOFFSET = 0                                           :(RETURN)
*
DECLAREV SIGN = ('signed' | 'SIGNED' | 'unsigned' | 'UNSIGNED') . S
         INT =  ('char' | 'CHAR' | 'short' | 'SHORT' | 'int' |
+                'INT' | 'long' | 'LONG' | 'pointer' | 'POINTER') . T
         FLOAT = ('float' | 'FLOAT' | 'double' | 'DOUBLE') . T
         AL = &UCASE &LCASE
         NU = &DIGITS
         SP = '_'
         BS = SPAN(' ' CHARS_TAB)
         BN = BS | NULL
         IDENT = (ANY(AL SP) (SPAN(AL NU SP) | NULL)) . I
         DIM = '[' BN SPAN(&DIGITS) . N BN ']'
         INTDECL = (SIGN BS INT) | SIGN | INT
         FLOATDECL = FLOAT
         DECL = BN (INTDECL | FLOATDECL) BN IDENT BN (DIM | NULL)
*
         SIZE =
+           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
         ALIGN =
+           #'CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8'
         ISINT =
+           #'CHAR=1,SHORT=1,INT=1,LONG=1,POINTER=1,FLOAT=,DOUBLE='
*
* ASSIGN PATTERN VARIABLE TO DEFAULTS - SIGNED INT [1]
*
         S = 'SIGNED'
         T = 'INT'
         I =
         N = 1
*
* SCAN THE DECLARATION, SETTING PATTERN VARIABLES S, T, I, N
*
         L DECL                                              :F(FRETURN)
*
* CONVERT T AND S TO UPPERCASE
*
         T = REPLACE(T, &LCASE, &UCASE)
         S = REPLACE(S, &LCASE, &UCASE)
*
* SIGNED = 1 IF SIGNED, 0 IF UNSIGNED
*
         SIGNED = 0
         S 'UNSIGNED'                                         :S(DECLV2)
         SIGNED = 1
*
* ADJUST OFFSET FOR ALIGNMENT
*
DECLV2   R = REMDR(VOFFSET, ALIGN<T>)
         VOFFSET = NE(R) VOFFSET + (ALIGN<T> - R)
*
* ALREADY DECLARED?
*
         V = VTAB<I>
         IDENT(V)                                            :F(FRETURN)
*
* CREATE CVART() RECORD FOR NEW VARIABLE
*
         V = CVART(VOFFSET, SIZE<T>, N, SIGNED, ISINT<T>)
*
* PUT VARIABLE INTO SYMBOL TABLE
*
         VTAB<I> = V
*
* ADJUST OFFSET BY SIZE OF NEW VARIABLE (INCLUDING DIMENSION)
*
         VOFFSET = VOFFSET + SIZE<T> * N
*
         DECLAREV = VOFFSET                                    :(RETURN)
*
DECLAREV_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>CVAR - C Variable Declaration</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
To interface with other software, <font face="Source Code Pro">CSNOBOL4</font> programs must exchange
data with this other software. This exchange can use files, pipes,
or calls. <font face="Source Code Pro">P64</font> provides <font face="Source Code Pro">BASIC</font>-like <font face="Source Code Pro">PEEK()</font> and <font face="Source Code Pro">POKE()</font>
functions.  <font face="Source Code Pro">CVAR</font> provides a "named variable" access to these
external variables, layered on the <font face="Source Code Pro">P64</font> facilities.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CVAR</font> converts declarations into a symbol table. Keeps variable
names in table <font face="Source Code Pro">VTAB</font>. Each variable is assigned an offset. When
all declarations are complete, <font face="Source Code Pro">VOFFSET</font> will be the size of the
data region (possibly for <font face="Source Code Pro">malloc()</font>).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Contrary to the valid declaration <font face="Source Code Pro">'UNSIGNED LONG'</font>, all 64 bit
integers are signed (because <font face="Source Code Pro">CSNOBOL4</font> wants it that way). Still,
63 bits of integer are probably just fine, so we ignore this issue.
On 32 bit systems, 64 bit variables won't work well. Similarly,
on 32 bit systems, 32 bit integers are always signed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Also, <font face="Source Code Pro">LONG DOUBLE</font> is not supported (but will likely <b>never</b>
be supported by <font face="Source Code Pro">CSNOBOL4</font>). Again, we ignore this.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
All variables are aligned to the correct boundary (1 for <font face="Source Code Pro">CHAR</font>,
2 for <font face="Source Code Pro">SHORT</font>, 4 for <font face="Source Code Pro">INT/FLOAT</font>, 8 for <font face="Source Code Pro">LONG/DOUBLE</font>). These
alignments are correct for 64 bit versions; they may require adjustment
for 32 bit targets.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
A variable name begins with a letter or underscore, followed by
letters, digits or underscore. variables are case sensitive.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DECLAREV()</font> will fail if an invalid declaration is passed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Each variable is described by:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     CV_OFFSET  Offset from base of data
|     CV_SIZE    Variable size (1, 2, 4, 8) in bytes
|     CV_DIM     Number of elements (1..N)
|     CV_SIGN    0 = UNSIGNED, 1 = SIGNED (if integer)
|     CV_ISINT   0 = FLOAT, 1 = INTEGER
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Example declarations:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|      CHAR S[20]         20 * 8 BIT SIGNED
|      UNSIGNED CHAR C    UNSIGNED 8 BIT
|      SHORT SH           SIGNED 16 BIT
|      UNSIGNED INT U     UNSIGNED 32 BIT
|      SIGNED I           SIGNED 32 BIT
|      UNSIGNED U2        UNSIGNED 32 BIT
|      LONG L             SIGNED 64 BIT
|      UNSIGNED LONG L2   UNSIGNED 64 BIT
|      POINTER P          64 BIT POINTER
|      FLOAT F[10]        10 * 32 BIT FLOATS
|      DOUBLE D           64 BIT DOUBLE
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|      CREATE NEW SYMBOL TABLE: NEWDECLV()
|      DECLARE NEW VARIABLE:    DECLAREV(S)
|      LOAD VAR FROM BASE:      LOADV(BASE, 'NAME' [, INDEX])
|      STORE VAR TO BASE:       STOREV(BASE, 'NAME, [INDEX], VALUE)
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="HASH.html">HASH</a><br>
<a href="P64.html">P64</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;P64.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CVAR&raquo;&equiv;</b>
-MODULE CVAR
-USES HASH()
%SET (BITS, HOST(HOST_POINTER_BITS))
-PUBLIC CVART(), CV_OFFSET(), CV_SIZE(), CV_DIM(), CV_SIGN(), CV_ISINT()
         DATA(&#39;CVART(CV_OFFSET,CV_SIZE,CV_DIM,CV_SIGN,CV_ISINT)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC PTRV(), LOADV(), STOREV(), NEWDECLV(), DECLAREV()
         DEFINE(&#39;PTRV(B,V,I)&#39;)
         DEFINE(&#39;LOADV(B,V,I)&#39;)
         DEFINE(&#39;STOREV(B,V,I,X)&#39;)
         DEFINE(&#39;NEWDECLV()&#39;)
         DEFINE(&#39;DECLAREV(L)SIGN,INT,FLOAT,AL,NU,SP,BS,BN,IDENT,DIM,&#39;
+                          &#39;INTDECL,FLOATDECL,DECL,SIZE,ALIGN,ISINT,&#39;
+                          &#39;S,T,I,N,SIGNED&#39;)
                                                         <b>:(DECLAREV_END)</b>
<font color="#818181"><i>*</i></font>
PTRV     V = VTAB&lt;V&gt;
         IDENT(V)                                            <b>:S(FRETURN)</b>
         I = IDENT(I) 0
         PTRV = B + CV_OFFSET(V) + I * CV_SIZE(V)              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
STOREV   B = PTRV(B, V, I)                                   <b>:F(FRETURN)</b>
         V = VTAB&lt;V&gt;                          <b>:($(&#39;STOREV_&#39; CV_SIZE(V)))</b>
STOREV_1 POKE_C(B, X)                                          <b>:(RETURN)</b>
STOREV_2 POKE_S(B, X)                                          <b>:(RETURN)</b>
STOREV_4 (EQ(CV_ISINT(V)) POKE_F(B, X))                       <b>:S(RETURN)</b>
         POKE_I(B, X)                                          <b>:(RETURN)</b>
STOREV_8 (EQ(CV_ISINT(V)) POKE_D(B, X))                       <b>:S(RETURN)</b>
         POKE_P(B, X)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
LOADV    B = PTRV(B, V, I)                                   <b>:F(FRETURN)</b>
         V = VTAB&lt;V&gt;                           <b>:($(&#39;LOADV_&#39; CV_SIZE(V)))</b>
LOADV_1  LOADV = PEEK_C(B)
         NE(CV_SIGN(V))                                       <b>:S(RETURN)</b>
         LOADV = LT(LOADV) (2 ** 8) + LOADV                    <b>:(RETURN)</b>
LOADV_2  LOADV = PEEK_S(B)
                                                               <b>:(RETURN)</b>
         NE(CV_SIGN(V))                                       <b>:S(RETURN)</b>
         LOADV = LT(LOADV) (2 ** 16) + LOADV                   <b>:(RETURN)</b>
LOADV_4  LOADV = EQ(CV_ISINT(V)) PEEK_F(B)                    <b>:S(RETURN)</b>
         LOADV = PEEK_I(B)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
The next statement attempts to convert a negative 32 bit integer
to positive, keeping the same bit pattern. It will not work on a 32
CSNOBOL4 system. 2**32 will overflow, so only done on 64 bit system.
On a 32 bit system, all 32 bit integers are signed.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;CVAR&raquo;&equiv;</b>
%IF (BITS EQ 32)
                                                               <b>:(RETURN)</b>
%ELSE
         NE(CV_SIGN(V))                                       <b>:S(RETURN)</b>
         LOADV = LT(LOADV) (2 ** 32) + LOADV                   <b>:(RETURN)</b>
%ENDIF
LOADV_8  LOADV = EQ(CV_ISINT(V)) PEEK_D(B)                    <b>:S(RETURN)</b>
         LOADV = PEEK_P(B)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
NEWDECLV VTAB = TABLE()
         VOFFSET = 0                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DECLAREV SIGN = (&#39;signed&#39; | &#39;SIGNED&#39; | &#39;unsigned&#39; | &#39;UNSIGNED&#39;) . S
         INT =  (&#39;char&#39; | &#39;CHAR&#39; | &#39;short&#39; | &#39;SHORT&#39; | &#39;int&#39; |
+                &#39;INT&#39; | &#39;long&#39; | &#39;LONG&#39; | &#39;pointer&#39; | &#39;POINTER&#39;) . T
         FLOAT = (&#39;float&#39; | &#39;FLOAT&#39; | &#39;double&#39; | &#39;DOUBLE&#39;) . T
         AL = &amp;UCASE &amp;LCASE
         NU = &amp;DIGITS
         SP = &#39;_&#39;
         BS = SPAN(&#39; &#39; CHARS_TAB)
         BN = BS | NULL
         IDENT = (ANY(AL SP) (SPAN(AL NU SP) | NULL)) . I
         DIM = &#39;[&#39; BN SPAN(&amp;DIGITS) . N BN &#39;]&#39;
         INTDECL = (SIGN BS INT) | SIGN | INT
         FLOATDECL = FLOAT
         DECL = BN (INTDECL | FLOATDECL) BN IDENT BN (DIM | NULL)
<font color="#818181"><i>*</i></font>
         SIZE =
+           #&#39;CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8&#39;
         ALIGN =
+           #&#39;CHAR=1,SHORT=2,INT=4,LONG=8,POINTER=8,FLOAT=4,DOUBLE=8&#39;
         ISINT =
+           #&#39;CHAR=1,SHORT=1,INT=1,LONG=1,POINTER=1,FLOAT=,DOUBLE=&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ASSIGN PATTERN VARIABLE TO DEFAULTS - SIGNED INT [1]</i></font>
<font color="#818181"><i>*</i></font>
         S = &#39;SIGNED&#39;
         T = &#39;INT&#39;
         I =
         N = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SCAN THE DECLARATION, SETTING PATTERN VARIABLES S, T, I, N</i></font>
<font color="#818181"><i>*</i></font>
         L DECL                                              <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONVERT T AND S TO UPPERCASE</i></font>
<font color="#818181"><i>*</i></font>
         T = REPLACE(T, &amp;LCASE, &amp;UCASE)
         S = REPLACE(S, &amp;LCASE, &amp;UCASE)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SIGNED = 1 IF SIGNED, 0 IF UNSIGNED</i></font>
<font color="#818181"><i>*</i></font>
         SIGNED = 0
         S &#39;UNSIGNED&#39;                                         <b>:S(DECLV2)</b>
         SIGNED = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ADJUST OFFSET FOR ALIGNMENT</i></font>
<font color="#818181"><i>*</i></font>
DECLV2   R = REMDR(VOFFSET, ALIGN&lt;T&gt;)
         VOFFSET = NE(R) VOFFSET + (ALIGN&lt;T&gt; - R)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ALREADY DECLARED?</i></font>
<font color="#818181"><i>*</i></font>
         V = VTAB&lt;I&gt;
         IDENT(V)                                            <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE CVART() RECORD FOR NEW VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
         V = CVART(VOFFSET, SIZE&lt;T&gt;, N, SIGNED, ISINT&lt;T&gt;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PUT VARIABLE INTO SYMBOL TABLE</i></font>
<font color="#818181"><i>*</i></font>
         VTAB&lt;I&gt; = V
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ADJUST OFFSET BY SIZE OF NEW VARIABLE (INCLUDING DIMENSION)</i></font>
<font color="#818181"><i>*</i></font>
         VOFFSET = VOFFSET + SIZE&lt;T&gt; * N
<font color="#818181"><i>*</i></font>
         DECLAREV = VOFFSET                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DECLAREV_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;CVAR.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL CVAR
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   #####   #     #     #     ######                   *</i></font>
<font color="#818181"><i>*                  #     #  #     #    # #    #     #                  *</i></font>
<font color="#818181"><i>*                  #        #     #   #   #   #     #                  *</i></font>
<font color="#818181"><i>*                  #        #     #  #     #  ######                   *</i></font>
<font color="#818181"><i>*                  #         #   #   #######  #   #                    *</i></font>
<font color="#818181"><i>*                  #     #    # #    #     #  #    #                   *</i></font>
<font color="#818181"><i>*                   #####      #     #     #  #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CVAR           C VARIABLE DECLARATIONS, AND LOAD/STORE               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CVAR.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;CVAR&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:54 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'CVAR.INC'
-LINE 214 "CVAR.lss"
         &CODE = 1
         &CODE = 0
END
<h1>DAY - Day of Week</h1>

Returns current day of the week (SUNDAY..SATURDAY). If no argument
is supplied, use today. Date is specified as M/D/Y. If year is not
specified, this year is used. If year is two digits, interpret as 20XX.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<DAY>>=
-MODULE DAY
-PUBLIC DAY()
         DEFINE('DAY(DATE)M,Y,CD')
         YEAR_ = 365
         YEAR_4 = 4 * YEAR_ + 1
         CENT_ = (25 * YEAR_4) - 1
         CENT_4 = 4 * CENT_ + 1
         DAY_ZERO = 2                                         :(DAY_END)
*
DAY      CD = DATE()
         DIFFER(DATE)                                          :S(DAY_3)
* IF NO DATE GIVEN, USE TODAY
         CD ARB . DATE ' '
DAY_3    DATE BREAK('/') . M LEN(1)
+           (BREAK('/') . D LEN(1) REM . Y | REM . D)
* IF NO YEAR GIVEN, USE THIS YEAR
         (IDENT(Y) CD) '/' ARB '/' LEN(4) . Y
* TWO DIGIT YEAR IS 20XX
         Y = EQ(SIZE(Y), 2) '20' Y
         M = LE(M, 2) M + 12                                   :F(DAY_1)
         Y = Y - 1
DAY_1    M = M - 3
DAY_2    DAY = (Y / 400) * CENT_4 + (REMDR(Y, 400) / 100) * CENT_
+           +  (REMDR(Y, 100) / 4) * YEAR_4 +  REMDR(Y, 4) * YEAR_
         DAY = DAY + ((153 * M) + 2) / 5 + D + DAY_ZERO
         D = REMDR(DAY, 7)
         '0SUN1MON2TUES3WEDNES4THURS5FRI6SATUR7'
+           D BREAK('01234567') . DAY
         DAY = DAY 'DAY'                                       :(RETURN)
*
DAY_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DAY.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL DAY
-EJECT
*
************************************************************************
*                                                                      *
*                      ######      #     #     #                       *
*                      #     #    # #     #   #                        *
*                      #     #   #   #     # #                         *
*                      #     #  #     #     #                          *
*                      #     #  #######     #                          *
*                      #     #  #     #     #                          *
*                      ######   #     #     #                          *
*                                                                      *
* DAY                         DAY OF WEEK                              *
*                                                                      *
************************************************************************
*
* DAY.lss
*
<<DAY>>
*
* CE: .MSNOBOL4;
@
-STITL DAY
-EJECT
*
-LINE 59 "DAY.lss"
************************************************************************
*                                                                      *
*                      ######      #     #     #                       *
*                      #     #    # #     #   #                        *
*                      #     #   #   #     # #                         *
*                      #     #  #     #     #                          *
*                      #     #  #######     #                          *
*                      #     #  #     #     #                          *
*                      ######   #     #     #                          *
*                                                                      *
* DAY                         DAY OF WEEK                              *
*                                                                      *
************************************************************************
*
* DAY.lss
*
-LINE 13 "DAY.lss"
-MODULE DAY
-PUBLIC DAY()
         DEFINE('DAY(DATE)M,Y,CD')
         YEAR_ = 365
         YEAR_4 = 4 * YEAR_ + 1
         CENT_ = (25 * YEAR_4) - 1
         CENT_4 = 4 * CENT_ + 1
         DAY_ZERO = 2                                         :(DAY_END)
*
DAY      CD = DATE()
         DIFFER(DATE)                                          :S(DAY_3)
* IF NO DATE GIVEN, USE TODAY
         CD ARB . DATE ' '
DAY_3    DATE BREAK('/') . M LEN(1)
+           (BREAK('/') . D LEN(1) REM . Y | REM . D)
* IF NO YEAR GIVEN, USE THIS YEAR
         (IDENT(Y) CD) '/' ARB '/' LEN(4) . Y
* TWO DIGIT YEAR IS 20XX
         Y = EQ(SIZE(Y), 2) '20' Y
         M = LE(M, 2) M + 12                                   :F(DAY_1)
         Y = Y - 1
DAY_1    M = M - 3
DAY_2    DAY = (Y / 400) * CENT_4 + (REMDR(Y, 400) / 100) * CENT_
+           +  (REMDR(Y, 100) / 4) * YEAR_4 +  REMDR(Y, 4) * YEAR_
         DAY = DAY + ((153 * M) + 2) / 5 + D + DAY_ZERO
         D = REMDR(DAY, 7)
         '0SUN1MON2TUES3WEDNES4THURS5FRI6SATUR7'
+           D BREAK('01234567') . DAY
         DAY = DAY 'DAY'                                       :(RETURN)
*
DAY_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DAY - Day of Week</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Returns current day of the week (SUNDAY..SATURDAY). If no argument
is supplied, use today. Date is specified as M/D/Y. If year is not
specified, this year is used. If year is two digits, interpret as 20XX.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DAY&raquo;&equiv;</b>
-MODULE DAY
-PUBLIC DAY()
         DEFINE(&#39;DAY(DATE)M,Y,CD&#39;)
         YEAR_ = 365
         YEAR_4 = 4 * YEAR_ + 1
         CENT_ = (25 * YEAR_4) - 1
         CENT_4 = 4 * CENT_ + 1
         DAY_ZERO = 2                                         <b>:(DAY_END)</b>
<font color="#818181"><i>*</i></font>
DAY      CD = DATE()
         DIFFER(DATE)                                          <b>:S(DAY_3)</b>
<font color="#818181"><i>* IF NO DATE GIVEN, USE TODAY</i></font>
         CD ARB . DATE &#39; &#39;
DAY_3    DATE BREAK(&#39;/&#39;) . M LEN(1)
+           (BREAK(&#39;/&#39;) . D LEN(1) REM . Y | REM . D)
<font color="#818181"><i>* IF NO YEAR GIVEN, USE THIS YEAR</i></font>
         (IDENT(Y) CD) &#39;/&#39; ARB &#39;/&#39; LEN(4) . Y
<font color="#818181"><i>* TWO DIGIT YEAR IS 20XX</i></font>
         Y = EQ(SIZE(Y), 2) &#39;20&#39; Y
         M = LE(M, 2) M + 12                                   <b>:F(DAY_1)</b>
         Y = Y - 1
DAY_1    M = M - 3
DAY_2    DAY = (Y / 400) * CENT_4 + (REMDR(Y, 400) / 100) * CENT_
+           +  (REMDR(Y, 100) / 4) * YEAR_4 +  REMDR(Y, 4) * YEAR_
         DAY = DAY + ((153 * M) + 2) / 5 + D + DAY_ZERO
         D = REMDR(DAY, 7)
         &#39;0SUN1MON2TUES3WEDNES4THURS5FRI6SATUR7&#39;
+           D BREAK(&#39;01234567&#39;) . DAY
         DAY = DAY &#39;DAY&#39;                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DAY_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DAY.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL DAY
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      ######      #     #     #                       *</i></font>
<font color="#818181"><i>*                      #     #    # #     #   #                        *</i></font>
<font color="#818181"><i>*                      #     #   #   #     # #                         *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #######     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      ######   #     #     #                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DAY                         DAY OF WEEK                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DAY.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DAY&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:54 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DAY.INC'
-LINE 50 "DAY.lss"
         &CODE = 1
         &CODE = 0
END
<h1>DDTCARD - A card with DDT()</h1>

Provide a card containing [[DDT()]]. For use with [[-L]] or [[-M]]
CSNOBOL4 options.

<h2>Uses</h2>
<a href="DDT.html">DDT</a><br>

<<INCLUDES>>=
-INCLUDE 'DDT.INC'
@

<<DDTCARD>>=
         DDT()
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DDTCARD.INC'
START    &CODE = 1
         &CODE = 0
END START
@

<<>>=
-MODULE DDTCARD
-STITL DDTCARD
-EJECT
*
************************************************************************
*                                                                      *
*    ######   ######   #######   #####      #     ######   ######      *
*    #     #  #     #     #     #     #    # #    #     #  #     #     *
*    #     #  #     #     #     #         #   #   #     #  #     #     *
*    #     #  #     #     #     #        #     #  ######   #     #     *
*    #     #  #     #     #     #        #######  #   #    #     #     *
*    #     #  #     #     #     #     #  #     #  #    #   #     #     *
*    ######   ######      #      #####   #     #  #     #  ######      *
*                                                                      *
* DDTCARD       FOR USE WITH -M (MULTI-FILE) OR -L                     *
*                                                                      *
************************************************************************
*
* DDTCARD.lss
*
<<DDTCARD>>
*
* CE: .MSNOBOL4;
@
-MODULE DDTCARD
-STITL DDTCARD
-EJECT
-LINE 30 "DDTCARD.lss"
*
************************************************************************
*                                                                      *
*    ######   ######   #######   #####      #     ######   ######      *
*    #     #  #     #     #     #     #    # #    #     #  #     #     *
*    #     #  #     #     #     #         #   #   #     #  #     #     *
*    #     #  #     #     #     #        #     #  ######   #     #     *
*    #     #  #     #     #     #        #######  #   #    #     #     *
*    #     #  #     #     #     #     #  #     #  #    #   #     #     *
*    ######   ######      #      #####   #     #  #     #  ######      *
*                                                                      *
* DDTCARD       FOR USE WITH -M (MULTI-FILE) OR -L                     *
*                                                                      *
************************************************************************
*
* DDTCARD.lss
*
-LINE 14 "DDTCARD.lss"
         DDT()
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DDTCARD - A card with DDT()</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Provide a card containing <font face="Source Code Pro">DDT()</font>. For use with <font face="Source Code Pro">-L</font> or <font face="Source Code Pro">-M</font>
CSNOBOL4 options.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="DDT.html">DDT</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;DDT.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDTCARD&raquo;&equiv;</b>
         DDT()
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DDTCARD.INC&#39;
START    &amp;CODE = 1
         &amp;CODE = 0
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE DDTCARD
-STITL DDTCARD
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    ######   ######   #######   #####      #     ######   ######      *</i></font>
<font color="#818181"><i>*    #     #  #     #     #     #     #    # #    #     #  #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #     #     #         #   #   #     #  #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #     #     #        #     #  ######   #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #     #     #        #######  #   #    #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #     #     #     #  #     #  #    #   #     #     *</i></font>
<font color="#818181"><i>*    ######   ######      #      #####   #     #  #     #  ######      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DDTCARD       FOR USE WITH -M (MULTI-FILE) OR -L                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DDTCARD.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DDTCARD&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:55 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DDTCARD.INC'
-LINE 21 "DDTCARD.lss"
START    &CODE = 1
         &CODE = 0
END START
<h1>DDT - An Interactive SNOBOL4 Debugger</h1>

<i>DDT</i> is a source level debugger for CSNOBOL4.

[[INCLUDE 'DDT.INC']] into the program to be debugged. At the point
that the debugger should be activated, insert the statement

[[
   DDT()
]]

which will enter the debugger.

Source statements can be made available by creating an environment
variable named [[LIST]] equated to the name of a listing file, or by

[[
    LIST=SRC.LST ./PROG.SNO
]]

or

[[
    DDT: X snobol4 -n -l SRC.LST SRC.SNO
    DDT: S
    LISTING: SRC.LST
    SOURCE LISTING LOADED
    DDT:
]]

Supplying a [[LIST=]] environment automatically attempts loading the
listing at debugger start. This will give a symbolic line for the
first line after the [[DDT()]] invocation.

If there is a block of statements that are to be excluded from tracing
(such as initializations), bracket them with

[[
    &TRACE = 0 ..... &TRACE = 999999999
]]

[[FREEZE()]] and [[THAW()]] are used to prevent entries from being
inserted into the breakpoint and source tables, keeping the footprint
of [[DDT]] smaller. [[READLINE()]] is used to allow editing and
retrieval of command lines.

<i>DDT</i> will display user datatypes with the = command. More
sophisticated behavious will be introduced with the INSPECT module
at a future date. (see DDT.E)

[[SLOAD]] is not actually needed for [[DDT]]. It is included to allow
additional tools to be incorporated while debugging.

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="FREEZE.html">FREEZE</a><br>
<a href="HOST.html">HOST</a><br>
<a href="QUOTE.html">QUOTE</a><br>
<a href="READLINE.html">READLINE</a><br>
<a href="SLOAD.html">SLOAD</a><br>
<a href="TRIMB.html">TRIMB</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'FREEZE.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'QUOTE.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'SLOAD.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
@

<<DDT>>=
-WEAK DSERVE_APPNAME
-USES SLOAD()
-PUBLIC DDT(), DEBUG(), DDT_LOADED, DDT_ACTIVE
         DEFINE('DDT(S)')
         DEFINE('DEBUG(S)', 'DDT')
*
         DDT_LOADED = 1
         DDT_ACTIVE = 0
*
* REMOTE DEBUG, DDT_USE_R IS FLAG TO GET INPUT FROM REMOTE (= 1).
* IF 2, WE ARE IN GUI.
* DDT_T IS OUTPUT (ALWAYS) AND DDT_R IN READ CHANNEL. IF DDT_USE_R
* IS NULL, READLINE() WILL BE USED. IF IT IS NOT NULL, DDT_R WILL
* BE USED FOR COMMANDS AND INPUT.
*
-PUBLIC DDT_T, DDT_USE_R, DDT_R
         DDT_T_UNIT = IO_FINDUNIT()
         OUTPUT(.DDT_T, DDT_T_UNIT, 'W', '/dev/stderr')
         DDT_USE_R =
*        DDT_R_UNIT = IO_FINDUNIT()
*        INPUT(.DDT_R, DDT_R_UNIT,, '/dev/stdin')
                                                              :(DDT_END)
*
DDT      DDT_ACTIVE = 1
         DDT_COUNT = 0
         DDT_IGNORE =
         DDT_UNIT2 =
         RLAPPNAME('DDT')
         READ_HISTORY('.DDT')
         STIFLE_HISTORY(50)
         DEFINE('DDT(S)', 'DDT_')
         DEFINE('DEBUG(S)', 'DDT_')
         DEFINE('DDT_SOURCE()')
@

[[DDT()]] and [[DEBUG()]] are the primary calls into the
debugger. [[DDT_SUSPEND()]] will suspend the debugger, and
[[DDT_RESUME()]] will resume normal operation.  [[DDT_ACTIVE]] and
[[DDT_LOADED]] variables can be examined. [[DDT_LOADED]] will be
[[NULL]] if [[DDT]] has not been loaded. See <A HREF="BQ.html">BQ</A>
for an example of this use.

<<DDT>>=
-PUBLIC DDT_SUSPEND(), DDT_RESUME(), DDT_TOUT()
         DEFINE('DDT_SUSPEND()', 'DDT.O')
         DEFINE('DDT_RESUME()')
         DEFINE('DDT_TOUT(S)')
*
         DDT_TOUT('DDT (FRI MAY 23 15:30:53 EDT 2014)')
         DDT_TOUT('TRY H FOR HELP')
         DDT_SOURCE =
         DDT_LIST_F =
         DDT_LIST_L =
         DDT_FINAL_STMT =
         DDT_CURR_STMT =
         DDT_BREAK_TAB = TABLE()
         DDT_BREAK_TEMP = TABLE()
         DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_WHITE = CHARS_HT ' '
         DDT_G_PAT = FENCE '=' (BREAK(DDT_WHITE ',') | REM)
+           . DDT_CMD (SPAN(DDT_WHITE ',') | RPOS(0))
         DDT_CHARU = CHARS_HT ' CBE=GHKLPQRTI+-?!XOSMV*.'
         DDT_CHARL = CHARS_HT ' cbe=ghklpqrti+-?!xosmv*.'
         DDT_CHARR =      'C' 'CCBEEGHKLPQRTI+-HXXOSMV*.'
         DDT_CHARS = FENCE ANY(DDT_CHARU DDT_CHARL) . DDT_C
+           (SPAN(DDT_WHITE) | '')
         DDT_DL_PAT = FENCE LEN(8) (NOTANY(DDT_WHITE)
+           (BREAK(DDT_WHITE CHARS_NL) | REM)) . DDT_LABEL
         DDT_GET_PAT1 = FENCE SPAN(&DIGITS) . DDT_GET_STMT
+           (SPAN(DDT_WHITE ',') | RPOS(0))
         DDT_GET_PAT2 = FENCE (BREAK(',') | REM) . LABEL
+           (SPAN(DDT_WHITE ',') | RPOS(0))
         DDT_GET_PAT3 = FENCE BREAK('+-' DDT_WHITE) . LABEL
+           BREAK('+-') LEN(1) . SIGN BREAK(&DIGITS)
+           SPAN(&DIGITS) . OFFSET
+           (SPAN(DDT_WHITE ',') | RPOS(0))
         DEFINE('DDT_LABEL(STNO)OFFSET')
         DEFINE('DDT_GET_STMT(S)LABEL,SIGN,OFFSET')
         DEFINE('DDT_FNC()')
         DEFINE('DDT_CASE(DDT_CASE)')
         DEFINE('DDT_CMD()'
+           'DDT_A,DDT_B,DDT_C,DDT_IN,DDT_I,DDT_FIELD,DDT_RESULT,DDT_V')
         DEFINE('DDT_READLIST(LABTAB,LAST)'
+           'STNO,STMT,LINE,LABEL,PAT1,PAT2,PAT3,PAT4,PAT5')
         DDT_STMTS = TABLE()
         DDT_LBLS = TABLE(50, 50)
         FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         HOST(HOST_GETENV, 'LIST')                              :F(DDT_)
         DDT_SOURCE()
*
@

The [[DDT()]] function can be invoked to re-enter the debugger. This is
usually used to generate complex breakpoints. [[DDT()]] (also known
as [[DEBUG()]]) can be given an argument. This name can be reference
in an I command: [[I 'MSG' N]] which ignores the next [[N]] calls to
[[DDT/DEBUG]] with the matching string. After this, the [[DDT()]] or
[[DEBUG()]] call will enter the debugger.

<<DDT>>=
DDT_     S DDT_IGNORE                                          :F(DDT2_)
         DDT_COUNT = GT(DDT_COUNT) DDT_COUNT - 1              :S(RETURN)
DDT2_    DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_TOUT('DDT(' S ')')
DDT_RESUME
         &STLIMIT = 999999999
         &TRACE = 999999999
         TRACE('STCOUNT', 'KEYWORD',, 'DDT_FNC')               :(RETURN)
*
* CURRENT STATEMENT
*
DDT_FNC  DDT_CURR_STMT = &LASTNO
*
* IF NOT SINGLE-STEPPING AND DID NOT HIT A BREAKPOINT, JUST RETURN.
*
         (LE(DDT_STEP_COUNT)
+           IDENT(DDT_BREAK_TAB<DDT_CURR_STMT>)
+           IDENT(DDT_BREAK_TEMP<DDT_CURR_STMT>))             :S(RETURN)
*
* IF IT WAS A BREAKPOINT, TURN OFF ANY SINGLE-STEPPING.
*
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TAB<DDT_CURR_STMT>)
+                                                        :S(DDT_DISPLAY)
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TEMP<DDT_CURR_STMT>)
+                                                        :S(DDT_DISPLAY)
*
* IF DOING A P TRACE, DON'T STOP IF DOWN IN A FUNCTION.
*
         GT(&FNCLEVEL, DDT_FNCLEVEL)                          :S(RETURN)
*
* MUST HAVE BEEN SINGLE-STEPPING. DECREMENT COUNT.
*
         DDT_STEP_COUNT = DDT_STEP_COUNT - 1
*
* DISPLAY CURRENT STATEMENT.
*
DDT_DISPLAY
         DIFFER(DDT_HOOK)                              :S(DDT_DISPLAY_2)
         DDT_FNC = DDT_LABEL(DDT_CURR_STMT)
         DDT_TOUT(VDIFFER(DDT_FNC))
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) DDT_STMTS<DDT_CURR_STMT>)
         DDT_TOUT(IDENT(DDT_FINAL_STMT) DDT_CURR_STMT)
*
* CALL EXTERNAL ROUTINE IF DEFINED TO REGISTER BREAK. THIS CAN
* REPLICATE SOME OF THE ABOVE IF NEEDED.
*
-PUBLIC DDT_HOOK
DDT_DISPLAY_2
         DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'BREAK', DDT_CURR_STMT)
*
* LISTING BEGINS HERE
*
         DDT_LIST_F = DDT_CURR_STMT
         DDT_LIST_L = DDT_CURR_STMT
*
* IF MORE SINGLE-STEPPING TO DO, JUST EXIT
*
         GT(DDT_STEP_COUNT)                                   :S(RETURN)
*
@

Here is where we read commands from the user. Control stays within
DDT.CMD until it is time to return to the user program. A failure
return means resume where interrupted. A success return requests a
direct jump to a user label. This direct jump is kludgy because we are
down one level in function call depth &ndash; too many of these and the
stack will overflow. Too bad you can't manipulate return.

<<DDT>>=
         THAW(DDT_BREAK_TAB)
         THAW(DDT_BREAK_TEMP)
         DDT_BREAK_TEMP = TABLE()
         DDT_ACTIVE = 1
         DDT_CURR_STMT = DDT_CMD()                            :F(RETURN)
*
* JUMP TO USER'S LABEL WITHOUT CLEARING INTERRUPT
*
         &TRACE = 999999999                            :($DDT_CURR_STMT)
*
* CONVERT TO UPPERCASE IF SOURCE IS NOT CASE SENSITIVE
*
DDT_CASE DDT_CASE = NE(&CASE)
+           REPLACE(DDT_CASE, &LCASE, &UCASE)                  :(RETURN)
*
@

Function to return [['(']] and statement label and offset [[')']]
given a statement number. If [[DDT_FINAL_STMT]] is [[NULL]], there
is no listing available, and we just return a [[NULL]] string.

<<DDT>>=
DDT_LABEL
         IDENT(DDT_FINAL_STMT)                                :S(RETURN)
DDT_LAB2 DDT_STMTS<STNO> DDT_DL_PAT                         :S(DDT_LAB1)
         STNO = GT(STNO, 1) STNO - 1                        :F(DDT_LAB1)
         OFFSET = OFFSET + 1                                 :(DDT_LAB2)
DDT_LAB1 DDT_LABEL = IDENT(OFFSET) '(' DDT_LABEL ')'          :S(RETURN)
         DDT_LABEL = '(' DDT_LABEL ' + ' OFFSET ')'            :(RETURN)
*
@

Get optional statement number

Input is name of variable containing string with statement number or
label. Label may be followed by [[' +-N']]

Output is statement number or [[NULL]] if none provided. Fails and
displays error if bad syntax or illegal label. Statement number or
label is removed from argument string.

<<DDT>>=
DDT_GET_STMT
         IDENT($S)                                            :S(RETURN)
* CHECK FOR SIMPLE NUMBER
         $S DDT_GET_PAT1 =                                    :S(RETURN)
* CHECK FOR TEXT LABEL
         $S DDT_GET_PAT2 =                                  :F(DDT_GET1)
* CHECK FOR OPTIONAL +N OR -N AFTER LABEL
         LABEL DDT_GET_PAT3
         OFFSET = IDENT(SIGN, '-') -OFFSET
* MAP CASE-CONVERTED LABEL TO STATEMENT NUMBER
         DDT_GET_STMT = DDT_LBLS<DDT_CASE(LABEL)>
* CHECK IF LABEL UNKNOWN TO US, AND ADD OFFSET.
         DDT_GET_STMT = VDIFFER(DDT_GET_STMT)
+           + OFFSET                                          :S(RETURN)
DDT_GET1 DDT_TOUT('BAD LABEL OR STATEMENT NUMBER')            :(FRETURN)
*
@

Function to read a listing file. Only numbered program statements
are retained.

Listing format is 4 columns of statement number, four blank columns,
then the user's statement.

<<DDT>>=
DDT_READLIST
         PAT1 = FENCE (LEN(4) | SPAN(&DIGITS)) . STNO
+           (LEN(4) | '') REM . STMT
         PAT2 = FENCE (NOTANY('-+.*;|#! ' CHARS_NP CHARS_HT)
+           BREAK(CHARS_HT ' ') ) . LABEL
         PAT3 = FENCE NOTANY(&DIGITS ' ' CHARS_HT)
         PAT4 = FENCE ANY('+.')
         PAT5 = FENCE ANY('*;|#!')
         DDT_READLIST = TABLE(151)
DDT_RL1  LINE = TRIM(DDT_SOURCE)                              :F(RETURN)
         IDENT(LINE)                                         :S(DDT_RL1)
         LINE PAT1                                           :F(DDT_RL1)
* IGNORE PAGE THROW, ERROR MESSAGE, FORM FEED, AND TITLES IN LISTING
* FILE.
         STNO PAT3                                           :S(DDT_RL1)
         STNO = TRIM(STNO)
         INTEGER(STNO)                                       :F(DDT_RL4)
* IGNORE COMMENTS
         STMT PAT5                                           :S(DDT_RL1)
* CONTINUATION LINES
         STMT PAT4                                           :S(DDT_RL2)
* ADJUST $LAST IF NEW STATEMENT NUMBER
         $LAST = +VDIFFER(STNO)                    :S(DDT_RL3)F(DDT_RL1)
* APPEND LF TO EXISTING TEXT IF CONTINUED STATEMENT
DDT_RL2  DDT_READLIST<$LAST> = VDIFFER(DDT_READLIST<$LAST>) CHARS_NL
* PLACE STATEMENT IN TABLE
DDT_RL3  DDT_READLIST<$LAST> = DDT_READLIST<$LAST> LINE
* EXTRACT LABEL
         (STMT ' ') PAT2                                     :F(DDT_RL1)
* RECORD CASE-CONVERTED LABEL TO STATEMENT NUMBER MAPPING
         ITEM(LABTAB, DDT_CASE(LABEL)) = $LAST                :(DDT_RL1)
DDT_RL4  DDT_TOUT('INCORRECT PROGRAM LIST FILE, LINE IN ERROR:')
         DDT_TOUT(LINE)                                       :(FRETURN)
*
@

Function to read and process debug commands. [[FAIL]]s when caller
should return to the interrupted user program (the 'normal' exit).

Returns [[SUCCESS]] to jump indirect to a user label (but down one
function level). The function value is the label name.

If [[EOF]] is read from keyboard, debugger shuts itself off.

<<DDT>>=
DDT_CMD  IDENT(DDT_UNIT2)                                   :S(DDT_CMD2)
         DDT_IN = DDT_INPUT                                 :F(DDT_CMD4)
         DDT_TOUT('DDT: ' DDT_IN)                            :(DDT_CMD3)
DDT_CMD4 ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =
DDT_CMD2 DDT_LL2 = DDT_LL
         IDENT(DDT_USE_R)                                   :S(DDT_CMD5)
         DDT_TOUT(EQ(DDT_USE_R, 1) 'DDT REMOTE (' DSERVE_APPNAME ')')
*
* NOTE: THIS IS THE ONLY READ FROM DDT_R.
*
* IF DDT_HOOK IS DEFINED, WE WILL CALL WITH THAT WITH 'READ'. SEE
* DDT_HOOK CALL WITH 'DISPLAY' ABOVE. IF THIS FAILS, WE ASSUME NORMAL
* READ IS NEEDED. IF USE_DDT_R, AND DDT_HOOK IS NOT SET, WE READ
* FROM DDT_R.
*
         IDENT(DDT_HOOK)                                    :S(DDT_CMD7)
         DDT_IN = TRIM(APPLY(DDT_HOOK, 'READ'))  :F(DDT_CMD5)S(DDT_CMD3)
DDT_CMD7 DDT_IN = TRIM(DDT_R)                       :S(DDT_CMD3)F(DDT.O)
DDT_CMD5 DDT_IN = TRIM(HISTORY_EXPAND(READLINE('DDT: ')))      :F(DDT.O)
*
* ONLY ADD NON-NULL COMMANDS THAT DIFFER FROM LAST COMMAND TO HISTORY
*
DDT_CMD6 IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_LL = DDT_IN
         ADD_HISTORY(VDIFFER(DDT_IN, DDT_LL2))
DDT_CMD3 IDENT(DDT_IN)                                       :S(DDT_CMD)
*
* TEST FOR VALID COMMAND AND BRANCH TO APPROPRIATE PROCESSOR (DDT.?).
* LOWER-CASE COMMANDS ARE EQUIVALENT TO UPPER-CASE, AND BLANK AND
* TAB ARE CONVERTED TO THE COMMAND 'C'.
*
         DDT_IN DDT_CHARS =                              :F(DDT_CMD_ERR)
         DDT_STEP_COUNT = 0
                       :($('DDT.' REPLACE(DDT_C, DDT_CHARL, DDT_CHARR)))
*
*** INVALID COMMAND
*
DDT_CMD_ERR
         DDT_TOUT('?')                                        :(DDT_CMD)
*
*** TURN OFF DEBUGGER
*
DDT.O    DDT_ACTIVE = 0
         WRITE_HISTORY('.DDT')
         &STLIMIT = -1
         STOPTR('STCOUNT', 'KEYWORD')                         :(FRETURN)
*
*** V - VIEW FILE
*
DDT.V    DDT_IN = IDENT(DDT_IN) DDT_FNAME
         (IDENT(DDT_IN) DIFFER(DDT_USE_R))                    :S(DDT.V2)
         DDT_IN = IDENT(DDT_IN) READLINE('FILE: ')
         DDT_FNAME = VDIFFER(DDT_IN)                         :F(DDT_CMD)
*
* FIXME: NEED SOMETHING BETTER. LIST FOR LOCAL, BUT DUMP TO DDT_T FOR
* REMOTE.
*
         HOST(HOST_SYSCMD, 'LIST ' DDT_IN)                    :(DDT_CMD)
DDT.V2   DDT_TOUT('USE V FILENAME')                           :(DDT_CMD)
*
*** M - MODIFY VARIABLE
*
DDT.M    IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_TOUT(DIFFER(DDT_USE_R) 'SORRY, NEED EDITLINE')  :S(DDT_CMD)
         DATATYPE($DDT_IN) 'STRING' | 'NAME' | 'INTEGER' | 'REAL'
+                                                             :S(DDT.M2)
         DDT_TOUT("SORRY, CAN'T MODIFY " DATATYPE($DDT_IN))   :(DDT_CMD)
DDT.M2   $DDT_IN = EDITLINE('EDIT<' DDT_IN '>: ', $DDT_IN)    :(DDT_CMD)
*
*** . - SOURCE FILE
*
DDT..    IDENT(DDT_UNIT2)                                     :S(DDT..1)
         DDT_TOUT('. COMMANDS CANNOT BE NESTED')               :(DDT..2)
DDT..1   IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_TOUT('SOURCING ' DDT_IN)
         DDT_UNIT2 = IO_FINDUNIT()
         INPUT(.DDT_INPUT, DDT_UNIT2,, DDT_IN)               :S(DDT_CMD)
         DDT_TOUT('CANNOT OPEN ' DDT_IN)
DDT..2   ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =                                          :(DDT_CMD)
*
*** * - COMMENT
*
DDT.*                                                         :(DDT_CMD)
*
*** H OR ? - HELP
*
<<HELP>>
                                                              :(DDT_CMD)
*
*** I - IGNORE
*
*       CALLS TO DDT() OR DEBUG() MAY HAVE A STRING. THE I COMMAND
*       IGNORES THE NEXT N CALLS TO DDT() WITH A MATCHING STRING.
*       NORMALLY, I IS FOLLOWED BY O TO EXECUTE AT FULL SPEED.
*
DDT.I    DDT_IGNORE =
         DDT_IN (("'" ARB . DDT_IGNORE "'") | '') SPAN(DDT_WHITE ',')
+           SPAN(&DIGITS) . DDT_COUNT RPOS(0)                :S(DDT_CMD)
         DDT_TOUT('BAD I SYNTAX')                             :(DDT_CMD)
*
*** Q - QUIT
*
DDT.Q    WRITE_HISTORY('.DDT')                                    :(END)
*
*** X - EXECUTE SHELL COMMAND
*
DDT.X    HOST(HOST_SYSCMD, DDT_IN)
         DDT_TOUT()                                           :(DDT_CMD)
*
*** C - IMMEDIATE EXECUTION OF AN UNLABELED CODE STATEMENT.
*       APPEND OUR OWN GOTOS TO REGAIN CONTROL AFTER EXECUTION.
*
DDT.C    DDT_C = CODE(' ' DDT_IN ' :S(DDT_SS)F(DDT_FF)')       :S<DDT_C>
         DDT_TOUT('COMPILATION ERROR: ' &ERRTEXT)             :(DDT_CMD)
DDT_SS   DDT_TOUT('SUCCESS')                                  :(DDT_CMD)
DDT_FF   DDT_TOUT('FAILURE')                                  :(DDT_CMD)
*
*** E - EXAMINE VARIABLE OR EVALUATE EXPRESSION. WE DISPLAY STRINGS,
*       NUMBERS AS SCALARS, ARRAYS AND TABLES AS PROTOTYPES, CODE,
*       EXPRESSION, PATTERN AS TYPE NAME, USER TYPES ARE DISPLAYED AS
*       MEMBERS
*
* FIXME - DATATYPE 'NAME' MAY BE AN ISSUE, SEE READL.INC AND FIX HERE
*         AND IN MODIFY DDT.M
*
DDT.E    DDT_RESULT = EVAL(DDT_IN)                            :F(DDT.E2)
         DDT_V = DATATYPE(DDT_RESULT)
         IDENT(DDT_RESULT)                                    :S(DDT.E3)
         DDT_RESULT = ?(DDT_V ? 'STRING' | 'NAME') QUOTE(DDT_RESULT)
+                                                             :S(DDT.E3)
         DDT_V 'INTEGER' | 'REAL'                             :S(DDT.E3)
         DDT_RESULT = ?(DDT_V ? 'CODE' | 'EXPRESSION' | 'PATTERN' |
+           'TABLE' | 'ARRAY') CONVERT(DDT_RESULT, 'STRING')  :S(DDT.E3)
*
* USER DEFINED DATATYPE - FIELD('TYPE',1..N)
*
         DDT_TOUT(DATATYPE(DDT_RESULT))
         DDT_I =
DDT.E4   DDT_I = DDT_I + 1
         DDT_FIELD = FIELD(DATATYPE(DDT_RESULT), DDT_I)      :F(DDT_CMD)
         DDT_V = DATATYPE(APPLY(DDT_FIELD, DDT_RESULT))
         DDT_V = IDENT(APPLY(DDT_FIELD, DDT_RESULT))          :S(DDT.E5)
         DDT_V = ?(DDT_V ? 'STRING' | 'NAME')
+           QUOTE(APPLY(DDT_FIELD, DDT_RESULT))               :S(DDT.E5)
         DDT_V = ?(DDT_V ? 'INTEGER' | 'REAL')
+           APPLY(DDT_FIELD, DDT_RESULT)                      :S(DDT.E5)
         DDT_V = CONVERT(APPLY(DDT_FIELD, DDT_RESULT), 'STRING')
DDT.E5   DDT_TOUT('    ' RPAD(DDT_FIELD, 10) ': ' DDT_V)       :(DDT.E4)
DDT.E3   DDT_TOUT(DDT_RESULT)                                 :(DDT_CMD)
DDT.E2   DDT_TOUT('EVALUATION ERROR: ' &ERRTEXT)              :(DDT_CMD)
*
*** T - STEP N STATEMENTS, DESCENDING INTO PROCEDURES
*
DDT.T    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = 50000
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
*
*** P - STEP N STATEMENTS, TREAT PROCEDURES AS INTACT ENTITIES
*
DDT.P    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = &FNCLEVEL - 1
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
*
*** R - REPORT BREAKPOINTS
*
DDT.R    DDT_A = SORT(DDT_BREAK_TAB)                          :F(DDT_R2)
         DDT_C = 0
DDT_R1   DDT_C = DDT_C + 1
         DDT_TOUT(DDT_A<DDT_C, 1> ' '
+           DDT_LABEL(DDT_A<DDT_C, 1>))             :S(DDT_R1)F(DDT_CMD)
DDT_R2   DDT_TOUT('NONE')                                     :(DDT_CMD)
*
*** K - KILL BREAKPOINT(S)
*
DDT.K    IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> =     :S(DDT.K)F(DDT_CMD)
*
*** B - SET BREAKPOINT(S)
*
DDT.B    IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> = 1   :S(DDT.B)F(DDT_CMD)
*
*** G - GO <=OPTIONAL DIRECT TRANSFER LABEL> <OPTIONAL BREAKPOINTS(S)>
*
* FIRST TEST FOR SIMPLE G BY ITSELF
DDT.G    DDT_STEP_COUNT = 0
         IDENT(DDT_IN)                                       :S(FRETURN)
* CHECK FOR =LABEL, ASSIGN LABEL TO DDT_CMD
         DDT_IN DDT_G_PAT =                                   :F(DDT_G1)
         DDT_CMD = DDT_CASE(DDT_CMD)
* ERROR IF LABEL UNKNOWN
         DDT_TOUT(IDENT(DDT_LBLS<DDT_CMD>) 'UNKNOWN LABEL ='
+           DDT_CMD)                                         :S(DDT_CMD)
* PROCESS ANY BREAKPOINTS
DDT_G1   DIFFER(DDT_IN)                                       :F(DDT_G2)
         DDT_BREAK_TEMP<+DDT_GET_STMT(.DDT_IN)> = 1 :S(DDT_G1)F(DDT_CMD)
* CHOOSE FRETURN TO RESUME EXECUTION WHERE INTERRUPTED, RETURN TO
* TRANSFER TO THE LABEL IN DDT_CMD.
DDT_G2   FREEZE(DDT_BREAK_TEMP)
         FREEZE(DDT_BREAK_TAB)
         DIFFER(DDT_CMD)                            :S(RETURN)F(FRETURN)
<<LIST>>
DDT_TOUT DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'DISPLAY', S)       
         DDT_T = S                                             :(RETURN)
*
*** S(FILE) - LOAD SOURCE LISTING
*
DDT.S    DDT_SOURCE()                                         :(DDT_CMD)
*
DDT_SOURCE
         THAW(DDT_STMTS)
         THAW(DDT_LBLS)
         DDT_LBLS = TABLE(50, 50)
         DDT_FINAL_STMT =
         DDT_UNIT = IO_FINDUNIT()
         DDT_FNAME = TRIMB(DDT_IN)
         DIFFER(DDT_FNAME)                                    :S(DDT_S3)
         INPUT('DDT_SOURCE', DDT_UNIT,,
+              DDT_FNAME = HOST(HOST_GETENV, 'LIST'))         :S(DDT_S1)
         DDT_TOUT(DIFFER(DDT_USE_R) 'USE S FILE')             :S(DDT_S2)
         DDT_FNAME = TRIM(HISTORY_EXPAND(READLINE('LISTING: ')))
DDT_S3   INPUT('DDT_SOURCE', DDT_UNIT,, DDT_FNAME)            :S(DDT_S1)
         DDT_FNAME =
         DDT_TOUT('NO LISTING FILE PROVIDED')                  :(DDT_S2)
DDT_S1   DDT_STMTS = DDT_READLIST(DDT_LBLS, .DDT_FINAL_STMT)
         ENDFILE(DDT_UNIT)
         DETACH(.DDT_SOURCE)
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) 'SOURCE LISTING LOADED')
DDT_S2   FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)                                      :(RETURN)
*
DDT_END
*
@

Provide help for [[DDT]]. Commands are a single letter followed
by (optional) arguments. This provides a reminder of the commands,
and what they do.

<<HELP>>=
DDT.H
 DDT_TOUT('STNO - STATEMENT NUMBERS SPECIFIED AS INTEGERS, OR LABEL+-N')
 DDT_TOUT('          BRACKETED ITEMS ARE OPTIONAL')
 DDT_TOUT('H            (OR ?)     HELP (THIS LIST)')
 DDT_TOUT('C STATEMENT  (OR TAB)   IMMEDIATE EXECUTION OF STATEMENT')
 DDT_TOUT('E EXPRESSION (OR =EXP)  EVALUATE EXPRESSION')
 DDT_TOUT('X COMMAND    (OR !)     EXECUTE SHELL COMMAND')
 DDT_TOUT('T [N]                   TRACE N STATEMENTS (INTO PROCS)')
 DDT_TOUT('P [N]                   TRACE N STATEMENTS (NO PROCEDURES)')
 DDT_TOUT('B STNO [,STNO,...]      SET BREAKPOINT(S)')
 DDT_TOUT('K BKPT [,BKPT,...]      KILL BREAKPOINT(S)')
 DDT_TOUT('R                       REPORT BREAKPOINTS SET')
 DDT_TOUT('G [=LABEL,](STNO1,...]  GO (FROM SPECIFIED LABEL),')
 DDT_TOUT('                          SET TEMPORARY BREAKPOINT(S)')
 DDT_TOUT('L [STNO1 [,STNO2]]      LIST STATEMENT OR RANGE')
 DDT_TOUT('+ [N]  OR  -[N]         LIST NEXT/PREVIOUS N STATEMENTS')
 DDT_TOUT('++ OR --                LIST 12 STATEMENTS FORWARD OR BACK')
 DDT_TOUT('Q                       QUIT')
 DDT_TOUT('O (OR ^D)               OFF - RESUME PROGRAM, STOP DEBUG')
 DDT_TOUT('S [FILE]                LOAD SOURCE')
 DDT_TOUT('M NAME                  MODIFY VARIABLE')
 DDT_TOUT("I 'MSG' N               IGNORE NEXT N CALLS TO DDT(MSG)")
 DDT_TOUT('* COMMENT               COMMENT (NO ACTION)')
 DDT_TOUT('. FILE                  SOURCE FILE (DO NOT NEST)')
 DDT_TOUT('V (FILE)                VIEW FILE (DEFAULT TO LIST FILE)')
@

[[L]] by itself lists the statement about to be executed<br>
[[L STMT]] lists the specified statement<br>
[[L STMT1,STMT2]] lists all statements in the specified range<br>
See also [[+]] and [[-]] commands, below<br>

[[DDT_A]] is the first statement to print, [[DDT_C]] is the last,
[[DDT_LIST_F]] and [[DDT_LIST_L]] are reference numbers for subsequent
[[+]] and [[-]]'s.

<<LIST>>=
*
*** L - LIST STATEMENT(S)
*
* DISPATCH IF L BY ITSELF
DDT.L    DDT_A = IDENT(DDT_IN) DDT_CURR_STMT                  :S(DDT_L1)
* GET FIRST LINE NUMBER
         DDT_A = +DDT_GET_STMT(.DDT_IN)                      :F(DDT_CMD)
* IF JUST ONE, DISPLAY IT BY ITSELF
         IDENT(DDT_IN)                                        :S(DDT_L1)
* IF ANOTHER, GET IT AS THE ENDING LINE NUMBER
         DDT_C = +DDT_GET_STMT(.DDT_IN)             :S(DDT_L2)F(DDT_CMD)
* DISPLAY ONE LINE AT DDT_A
DDT_L1   DDT_C = DDT_A
* USE DDT_C AS THE REFERENCE FOR SUBSEQUENT DISPLAY
DDT_L2   DDT_B = .DDT_C
* CHECK RANGE OF VALUES SPECIFIED
         IDENT(DDT_FINAL_STMT)                               :S(DDT_CMD)
         DDT_A = LT(DDT_A, 1) 1
         DDT_A = GT(DDT_A, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_C = LT(DDT_C, DDT_A) DDT_A
         DDT_C = GT(DDT_C, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_LIST_F = DDT_A
         DDT_LIST_L = DDT_C
* DISPLAY LOOP
DDT_L3   DDT_TOUT(VDIFFER(DDT_STMTS<DDT_A>))
         DDT_A = LT(DDT_A, DDT_C) DDT_A + 1         :S(DDT_L3)F(DDT_CMD)
*
*** +<N> - LIST NEXT STATEMENT(S), ++ LISTS THE NEXT 12 LINES.
*
DDT.+    DDT_A = DDT_LIST_L + 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L4)
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
         DDT_C = LE(DDT_C) 1
DDT_L4   DDT_C = DDT_A + DDT_C - 1                             :(DDT_L2)
*
*** -<N> - LIST PREVIOUS STATEMENT(S), -- LISTS THE PREVIOUS 12 LINES.
*
DDT.-    DDT_B = DDT_LIST_F - 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L5)
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
         DDT_C = LE(DDT_C) 1
DDT_L5   DDT_A = DDT_B - DDT_C + 1
         DDT_C = DDT_B                                         :(DDT_L2)
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DDT.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE DDT
<<INCLUDES>>
-STITL DDT
-EJECT
*
************************************************************************
*                                                                      *
*                      ######   ######   #######                       *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      ######   ######      #                          *
*                                                                      *
* DDT             AN INTERACTIVE SNOBOL4 DEBUGGER                      *
*                                                                      *
************************************************************************
*
* DDT.lss
*
<<DDT>>
*
* CE: .F.MSNOBOL4;
@
-MODULE DDT
-LINE 65 "DDT.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'FREEZE.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'QUOTE.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'SLOAD.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
-STITL DDT
-LINE 705 "DDT.lss"
-EJECT
*
************************************************************************
*                                                                      *
*                      ######   ######   #######                       *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      ######   ######      #                          *
*                                                                      *
* DDT             AN INTERACTIVE SNOBOL4 DEBUGGER                      *
*                                                                      *
************************************************************************
*
* DDT.lss
*
-LINE 76 "DDT.lss"
-WEAK DSERVE_APPNAME
-USES SLOAD()
-PUBLIC DDT(), DEBUG(), DDT_LOADED, DDT_ACTIVE
         DEFINE('DDT(S)')
         DEFINE('DEBUG(S)', 'DDT')
*
         DDT_LOADED = 1
         DDT_ACTIVE = 0
*
* REMOTE DEBUG, DDT_USE_R IS FLAG TO GET INPUT FROM REMOTE (= 1).
* IF 2, WE ARE IN GUI.
* DDT_T IS OUTPUT (ALWAYS) AND DDT_R IN READ CHANNEL. IF DDT_USE_R
* IS NULL, READLINE() WILL BE USED. IF IT IS NOT NULL, DDT_R WILL
* BE USED FOR COMMANDS AND INPUT.
*
-PUBLIC DDT_T, DDT_USE_R, DDT_R
         DDT_T_UNIT = IO_FINDUNIT()
         OUTPUT(.DDT_T, DDT_T_UNIT, 'W', '/dev/stderr')
         DDT_USE_R =
*        DDT_R_UNIT = IO_FINDUNIT()
*        INPUT(.DDT_R, DDT_R_UNIT,, '/dev/stdin')
                                                              :(DDT_END)
*
DDT      DDT_ACTIVE = 1
         DDT_COUNT = 0
         DDT_IGNORE =
         DDT_UNIT2 =
         RLAPPNAME('DDT')
         READ_HISTORY('.DDT')
         STIFLE_HISTORY(50)
         DEFINE('DDT(S)', 'DDT_')
         DEFINE('DEBUG(S)', 'DDT_')
         DEFINE('DDT_SOURCE()')
-LINE 119 "DDT.lss"
-PUBLIC DDT_SUSPEND(), DDT_RESUME(), DDT_TOUT()
         DEFINE('DDT_SUSPEND()', 'DDT.O')
         DEFINE('DDT_RESUME()')
         DEFINE('DDT_TOUT(S)')
*
         DDT_TOUT('DDT (FRI MAY 23 15:30:53 EDT 2014)')
         DDT_TOUT('TRY H FOR HELP')
         DDT_SOURCE =
         DDT_LIST_F =
         DDT_LIST_L =
         DDT_FINAL_STMT =
         DDT_CURR_STMT =
         DDT_BREAK_TAB = TABLE()
         DDT_BREAK_TEMP = TABLE()
         DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_WHITE = CHARS_HT ' '
         DDT_G_PAT = FENCE '=' (BREAK(DDT_WHITE ',') | REM)
+           . DDT_CMD (SPAN(DDT_WHITE ',') | RPOS(0))
         DDT_CHARU = CHARS_HT ' CBE=GHKLPQRTI+-?!XOSMV*.'
         DDT_CHARL = CHARS_HT ' cbe=ghklpqrti+-?!xosmv*.'
         DDT_CHARR =      'C' 'CCBEEGHKLPQRTI+-HXXOSMV*.'
         DDT_CHARS = FENCE ANY(DDT_CHARU DDT_CHARL) . DDT_C
+           (SPAN(DDT_WHITE) | '')
         DDT_DL_PAT = FENCE LEN(8) (NOTANY(DDT_WHITE)
+           (BREAK(DDT_WHITE CHARS_NL) | REM)) . DDT_LABEL
         DDT_GET_PAT1 = FENCE SPAN(&DIGITS) . DDT_GET_STMT
+           (SPAN(DDT_WHITE ',') | RPOS(0))
         DDT_GET_PAT2 = FENCE (BREAK(',') | REM) . LABEL
+           (SPAN(DDT_WHITE ',') | RPOS(0))
         DDT_GET_PAT3 = FENCE BREAK('+-' DDT_WHITE) . LABEL
+           BREAK('+-') LEN(1) . SIGN BREAK(&DIGITS)
+           SPAN(&DIGITS) . OFFSET
+           (SPAN(DDT_WHITE ',') | RPOS(0))
         DEFINE('DDT_LABEL(STNO)OFFSET')
         DEFINE('DDT_GET_STMT(S)LABEL,SIGN,OFFSET')
         DEFINE('DDT_FNC()')
         DEFINE('DDT_CASE(DDT_CASE)')
         DEFINE('DDT_CMD()'
+           'DDT_A,DDT_B,DDT_C,DDT_IN,DDT_I,DDT_FIELD,DDT_RESULT,DDT_V')
         DEFINE('DDT_READLIST(LABTAB,LAST)'
+           'STNO,STMT,LINE,LABEL,PAT1,PAT2,PAT3,PAT4,PAT5')
         DDT_STMTS = TABLE()
         DDT_LBLS = TABLE(50, 50)
         FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         HOST(HOST_GETENV, 'LIST')                              :F(DDT_)
         DDT_SOURCE()
*
-LINE 180 "DDT.lss"
DDT_     S DDT_IGNORE                                          :F(DDT2_)
         DDT_COUNT = GT(DDT_COUNT) DDT_COUNT - 1              :S(RETURN)
DDT2_    DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_TOUT('DDT(' S ')')
DDT_RESUME
         &STLIMIT = 999999999
         &TRACE = 999999999
         TRACE('STCOUNT', 'KEYWORD',, 'DDT_FNC')               :(RETURN)
*
* CURRENT STATEMENT
*
DDT_FNC  DDT_CURR_STMT = &LASTNO
*
* IF NOT SINGLE-STEPPING AND DID NOT HIT A BREAKPOINT, JUST RETURN.
*
         (LE(DDT_STEP_COUNT)
+           IDENT(DDT_BREAK_TAB<DDT_CURR_STMT>)
+           IDENT(DDT_BREAK_TEMP<DDT_CURR_STMT>))             :S(RETURN)
*
* IF IT WAS A BREAKPOINT, TURN OFF ANY SINGLE-STEPPING.
*
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TAB<DDT_CURR_STMT>)
+                                                        :S(DDT_DISPLAY)
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TEMP<DDT_CURR_STMT>)
+                                                        :S(DDT_DISPLAY)
*
* IF DOING A P TRACE, DON'T STOP IF DOWN IN A FUNCTION.
*
         GT(&FNCLEVEL, DDT_FNCLEVEL)                          :S(RETURN)
*
* MUST HAVE BEEN SINGLE-STEPPING. DECREMENT COUNT.
*
         DDT_STEP_COUNT = DDT_STEP_COUNT - 1
*
* DISPLAY CURRENT STATEMENT.
*
DDT_DISPLAY
         DIFFER(DDT_HOOK)                              :S(DDT_DISPLAY_2)
         DDT_FNC = DDT_LABEL(DDT_CURR_STMT)
         DDT_TOUT(VDIFFER(DDT_FNC))
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) DDT_STMTS<DDT_CURR_STMT>)
         DDT_TOUT(IDENT(DDT_FINAL_STMT) DDT_CURR_STMT)
*
* CALL EXTERNAL ROUTINE IF DEFINED TO REGISTER BREAK. THIS CAN
* REPLICATE SOME OF THE ABOVE IF NEEDED.
*
-PUBLIC DDT_HOOK
DDT_DISPLAY_2
         DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'BREAK', DDT_CURR_STMT)
*
* LISTING BEGINS HERE
*
         DDT_LIST_F = DDT_CURR_STMT
         DDT_LIST_L = DDT_CURR_STMT
*
* IF MORE SINGLE-STEPPING TO DO, JUST EXIT
*
         GT(DDT_STEP_COUNT)                                   :S(RETURN)
*
-LINE 250 "DDT.lss"
         THAW(DDT_BREAK_TAB)
         THAW(DDT_BREAK_TEMP)
         DDT_BREAK_TEMP = TABLE()
         DDT_ACTIVE = 1
         DDT_CURR_STMT = DDT_CMD()                            :F(RETURN)
*
* JUMP TO USER'S LABEL WITHOUT CLEARING INTERRUPT
*
         &TRACE = 999999999                            :($DDT_CURR_STMT)
*
* CONVERT TO UPPERCASE IF SOURCE IS NOT CASE SENSITIVE
*
DDT_CASE DDT_CASE = NE(&CASE)
+           REPLACE(DDT_CASE, &LCASE, &UCASE)                  :(RETURN)
*
-LINE 272 "DDT.lss"
DDT_LABEL
         IDENT(DDT_FINAL_STMT)                                :S(RETURN)
DDT_LAB2 DDT_STMTS<STNO> DDT_DL_PAT                         :S(DDT_LAB1)
         STNO = GT(STNO, 1) STNO - 1                        :F(DDT_LAB1)
         OFFSET = OFFSET + 1                                 :(DDT_LAB2)
DDT_LAB1 DDT_LABEL = IDENT(OFFSET) '(' DDT_LABEL ')'          :S(RETURN)
         DDT_LABEL = '(' DDT_LABEL ' + ' OFFSET ')'            :(RETURN)
*
-LINE 292 "DDT.lss"
DDT_GET_STMT
         IDENT($S)                                            :S(RETURN)
* CHECK FOR SIMPLE NUMBER
         $S DDT_GET_PAT1 =                                    :S(RETURN)
* CHECK FOR TEXT LABEL
         $S DDT_GET_PAT2 =                                  :F(DDT_GET1)
* CHECK FOR OPTIONAL +N OR -N AFTER LABEL
         LABEL DDT_GET_PAT3
         OFFSET = IDENT(SIGN, '-') -OFFSET
* MAP CASE-CONVERTED LABEL TO STATEMENT NUMBER
         DDT_GET_STMT = DDT_LBLS<DDT_CASE(LABEL)>
* CHECK IF LABEL UNKNOWN TO US, AND ADD OFFSET.
         DDT_GET_STMT = VDIFFER(DDT_GET_STMT)
+           + OFFSET                                          :S(RETURN)
DDT_GET1 DDT_TOUT('BAD LABEL OR STATEMENT NUMBER')            :(FRETURN)
*
-LINE 317 "DDT.lss"
DDT_READLIST
         PAT1 = FENCE (LEN(4) | SPAN(&DIGITS)) . STNO
+           (LEN(4) | '') REM . STMT
         PAT2 = FENCE (NOTANY('-+.*;|#! ' CHARS_NP CHARS_HT)
+           BREAK(CHARS_HT ' ') ) . LABEL
         PAT3 = FENCE NOTANY(&DIGITS ' ' CHARS_HT)
         PAT4 = FENCE ANY('+.')
         PAT5 = FENCE ANY('*;|#!')
         DDT_READLIST = TABLE(151)
DDT_RL1  LINE = TRIM(DDT_SOURCE)                              :F(RETURN)
         IDENT(LINE)                                         :S(DDT_RL1)
         LINE PAT1                                           :F(DDT_RL1)
* IGNORE PAGE THROW, ERROR MESSAGE, FORM FEED, AND TITLES IN LISTING
* FILE.
         STNO PAT3                                           :S(DDT_RL1)
         STNO = TRIM(STNO)
         INTEGER(STNO)                                       :F(DDT_RL4)
* IGNORE COMMENTS
         STMT PAT5                                           :S(DDT_RL1)
* CONTINUATION LINES
         STMT PAT4                                           :S(DDT_RL2)
* ADJUST $LAST IF NEW STATEMENT NUMBER
         $LAST = +VDIFFER(STNO)                    :S(DDT_RL3)F(DDT_RL1)
* APPEND LF TO EXISTING TEXT IF CONTINUED STATEMENT
DDT_RL2  DDT_READLIST<$LAST> = VDIFFER(DDT_READLIST<$LAST>) CHARS_NL
* PLACE STATEMENT IN TABLE
DDT_RL3  DDT_READLIST<$LAST> = DDT_READLIST<$LAST> LINE
* EXTRACT LABEL
         (STMT ' ') PAT2                                     :F(DDT_RL1)
* RECORD CASE-CONVERTED LABEL TO STATEMENT NUMBER MAPPING
         ITEM(LABTAB, DDT_CASE(LABEL)) = $LAST                :(DDT_RL1)
DDT_RL4  DDT_TOUT('INCORRECT PROGRAM LIST FILE, LINE IN ERROR:')
         DDT_TOUT(LINE)                                       :(FRETURN)
*
-LINE 362 "DDT.lss"
DDT_CMD  IDENT(DDT_UNIT2)                                   :S(DDT_CMD2)
         DDT_IN = DDT_INPUT                                 :F(DDT_CMD4)
         DDT_TOUT('DDT: ' DDT_IN)                            :(DDT_CMD3)
DDT_CMD4 ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =
DDT_CMD2 DDT_LL2 = DDT_LL
         IDENT(DDT_USE_R)                                   :S(DDT_CMD5)
         DDT_TOUT(EQ(DDT_USE_R, 1) 'DDT REMOTE (' DSERVE_APPNAME ')')
*
* NOTE: THIS IS THE ONLY READ FROM DDT_R.
*
* IF DDT_HOOK IS DEFINED, WE WILL CALL WITH THAT WITH 'READ'. SEE
* DDT_HOOK CALL WITH 'DISPLAY' ABOVE. IF THIS FAILS, WE ASSUME NORMAL
* READ IS NEEDED. IF USE_DDT_R, AND DDT_HOOK IS NOT SET, WE READ
* FROM DDT_R.
*
         IDENT(DDT_HOOK)                                    :S(DDT_CMD7)
         DDT_IN = TRIM(APPLY(DDT_HOOK, 'READ'))  :F(DDT_CMD5)S(DDT_CMD3)
DDT_CMD7 DDT_IN = TRIM(DDT_R)                       :S(DDT_CMD3)F(DDT.O)
DDT_CMD5 DDT_IN = TRIM(HISTORY_EXPAND(READLINE('DDT: ')))      :F(DDT.O)
*
* ONLY ADD NON-NULL COMMANDS THAT DIFFER FROM LAST COMMAND TO HISTORY
*
DDT_CMD6 IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_LL = DDT_IN
         ADD_HISTORY(VDIFFER(DDT_IN, DDT_LL2))
DDT_CMD3 IDENT(DDT_IN)                                       :S(DDT_CMD)
*
* TEST FOR VALID COMMAND AND BRANCH TO APPROPRIATE PROCESSOR (DDT.?).
* LOWER-CASE COMMANDS ARE EQUIVALENT TO UPPER-CASE, AND BLANK AND
* TAB ARE CONVERTED TO THE COMMAND 'C'.
*
         DDT_IN DDT_CHARS =                              :F(DDT_CMD_ERR)
         DDT_STEP_COUNT = 0
                       :($('DDT.' REPLACE(DDT_C, DDT_CHARL, DDT_CHARR)))
*
*** INVALID COMMAND
*
DDT_CMD_ERR
         DDT_TOUT('?')                                        :(DDT_CMD)
*
*** TURN OFF DEBUGGER
*
DDT.O    DDT_ACTIVE = 0
         WRITE_HISTORY('.DDT')
         &STLIMIT = -1
         STOPTR('STCOUNT', 'KEYWORD')                         :(FRETURN)
*
*** V - VIEW FILE
*
DDT.V    DDT_IN = IDENT(DDT_IN) DDT_FNAME
         (IDENT(DDT_IN) DIFFER(DDT_USE_R))                    :S(DDT.V2)
         DDT_IN = IDENT(DDT_IN) READLINE('FILE: ')
         DDT_FNAME = VDIFFER(DDT_IN)                         :F(DDT_CMD)
*
* FIXME: NEED SOMETHING BETTER. LIST FOR LOCAL, BUT DUMP TO DDT_T FOR
* REMOTE.
*
         HOST(HOST_SYSCMD, 'LIST ' DDT_IN)                    :(DDT_CMD)
DDT.V2   DDT_TOUT('USE V FILENAME')                           :(DDT_CMD)
*
*** M - MODIFY VARIABLE
*
DDT.M    IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_TOUT(DIFFER(DDT_USE_R) 'SORRY, NEED EDITLINE')  :S(DDT_CMD)
         DATATYPE($DDT_IN) 'STRING' | 'NAME' | 'INTEGER' | 'REAL'
+                                                             :S(DDT.M2)
         DDT_TOUT("SORRY, CAN'T MODIFY " DATATYPE($DDT_IN))   :(DDT_CMD)
DDT.M2   $DDT_IN = EDITLINE('EDIT<' DDT_IN '>: ', $DDT_IN)    :(DDT_CMD)
*
*** . - SOURCE FILE
*
DDT..    IDENT(DDT_UNIT2)                                     :S(DDT..1)
         DDT_TOUT('. COMMANDS CANNOT BE NESTED')               :(DDT..2)
DDT..1   IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_TOUT('SOURCING ' DDT_IN)
         DDT_UNIT2 = IO_FINDUNIT()
         INPUT(.DDT_INPUT, DDT_UNIT2,, DDT_IN)               :S(DDT_CMD)
         DDT_TOUT('CANNOT OPEN ' DDT_IN)
DDT..2   ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =                                          :(DDT_CMD)
*
*** * - COMMENT
*
DDT.*                                                         :(DDT_CMD)
*
*** H OR ? - HELP
*
-LINE 610 "DDT.lss"
DDT.H
 DDT_TOUT('STNO - STATEMENT NUMBERS SPECIFIED AS INTEGERS, OR LABEL+-N')
 DDT_TOUT('          BRACKETED ITEMS ARE OPTIONAL')
 DDT_TOUT('H            (OR ?)     HELP (THIS LIST)')
 DDT_TOUT('C STATEMENT  (OR TAB)   IMMEDIATE EXECUTION OF STATEMENT')
 DDT_TOUT('E EXPRESSION (OR =EXP)  EVALUATE EXPRESSION')
 DDT_TOUT('X COMMAND    (OR !)     EXECUTE SHELL COMMAND')
 DDT_TOUT('T [N]                   TRACE N STATEMENTS (INTO PROCS)')
 DDT_TOUT('P [N]                   TRACE N STATEMENTS (NO PROCEDURES)')
 DDT_TOUT('B STNO [,STNO,...]      SET BREAKPOINT(S)')
 DDT_TOUT('K BKPT [,BKPT,...]      KILL BREAKPOINT(S)')
 DDT_TOUT('R                       REPORT BREAKPOINTS SET')
 DDT_TOUT('G [=LABEL,](STNO1,...]  GO (FROM SPECIFIED LABEL),')
 DDT_TOUT('                          SET TEMPORARY BREAKPOINT(S)')
 DDT_TOUT('L [STNO1 [,STNO2]]      LIST STATEMENT OR RANGE')
 DDT_TOUT('+ [N]  OR  -[N]         LIST NEXT/PREVIOUS N STATEMENTS')
 DDT_TOUT('++ OR --                LIST 12 STATEMENTS FORWARD OR BACK')
 DDT_TOUT('Q                       QUIT')
 DDT_TOUT('O (OR ^D)               OFF - RESUME PROGRAM, STOP DEBUG')
 DDT_TOUT('S [FILE]                LOAD SOURCE')
 DDT_TOUT('M NAME                  MODIFY VARIABLE')
 DDT_TOUT("I 'MSG' N               IGNORE NEXT N CALLS TO DDT(MSG)")
 DDT_TOUT('* COMMENT               COMMENT (NO ACTION)')
 DDT_TOUT('. FILE                  SOURCE FILE (DO NOT NEST)')
 DDT_TOUT('V (FILE)                VIEW FILE (DEFAULT TO LIST FILE)')
                                                              :(DDT_CMD)
*
*** I - IGNORE
*
*       CALLS TO DDT() OR DEBUG() MAY HAVE A STRING. THE I COMMAND
*       IGNORES THE NEXT N CALLS TO DDT() WITH A MATCHING STRING.
*       NORMALLY, I IS FOLLOWED BY O TO EXECUTE AT FULL SPEED.
*
DDT.I    DDT_IGNORE =
         DDT_IN (("'" ARB . DDT_IGNORE "'") | '') SPAN(DDT_WHITE ',')
+           SPAN(&DIGITS) . DDT_COUNT RPOS(0)                :S(DDT_CMD)
         DDT_TOUT('BAD I SYNTAX')                             :(DDT_CMD)
*
*** Q - QUIT
*
DDT.Q    WRITE_HISTORY('.DDT')                                    :(END)
*
*** X - EXECUTE SHELL COMMAND
*
DDT.X    HOST(HOST_SYSCMD, DDT_IN)
         DDT_TOUT()                                           :(DDT_CMD)
*
*** C - IMMEDIATE EXECUTION OF AN UNLABELED CODE STATEMENT.
*       APPEND OUR OWN GOTOS TO REGAIN CONTROL AFTER EXECUTION.
*
DDT.C    DDT_C = CODE(' ' DDT_IN ' :S(DDT_SS)F(DDT_FF)')       :S<DDT_C>
         DDT_TOUT('COMPILATION ERROR: ' &ERRTEXT)             :(DDT_CMD)
DDT_SS   DDT_TOUT('SUCCESS')                                  :(DDT_CMD)
DDT_FF   DDT_TOUT('FAILURE')                                  :(DDT_CMD)
*
*** E - EXAMINE VARIABLE OR EVALUATE EXPRESSION. WE DISPLAY STRINGS,
*       NUMBERS AS SCALARS, ARRAYS AND TABLES AS PROTOTYPES, CODE,
*       EXPRESSION, PATTERN AS TYPE NAME, USER TYPES ARE DISPLAYED AS
*       MEMBERS
*
* FIXME - DATATYPE 'NAME' MAY BE AN ISSUE, SEE READL.INC AND FIX HERE
*         AND IN MODIFY DDT.M
*
DDT.E    DDT_RESULT = EVAL(DDT_IN)                            :F(DDT.E2)
         DDT_V = DATATYPE(DDT_RESULT)
         IDENT(DDT_RESULT)                                    :S(DDT.E3)
         DDT_RESULT = ?(DDT_V ? 'STRING' | 'NAME') QUOTE(DDT_RESULT)
+                                                             :S(DDT.E3)
         DDT_V 'INTEGER' | 'REAL'                             :S(DDT.E3)
         DDT_RESULT = ?(DDT_V ? 'CODE' | 'EXPRESSION' | 'PATTERN' |
+           'TABLE' | 'ARRAY') CONVERT(DDT_RESULT, 'STRING')  :S(DDT.E3)
*
* USER DEFINED DATATYPE - FIELD('TYPE',1..N)
*
         DDT_TOUT(DATATYPE(DDT_RESULT))
         DDT_I =
DDT.E4   DDT_I = DDT_I + 1
         DDT_FIELD = FIELD(DATATYPE(DDT_RESULT), DDT_I)      :F(DDT_CMD)
         DDT_V = DATATYPE(APPLY(DDT_FIELD, DDT_RESULT))
         DDT_V = IDENT(APPLY(DDT_FIELD, DDT_RESULT))          :S(DDT.E5)
         DDT_V = ?(DDT_V ? 'STRING' | 'NAME')
+           QUOTE(APPLY(DDT_FIELD, DDT_RESULT))               :S(DDT.E5)
         DDT_V = ?(DDT_V ? 'INTEGER' | 'REAL')
+           APPLY(DDT_FIELD, DDT_RESULT)                      :S(DDT.E5)
         DDT_V = CONVERT(APPLY(DDT_FIELD, DDT_RESULT), 'STRING')
DDT.E5   DDT_TOUT('    ' RPAD(DDT_FIELD, 10) ': ' DDT_V)       :(DDT.E4)
DDT.E3   DDT_TOUT(DDT_RESULT)                                 :(DDT_CMD)
DDT.E2   DDT_TOUT('EVALUATION ERROR: ' &ERRTEXT)              :(DDT_CMD)
*
*** T - STEP N STATEMENTS, DESCENDING INTO PROCEDURES
*
DDT.T    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = 50000
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
*
*** P - STEP N STATEMENTS, TREAT PROCEDURES AS INTACT ENTITIES
*
DDT.P    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        :F(DDT_CMD_ERR)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = &FNCLEVEL - 1
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                :(FRETURN)
*
*** R - REPORT BREAKPOINTS
*
DDT.R    DDT_A = SORT(DDT_BREAK_TAB)                          :F(DDT_R2)
         DDT_C = 0
DDT_R1   DDT_C = DDT_C + 1
         DDT_TOUT(DDT_A<DDT_C, 1> ' '
+           DDT_LABEL(DDT_A<DDT_C, 1>))             :S(DDT_R1)F(DDT_CMD)
DDT_R2   DDT_TOUT('NONE')                                     :(DDT_CMD)
*
*** K - KILL BREAKPOINT(S)
*
DDT.K    IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> =     :S(DDT.K)F(DDT_CMD)
*
*** B - SET BREAKPOINT(S)
*
DDT.B    IDENT(DDT_IN)                                       :S(DDT_CMD)
         DDT_BREAK_TAB<+DDT_GET_STMT(.DDT_IN)> = 1   :S(DDT.B)F(DDT_CMD)
*
*** G - GO <=OPTIONAL DIRECT TRANSFER LABEL> <OPTIONAL BREAKPOINTS(S)>
*
* FIRST TEST FOR SIMPLE G BY ITSELF
DDT.G    DDT_STEP_COUNT = 0
         IDENT(DDT_IN)                                       :S(FRETURN)
* CHECK FOR =LABEL, ASSIGN LABEL TO DDT_CMD
         DDT_IN DDT_G_PAT =                                   :F(DDT_G1)
         DDT_CMD = DDT_CASE(DDT_CMD)
* ERROR IF LABEL UNKNOWN
         DDT_TOUT(IDENT(DDT_LBLS<DDT_CMD>) 'UNKNOWN LABEL ='
+           DDT_CMD)                                         :S(DDT_CMD)
* PROCESS ANY BREAKPOINTS
DDT_G1   DIFFER(DDT_IN)                                       :F(DDT_G2)
         DDT_BREAK_TEMP<+DDT_GET_STMT(.DDT_IN)> = 1 :S(DDT_G1)F(DDT_CMD)
* CHOOSE FRETURN TO RESUME EXECUTION WHERE INTERRUPTED, RETURN TO
* TRANSFER TO THE LABEL IN DDT_CMD.
DDT_G2   FREEZE(DDT_BREAK_TEMP)
         FREEZE(DDT_BREAK_TAB)
         DIFFER(DDT_CMD)                            :S(RETURN)F(FRETURN)
-LINE 647 "DDT.lss"
*
*** L - LIST STATEMENT(S)
*
* DISPATCH IF L BY ITSELF
DDT.L    DDT_A = IDENT(DDT_IN) DDT_CURR_STMT                  :S(DDT_L1)
* GET FIRST LINE NUMBER
         DDT_A = +DDT_GET_STMT(.DDT_IN)                      :F(DDT_CMD)
* IF JUST ONE, DISPLAY IT BY ITSELF
         IDENT(DDT_IN)                                        :S(DDT_L1)
* IF ANOTHER, GET IT AS THE ENDING LINE NUMBER
         DDT_C = +DDT_GET_STMT(.DDT_IN)             :S(DDT_L2)F(DDT_CMD)
* DISPLAY ONE LINE AT DDT_A
DDT_L1   DDT_C = DDT_A
* USE DDT_C AS THE REFERENCE FOR SUBSEQUENT DISPLAY
DDT_L2   DDT_B = .DDT_C
* CHECK RANGE OF VALUES SPECIFIED
         IDENT(DDT_FINAL_STMT)                               :S(DDT_CMD)
         DDT_A = LT(DDT_A, 1) 1
         DDT_A = GT(DDT_A, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_C = LT(DDT_C, DDT_A) DDT_A
         DDT_C = GT(DDT_C, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_LIST_F = DDT_A
         DDT_LIST_L = DDT_C
* DISPLAY LOOP
DDT_L3   DDT_TOUT(VDIFFER(DDT_STMTS<DDT_A>))
         DDT_A = LT(DDT_A, DDT_C) DDT_A + 1         :S(DDT_L3)F(DDT_CMD)
*
*** +<N> - LIST NEXT STATEMENT(S), ++ LISTS THE NEXT 12 LINES.
*
DDT.+    DDT_A = DDT_LIST_L + 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L4)
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
         DDT_C = LE(DDT_C) 1
DDT_L4   DDT_C = DDT_A + DDT_C - 1                             :(DDT_L2)
*
*** -<N> - LIST PREVIOUS STATEMENT(S), -- LISTS THE PREVIOUS 12 LINES.
*
DDT.-    DDT_B = DDT_LIST_F - 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      :S(DDT_L5)
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 :F(DDT_CMD_ERR)
         DDT_C = LE(DDT_C) 1
DDT_L5   DDT_A = DDT_B - DDT_C + 1
         DDT_C = DDT_B                                         :(DDT_L2)
DDT_TOUT DIFFER(DDT_HOOK) APPLY(DDT_HOOK, 'DISPLAY', S)
         DDT_T = S                                             :(RETURN)
*
*** S(FILE) - LOAD SOURCE LISTING
*
DDT.S    DDT_SOURCE()                                         :(DDT_CMD)
*
DDT_SOURCE
         THAW(DDT_STMTS)
         THAW(DDT_LBLS)
         DDT_LBLS = TABLE(50, 50)
         DDT_FINAL_STMT =
         DDT_UNIT = IO_FINDUNIT()
         DDT_FNAME = TRIMB(DDT_IN)
         DIFFER(DDT_FNAME)                                    :S(DDT_S3)
         INPUT('DDT_SOURCE', DDT_UNIT,,
+              DDT_FNAME = HOST(HOST_GETENV, 'LIST'))         :S(DDT_S1)
         DDT_TOUT(DIFFER(DDT_USE_R) 'USE S FILE')             :S(DDT_S2)
         DDT_FNAME = TRIM(HISTORY_EXPAND(READLINE('LISTING: ')))
DDT_S3   INPUT('DDT_SOURCE', DDT_UNIT,, DDT_FNAME)            :S(DDT_S1)
         DDT_FNAME =
         DDT_TOUT('NO LISTING FILE PROVIDED')                  :(DDT_S2)
DDT_S1   DDT_STMTS = DDT_READLIST(DDT_LBLS, .DDT_FINAL_STMT)
         ENDFILE(DDT_UNIT)
         DETACH(.DDT_SOURCE)
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) 'SOURCE LISTING LOADED')
DDT_S2   FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)                                      :(RETURN)
*
DDT_END
*
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DDT - An Interactive SNOBOL4 Debugger</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<i>DDT</i> is a source level debugger for CSNOBOL4.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">INCLUDE 'DDT.INC'</font> into the program to be debugged. At the point
that the debugger should be activated, insert the statement
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|    DDT()
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
which will enter the debugger.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Source statements can be made available by creating an environment
variable named <font face="Source Code Pro">LIST</font> equated to the name of a listing file, or by
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     LIST=SRC.LST ./PROG.SNO
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
or
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     DDT: X snobol4 -n -l SRC.LST SRC.SNO
|     DDT: S
|     LISTING: SRC.LST
|     SOURCE LISTING LOADED
|     DDT:
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Supplying a <font face="Source Code Pro">LIST=</font> environment automatically attempts loading the
listing at debugger start. This will give a symbolic line for the
first line after the <font face="Source Code Pro">DDT()</font> invocation.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If there is a block of statements that are to be excluded from tracing
(such as initializations), bracket them with
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     &TRACE = 0 ..... &TRACE = 999999999
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FREEZE()</font> and <font face="Source Code Pro">THAW()</font> are used to prevent entries from being
inserted into the breakpoint and source tables, keeping the footprint
of <font face="Source Code Pro">DDT</font> smaller. <font face="Source Code Pro">READLINE()</font> is used to allow editing and
retrieval of command lines.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<i>DDT</i> will display user datatypes with the = command. More
sophisticated behavious will be introduced with the INSPECT module
at a future date. (see DDT.E)
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SLOAD</font> is not actually needed for <font face="Source Code Pro">DDT</font>. It is included to allow
additional tools to be incorporated while debugging.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="FREEZE.html">FREEZE</a><br>
<a href="HOST.html">HOST</a><br>
<a href="QUOTE.html">QUOTE</a><br>
<a href="READLINE.html">READLINE</a><br>
<a href="SLOAD.html">SLOAD</a><br>
<a href="TRIMB.html">TRIMB</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;FREEZE.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;QUOTE.INC&#39;
-INCLUDE &#39;READLINE.INC&#39;
-INCLUDE &#39;SLOAD.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
-WEAK DSERVE_APPNAME
-USES SLOAD()
-PUBLIC DDT(), DEBUG(), DDT_LOADED, DDT_ACTIVE
         DEFINE(&#39;DDT(S)&#39;)
         DEFINE(&#39;DEBUG(S)&#39;, &#39;DDT&#39;)
<font color="#818181"><i>*</i></font>
         DDT_LOADED = 1
         DDT_ACTIVE = 0
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REMOTE DEBUG, DDT_USE_R IS FLAG TO GET INPUT FROM REMOTE (= 1).</i></font>
<font color="#818181"><i>* IF 2, WE ARE IN GUI.</i></font>
<font color="#818181"><i>* DDT_T IS OUTPUT (ALWAYS) AND DDT_R IN READ CHANNEL. IF DDT_USE_R</i></font>
<font color="#818181"><i>* IS NULL, READLINE() WILL BE USED. IF IT IS NOT NULL, DDT_R WILL</i></font>
<font color="#818181"><i>* BE USED FOR COMMANDS AND INPUT.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC DDT_T, DDT_USE_R, DDT_R
         DDT_T_UNIT = IO_FINDUNIT()
         OUTPUT(.DDT_T, DDT_T_UNIT, &#39;W&#39;, &#39;/dev/stderr&#39;)
         DDT_USE_R =
<font color="#818181"><i>*        DDT_R_UNIT = IO_FINDUNIT()</i></font>
<font color="#818181"><i>*        INPUT(.DDT_R, DDT_R_UNIT,, &#39;/dev/stdin&#39;)</i></font>
                                                              <b>:(DDT_END)</b>
<font color="#818181"><i>*</i></font>
DDT      DDT_ACTIVE = 1
         DDT_COUNT = 0
         DDT_IGNORE =
         DDT_UNIT2 =
         RLAPPNAME(&#39;DDT&#39;)
         READ_HISTORY(&#39;.DDT&#39;)
         STIFLE_HISTORY(50)
         DEFINE(&#39;DDT(S)&#39;, &#39;DDT_&#39;)
         DEFINE(&#39;DEBUG(S)&#39;, &#39;DDT_&#39;)
         DEFINE(&#39;DDT_SOURCE()&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DDT()</font> and <font face="Source Code Pro">DEBUG()</font> are the primary calls into the
debugger. <font face="Source Code Pro">DDT_SUSPEND()</font> will suspend the debugger, and
<font face="Source Code Pro">DDT_RESUME()</font> will resume normal operation.  <font face="Source Code Pro">DDT_ACTIVE</font> and
<font face="Source Code Pro">DDT_LOADED</font> variables can be examined. <font face="Source Code Pro">DDT_LOADED</font> will be
<font face="Source Code Pro">NULL</font> if <font face="Source Code Pro">DDT</font> has not been loaded. See <A HREF="BQ.html">BQ</A>
for an example of this use.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
-PUBLIC DDT_SUSPEND(), DDT_RESUME(), DDT_TOUT()
         DEFINE(&#39;DDT_SUSPEND()&#39;, &#39;DDT.O&#39;)
         DEFINE(&#39;DDT_RESUME()&#39;)
         DEFINE(&#39;DDT_TOUT(S)&#39;)
<font color="#818181"><i>*</i></font>
         DDT_TOUT(&#39;DDT (FRI MAY 23 15:30:53 EDT 2014)&#39;)
         DDT_TOUT(&#39;TRY H FOR HELP&#39;)
         DDT_SOURCE =
         DDT_LIST_F =
         DDT_LIST_L =
         DDT_FINAL_STMT =
         DDT_CURR_STMT =
         DDT_BREAK_TAB = TABLE()
         DDT_BREAK_TEMP = TABLE()
         DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_WHITE = CHARS_HT &#39; &#39;
         DDT_G_PAT = FENCE &#39;=&#39; (BREAK(DDT_WHITE &#39;,&#39;) | REM)
+           . DDT_CMD (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DDT_CHARU = CHARS_HT &#39; CBE=GHKLPQRTI+-?!XOSMV*.&#39;
         DDT_CHARL = CHARS_HT &#39; cbe=ghklpqrti+-?!xosmv*.&#39;
         DDT_CHARR =      &#39;C&#39; &#39;CCBEEGHKLPQRTI+-HXXOSMV*.&#39;
         DDT_CHARS = FENCE ANY(DDT_CHARU DDT_CHARL) . DDT_C
+           (SPAN(DDT_WHITE) | &#39;&#39;)
         DDT_DL_PAT = FENCE LEN(8) (NOTANY(DDT_WHITE)
+           (BREAK(DDT_WHITE CHARS_NL) | REM)) . DDT_LABEL
         DDT_GET_PAT1 = FENCE SPAN(&amp;DIGITS) . DDT_GET_STMT
+           (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DDT_GET_PAT2 = FENCE (BREAK(&#39;,&#39;) | REM) . LABEL
+           (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DDT_GET_PAT3 = FENCE BREAK(&#39;+-&#39; DDT_WHITE) . LABEL
+           BREAK(&#39;+-&#39;) LEN(1) . SIGN BREAK(&amp;DIGITS)
+           SPAN(&amp;DIGITS) . OFFSET
+           (SPAN(DDT_WHITE &#39;,&#39;) | RPOS(0))
         DEFINE(&#39;DDT_LABEL(STNO)OFFSET&#39;)
         DEFINE(&#39;DDT_GET_STMT(S)LABEL,SIGN,OFFSET&#39;)
         DEFINE(&#39;DDT_FNC()&#39;)
         DEFINE(&#39;DDT_CASE(DDT_CASE)&#39;)
         DEFINE(&#39;DDT_CMD()&#39;
+           &#39;DDT_A,DDT_B,DDT_C,DDT_IN,DDT_I,DDT_FIELD,DDT_RESULT,DDT_V&#39;)
         DEFINE(&#39;DDT_READLIST(LABTAB,LAST)&#39;
+           &#39;STNO,STMT,LINE,LABEL,PAT1,PAT2,PAT3,PAT4,PAT5&#39;)
         DDT_STMTS = TABLE()
         DDT_LBLS = TABLE(50, 50)
         FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         HOST(HOST_GETENV, &#39;LIST&#39;)                              <b>:F(DDT_)</b>
         DDT_SOURCE()
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
The <font face="Source Code Pro">DDT()</font> function can be invoked to re-enter the debugger. This is
usually used to generate complex breakpoints. <font face="Source Code Pro">DDT()</font> (also known
as <font face="Source Code Pro">DEBUG()</font>) can be given an argument. This name can be reference
in an I command: <font face="Source Code Pro">I 'MSG' N</font> which ignores the next <font face="Source Code Pro">N</font> calls to
<font face="Source Code Pro">DDT/DEBUG</font> with the matching string. After this, the <font face="Source Code Pro">DDT()</font> or
<font face="Source Code Pro">DEBUG()</font> call will enter the debugger.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_     S DDT_IGNORE                                          <b>:F(DDT2_)</b>
         DDT_COUNT = GT(DDT_COUNT) DDT_COUNT - 1              <b>:S(RETURN)</b>
DDT2_    DDT_STEP_COUNT = 1
         DDT_FNCLEVEL = 50000
         DDT_TOUT(&#39;DDT(&#39; S &#39;)&#39;)
DDT_RESUME
         &amp;STLIMIT = 999999999
         &amp;TRACE = 999999999
         TRACE(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;,, &#39;DDT_FNC&#39;)               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CURRENT STATEMENT</i></font>
<font color="#818181"><i>*</i></font>
DDT_FNC  DDT_CURR_STMT = &amp;LASTNO
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF NOT SINGLE-STEPPING AND DID NOT HIT A BREAKPOINT, JUST RETURN.</i></font>
<font color="#818181"><i>*</i></font>
         (LE(DDT_STEP_COUNT)
+           IDENT(DDT_BREAK_TAB&lt;DDT_CURR_STMT&gt;)
+           IDENT(DDT_BREAK_TEMP&lt;DDT_CURR_STMT&gt;))             <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF IT WAS A BREAKPOINT, TURN OFF ANY SINGLE-STEPPING.</i></font>
<font color="#818181"><i>*</i></font>
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TAB&lt;DDT_CURR_STMT&gt;)
+                                                        <b>:S(DDT_DISPLAY)</b>
         DDT_STEP_COUNT = DIFFER(DDT_BREAK_TEMP&lt;DDT_CURR_STMT&gt;)
+                                                        <b>:S(DDT_DISPLAY)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF DOING A P TRACE, DON&#39;T STOP IF DOWN IN A FUNCTION.</i></font>
<font color="#818181"><i>*</i></font>
         GT(&amp;FNCLEVEL, DDT_FNCLEVEL)                          <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MUST HAVE BEEN SINGLE-STEPPING. DECREMENT COUNT.</i></font>
<font color="#818181"><i>*</i></font>
         DDT_STEP_COUNT = DDT_STEP_COUNT - 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPLAY CURRENT STATEMENT.</i></font>
<font color="#818181"><i>*</i></font>
DDT_DISPLAY
         DIFFER(DDT_HOOK)                              <b>:S(DDT_DISPLAY_2)</b>
         DDT_FNC = DDT_LABEL(DDT_CURR_STMT)
         DDT_TOUT(VDIFFER(DDT_FNC))
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) DDT_STMTS&lt;DDT_CURR_STMT&gt;)
         DDT_TOUT(IDENT(DDT_FINAL_STMT) DDT_CURR_STMT)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CALL EXTERNAL ROUTINE IF DEFINED TO REGISTER BREAK. THIS CAN</i></font>
<font color="#818181"><i>* REPLICATE SOME OF THE ABOVE IF NEEDED.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC DDT_HOOK
DDT_DISPLAY_2
         DIFFER(DDT_HOOK) APPLY(DDT_HOOK, &#39;BREAK&#39;, DDT_CURR_STMT)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LISTING BEGINS HERE</i></font>
<font color="#818181"><i>*</i></font>
         DDT_LIST_F = DDT_CURR_STMT
         DDT_LIST_L = DDT_CURR_STMT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF MORE SINGLE-STEPPING TO DO, JUST EXIT</i></font>
<font color="#818181"><i>*</i></font>
         GT(DDT_STEP_COUNT)                                   <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Here is where we read commands from the user. Control stays within
DDT.CMD until it is time to return to the user program. A failure
return means resume where interrupted. A success return requests a
direct jump to a user label. This direct jump is kludgy because we are
down one level in function call depth &ndash; too many of these and the
stack will overflow. Too bad you can't manipulate return.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
         THAW(DDT_BREAK_TAB)
         THAW(DDT_BREAK_TEMP)
         DDT_BREAK_TEMP = TABLE()
         DDT_ACTIVE = 1
         DDT_CURR_STMT = DDT_CMD()                            <b>:F(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JUMP TO USER&#39;S LABEL WITHOUT CLEARING INTERRUPT</i></font>
<font color="#818181"><i>*</i></font>
         &amp;TRACE = 999999999                            <b>:($DDT_CURR_STMT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONVERT TO UPPERCASE IF SOURCE IS NOT CASE SENSITIVE</i></font>
<font color="#818181"><i>*</i></font>
DDT_CASE DDT_CASE = NE(&amp;CASE)
+           REPLACE(DDT_CASE, &amp;LCASE, &amp;UCASE)                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Function to return <font face="Source Code Pro">'('</font> and statement label and offset <font face="Source Code Pro">')'</font>
given a statement number. If <font face="Source Code Pro">DDT_FINAL_STMT</font> is <font face="Source Code Pro">NULL</font>, there
is no listing available, and we just return a <font face="Source Code Pro">NULL</font> string.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_LABEL
         IDENT(DDT_FINAL_STMT)                                <b>:S(RETURN)</b>
DDT_LAB2 DDT_STMTS&lt;STNO&gt; DDT_DL_PAT                         <b>:S(DDT_LAB1)</b>
         STNO = GT(STNO, 1) STNO - 1                        <b>:F(DDT_LAB1)</b>
         OFFSET = OFFSET + 1                                 <b>:(DDT_LAB2)</b>
DDT_LAB1 DDT_LABEL = IDENT(OFFSET) &#39;(&#39; DDT_LABEL &#39;)&#39;          <b>:S(RETURN)</b>
         DDT_LABEL = &#39;(&#39; DDT_LABEL &#39; + &#39; OFFSET &#39;)&#39;            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Get optional statement number
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Input is name of variable containing string with statement number or
label. Label may be followed by <font face="Source Code Pro">' +-N'</font>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Output is statement number or <font face="Source Code Pro">NULL</font> if none provided. Fails and
displays error if bad syntax or illegal label. Statement number or
label is removed from argument string.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_GET_STMT
         IDENT($S)                                            <b>:S(RETURN)</b>
<font color="#818181"><i>* CHECK FOR SIMPLE NUMBER</i></font>
         $S DDT_GET_PAT1 =                                    <b>:S(RETURN)</b>
<font color="#818181"><i>* CHECK FOR TEXT LABEL</i></font>
         $S DDT_GET_PAT2 =                                  <b>:F(DDT_GET1)</b>
<font color="#818181"><i>* CHECK FOR OPTIONAL +N OR -N AFTER LABEL</i></font>
         LABEL DDT_GET_PAT3
         OFFSET = IDENT(SIGN, &#39;-&#39;) -OFFSET
<font color="#818181"><i>* MAP CASE-CONVERTED LABEL TO STATEMENT NUMBER</i></font>
         DDT_GET_STMT = DDT_LBLS&lt;DDT_CASE(LABEL)&gt;
<font color="#818181"><i>* CHECK IF LABEL UNKNOWN TO US, AND ADD OFFSET.</i></font>
         DDT_GET_STMT = VDIFFER(DDT_GET_STMT)
+           + OFFSET                                          <b>:S(RETURN)</b>
DDT_GET1 DDT_TOUT(&#39;BAD LABEL OR STATEMENT NUMBER&#39;)            <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Function to read a listing file. Only numbered program statements
are retained.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Listing format is 4 columns of statement number, four blank columns,
then the user's statement.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_READLIST
         PAT1 = FENCE (LEN(4) | SPAN(&amp;DIGITS)) . STNO
+           (LEN(4) | &#39;&#39;) REM . STMT
         PAT2 = FENCE (NOTANY(&#39;-+.*;|#! &#39; CHARS_NP CHARS_HT)
+           BREAK(CHARS_HT &#39; &#39;) ) . LABEL
         PAT3 = FENCE NOTANY(&amp;DIGITS &#39; &#39; CHARS_HT)
         PAT4 = FENCE ANY(&#39;+.&#39;)
         PAT5 = FENCE ANY(&#39;*;|#!&#39;)
         DDT_READLIST = TABLE(151)
DDT_RL1  LINE = TRIM(DDT_SOURCE)                              <b>:F(RETURN)</b>
         IDENT(LINE)                                         <b>:S(DDT_RL1)</b>
         LINE PAT1                                           <b>:F(DDT_RL1)</b>
<font color="#818181"><i>* IGNORE PAGE THROW, ERROR MESSAGE, FORM FEED, AND TITLES IN LISTING</i></font>
<font color="#818181"><i>* FILE.</i></font>
         STNO PAT3                                           <b>:S(DDT_RL1)</b>
         STNO = TRIM(STNO)
         INTEGER(STNO)                                       <b>:F(DDT_RL4)</b>
<font color="#818181"><i>* IGNORE COMMENTS</i></font>
         STMT PAT5                                           <b>:S(DDT_RL1)</b>
<font color="#818181"><i>* CONTINUATION LINES</i></font>
         STMT PAT4                                           <b>:S(DDT_RL2)</b>
<font color="#818181"><i>* ADJUST $LAST IF NEW STATEMENT NUMBER</i></font>
         $LAST = +VDIFFER(STNO)                    <b>:S(DDT_RL3)F(DDT_RL1)</b>
<font color="#818181"><i>* APPEND LF TO EXISTING TEXT IF CONTINUED STATEMENT</i></font>
DDT_RL2  DDT_READLIST&lt;$LAST&gt; = VDIFFER(DDT_READLIST&lt;$LAST&gt;) CHARS_NL
<font color="#818181"><i>* PLACE STATEMENT IN TABLE</i></font>
DDT_RL3  DDT_READLIST&lt;$LAST&gt; = DDT_READLIST&lt;$LAST&gt; LINE
<font color="#818181"><i>* EXTRACT LABEL</i></font>
         (STMT &#39; &#39;) PAT2                                     <b>:F(DDT_RL1)</b>
<font color="#818181"><i>* RECORD CASE-CONVERTED LABEL TO STATEMENT NUMBER MAPPING</i></font>
         ITEM(LABTAB, DDT_CASE(LABEL)) = $LAST                <b>:(DDT_RL1)</b>
DDT_RL4  DDT_TOUT(&#39;INCORRECT PROGRAM LIST FILE, LINE IN ERROR:&#39;)
         DDT_TOUT(LINE)                                       <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Function to read and process debug commands. <font face="Source Code Pro">FAIL</font>s when caller
should return to the interrupted user program (the 'normal' exit).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Returns <font face="Source Code Pro">SUCCESS</font> to jump indirect to a user label (but down one
function level). The function value is the label name.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If <font face="Source Code Pro">EOF</font> is read from keyboard, debugger shuts itself off.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DDT&raquo;&equiv;</b>
DDT_CMD  IDENT(DDT_UNIT2)                                   <b>:S(DDT_CMD2)</b>
         DDT_IN = DDT_INPUT                                 <b>:F(DDT_CMD4)</b>
         DDT_TOUT(&#39;DDT: &#39; DDT_IN)                            <b>:(DDT_CMD3)</b>
DDT_CMD4 ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =
DDT_CMD2 DDT_LL2 = DDT_LL
         IDENT(DDT_USE_R)                                   <b>:S(DDT_CMD5)</b>
         DDT_TOUT(EQ(DDT_USE_R, 1) &#39;DDT REMOTE (&#39; DSERVE_APPNAME &#39;)&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NOTE: THIS IS THE ONLY READ FROM DDT_R.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF DDT_HOOK IS DEFINED, WE WILL CALL WITH THAT WITH &#39;READ&#39;. SEE</i></font>
<font color="#818181"><i>* DDT_HOOK CALL WITH &#39;DISPLAY&#39; ABOVE. IF THIS FAILS, WE ASSUME NORMAL</i></font>
<font color="#818181"><i>* READ IS NEEDED. IF USE_DDT_R, AND DDT_HOOK IS NOT SET, WE READ</i></font>
<font color="#818181"><i>* FROM DDT_R.</i></font>
<font color="#818181"><i>*</i></font>
         IDENT(DDT_HOOK)                                    <b>:S(DDT_CMD7)</b>
         DDT_IN = TRIM(APPLY(DDT_HOOK, &#39;READ&#39;))  <b>:F(DDT_CMD5)S(DDT_CMD3)</b>
DDT_CMD7 DDT_IN = TRIM(DDT_R)                       <b>:S(DDT_CMD3)F(DDT.O)</b>
DDT_CMD5 DDT_IN = TRIM(HISTORY_EXPAND(READLINE(&#39;DDT: &#39;)))      <b>:F(DDT.O)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ONLY ADD NON-NULL COMMANDS THAT DIFFER FROM LAST COMMAND TO HISTORY</i></font>
<font color="#818181"><i>*</i></font>
DDT_CMD6 IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_LL = DDT_IN
         ADD_HISTORY(VDIFFER(DDT_IN, DDT_LL2))
DDT_CMD3 IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TEST FOR VALID COMMAND AND BRANCH TO APPROPRIATE PROCESSOR (DDT.?).</i></font>
<font color="#818181"><i>* LOWER-CASE COMMANDS ARE EQUIVALENT TO UPPER-CASE, AND BLANK AND</i></font>
<font color="#818181"><i>* TAB ARE CONVERTED TO THE COMMAND &#39;C&#39;.</i></font>
<font color="#818181"><i>*</i></font>
         DDT_IN DDT_CHARS =                              <b>:F(DDT_CMD_ERR)</b>
         DDT_STEP_COUNT = 0
                       <b>:($(&#39;DDT.&#39; REPLACE(DDT_C, DDT_CHARL, DDT_CHARR)))</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** INVALID COMMAND</i></font>
<font color="#818181"><i>*</i></font>
DDT_CMD_ERR
         DDT_TOUT(&#39;?&#39;)                                        <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** TURN OFF DEBUGGER</i></font>
<font color="#818181"><i>*</i></font>
DDT.O    DDT_ACTIVE = 0
         WRITE_HISTORY(&#39;.DDT&#39;)
         &amp;STLIMIT = -1
         STOPTR(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;)                         <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** V - VIEW FILE</i></font>
<font color="#818181"><i>*</i></font>
DDT.V    DDT_IN = IDENT(DDT_IN) DDT_FNAME
         (IDENT(DDT_IN) DIFFER(DDT_USE_R))                    <b>:S(DDT.V2)</b>
         DDT_IN = IDENT(DDT_IN) READLINE(&#39;FILE: &#39;)
         DDT_FNAME = VDIFFER(DDT_IN)                         <b>:F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME: NEED SOMETHING BETTER. LIST FOR LOCAL, BUT DUMP TO DDT_T FOR</i></font>
<font color="#818181"><i>* REMOTE.</i></font>
<font color="#818181"><i>*</i></font>
         HOST(HOST_SYSCMD, &#39;LIST &#39; DDT_IN)                    <b>:(DDT_CMD)</b>
DDT.V2   DDT_TOUT(&#39;USE V FILENAME&#39;)                           <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** M - MODIFY VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
DDT.M    IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_TOUT(DIFFER(DDT_USE_R) &#39;SORRY, NEED EDITLINE&#39;)  <b>:S(DDT_CMD)</b>
         DATATYPE($DDT_IN) &#39;STRING&#39; | &#39;NAME&#39; | &#39;INTEGER&#39; | &#39;REAL&#39;
+                                                             <b>:S(DDT.M2)</b>
         DDT_TOUT(&quot;SORRY, CAN&#39;T MODIFY &quot; DATATYPE($DDT_IN))   <b>:(DDT_CMD)</b>
DDT.M2   $DDT_IN = EDITLINE(&#39;EDIT&lt;&#39; DDT_IN &#39;&gt;: &#39;, $DDT_IN)    <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** . - SOURCE FILE</i></font>
<font color="#818181"><i>*</i></font>
DDT..    IDENT(DDT_UNIT2)                                     <b>:S(DDT..1)</b>
         DDT_TOUT(&#39;. COMMANDS CANNOT BE NESTED&#39;)               <b>:(DDT..2)</b>
DDT..1   IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_TOUT(&#39;SOURCING &#39; DDT_IN)
         DDT_UNIT2 = IO_FINDUNIT()
         INPUT(.DDT_INPUT, DDT_UNIT2,, DDT_IN)               <b>:S(DDT_CMD)</b>
         DDT_TOUT(&#39;CANNOT OPEN &#39; DDT_IN)
DDT..2   ENDFILE(DDT_UNIT2)
         DETACH(.DDT_INPUT)
         DDT_UNIT2 =                                          <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** * - COMMENT</i></font>
<font color="#818181"><i>*</i></font>
DDT.*                                                         <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** H OR ? - HELP</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;HELP&raquo;</b>
                                                              <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** I - IGNORE</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*       CALLS TO DDT() OR DEBUG() MAY HAVE A STRING. THE I COMMAND</i></font>
<font color="#818181"><i>*       IGNORES THE NEXT N CALLS TO DDT() WITH A MATCHING STRING.</i></font>
<font color="#818181"><i>*       NORMALLY, I IS FOLLOWED BY O TO EXECUTE AT FULL SPEED.</i></font>
<font color="#818181"><i>*</i></font>
DDT.I    DDT_IGNORE =
         DDT_IN ((&quot;&#39;&quot; ARB . DDT_IGNORE &quot;&#39;&quot;) | &#39;&#39;) SPAN(DDT_WHITE &#39;,&#39;)
+           SPAN(&amp;DIGITS) . DDT_COUNT RPOS(0)                <b>:S(DDT_CMD)</b>
         DDT_TOUT(&#39;BAD I SYNTAX&#39;)                             <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** Q - QUIT</i></font>
<font color="#818181"><i>*</i></font>
DDT.Q    WRITE_HISTORY(&#39;.DDT&#39;)                                    <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** X - EXECUTE SHELL COMMAND</i></font>
<font color="#818181"><i>*</i></font>
DDT.X    HOST(HOST_SYSCMD, DDT_IN)
         DDT_TOUT()                                           <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** C - IMMEDIATE EXECUTION OF AN UNLABELED CODE STATEMENT.</i></font>
<font color="#818181"><i>*       APPEND OUR OWN GOTOS TO REGAIN CONTROL AFTER EXECUTION.</i></font>
<font color="#818181"><i>*</i></font>
DDT.C    DDT_C = CODE(&#39; &#39; DDT_IN &#39; :S(DDT_SS)F(DDT_FF)&#39;)       <b>:S&lt;DDT_C&gt;</b>
         DDT_TOUT(&#39;COMPILATION ERROR: &#39; &amp;ERRTEXT)             <b>:(DDT_CMD)</b>
DDT_SS   DDT_TOUT(&#39;SUCCESS&#39;)                                  <b>:(DDT_CMD)</b>
DDT_FF   DDT_TOUT(&#39;FAILURE&#39;)                                  <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** E - EXAMINE VARIABLE OR EVALUATE EXPRESSION. WE DISPLAY STRINGS,</i></font>
<font color="#818181"><i>*       NUMBERS AS SCALARS, ARRAYS AND TABLES AS PROTOTYPES, CODE,</i></font>
<font color="#818181"><i>*       EXPRESSION, PATTERN AS TYPE NAME, USER TYPES ARE DISPLAYED AS</i></font>
<font color="#818181"><i>*       MEMBERS</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME - DATATYPE &#39;NAME&#39; MAY BE AN ISSUE, SEE READL.INC AND FIX HERE</i></font>
<font color="#818181"><i>*         AND IN MODIFY DDT.M</i></font>
<font color="#818181"><i>*</i></font>
DDT.E    DDT_RESULT = EVAL(DDT_IN)                            <b>:F(DDT.E2)</b>
         DDT_V = DATATYPE(DDT_RESULT)
         IDENT(DDT_RESULT)                                    <b>:S(DDT.E3)</b>
         DDT_RESULT = ?(DDT_V ? &#39;STRING&#39; | &#39;NAME&#39;) QUOTE(DDT_RESULT)
+                                                             <b>:S(DDT.E3)</b>
         DDT_V &#39;INTEGER&#39; | &#39;REAL&#39;                             <b>:S(DDT.E3)</b>
         DDT_RESULT = ?(DDT_V ? &#39;CODE&#39; | &#39;EXPRESSION&#39; | &#39;PATTERN&#39; |
+           &#39;TABLE&#39; | &#39;ARRAY&#39;) CONVERT(DDT_RESULT, &#39;STRING&#39;)  <b>:S(DDT.E3)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* USER DEFINED DATATYPE - FIELD(&#39;TYPE&#39;,1..N)</i></font>
<font color="#818181"><i>*</i></font>
         DDT_TOUT(DATATYPE(DDT_RESULT))
         DDT_I =
DDT.E4   DDT_I = DDT_I + 1
         DDT_FIELD = FIELD(DATATYPE(DDT_RESULT), DDT_I)      <b>:F(DDT_CMD)</b>
         DDT_V = DATATYPE(APPLY(DDT_FIELD, DDT_RESULT))
         DDT_V = IDENT(APPLY(DDT_FIELD, DDT_RESULT))          <b>:S(DDT.E5)</b>
         DDT_V = ?(DDT_V ? &#39;STRING&#39; | &#39;NAME&#39;)
+           QUOTE(APPLY(DDT_FIELD, DDT_RESULT))               <b>:S(DDT.E5)</b>
         DDT_V = ?(DDT_V ? &#39;INTEGER&#39; | &#39;REAL&#39;)
+           APPLY(DDT_FIELD, DDT_RESULT)                      <b>:S(DDT.E5)</b>
         DDT_V = CONVERT(APPLY(DDT_FIELD, DDT_RESULT), &#39;STRING&#39;)
DDT.E5   DDT_TOUT(&#39;    &#39; RPAD(DDT_FIELD, 10) &#39;: &#39; DDT_V)       <b>:(DDT.E4)</b>
DDT.E3   DDT_TOUT(DDT_RESULT)                                 <b>:(DDT_CMD)</b>
DDT.E2   DDT_TOUT(&#39;EVALUATION ERROR: &#39; &amp;ERRTEXT)              <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** T - STEP N STATEMENTS, DESCENDING INTO PROCEDURES</i></font>
<font color="#818181"><i>*</i></font>
DDT.T    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        <b>:F(DDT_CMD_ERR)</b>
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = 50000
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** P - STEP N STATEMENTS, TREAT PROCEDURES AS INTACT ENTITIES</i></font>
<font color="#818181"><i>*</i></font>
DDT.P    DDT_STEP_COUNT = INTEGER(DDT_IN) +DDT_IN        <b>:F(DDT_CMD_ERR)</b>
         FREEZE(DDT_BREAK_TAB)
         FREEZE(DDT_BREAK_TEMP)
         DDT_FNCLEVEL = &amp;FNCLEVEL - 1
         DDT_STEP_COUNT = LE(DDT_STEP_COUNT) 1                <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** R - REPORT BREAKPOINTS</i></font>
<font color="#818181"><i>*</i></font>
DDT.R    DDT_A = SORT(DDT_BREAK_TAB)                          <b>:F(DDT_R2)</b>
         DDT_C = 0
DDT_R1   DDT_C = DDT_C + 1
         DDT_TOUT(DDT_A&lt;DDT_C, 1&gt; &#39; &#39;
+           DDT_LABEL(DDT_A&lt;DDT_C, 1&gt;))             <b>:S(DDT_R1)F(DDT_CMD)</b>
DDT_R2   DDT_TOUT(&#39;NONE&#39;)                                     <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** K - KILL BREAKPOINT(S)</i></font>
<font color="#818181"><i>*</i></font>
DDT.K    IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_BREAK_TAB&lt;+DDT_GET_STMT(.DDT_IN)&gt; =     <b>:S(DDT.K)F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** B - SET BREAKPOINT(S)</i></font>
<font color="#818181"><i>*</i></font>
DDT.B    IDENT(DDT_IN)                                       <b>:S(DDT_CMD)</b>
         DDT_BREAK_TAB&lt;+DDT_GET_STMT(.DDT_IN)&gt; = 1   <b>:S(DDT.B)F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** G - GO &lt;=OPTIONAL DIRECT TRANSFER LABEL&gt; &lt;OPTIONAL BREAKPOINTS(S)&gt;</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIRST TEST FOR SIMPLE G BY ITSELF</i></font>
DDT.G    DDT_STEP_COUNT = 0
         IDENT(DDT_IN)                                       <b>:S(FRETURN)</b>
<font color="#818181"><i>* CHECK FOR =LABEL, ASSIGN LABEL TO DDT_CMD</i></font>
         DDT_IN DDT_G_PAT =                                   <b>:F(DDT_G1)</b>
         DDT_CMD = DDT_CASE(DDT_CMD)
<font color="#818181"><i>* ERROR IF LABEL UNKNOWN</i></font>
         DDT_TOUT(IDENT(DDT_LBLS&lt;DDT_CMD&gt;) &#39;UNKNOWN LABEL =&#39;
+           DDT_CMD)                                         <b>:S(DDT_CMD)</b>
<font color="#818181"><i>* PROCESS ANY BREAKPOINTS</i></font>
DDT_G1   DIFFER(DDT_IN)                                       <b>:F(DDT_G2)</b>
         DDT_BREAK_TEMP&lt;+DDT_GET_STMT(.DDT_IN)&gt; = 1 <b>:S(DDT_G1)F(DDT_CMD)</b>
<font color="#818181"><i>* CHOOSE FRETURN TO RESUME EXECUTION WHERE INTERRUPTED, RETURN TO</i></font>
<font color="#818181"><i>* TRANSFER TO THE LABEL IN DDT_CMD.</i></font>
DDT_G2   FREEZE(DDT_BREAK_TEMP)
         FREEZE(DDT_BREAK_TAB)
         DIFFER(DDT_CMD)                            <b>:S(RETURN)F(FRETURN)</b>
<b>&laquo;LIST&raquo;</b>
DDT_TOUT DIFFER(DDT_HOOK) APPLY(DDT_HOOK, &#39;DISPLAY&#39;, S)
         DDT_T = S                                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** S(FILE) - LOAD SOURCE LISTING</i></font>
<font color="#818181"><i>*</i></font>
DDT.S    DDT_SOURCE()                                         <b>:(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
DDT_SOURCE
         THAW(DDT_STMTS)
         THAW(DDT_LBLS)
         DDT_LBLS = TABLE(50, 50)
         DDT_FINAL_STMT =
         DDT_UNIT = IO_FINDUNIT()
         DDT_FNAME = TRIMB(DDT_IN)
         DIFFER(DDT_FNAME)                                    <b>:S(DDT_S3)</b>
         INPUT(&#39;DDT_SOURCE&#39;, DDT_UNIT,,
+              DDT_FNAME = HOST(HOST_GETENV, &#39;LIST&#39;))         <b>:S(DDT_S1)</b>
         DDT_TOUT(DIFFER(DDT_USE_R) &#39;USE S FILE&#39;)             <b>:S(DDT_S2)</b>
         DDT_FNAME = TRIM(HISTORY_EXPAND(READLINE(&#39;LISTING: &#39;)))
DDT_S3   INPUT(&#39;DDT_SOURCE&#39;, DDT_UNIT,, DDT_FNAME)            <b>:S(DDT_S1)</b>
         DDT_FNAME =
         DDT_TOUT(&#39;NO LISTING FILE PROVIDED&#39;)                  <b>:(DDT_S2)</b>
DDT_S1   DDT_STMTS = DDT_READLIST(DDT_LBLS, .DDT_FINAL_STMT)
         ENDFILE(DDT_UNIT)
         DETACH(.DDT_SOURCE)
         DDT_TOUT(DIFFER(DDT_FINAL_STMT) &#39;SOURCE LISTING LOADED&#39;)
DDT_S2   FREEZE(DDT_STMTS)
         FREEZE(DDT_LBLS)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DDT_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Provide help for <font face="Source Code Pro">DDT</font>. Commands are a single letter followed
by (optional) arguments. This provides a reminder of the commands,
and what they do.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HELP&raquo;&equiv;</b>
DDT.H
 DDT_TOUT(&#39;STNO - STATEMENT NUMBERS SPECIFIED AS INTEGERS, OR LABEL+-N&#39;)
 DDT_TOUT(&#39;          BRACKETED ITEMS ARE OPTIONAL&#39;)
 DDT_TOUT(&#39;H            (OR ?)     HELP (THIS LIST)&#39;)
 DDT_TOUT(&#39;C STATEMENT  (OR TAB)   IMMEDIATE EXECUTION OF STATEMENT&#39;)
 DDT_TOUT(&#39;E EXPRESSION (OR =EXP)  EVALUATE EXPRESSION&#39;)
 DDT_TOUT(&#39;X COMMAND    (OR !)     EXECUTE SHELL COMMAND&#39;)
 DDT_TOUT(&#39;T [N]                   TRACE N STATEMENTS (INTO PROCS)&#39;)
 DDT_TOUT(&#39;P [N]                   TRACE N STATEMENTS (NO PROCEDURES)&#39;)
 DDT_TOUT(&#39;B STNO [,STNO,...]      SET BREAKPOINT(S)&#39;)
 DDT_TOUT(&#39;K BKPT [,BKPT,...]      KILL BREAKPOINT(S)&#39;)
 DDT_TOUT(&#39;R                       REPORT BREAKPOINTS SET&#39;)
 DDT_TOUT(&#39;G [=LABEL,](STNO1,...]  GO (FROM SPECIFIED LABEL),&#39;)
 DDT_TOUT(&#39;                          SET TEMPORARY BREAKPOINT(S)&#39;)
 DDT_TOUT(&#39;L [STNO1 [,STNO2]]      LIST STATEMENT OR RANGE&#39;)
 DDT_TOUT(&#39;+ [N]  OR  -[N]         LIST NEXT/PREVIOUS N STATEMENTS&#39;)
 DDT_TOUT(&#39;++ OR --                LIST 12 STATEMENTS FORWARD OR BACK&#39;)
 DDT_TOUT(&#39;Q                       QUIT&#39;)
 DDT_TOUT(&#39;O (OR ^D)               OFF - RESUME PROGRAM, STOP DEBUG&#39;)
 DDT_TOUT(&#39;S [FILE]                LOAD SOURCE&#39;)
 DDT_TOUT(&#39;M NAME                  MODIFY VARIABLE&#39;)
 DDT_TOUT(&quot;I &#39;MSG&#39; N               IGNORE NEXT N CALLS TO DDT(MSG)&quot;)
 DDT_TOUT(&#39;* COMMENT               COMMENT (NO ACTION)&#39;)
 DDT_TOUT(&#39;. FILE                  SOURCE FILE (DO NOT NEST)&#39;)
 DDT_TOUT(&#39;V (FILE)                VIEW FILE (DEFAULT TO LIST FILE)&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">L</font> by itself lists the statement about to be executed<br>
<font face="Source Code Pro">L STMT</font> lists the specified statement<br>
<font face="Source Code Pro">L STMT1,STMT2</font> lists all statements in the specified range<br>
See also <font face="Source Code Pro">+</font> and <font face="Source Code Pro">-</font> commands, below<br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DDT_A</font> is the first statement to print, <font face="Source Code Pro">DDT_C</font> is the last,
<font face="Source Code Pro">DDT_LIST_F</font> and <font face="Source Code Pro">DDT_LIST_L</font> are reference numbers for subsequent
<font face="Source Code Pro">+</font> and <font face="Source Code Pro">-</font>'s.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LIST&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** L - LIST STATEMENT(S)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPATCH IF L BY ITSELF</i></font>
DDT.L    DDT_A = IDENT(DDT_IN) DDT_CURR_STMT                  <b>:S(DDT_L1)</b>
<font color="#818181"><i>* GET FIRST LINE NUMBER</i></font>
         DDT_A = +DDT_GET_STMT(.DDT_IN)                      <b>:F(DDT_CMD)</b>
<font color="#818181"><i>* IF JUST ONE, DISPLAY IT BY ITSELF</i></font>
         IDENT(DDT_IN)                                        <b>:S(DDT_L1)</b>
<font color="#818181"><i>* IF ANOTHER, GET IT AS THE ENDING LINE NUMBER</i></font>
         DDT_C = +DDT_GET_STMT(.DDT_IN)             <b>:S(DDT_L2)F(DDT_CMD)</b>
<font color="#818181"><i>* DISPLAY ONE LINE AT DDT_A</i></font>
DDT_L1   DDT_C = DDT_A
<font color="#818181"><i>* USE DDT_C AS THE REFERENCE FOR SUBSEQUENT DISPLAY</i></font>
DDT_L2   DDT_B = .DDT_C
<font color="#818181"><i>* CHECK RANGE OF VALUES SPECIFIED</i></font>
         IDENT(DDT_FINAL_STMT)                               <b>:S(DDT_CMD)</b>
         DDT_A = LT(DDT_A, 1) 1
         DDT_A = GT(DDT_A, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_C = LT(DDT_C, DDT_A) DDT_A
         DDT_C = GT(DDT_C, DDT_FINAL_STMT) DDT_FINAL_STMT
         DDT_LIST_F = DDT_A
         DDT_LIST_L = DDT_C
<font color="#818181"><i>* DISPLAY LOOP</i></font>
DDT_L3   DDT_TOUT(VDIFFER(DDT_STMTS&lt;DDT_A&gt;))
         DDT_A = LT(DDT_A, DDT_C) DDT_A + 1         <b>:S(DDT_L3)F(DDT_CMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** +&lt;N&gt; - LIST NEXT STATEMENT(S), ++ LISTS THE NEXT 12 LINES.</i></font>
<font color="#818181"><i>*</i></font>
DDT.+    DDT_A = DDT_LIST_L + 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      <b>:S(DDT_L4)</b>
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 <b>:F(DDT_CMD_ERR)</b>
         DDT_C = LE(DDT_C) 1
DDT_L4   DDT_C = DDT_A + DDT_C - 1                             <b>:(DDT_L2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*** -&lt;N&gt; - LIST PREVIOUS STATEMENT(S), -- LISTS THE PREVIOUS 12 LINES.</i></font>
<font color="#818181"><i>*</i></font>
DDT.-    DDT_B = DDT_LIST_F - 1
         DDT_C = IDENT(DDT_IN, DDT_C) 11                      <b>:S(DDT_L5)</b>
         DDT_C = INTEGER(DDT_IN) +DDT_IN                 <b>:F(DDT_CMD_ERR)</b>
         DDT_C = LE(DDT_C) 1
DDT_L5   DDT_A = DDT_B - DDT_C + 1
         DDT_C = DDT_B                                         <b>:(DDT_L2)</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DDT.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE DDT
<b>&laquo;INCLUDES&raquo;</b>
-STITL DDT
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      ######   ######   #######                       *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      ######   ######      #                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DDT             AN INTERACTIVE SNOBOL4 DEBUGGER                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DDT.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DDT&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:55 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DDT.INC'
-LINE 696 "DDT.lss"
         &CODE = 1
         &CODE = 0
END
<h1>DEDUPA - "Dedup" a vector</h1>

Removes identical elements frome a one-dimension array (vector) [[A]]
by making it into a table, and then making an array from from the keys.
An empty array dedups to itself, and if keys_in_table fails, no update
is made.                   

<h2>Uses</h2>
<a href="SIZEA.html">SIZEA</a><br>
<a href="HASH.html">HASH</a><br>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>= 
-INCLUDE 'SIZEA.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'SEQ.INC'
@

<<DEDUPA>>=
-PUBLIC DEDUPA()
*
         DEFINE('DEDUPA(A)T,I')                            :(END_DEDUPA)
*
DEDUPA   DEDUPA = IDENT(A, ARRAY0) A                          :S(RETURN)
         T = TABLE()
         SEQ(' T<A<I>> = 1', .I)
         DEDUPA = KEYST(T)                                     :(RETURN)
*
END_DEDUPA
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DEDUPA.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE DEDUPA
-IN72
<<INCLUDES>>
-STITL DEDUPA
-EJECT
*
************************************************************************
*                                                                      *
*         ######   #######  ######   #     #  ######      #            *
*         #     #  #        #     #  #     #  #     #    # #           *
*         #     #  #        #     #  #     #  #     #   #   #          *
*         #     #  #####    #     #  #     #  ######   #     #         *
*         #     #  #        #     #  #     #  #        #######         *
*         #     #  #        #     #  #     #  #        #     #         *
*         ######   #######  ######    #####   #        #     #         *
*                                                                      *
*                                                                      *
* DEDUPA                      DEDUP ARRAY                              *
*                                                                      *
************************************************************************
*
* DEDUPA.lss
*
<<DEDUPA>>
*
* CE: .MSNOBOL4;
@
-MODULE DEDUPA
-IN72
-LINE 14 "DEDUPA.lss"
-INCLUDE 'SIZEA.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'SEQ.INC'
-LINE 45 "DEDUPA.lss"
-STITL DEDUPA
-EJECT
*
************************************************************************
*                                                                      *
*         ######   #######  ######   #     #  ######      #            *
*         #     #  #        #     #  #     #  #     #    # #           *
*         #     #  #        #     #  #     #  #     #   #   #          *
*         #     #  #####    #     #  #     #  ######   #     #         *
*         #     #  #        #     #  #     #  #        #######         *
*         #     #  #        #     #  #     #  #        #     #         *
*         ######   #######  ######    #####   #        #     #         *
*                                                                      *
*                                                                      *
* DEDUPA                      DEDUP ARRAY                              *
*                                                                      *
************************************************************************
*
* DEDUPA.lss
*
-LINE 20 "DEDUPA.lss"
-PUBLIC DEDUPA()
*
         DEFINE('DEDUPA(A)T,I')                            :(END_DEDUPA)
*
DEDUPA   DEDUPA = IDENT(A, ARRAY0) A                          :S(RETURN)
         T = TABLE()
         SEQ(' T<A<I>> = 1', .I)
         DEDUPA = KEYST(T)                                     :(RETURN)
*
END_DEDUPA
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DEDUPA - "Dedup" a vector</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Removes identical elements frome a one-dimension array (vector) <font face="Source Code Pro">A</font>
by making it into a table, and then making an array from from the keys.
An empty array dedups to itself, and if keys_in_table fails, no update
is made.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SIZEA.html">SIZEA</a><br>
<a href="HASH.html">HASH</a><br>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SIZEA.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DEDUPA&raquo;&equiv;</b>
-PUBLIC DEDUPA()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;DEDUPA(A)T,I&#39;)                            <b>:(END_DEDUPA)</b>
<font color="#818181"><i>*</i></font>
DEDUPA   DEDUPA = IDENT(A, ARRAY0) A                          <b>:S(RETURN)</b>
         T = TABLE()
         SEQ(&#39; T&lt;A&lt;I&gt;&gt; = 1&#39;, .I)
         DEDUPA = KEYST(T)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_DEDUPA
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DEDUPA.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE DEDUPA
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL DEDUPA
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         ######   #######  ######   #     #  ######      #            *</i></font>
<font color="#818181"><i>*         #     #  #        #     #  #     #  #     #    # #           *</i></font>
<font color="#818181"><i>*         #     #  #        #     #  #     #  #     #   #   #          *</i></font>
<font color="#818181"><i>*         #     #  #####    #     #  #     #  ######   #     #         *</i></font>
<font color="#818181"><i>*         #     #  #        #     #  #     #  #        #######         *</i></font>
<font color="#818181"><i>*         #     #  #        #     #  #     #  #        #     #         *</i></font>
<font color="#818181"><i>*         ######   #######  ######    #####   #        #     #         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DEDUPA                      DEDUP ARRAY                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DEDUPA.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DEDUPA&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:25 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DEDUPA.INC'
-LINE 36 "DEDUPA.lss"
         &CODE = 1
         &CODE = 0
END
<h1>deretn</h1>

Remove line numbers (de-retain) from [[code]] SAVE file.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<deretn>>=
         TERMINAL = 'DERETN (FRI NOV 22 00:38:55 EST 2013)'
*
         S = DUPL(' ', 5)
*
TOP      (INPUT S) LEN(5) REM . L                                :F(END)
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM DERETN
-TITLE DERETN
START
*
************************************************************************
*                                                                      *
*                                                                      *
*         ######   #######  ######   #######  #######  #     #         *
*         #     #  #        #     #  #           #     ##    #         *
*         #     #  #        #     #  #           #     # #   #         *
*         #     #  #####    ######   #####       #     #  #  #         *
*         #     #  #        #   #    #           #     #   # #         *
*         #     #  #        #    #   #           #     #    ##         *
*         ######   #######  #     #  #######     #     #     #         *
*                                                                      *
* DERETN         REMOVE LINE NUMBERS FROM CODE SAVE FILE               *
*                                                                      *
************************************************************************
*
* deretn.lss
*
<<deretn>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM DERETN
-LINE 25 "deretn.lss"
-TITLE DERETN
START
*
************************************************************************
*                                                                      *
*                                                                      *
*         ######   #######  ######   #######  #######  #     #         *
*         #     #  #        #     #  #           #     ##    #         *
*         #     #  #        #     #  #           #     # #   #         *
*         #     #  #####    ######   #####       #     #  #  #         *
*         #     #  #        #   #    #           #     #   # #         *
*         #     #  #        #    #   #           #     #    ##         *
*         ######   #######  #     #  #######     #     #     #         *
*                                                                      *
* DERETN         REMOVE LINE NUMBERS FROM CODE SAVE FILE               *
*                                                                      *
************************************************************************
*
* deretn.lss
*
-LINE 11 "deretn.lss"
         TERMINAL = 'DERETN (FRI NOV 22 00:38:55 EST 2013)'
*
         S = DUPL(' ', 5)
*
TOP      (INPUT S) LEN(5) REM . L                                :F(END)
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>deretn</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Remove line numbers (de-retain) from <font face="Source Code Pro">code</font> SAVE file.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;deretn&raquo;&equiv;</b>
         TERMINAL = &#39;DERETN (FRI NOV 22 00:38:55 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         S = DUPL(&#39; &#39;, 5)
<font color="#818181"><i>*</i></font>
TOP      (INPUT S) LEN(5) REM . L                                <b>:F(END)</b>
         OUTPUT = TRIM(L)                                         <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM DERETN
-TITLE DERETN
START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         ######   #######  ######   #######  #######  #     #         *</i></font>
<font color="#818181"><i>*         #     #  #        #     #  #           #     ##    #         *</i></font>
<font color="#818181"><i>*         #     #  #        #     #  #           #     # #   #         *</i></font>
<font color="#818181"><i>*         #     #  #####    ######   #####       #     #  #  #         *</i></font>
<font color="#818181"><i>*         #     #  #        #   #    #           #     #   # #         *</i></font>
<font color="#818181"><i>*         #     #  #        #    #   #           #     #    ##         *</i></font>
<font color="#818181"><i>*         ######   #######  #     #  #######     #     #     #         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DERETN         REMOVE LINE NUMBERS FROM CODE SAVE FILE               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* deretn.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;deretn&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:56 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<H1>deseql</H1>

<h2>Uses</h2>

<<INCLUDES>>=
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM DESEQL
-TITLE DESEQL
START
*
************************************************************************
*                                                                      *
*          ######   #######   #####   #######   #####   #              *
*          #     #  #        #     #  #        #     #  #              *
*          #     #  #        #        #        #     #  #              *
*          #     #  #####     #####   #####    #     #  #              *
*          #     #  #              #  #        #   # #  #              *
*          #     #  #        #     #  #        #    #   #              *
*          ######   #######   #####   #######   #### #  #######        *
*                                                                      *
* DESEQL            DESEQUENCE A SOURCE DECK (1-6)                     *
*                                                                      *
************************************************************************
*
* deseql.lss
*
         TERMINAL = 'DESEQL (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 6)
*
TOP      (INPUT S) LEN(6) REM . L                                :F(END)
         OUTPUT = S TRIM(L)                                       :(TOP)
*
END START
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM DESEQL
-LINE 12 "deseql.lss"
-TITLE DESEQL
START
*
************************************************************************
*                                                                      *
*          ######   #######   #####   #######   #####   #              *
*          #     #  #        #     #  #        #     #  #              *
*          #     #  #        #        #        #     #  #              *
*          #     #  #####     #####   #####    #     #  #              *
*          #     #  #              #  #        #   # #  #              *
*          #     #  #        #     #  #        #    #   #              *
*          ######   #######   #####   #######   #### #  #######        *
*                                                                      *
* DESEQL            DESEQUENCE A SOURCE DECK (1-6)                     *
*                                                                      *
************************************************************************
*
* deseql.lss
*
         TERMINAL = 'DESEQL (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 6)
*
TOP      (INPUT S) LEN(6) REM . L                                :F(END)
         OUTPUT = S TRIM(L)                                       :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>deseql</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM DESEQL
-TITLE DESEQL
START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*          ######   #######   #####   #######   #####   #              *</i></font>
<font color="#818181"><i>*          #     #  #        #     #  #        #     #  #              *</i></font>
<font color="#818181"><i>*          #     #  #        #        #        #     #  #              *</i></font>
<font color="#818181"><i>*          #     #  #####     #####   #####    #     #  #              *</i></font>
<font color="#818181"><i>*          #     #  #              #  #        #   # #  #              *</i></font>
<font color="#818181"><i>*          #     #  #        #     #  #        #    #   #              *</i></font>
<font color="#818181"><i>*          ######   #######   #####   #######   #### #  #######        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DESEQL            DESEQUENCE A SOURCE DECK (1-6)                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* deseql.lss</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;DESEQL (SUN JUN 16 14:13:20 EDT 2013)&#39;
<font color="#818181"><i>*</i></font>
         S = DUPL(&#39; &#39;, 6)
<font color="#818181"><i>*</i></font>
TOP      (INPUT S) LEN(6) REM . L                                <b>:F(END)</b>
         OUTPUT = S TRIM(L)                                       <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:57 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>deseq</h1>

Desequence a FORTRAN source deck. Keeps columns 1 through 72, and
discards columns 73 and beyond. This removes sequence numbers from
fixed format FORTRAN programs.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<deseq>>=
         TERMINAL = 'DESEQ (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 72)
*
TOP      (INPUT S) LEN(72) . L                                   :F(END)
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM DESEQ
-TITLE DESEQ
START
*
************************************************************************
*                                                                      *
*             ######   #######   #####   #######   #####               *
*             #     #  #        #     #  #        #     #              *
*             #     #  #        #        #        #     #              *
*             #     #  #####     #####   #####    #     #              *
*             #     #  #              #  #        #   # #              *
*             #     #  #        #     #  #        #    #               *
*             ######   #######   #####   #######   #### #              *
*                                                                      *
* DESEQ             DESEQUENCE A SOURCE DECK (73-80)                   *
*                                                                      *
************************************************************************
*
* deseq.lss
*
<<deseq>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM DESEQ
-LINE 27 "deseq.lss"
-TITLE DESEQ
START
*
************************************************************************
*                                                                      *
*             ######   #######   #####   #######   #####               *
*             #     #  #        #     #  #        #     #              *
*             #     #  #        #        #        #     #              *
*             #     #  #####     #####   #####    #     #              *
*             #     #  #              #  #        #   # #              *
*             #     #  #        #     #  #        #    #               *
*             ######   #######   #####   #######   #### #              *
*                                                                      *
* DESEQ             DESEQUENCE A SOURCE DECK (73-80)                   *
*                                                                      *
************************************************************************
*
* deseq.lss
*
-LINE 13 "deseq.lss"
         TERMINAL = 'DESEQ (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 72)
*
TOP      (INPUT S) LEN(72) . L                                   :F(END)
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>deseq</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Desequence a FORTRAN source deck. Keeps columns 1 through 72, and
discards columns 73 and beyond. This removes sequence numbers from
fixed format FORTRAN programs.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;deseq&raquo;&equiv;</b>
         TERMINAL = &#39;DESEQ (SUN JUN 16 14:13:20 EDT 2013)&#39;
<font color="#818181"><i>*</i></font>
         S = DUPL(&#39; &#39;, 72)
<font color="#818181"><i>*</i></font>
TOP      (INPUT S) LEN(72) . L                                   <b>:F(END)</b>
         OUTPUT = TRIM(L)                                         <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM DESEQ
-TITLE DESEQ
START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             ######   #######   #####   #######   #####               *</i></font>
<font color="#818181"><i>*             #     #  #        #     #  #        #     #              *</i></font>
<font color="#818181"><i>*             #     #  #        #        #        #     #              *</i></font>
<font color="#818181"><i>*             #     #  #####     #####   #####    #     #              *</i></font>
<font color="#818181"><i>*             #     #  #              #  #        #   # #              *</i></font>
<font color="#818181"><i>*             #     #  #        #     #  #        #    #               *</i></font>
<font color="#818181"><i>*             ######   #######   #####   #######   #### #              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DESEQ             DESEQUENCE A SOURCE DECK (73-80)                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* deseq.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;deseq&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:57 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>DEXP - Simple Function Definition</h1>

Simple function definition. [[DEXP(PROTO)]] defines functions in
terms of a simple, one-line expression, such as

[[
    DEXP('AVE(X,Y) = (X + Y) / 2.0')
]]

<h2>Uses</h2>

<<INCLUDES>>=
@

<<DEXP>>=
-MODULE DEXP
-PUBLIC DEXP()
         DEFINE('DEXP(PROTO)NAME,ARGS')                      :(DEXP_END)
*
DEXP     PROTO POS(0) SPAN(' ') =
         PROTO BREAK('(') . NAME BAL . ARGS = NAME
         CODE(NAME ' ' PROTO ' :S(RETURN)F(FRETURN)')
         DEFINE(NAME ARGS)                                     :(RETURN)
*
DEXP_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DEXP.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL DEXP
-EJECT
*
************************************************************************
*                                                                      *
*                   ######   #######  #     #  ######                  *
*                   #     #  #         #   #   #     #                 *
*                   #     #  #          # #    #     #                 *
*                   #     #  #####       #     ######                  *
*                   #     #  #          # #    #                       *
*                   #     #  #         #   #   #                       *
*                   ######   #######  #     #  #                       *
*                                                                      *
* DEXP                 SIMPLE FUNCTION DEFINTION                       *
*                                                                      *
************************************************************************
*
* DEXP.lss
*
<<DEXP>>
*
* CE: .MSNOBOL4;
@
-STITL DEXP
-EJECT
*
-LINE 41 "DEXP.lss"
************************************************************************
*                                                                      *
*                   ######   #######  #     #  ######                  *
*                   #     #  #         #   #   #     #                 *
*                   #     #  #          # #    #     #                 *
*                   #     #  #####       #     ######                  *
*                   #     #  #          # #    #                       *
*                   #     #  #         #   #   #                       *
*                   ######   #######  #     #  #                       *
*                                                                      *
* DEXP                 SIMPLE FUNCTION DEFINTION                       *
*                                                                      *
************************************************************************
*
* DEXP.lss
*
-LINE 16 "DEXP.lss"
-MODULE DEXP
-PUBLIC DEXP()
         DEFINE('DEXP(PROTO)NAME,ARGS')                      :(DEXP_END)
*
DEXP     PROTO POS(0) SPAN(' ') =
         PROTO BREAK('(') . NAME BAL . ARGS = NAME
         CODE(NAME ' ' PROTO ' :S(RETURN)F(FRETURN)')
         DEFINE(NAME ARGS)                                     :(RETURN)
*
DEXP_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DEXP - Simple Function Definition</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Simple function definition. <font face="Source Code Pro">DEXP(PROTO)</font> defines functions in
terms of a simple, one-line expression, such as
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     DEXP('AVE(X,Y) = (X + Y) / 2.0')
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DEXP&raquo;&equiv;</b>
-MODULE DEXP
-PUBLIC DEXP()
         DEFINE(&#39;DEXP(PROTO)NAME,ARGS&#39;)                      <b>:(DEXP_END)</b>
<font color="#818181"><i>*</i></font>
DEXP     PROTO POS(0) SPAN(&#39; &#39;) =
         PROTO BREAK(&#39;(&#39;) . NAME BAL . ARGS = NAME
         CODE(NAME &#39; &#39; PROTO &#39; :S(RETURN)F(FRETURN)&#39;)
         DEFINE(NAME ARGS)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DEXP_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DEXP.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL DEXP
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   ######   #######  #     #  ######                  *</i></font>
<font color="#818181"><i>*                   #     #  #         #   #   #     #                 *</i></font>
<font color="#818181"><i>*                   #     #  #          # #    #     #                 *</i></font>
<font color="#818181"><i>*                   #     #  #####       #     ######                  *</i></font>
<font color="#818181"><i>*                   #     #  #          # #    #                       *</i></font>
<font color="#818181"><i>*                   #     #  #         #   #   #                       *</i></font>
<font color="#818181"><i>*                   ######   #######  #     #  #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DEXP                 SIMPLE FUNCTION DEFINTION                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DEXP.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DEXP&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:58 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DEXP.INC'
-LINE 32 "DEXP.lss"
         &CODE = 1
         &CODE = 0
END
<h1>DISPLAY - Display control</h1>

Use [[tput]] to determine strings to control the display. [[curses]]
may be better, but this does (at least) <b>allow</b> full-screen
applications. We add to this file as additional display controls
are needed.

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'VDIFFER.INC'
@

<<DISPLAY>>=
-MODULE DISPLAY
-PUBLIC DS_SMSO, DS_RMSO, DS_SMUL, DS_RMUL, DS_BLINK
-PUBLIC DS_BOLD, DS_DIM, DS_REV, DS_SGR0, DS_CIVIS, DS_CNORM, DS_CVVIS
-PUBLIC DS_GOTO(), DS_FOREGROUND_COLOR(), DS_BACKGROUND_COLOR()
-PUBLIC DS_BLACK, DS_RED, DS_GREEN, DS_YELLOW, DS_BLUE, DS_PURPLE
-PUBLIC DS_CYAN, DS_WHITE, DS_IND, DS_RI
-PUBLIC DS_EL, DS_HOME, DS_CLEAR, DS_COLS, DS_LINES 
DISPLAY
*
* GATHER STATIC TERMINAL STRINGS.
*
* STANDOUT (BOLD)
         DS_SMSO  = BQ('tput smso')
* STANDOUT OFF
         DS_RMSO  = BQ('tput rmso')
* UNDERLINE
         DS_SMUL  = BQ('tput smul')
* UNDERLINE OFF
         DS_RMUL  = BQ('tput rmul')
* BLINK
         DS_BLINK = BQ('tput blink')
* BOLD
         DS_BOLD  = BQ('tput bold')
* DIM (HALF-BRIGHT)
         DS_DIM   = BQ('tput dim')
* REVERSE
         DS_REV   = BQ('tput rev')
* RESET ALL
         DS_SGR0  = BQ('tput sgr0')
*
* CURSOR OFF
         DS_CIVIS = BQ('tput civis')
* CURSOR ON
         DS_CNORM = BQ('tput cnorm')
* CURSOR VERY VISIBLE
         DS_CVVIS = BQ('tput cvvis')
*
* ERASE TO END-LINE
         DS_EL    = BQ('tput el')
* HOME CURSOR
         DS_HOME  = BQ('tput home')
* CLEAR DISPLAY
         DS_CLEAR = BQ('tput clear')
*
* NUMBER OF COLUMNS
         DS_COLS  = BQ('tput cols')
*
* NUMBER OF LINES
         DS_LINES = BQ('tput lines')
*
* DYNAMIC STRINGS. THESE ARE CACHED IN TABLE DS_
*
         DS_ = TABLE(DS_LINES * DS_COLS + 16)
*
         DEFINE('DS_GOTO(ROW,COL)')
         DEFINE('DS_FOREGROUND_COLOR(N)')
         DEFINE('DS_BACKGROUND_COLOR(N)')
*
* DEFINED COLORS
*
         DS_BLACK  = 0
         DS_RED    = 1
         DS_GREEN  = 2
         DS_YELLOW = 3
         DS_BLUE   = 4
         DS_PURPLE = 5
         DS_CYAN   = 6
         DS_WHITE  = 7                                    :(DS_GOTO_END)
*
@

These routines check to see if the entry is in the [[DS_]] table
(cached). If so, return the string. If not, use [[tput]] to generate
the string, insert into the cache table, and then return.

<<DISPLAY>>=
*
* SET FOREGROUND COLOR.
*
DS_FOREGROUND_COLOR
         DS_FOREGROUND_COLOR = VDIFFER(DS<'F' N>)             :S(RETURN)
         DS_<'F' N> = BQ('tput setaf ' N)         :(DS_FOREGROUND_COLOR)
*
* SET BACKGROUND COLOR.
*
DS_BACKGROUND_COLOR
         DS_BACKGROUND_COLOR = VDIFFER(DS<'B' N>)             :S(RETURN)
         DS_<'B' N> = BQ('tput setab ' N)         :(DS_BACKGROUND_COLOR)
*
* POSITION CURSOR TO (ROW, COLUMN)
*
DS_GOTO  DS_GOTO = VDIFFER(DS_<ROW ' ' COL>)                  :S(RETURN)
*
@

[[COLLECT()]] was needed here in earlier versions of CSNOBOL. It is
no longer needed. (GC within BQ was deadly in CSNOBOL4 1.1!).

<<DISPLAY>>=
         DS_<ROW ' ' COL> = BQ('tput cup ' ROW ' ' COL)       :(DS_GOTO)
*
DS_GOTO_END
*
* IND - SCROLL UP
* NOTE THAT IND IS NL, SO BQ RETURNS IS NOT SUITABLE WE THEREFORE
* DON'T USE BQ('tput ind') BUT CHARS_NL DIRECTLY
*
         DS_IND = DS_GOTO(DS_LINES - 1, 0) CHARS_NL
* RI - SCROLL DOWN
         DS_RI = DS_HOME BQ('tput ri')
*
         CODE('DISPLAY')
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DISPLAY.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL DISPLAY
-EJECT
*
************************************************************************
*                                                                      *
*     ######   ###   #####   ######   #           #     #     #        *
*     #     #   #   #     #  #     #  #          # #     #   #         *
*     #     #   #   #        #     #  #         #   #     # #          *
*     #     #   #    #####   ######   #        #     #     #           *
*     #     #   #         #  #        #        #######     #           *
*     #     #   #   #     #  #        #        #     #     #           *
*     ######   ###   #####   #        #######  #     #     #           *
*                                                                      *
* DISPLAY            DISPLAY CONTROL (FULL-SCREEN)                     *
*                                                                      *
************************************************************************
*
* DISPLAY.lss
*
<<DISPLAY>>
*
* CE: .MSNOBOL4;
@
-LINE 14 "DISPLAY.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'VDIFFER.INC'
-STITL DISPLAY
-EJECT
-LINE 147 "DISPLAY.lss"
*
************************************************************************
*                                                                      *
*     ######   ###   #####   ######   #           #     #     #        *
*     #     #   #   #     #  #     #  #          # #     #   #         *
*     #     #   #   #        #     #  #         #   #     # #          *
*     #     #   #    #####   ######   #        #     #     #           *
*     #     #   #         #  #        #        #######     #           *
*     #     #   #   #     #  #        #        #     #     #           *
*     ######   ###   #####   #        #######  #     #     #           *
*                                                                      *
* DISPLAY            DISPLAY CONTROL (FULL-SCREEN)                     *
*                                                                      *
************************************************************************
*
* DISPLAY.lss
*
-LINE 20 "DISPLAY.lss"
-MODULE DISPLAY
-PUBLIC DS_SMSO, DS_RMSO, DS_SMUL, DS_RMUL, DS_BLINK
-PUBLIC DS_BOLD, DS_DIM, DS_REV, DS_SGR0, DS_CIVIS, DS_CNORM, DS_CVVIS
-PUBLIC DS_GOTO(), DS_FOREGROUND_COLOR(), DS_BACKGROUND_COLOR()
-PUBLIC DS_BLACK, DS_RED, DS_GREEN, DS_YELLOW, DS_BLUE, DS_PURPLE
-PUBLIC DS_CYAN, DS_WHITE, DS_IND, DS_RI
-PUBLIC DS_EL, DS_HOME, DS_CLEAR, DS_COLS, DS_LINES
DISPLAY
*
* GATHER STATIC TERMINAL STRINGS.
*
* STANDOUT (BOLD)
         DS_SMSO  = BQ('tput smso')
* STANDOUT OFF
         DS_RMSO  = BQ('tput rmso')
* UNDERLINE
         DS_SMUL  = BQ('tput smul')
* UNDERLINE OFF
         DS_RMUL  = BQ('tput rmul')
* BLINK
         DS_BLINK = BQ('tput blink')
* BOLD
         DS_BOLD  = BQ('tput bold')
* DIM (HALF-BRIGHT)
         DS_DIM   = BQ('tput dim')
* REVERSE
         DS_REV   = BQ('tput rev')
* RESET ALL
         DS_SGR0  = BQ('tput sgr0')
*
* CURSOR OFF
         DS_CIVIS = BQ('tput civis')
* CURSOR ON
         DS_CNORM = BQ('tput cnorm')
* CURSOR VERY VISIBLE
         DS_CVVIS = BQ('tput cvvis')
*
* ERASE TO END-LINE
         DS_EL    = BQ('tput el')
* HOME CURSOR
         DS_HOME  = BQ('tput home')
* CLEAR DISPLAY
         DS_CLEAR = BQ('tput clear')
*
* NUMBER OF COLUMNS
         DS_COLS  = BQ('tput cols')
*
* NUMBER OF LINES
         DS_LINES = BQ('tput lines')
*
* DYNAMIC STRINGS. THESE ARE CACHED IN TABLE DS_
*
         DS_ = TABLE(DS_LINES * DS_COLS + 16)
*
         DEFINE('DS_GOTO(ROW,COL)')
         DEFINE('DS_FOREGROUND_COLOR(N)')
         DEFINE('DS_BACKGROUND_COLOR(N)')
*
* DEFINED COLORS
*
         DS_BLACK  = 0
         DS_RED    = 1
         DS_GREEN  = 2
         DS_YELLOW = 3
         DS_BLUE   = 4
         DS_PURPLE = 5
         DS_CYAN   = 6
         DS_WHITE  = 7                                    :(DS_GOTO_END)
*
-LINE 96 "DISPLAY.lss"
*
* SET FOREGROUND COLOR.
*
DS_FOREGROUND_COLOR
         DS_FOREGROUND_COLOR = VDIFFER(DS<'F' N>)             :S(RETURN)
         DS_<'F' N> = BQ('tput setaf ' N)         :(DS_FOREGROUND_COLOR)
*
* SET BACKGROUND COLOR.
*
DS_BACKGROUND_COLOR
         DS_BACKGROUND_COLOR = VDIFFER(DS<'B' N>)             :S(RETURN)
         DS_<'B' N> = BQ('tput setab ' N)         :(DS_BACKGROUND_COLOR)
*
* POSITION CURSOR TO (ROW, COLUMN)
*
DS_GOTO  DS_GOTO = VDIFFER(DS_<ROW ' ' COL>)                  :S(RETURN)
*
-LINE 119 "DISPLAY.lss"
         DS_<ROW ' ' COL> = BQ('tput cup ' ROW ' ' COL)       :(DS_GOTO)
*
DS_GOTO_END
*
* IND - SCROLL UP
* NOTE THAT IND IS NL, SO BQ RETURNS IS NOT SUITABLE WE THEREFORE
* DON'T USE BQ('tput ind') BUT CHARS_NL DIRECTLY
*
         DS_IND = DS_GOTO(DS_LINES - 1, 0) CHARS_NL
* RI - SCROLL DOWN
         DS_RI = DS_HOME BQ('tput ri')
*
         CODE('DISPLAY')
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DISPLAY - Display control</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Use <font face="Source Code Pro">tput</font> to determine strings to control the display. <font face="Source Code Pro">curses</font>
may be better, but this does (at least) <b>allow</b> full-screen
applications. We add to this file as additional display controls
are needed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DISPLAY&raquo;&equiv;</b>
-MODULE DISPLAY
-PUBLIC DS_SMSO, DS_RMSO, DS_SMUL, DS_RMUL, DS_BLINK
-PUBLIC DS_BOLD, DS_DIM, DS_REV, DS_SGR0, DS_CIVIS, DS_CNORM, DS_CVVIS
-PUBLIC DS_GOTO(), DS_FOREGROUND_COLOR(), DS_BACKGROUND_COLOR()
-PUBLIC DS_BLACK, DS_RED, DS_GREEN, DS_YELLOW, DS_BLUE, DS_PURPLE
-PUBLIC DS_CYAN, DS_WHITE, DS_IND, DS_RI
-PUBLIC DS_EL, DS_HOME, DS_CLEAR, DS_COLS, DS_LINES
DISPLAY
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GATHER STATIC TERMINAL STRINGS.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* STANDOUT (BOLD)</i></font>
         DS_SMSO  = BQ(&#39;tput smso&#39;)
<font color="#818181"><i>* STANDOUT OFF</i></font>
         DS_RMSO  = BQ(&#39;tput rmso&#39;)
<font color="#818181"><i>* UNDERLINE</i></font>
         DS_SMUL  = BQ(&#39;tput smul&#39;)
<font color="#818181"><i>* UNDERLINE OFF</i></font>
         DS_RMUL  = BQ(&#39;tput rmul&#39;)
<font color="#818181"><i>* BLINK</i></font>
         DS_BLINK = BQ(&#39;tput blink&#39;)
<font color="#818181"><i>* BOLD</i></font>
         DS_BOLD  = BQ(&#39;tput bold&#39;)
<font color="#818181"><i>* DIM (HALF-BRIGHT)</i></font>
         DS_DIM   = BQ(&#39;tput dim&#39;)
<font color="#818181"><i>* REVERSE</i></font>
         DS_REV   = BQ(&#39;tput rev&#39;)
<font color="#818181"><i>* RESET ALL</i></font>
         DS_SGR0  = BQ(&#39;tput sgr0&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CURSOR OFF</i></font>
         DS_CIVIS = BQ(&#39;tput civis&#39;)
<font color="#818181"><i>* CURSOR ON</i></font>
         DS_CNORM = BQ(&#39;tput cnorm&#39;)
<font color="#818181"><i>* CURSOR VERY VISIBLE</i></font>
         DS_CVVIS = BQ(&#39;tput cvvis&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ERASE TO END-LINE</i></font>
         DS_EL    = BQ(&#39;tput el&#39;)
<font color="#818181"><i>* HOME CURSOR</i></font>
         DS_HOME  = BQ(&#39;tput home&#39;)
<font color="#818181"><i>* CLEAR DISPLAY</i></font>
         DS_CLEAR = BQ(&#39;tput clear&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NUMBER OF COLUMNS</i></font>
         DS_COLS  = BQ(&#39;tput cols&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NUMBER OF LINES</i></font>
         DS_LINES = BQ(&#39;tput lines&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DYNAMIC STRINGS. THESE ARE CACHED IN TABLE DS_</i></font>
<font color="#818181"><i>*</i></font>
         DS_ = TABLE(DS_LINES * DS_COLS + 16)
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;DS_GOTO(ROW,COL)&#39;)
         DEFINE(&#39;DS_FOREGROUND_COLOR(N)&#39;)
         DEFINE(&#39;DS_BACKGROUND_COLOR(N)&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DEFINED COLORS</i></font>
<font color="#818181"><i>*</i></font>
         DS_BLACK  = 0
         DS_RED    = 1
         DS_GREEN  = 2
         DS_YELLOW = 3
         DS_BLUE   = 4
         DS_PURPLE = 5
         DS_CYAN   = 6
         DS_WHITE  = 7                                    <b>:(DS_GOTO_END)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
These routines check to see if the entry is in the <font face="Source Code Pro">DS_</font> table
(cached). If so, return the string. If not, use <font face="Source Code Pro">tput</font> to generate
the string, insert into the cache table, and then return.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DISPLAY&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SET FOREGROUND COLOR.</i></font>
<font color="#818181"><i>*</i></font>
DS_FOREGROUND_COLOR
         DS_FOREGROUND_COLOR = VDIFFER(DS&lt;&#39;F&#39; N&gt;)             <b>:S(RETURN)</b>
         DS_&lt;&#39;F&#39; N&gt; = BQ(&#39;tput setaf &#39; N)         <b>:(DS_FOREGROUND_COLOR)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SET BACKGROUND COLOR.</i></font>
<font color="#818181"><i>*</i></font>
DS_BACKGROUND_COLOR
         DS_BACKGROUND_COLOR = VDIFFER(DS&lt;&#39;B&#39; N&gt;)             <b>:S(RETURN)</b>
         DS_&lt;&#39;B&#39; N&gt; = BQ(&#39;tput setab &#39; N)         <b>:(DS_BACKGROUND_COLOR)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* POSITION CURSOR TO (ROW, COLUMN)</i></font>
<font color="#818181"><i>*</i></font>
DS_GOTO  DS_GOTO = VDIFFER(DS_&lt;ROW &#39; &#39; COL&gt;)                  <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">COLLECT()</font> was needed here in earlier versions of CSNOBOL. It is
no longer needed. (GC within BQ was deadly in CSNOBOL4 1.1!).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DISPLAY&raquo;&equiv;</b>
         DS_&lt;ROW &#39; &#39; COL&gt; = BQ(&#39;tput cup &#39; ROW &#39; &#39; COL)       <b>:(DS_GOTO)</b>
<font color="#818181"><i>*</i></font>
DS_GOTO_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IND - SCROLL UP</i></font>
<font color="#818181"><i>* NOTE THAT IND IS NL, SO BQ RETURNS IS NOT SUITABLE WE THEREFORE</i></font>
<font color="#818181"><i>* DON&#39;T USE BQ(&#39;tput ind&#39;) BUT CHARS_NL DIRECTLY</i></font>
<font color="#818181"><i>*</i></font>
         DS_IND = DS_GOTO(DS_LINES - 1, 0) CHARS_NL
<font color="#818181"><i>* RI - SCROLL DOWN</i></font>
         DS_RI = DS_HOME BQ(&#39;tput ri&#39;)
<font color="#818181"><i>*</i></font>
         CODE(&#39;DISPLAY&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DISPLAY.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL DISPLAY
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*     ######   ###   #####   ######   #           #     #     #        *</i></font>
<font color="#818181"><i>*     #     #   #   #     #  #     #  #          # #     #   #         *</i></font>
<font color="#818181"><i>*     #     #   #   #        #     #  #         #   #     # #          *</i></font>
<font color="#818181"><i>*     #     #   #    #####   ######   #        #     #     #           *</i></font>
<font color="#818181"><i>*     #     #   #         #  #        #        #######     #           *</i></font>
<font color="#818181"><i>*     #     #   #   #     #  #        #        #     #     #           *</i></font>
<font color="#818181"><i>*     ######   ###   #####   #        #######  #     #     #           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DISPLAY            DISPLAY CONTROL (FULL-SCREEN)                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPLAY.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DISPLAY&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:58 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DISPLAY.INC'
-LINE 138 "DISPLAY.lss"
         &CODE = 1
         &CODE = 0
END
<h1>DSERVE - DDT Server</h1>

[[DSERVE]] provides a method to allow debugging applications that
cannot normally be debugged. The application will call [[DSERVE_INIT()]]
to initialize. This creates a listener process that waits for telnet
connections. When a connection is made, two processes will shuttle
data between telnet and [[DDT]].

Not very good at cleaning up, but this does work.

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="DDT.html">DDT</a><br>
<a href="P64.html">P64</a><br>
<a href="REPL.html">REPL</a><br>
<a href="TRIMB.html">TRIMB</a><br>

<<INCLUDES>>= 
-INCLUDE 'CHARS.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'P64.INC'
-INCLUDE 'DDT.INC'
@

<<DSERVE>>=
-MODULE DSERVE
-PUBLIC DSERVE_INIT(), DSERVE()
-PUBLIC DSERVE_PORT, DSERVE_APPNAME
         DEFINE('DSERVE_INIT(APPNAME,PORT,KEY)')      :(DSERVE_INIT_END)
*
DSERVE_INIT
         DSERVE_KEY = KEY
         DSERVE_PORT = PORT
         DSERVE_APPNAME = APPNAME
*
         LT(CREATEPIPE())                                    :S(DSERVE9)
         DSERVE_P1_RFD = GETPIPEFD(0)
         DSERVE_P1_WFD = GETPIPEFD(1)
         LT(CREATEPIPE())                                    :S(DSERVE9)
         DSERVE_P2_RFD = GETPIPEFD(0)
         DSERVE_P2_WFD = GETPIPEFD(1)
         PID = FORK()                                        :F(DSERVE9)
         LT(PID)                                             :S(DSERVE9)
         EQ(PID)                                             :S(DSERVE2)
*
* PRIMORDIAL PROCESS - POLLS WITH DSERVE() WAITING FOR CONNECTION AND
* DEBUGGER ENTRY
*
         DSERVE_FDS = MALLOC(SIZEOF_FD_SET())
         DSERVE_TV = MALLOC(SIZEOF_TIMEVAL())                  :(RETURN)
*
DSERVE_INIT_END
*
         DEFINE('DSERVE()N,S')                             :(DSERVE_END)
DSERVE   NE(DDT_ACTIVE)                                        :(RETURN)
         SET_TIMEVAL(DSERVE_TV, 0, 0)
         FD_ZERO(DSERVE_FDS)
         FD_SET(DSERVE_P2_RFD, DSERVE_FDS)
         N = SELECT(DSERVE_P2_RFD + 1, DSERVE_FDS, 0, 0, DSERVE_TV)
         EQ(N)                                                :S(RETURN)
*
         OUTPUT(.DDT_T, 10, 'W', '/dev/fd/' DSERVE_P1_WFD)   :F(DSERVE9)
         INPUT(.DDT_R, 11,, '/dev/fd/' DSERVE_P2_RFD)        :F(DSERVE9)
*
* WAIT FOR MESSAGE FROM NET PROCESS
*
         S = DDT_R
         IDENT(S, 'DDT')                                     :S(DSERVE7)
         DDT_T = 'OPTION ' S ' NOT AVAILABLE'                  :(RETURN)
DSERVE7  DDT_T = NE(DDT_ACTIVE) 'APP ALREADY IN DDT'          :S(RETURN)
         DDT_USE_R = 1
         DSERVE = 'DDT'
         DDT()
                                                               :(RETURN)
*
* CONNECTION LISTENER PROCESS
*
DSERVE2  INPUT(.FROM_PRIMORDIAL, 12,, '/dev/fd/' DSERVE_P1_RFD)
+                                                            :F(DSERVE9)
         OUTPUT(.TO_PRIMORDIAL, 13, 'W', '/dev/fd/' DSERVE_P2_WFD)
+                                                            :F(DSERVE9)
*
DSERVE3  FDN = SERV_LISTEN('inet', 'stream', DSERVE_PORT)    :F(DSERVE9)
         INPUT(.NET, 9, 'UWT', '/dev/fd/' FDN)               :F(DSERVE9)
         OUTPUT(.NET, 9)                                     :F(DSERVE9)
         CRLF = CHARS_CR CHARS_LF
*
         NET = 'DSERVE ' DSERVE_APPNAME CRLF
         NET = CRLF
         NET = 'LOGIN REQUIRED: ' CRLF
         S = NET
         S = REPL(S, CRLF)
         S = TRIMB(S)
*
* LOGIN IS PLAINTEXT. THIS SHOULD ONLY BE USED OVER TELNET RUNNING ON
* THE SAME HOST AS THE APPLICATION BEING DEBUGGED. THERE IS NO USER
* NAME/PASSWORD -- JUST A SINGLE MAGIC WORD.
*
         IDENT(S, DSERVE_KEY)                                :S(DSERVE8)
         NET = 'BAD LOGIN' CRLF                                   :(END)
DSERVE8  NET = 'LOGIN CONFIRM' CRLF
*
* SEND MESSAGE TO PRIMORDIAL.
*
         TO_PRIMORDIAL = 'DDT'
*
* FORK TO TWO COPY LOOPS: PRIMORDIAL -> NET AND NET -> PRIMORDIAL
*
         PID = FORK()
         LT(PID)                                             :S(DSERVE9)
         EQ(PID)                                            :S(DSERVE12)
*
* PRIMORDIAL -> NET COPY PROCESS
*
DSERVE11 S = FROM_PRIMORDIAL                                     :F(END)
         NET = S CRLF                                        :(DSERVE11)
*
* NET -> PRIMORDIAL COPY PROCESS
*
DSERVE12 S = NET                                                 :F(END)
         S = REPL(S, CHARS_CR)
         S = REPL(S, CHARS_LF)
         TO_PRIMORDIAL = S                                   :(DSERVE12)
*
DSERVE9  TERMINAL = 'DSERVE: INTERNAL FAILURE'                    :(END)
*
DSERVE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DSERVE.INC'
         &CODE = 1
         DSERVE_INIT('TEST', 54321, 'magic')
LUP      DSERVE()
         MAJOR = MAJOR + 1
         TERMINAL = 'MAJOR = ' MAJOR
         N = 0
LUP2     N = N + 1
         LT(N, 10000000)                                  :S(LUP2)F(LUP)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL DSERVE
-EJECT
*
************************************************************************
*                                                                      *
*         ######    #####   #######  ######   #     #  #######         *
*         #     #  #     #  #        #     #  #     #  #               *
*         #     #  #        #        #     #  #     #  #               *
*         #     #   #####   #####    ######   #     #  #####           *
*         #     #        #  #        #   #     #   #   #               *
*         #     #  #     #  #        #    #     # #    #               *
*         ######    #####   #######  #     #     #     #######         *
*                                                                      *
* DSERVE                     DDT SERVER                                *
*                                                                      *
************************************************************************
*
* DSERVE.lss
*
<<DSERVE>>
*
* CE: .MSNOBOL4;
@
-LINE 20 "DSERVE.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'P64.INC'
-INCLUDE 'DDT.INC'
-STITL DSERVE
-EJECT
-LINE 153 "DSERVE.lss"
*
************************************************************************
*                                                                      *
*         ######    #####   #######  ######   #     #  #######         *
*         #     #  #     #  #        #     #  #     #  #               *
*         #     #  #        #        #     #  #     #  #               *
*         #     #   #####   #####    ######   #     #  #####           *
*         #     #        #  #        #   #     #   #   #               *
*         #     #  #     #  #        #    #     # #    #               *
*         ######    #####   #######  #     #     #     #######         *
*                                                                      *
* DSERVE                     DDT SERVER                                *
*                                                                      *
************************************************************************
*
* DSERVE.lss
*
-LINE 29 "DSERVE.lss"
-MODULE DSERVE
-PUBLIC DSERVE_INIT(), DSERVE()
-PUBLIC DSERVE_PORT, DSERVE_APPNAME
         DEFINE('DSERVE_INIT(APPNAME,PORT,KEY)')      :(DSERVE_INIT_END)
*
DSERVE_INIT
         DSERVE_KEY = KEY
         DSERVE_PORT = PORT
         DSERVE_APPNAME = APPNAME
*
         LT(CREATEPIPE())                                    :S(DSERVE9)
         DSERVE_P1_RFD = GETPIPEFD(0)
         DSERVE_P1_WFD = GETPIPEFD(1)
         LT(CREATEPIPE())                                    :S(DSERVE9)
         DSERVE_P2_RFD = GETPIPEFD(0)
         DSERVE_P2_WFD = GETPIPEFD(1)
         PID = FORK()                                        :F(DSERVE9)
         LT(PID)                                             :S(DSERVE9)
         EQ(PID)                                             :S(DSERVE2)
*
* PRIMORDIAL PROCESS - POLLS WITH DSERVE() WAITING FOR CONNECTION AND
* DEBUGGER ENTRY
*
         DSERVE_FDS = MALLOC(SIZEOF_FD_SET())
         DSERVE_TV = MALLOC(SIZEOF_TIMEVAL())                  :(RETURN)
*
DSERVE_INIT_END
*
         DEFINE('DSERVE()N,S')                             :(DSERVE_END)
DSERVE   NE(DDT_ACTIVE)                                        :(RETURN)
         SET_TIMEVAL(DSERVE_TV, 0, 0)
         FD_ZERO(DSERVE_FDS)
         FD_SET(DSERVE_P2_RFD, DSERVE_FDS)
         N = SELECT(DSERVE_P2_RFD + 1, DSERVE_FDS, 0, 0, DSERVE_TV)
         EQ(N)                                                :S(RETURN)
*
         OUTPUT(.DDT_T, 10, 'W', '/dev/fd/' DSERVE_P1_WFD)   :F(DSERVE9)
         INPUT(.DDT_R, 11,, '/dev/fd/' DSERVE_P2_RFD)        :F(DSERVE9)
*
* WAIT FOR MESSAGE FROM NET PROCESS
*
         S = DDT_R
         IDENT(S, 'DDT')                                     :S(DSERVE7)
         DDT_T = 'OPTION ' S ' NOT AVAILABLE'                  :(RETURN)
DSERVE7  DDT_T = NE(DDT_ACTIVE) 'APP ALREADY IN DDT'          :S(RETURN)
         DDT_USE_R = 1
         DSERVE = 'DDT'
         DDT()
                                                               :(RETURN)
*
* CONNECTION LISTENER PROCESS
*
DSERVE2  INPUT(.FROM_PRIMORDIAL, 12,, '/dev/fd/' DSERVE_P1_RFD)
+                                                            :F(DSERVE9)
         OUTPUT(.TO_PRIMORDIAL, 13, 'W', '/dev/fd/' DSERVE_P2_WFD)
+                                                            :F(DSERVE9)
*
DSERVE3  FDN = SERV_LISTEN('inet', 'stream', DSERVE_PORT)    :F(DSERVE9)
         INPUT(.NET, 9, 'UWT', '/dev/fd/' FDN)               :F(DSERVE9)
         OUTPUT(.NET, 9)                                     :F(DSERVE9)
         CRLF = CHARS_CR CHARS_LF
*
         NET = 'DSERVE ' DSERVE_APPNAME CRLF
         NET = CRLF
         NET = 'LOGIN REQUIRED: ' CRLF
         S = NET
         S = REPL(S, CRLF)
         S = TRIMB(S)
*
* LOGIN IS PLAINTEXT. THIS SHOULD ONLY BE USED OVER TELNET RUNNING ON
* THE SAME HOST AS THE APPLICATION BEING DEBUGGED. THERE IS NO USER
* NAME/PASSWORD -- JUST A SINGLE MAGIC WORD.
*
         IDENT(S, DSERVE_KEY)                                :S(DSERVE8)
         NET = 'BAD LOGIN' CRLF                                   :(END)
DSERVE8  NET = 'LOGIN CONFIRM' CRLF
*
* SEND MESSAGE TO PRIMORDIAL.
*
         TO_PRIMORDIAL = 'DDT'
*
* FORK TO TWO COPY LOOPS: PRIMORDIAL -> NET AND NET -> PRIMORDIAL
*
         PID = FORK()
         LT(PID)                                             :S(DSERVE9)
         EQ(PID)                                            :S(DSERVE12)
*
* PRIMORDIAL -> NET COPY PROCESS
*
DSERVE11 S = FROM_PRIMORDIAL                                     :F(END)
         NET = S CRLF                                        :(DSERVE11)
*
* NET -> PRIMORDIAL COPY PROCESS
*
DSERVE12 S = NET                                                 :F(END)
         S = REPL(S, CHARS_CR)
         S = REPL(S, CHARS_LF)
         TO_PRIMORDIAL = S                                   :(DSERVE12)
*
DSERVE9  TERMINAL = 'DSERVE: INTERNAL FAILURE'                    :(END)
*
DSERVE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DSERVE - DDT Server</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">DSERVE</font> provides a method to allow debugging applications that
cannot normally be debugged. The application will call <font face="Source Code Pro">DSERVE_INIT()</font>
to initialize. This creates a listener process that waits for telnet
connections. When a connection is made, two processes will shuttle
data between telnet and <font face="Source Code Pro">DDT</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Not very good at cleaning up, but this does work.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="DDT.html">DDT</a><br>
<a href="P64.html">P64</a><br>
<a href="REPL.html">REPL</a><br>
<a href="TRIMB.html">TRIMB</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
-INCLUDE &#39;CSNOBOL4.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
-INCLUDE &#39;P64.INC&#39;
-INCLUDE &#39;DDT.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DSERVE&raquo;&equiv;</b>
-MODULE DSERVE
-PUBLIC DSERVE_INIT(), DSERVE()
-PUBLIC DSERVE_PORT, DSERVE_APPNAME
         DEFINE(&#39;DSERVE_INIT(APPNAME,PORT,KEY)&#39;)      <b>:(DSERVE_INIT_END)</b>
<font color="#818181"><i>*</i></font>
DSERVE_INIT
         DSERVE_KEY = KEY
         DSERVE_PORT = PORT
         DSERVE_APPNAME = APPNAME
<font color="#818181"><i>*</i></font>
         LT(CREATEPIPE())                                    <b>:S(DSERVE9)</b>
         DSERVE_P1_RFD = GETPIPEFD(0)
         DSERVE_P1_WFD = GETPIPEFD(1)
         LT(CREATEPIPE())                                    <b>:S(DSERVE9)</b>
         DSERVE_P2_RFD = GETPIPEFD(0)
         DSERVE_P2_WFD = GETPIPEFD(1)
         PID = FORK()                                        <b>:F(DSERVE9)</b>
         LT(PID)                                             <b>:S(DSERVE9)</b>
         EQ(PID)                                             <b>:S(DSERVE2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PRIMORDIAL PROCESS - POLLS WITH DSERVE() WAITING FOR CONNECTION AND</i></font>
<font color="#818181"><i>* DEBUGGER ENTRY</i></font>
<font color="#818181"><i>*</i></font>
         DSERVE_FDS = MALLOC(SIZEOF_FD_SET())
         DSERVE_TV = MALLOC(SIZEOF_TIMEVAL())                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DSERVE_INIT_END
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;DSERVE()N,S&#39;)                             <b>:(DSERVE_END)</b>
DSERVE   NE(DDT_ACTIVE)                                        <b>:(RETURN)</b>
         SET_TIMEVAL(DSERVE_TV, 0, 0)
         FD_ZERO(DSERVE_FDS)
         FD_SET(DSERVE_P2_RFD, DSERVE_FDS)
         N = SELECT(DSERVE_P2_RFD + 1, DSERVE_FDS, 0, 0, DSERVE_TV)
         EQ(N)                                                <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
         OUTPUT(.DDT_T, 10, &#39;W&#39;, &#39;/dev/fd/&#39; DSERVE_P1_WFD)   <b>:F(DSERVE9)</b>
         INPUT(.DDT_R, 11,, &#39;/dev/fd/&#39; DSERVE_P2_RFD)        <b>:F(DSERVE9)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WAIT FOR MESSAGE FROM NET PROCESS</i></font>
<font color="#818181"><i>*</i></font>
         S = DDT_R
         IDENT(S, &#39;DDT&#39;)                                     <b>:S(DSERVE7)</b>
         DDT_T = &#39;OPTION &#39; S &#39; NOT AVAILABLE&#39;                  <b>:(RETURN)</b>
DSERVE7  DDT_T = NE(DDT_ACTIVE) &#39;APP ALREADY IN DDT&#39;          <b>:S(RETURN)</b>
         DDT_USE_R = 1
         DSERVE = &#39;DDT&#39;
         DDT()
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONNECTION LISTENER PROCESS</i></font>
<font color="#818181"><i>*</i></font>
DSERVE2  INPUT(.FROM_PRIMORDIAL, 12,, &#39;/dev/fd/&#39; DSERVE_P1_RFD)
+                                                            <b>:F(DSERVE9)</b>
         OUTPUT(.TO_PRIMORDIAL, 13, &#39;W&#39;, &#39;/dev/fd/&#39; DSERVE_P2_WFD)
+                                                            <b>:F(DSERVE9)</b>
<font color="#818181"><i>*</i></font>
DSERVE3  FDN = SERV_LISTEN(&#39;inet&#39;, &#39;stream&#39;, DSERVE_PORT)    <b>:F(DSERVE9)</b>
         INPUT(.NET, 9, &#39;UWT&#39;, &#39;/dev/fd/&#39; FDN)               <b>:F(DSERVE9)</b>
         OUTPUT(.NET, 9)                                     <b>:F(DSERVE9)</b>
         CRLF = CHARS_CR CHARS_LF
<font color="#818181"><i>*</i></font>
         NET = &#39;DSERVE &#39; DSERVE_APPNAME CRLF
         NET = CRLF
         NET = &#39;LOGIN REQUIRED: &#39; CRLF
         S = NET
         S = REPL(S, CRLF)
         S = TRIMB(S)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOGIN IS PLAINTEXT. THIS SHOULD ONLY BE USED OVER TELNET RUNNING ON</i></font>
<font color="#818181"><i>* THE SAME HOST AS THE APPLICATION BEING DEBUGGED. THERE IS NO USER</i></font>
<font color="#818181"><i>* NAME/PASSWORD -- JUST A SINGLE MAGIC WORD.</i></font>
<font color="#818181"><i>*</i></font>
         IDENT(S, DSERVE_KEY)                                <b>:S(DSERVE8)</b>
         NET = &#39;BAD LOGIN&#39; CRLF                                   <b>:(END)</b>
DSERVE8  NET = &#39;LOGIN CONFIRM&#39; CRLF
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SEND MESSAGE TO PRIMORDIAL.</i></font>
<font color="#818181"><i>*</i></font>
         TO_PRIMORDIAL = &#39;DDT&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FORK TO TWO COPY LOOPS: PRIMORDIAL -&gt; NET AND NET -&gt; PRIMORDIAL</i></font>
<font color="#818181"><i>*</i></font>
         PID = FORK()
         LT(PID)                                             <b>:S(DSERVE9)</b>
         EQ(PID)                                            <b>:S(DSERVE12)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PRIMORDIAL -&gt; NET COPY PROCESS</i></font>
<font color="#818181"><i>*</i></font>
DSERVE11 S = FROM_PRIMORDIAL                                     <b>:F(END)</b>
         NET = S CRLF                                        <b>:(DSERVE11)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NET -&gt; PRIMORDIAL COPY PROCESS</i></font>
<font color="#818181"><i>*</i></font>
DSERVE12 S = NET                                                 <b>:F(END)</b>
         S = REPL(S, CHARS_CR)
         S = REPL(S, CHARS_LF)
         TO_PRIMORDIAL = S                                   <b>:(DSERVE12)</b>
<font color="#818181"><i>*</i></font>
DSERVE9  TERMINAL = &#39;DSERVE: INTERNAL FAILURE&#39;                    <b>:(END)</b>
<font color="#818181"><i>*</i></font>
DSERVE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DSERVE.INC&#39;
         &amp;CODE = 1
         DSERVE_INIT(&#39;TEST&#39;, 54321, &#39;magic&#39;)
LUP      DSERVE()
         MAJOR = MAJOR + 1
         TERMINAL = &#39;MAJOR = &#39; MAJOR
         N = 0
LUP2     N = N + 1
         LT(N, 10000000)                                  <b>:S(LUP2)F(LUP)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL DSERVE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         ######    #####   #######  ######   #     #  #######         *</i></font>
<font color="#818181"><i>*         #     #  #     #  #        #     #  #     #  #               *</i></font>
<font color="#818181"><i>*         #     #  #        #        #     #  #     #  #               *</i></font>
<font color="#818181"><i>*         #     #   #####   #####    ######   #     #  #####           *</i></font>
<font color="#818181"><i>*         #     #        #  #        #   #     #   #   #               *</i></font>
<font color="#818181"><i>*         #     #  #     #  #        #    #     # #    #               *</i></font>
<font color="#818181"><i>*         ######    #####   #######  #     #     #     #######         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DSERVE                     DDT SERVER                                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DSERVE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DSERVE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:45 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DSERVE.INC'
-LINE 137 "DSERVE.lss"
         &CODE = 1
         DSERVE_INIT('TEST', 54321, 'magic')
LUP      DSERVE()
         MAJOR = MAJOR + 1
         TERMINAL = 'MAJOR = ' MAJOR
         N = 0
LUP2     N = N + 1
         LT(N, 10000000)                                  :S(LUP2)F(LUP)
         &CODE = 0
END
<h1>DYNAMIC - Create Dynamic Modules for CSNOBOL4</h1>

Create dynamic modules for [[CSNOBOL4]].

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="HOST.html">HOST</a><br>
<a href="REPL.html">REPL</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'REPL.INC'
@

<<DYNAMIC>>=
-MODULE DYNAMIC
-PUBLIC COMPILE_COBOL(), COMPILE_FORTRAN(), COMPILE_SCHEME()
-PUBLIC COMPILE_DYNAMIC(), LIBS_FORTRAN(), LIBS_COBOL(), LIBS_SCHEME()
DYNAMIC  DEFINE('COMPILE_COBOL(SRC)CMD,COBC')
         DEFINE('COMPILE_FORTRAN(SRC)CMD')
         DEFINE('COMPILE_SCHEME(SRC)CMD,CC,DL_CFLAGS,COPT')
         DEFINE('COMPILE_DYNAMIC(SRC)CMD,CC,DL_CFLAGS,COPT,CINC')
         DEFINE('LIBS_FORTRAN()')
         DEFINE('LIBS_COBOL()')
         DEFINE('LIBS_SCHEME()')                  :(COMPILE_DYNAMIC_END)
*
@

Return libraries needed for [[FORTRAN]] subprograms.

<<DYNAMIC>>=
LIBS_FORTRAN
         LIBS_FORTRAN = '-lgfortran'                           :(RETURN)
*
@

Return libraries needed for [[COBOL]] subprograms. Use [[cob-config]]
to provide the information needed.

<<DYNAMIC>>=
LIBS_COBOL
         LIBS_COBOL = BQ('cob-config --libs')                  :(RETURN)
*
@

Return libraries needed for [[SCHEME]] subprograms.

<<DYNAMIC>>=
LIBS_SCHEME
         LIBS_SCHEME = 'prog_.o -lgambc -ldl -lm -lutil'       :(RETURN)
@

Compile [[COBOL]] source to [[.o]], prior to building [[.so]] shared
object.  Uses [[cobc]] to compile [[COBOL]] to [[C]], and then [[gcc]]
to compile [[C]] to [[object]].

<<DYNAMIC>>=
*
* DYNAMIC COMPILE COBOL SOURCE
*
COMPILE_COBOL
         CMD = 'cobc -C ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         COBC = BQ('cob-config --cflags')
         SRC '.cbl' =
         SRC '.CBL' = 
         CC = HOST(HOST_CC)                                  :F(FRETURN)
         IDENT(CC)                                           :S(FRETURN)
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
         COPT = HOST(HOST_COPT) ' '
         CMD = CC ' -c ' COPT DL_CFLAGS ' -DPIC -O3 ' COBC ' ' SRC '.c'
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         DELETE(SRC '.c')
         DELETE(SRC '.c.h')
         DELETE(SRC '.c.l.h')                                  :(RETURN)
@

Compile [[FORTRAN]] source to [[.o]], prior to building [[.so]]
shared object. Uses [[gfortran]] as the compiler. [[-ff2c]] and
[[-std=legacy]] used to control parameter passing, and some details
of the compilation. I am mostly interested in running older code using
[[FORTRAN 77]] or earlier standards.

<<DYNAMIC>>=
*
* DYNAMIC COMPILE FORTRAN SOURCE
*
COMPILE_FORTRAN
         CMD = 'gfortran -c -fpic -O3 -ff2c -std=legacy ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
*
@

Only compile in a single [[SCHEME]] module. In turn, that can load
other files as needed. The issue is the link file that is needed
(second invocation of [[gsc]] -- yes, it should be factored out).

<<DYNAMIC>>=
COMPILE_SCHEME
         CMD = 'gsc -c ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
         SRC '.scm' = '.c'
         SRC '.six' = '.c'
         CMD = 'gsc -link -o prog_.c ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         CC = HOST(HOST_CC)                                  :F(FRETURN)
         IDENT(CC)                                           :S(FRETURN)
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
         COPT = HOST(HOST_COPT) ' '
         CMD = CC ' -c -D___LIBRARY ' COPT DL_CFLAGS ' ' SRC ' prog_.c'
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         DELETE(SRC)
         DELETE('prog_.c')                                     :(RETURN)
@

Compile [[C]] source to object. Uses the same compiler used for
building [[CSNOBOL4]] itself.

<<DYNAMIC>>=
*
* DYNAMIC COMPILE C SOURCE
*
COMPILE_DYNAMIC
         CC = HOST(HOST_CC)                                  :F(FRETURN)
         IDENT(CC)                                           :S(FRETURN)
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
         COPT = HOST(HOST_COPT) ' '
         CINC = HOST(HOST_SNOLIB_DIR)
         CINC = HOST(HOST_INCLUDE_DIR)
         CMD = CC ' -c ' COPT DL_CFLAGS ' -I' CINC ' ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
*
COMPILE_DYNAMIC_END
*
-PUBLIC LINK_DYNAMIC()
         DEFINE('LINK_DYNAMIC(OUT,OBJ,LIBS)'
+               'CMD,DL_LD,DL_EXT,DL_LDFLAGS,DSEP')  :(LINK_DYNAMIC_END)
*
LINK_DYNAMIC
         DL_LD = HOST(HOST_DL_LD)                            :F(FRETURN)
         IDENT(DL_LD)                                        :S(FRETURN)
         DL_EXT = HOST(HOST_DL_EXT)
         OUT = DIFFER(DL_EXT) OUT DL_EXT
         DL_LDFLAGS = HOST(HOST_DL_LDFLAGS) ' '
         CMD = DL_LD ' ' DL_LDFLAGS '-o ' OUT ' ' OBJ ' ' LIBS
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
         LINK_DYNAMIC = OUT
         DSEP = HOST(HOST_DIR_SEP)
         LINK_DYNAMIC BREAK(DSEP) DSEP                        :S(RETURN)
         LINK_DYNAMIC = '.' DSEP LINK_DYNAMIC                  :(RETURN)
LINK_DYNAMIC_END
*
* MAKE A DYNAMIC MODULE, GIVEN C SOURCES
* LIBS MAY CONTAIN BOTH OBJECTS AND LIBRARIES
*
-PUBLIC MAKE_DYNAMIC_MODULE()
         DEFINE('MAKE_DYNAMIC_MODULE(OUT,SRC,LIBS)OBJ')
                                              :(MAKE_DYNAMIC_MODULE_END)
MAKE_DYNAMIC_MODULE
         IDENT(SRC)                                         :S(MDM_LINK)
         COMPILE_DYNAMIC(SRC)                                :F(FRETURN)
         OBJ = REPL(SRC, '.o', '.c')
MDM_LINK IDENT(OBJ LIBS)                                     :S(FRETURN)
         MAKE_DYNAMIC_MODULE = LINK_DYNAMIC(OUT, OBJ, LIBS)  :F(FRETURN)
                                                               :(RETURN)
MAKE_DYNAMIC_MODULE_END
*
DYNAMIC_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DYNAMIC.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL DYNAMIC
-EJECT
*
************************************************************************
*                                                                      *
*    ######   #     #  #     #     #     #     #  ###   #####          *
*    #     #   #   #   ##    #    # #    ##   ##   #   #     #         *
*    #     #    # #    # #   #   #   #   # # # #   #   #               *
*    #     #     #     #  #  #  #     #  #  #  #   #   #               *
*    #     #     #     #   # #  #######  #     #   #   #               *
*    #     #     #     #    ##  #     #  #     #   #   #     #         *
*    ######      #     #     #  #     #  #     #  ###   #####          *
*                                                                      *
* DYNAMIC       CREATE DYNAMICALLY LOADABLE MODULE FOR LOAD()          *
*                                                                      *
* PHIL BUDNE, NOVEMBER 2005                                            *
*                                                                      *
************************************************************************
*
* DYNAMIC.lss
*
<<DYNAMIC>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "DYNAMIC.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'REPL.INC'
-STITL DYNAMIC
-EJECT
-LINE 197 "DYNAMIC.lss"
*
************************************************************************
*                                                                      *
*    ######   #     #  #     #     #     #     #  ###   #####          *
*    #     #   #   #   ##    #    # #    ##   ##   #   #     #         *
*    #     #    # #    # #   #   #   #   # # # #   #   #               *
*    #     #     #     #  #  #  #     #  #  #  #   #   #               *
*    #     #     #     #   # #  #######  #     #   #   #               *
*    #     #     #     #    ##  #     #  #     #   #   #     #         *
*    ######      #     #     #  #     #  #     #  ###   #####          *
*                                                                      *
* DYNAMIC       CREATE DYNAMICALLY LOADABLE MODULE FOR LOAD()          *
*                                                                      *
* PHIL BUDNE, NOVEMBER 2005                                            *
*                                                                      *
************************************************************************
*
* DYNAMIC.lss
*
-LINE 17 "DYNAMIC.lss"
-MODULE DYNAMIC
-PUBLIC COMPILE_COBOL(), COMPILE_FORTRAN(), COMPILE_SCHEME()
-PUBLIC COMPILE_DYNAMIC(), LIBS_FORTRAN(), LIBS_COBOL(), LIBS_SCHEME()
DYNAMIC  DEFINE('COMPILE_COBOL(SRC)CMD,COBC')
         DEFINE('COMPILE_FORTRAN(SRC)CMD')
         DEFINE('COMPILE_SCHEME(SRC)CMD,CC,DL_CFLAGS,COPT')
         DEFINE('COMPILE_DYNAMIC(SRC)CMD,CC,DL_CFLAGS,COPT,CINC')
         DEFINE('LIBS_FORTRAN()')
         DEFINE('LIBS_COBOL()')
         DEFINE('LIBS_SCHEME()')                  :(COMPILE_DYNAMIC_END)
*
-LINE 33 "DYNAMIC.lss"
LIBS_FORTRAN
         LIBS_FORTRAN = '-lgfortran'                           :(RETURN)
*
-LINE 42 "DYNAMIC.lss"
LIBS_COBOL
         LIBS_COBOL = BQ('cob-config --libs')                  :(RETURN)
*
-LINE 50 "DYNAMIC.lss"
LIBS_SCHEME
         LIBS_SCHEME = 'prog_.o -lgambc -ldl -lm -lutil'       :(RETURN)
-LINE 59 "DYNAMIC.lss"
*
* DYNAMIC COMPILE COBOL SOURCE
*
COMPILE_COBOL
         CMD = 'cobc -C ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         COBC = BQ('cob-config --cflags')
         SRC '.cbl' =
         SRC '.CBL' =
         CC = HOST(HOST_CC)                                  :F(FRETURN)
         IDENT(CC)                                           :S(FRETURN)
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
         COPT = HOST(HOST_COPT) ' '
         CMD = CC ' -c ' COPT DL_CFLAGS ' -DPIC -O3 ' COBC ' ' SRC '.c'
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         DELETE(SRC '.c')
         DELETE(SRC '.c.h')
         DELETE(SRC '.c.l.h')                                  :(RETURN)
-LINE 90 "DYNAMIC.lss"
*
* DYNAMIC COMPILE FORTRAN SOURCE
*
COMPILE_FORTRAN
         CMD = 'gfortran -c -fpic -O3 -ff2c -std=legacy ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
*
-LINE 105 "DYNAMIC.lss"
COMPILE_SCHEME
         CMD = 'gsc -c ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
         SRC '.scm' = '.c'
         SRC '.six' = '.c'
         CMD = 'gsc -link -o prog_.c ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         CC = HOST(HOST_CC)                                  :F(FRETURN)
         IDENT(CC)                                           :S(FRETURN)
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
         COPT = HOST(HOST_COPT) ' '
         CMD = CC ' -c -D___LIBRARY ' COPT DL_CFLAGS ' ' SRC ' prog_.c'
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
*
         DELETE(SRC)
         DELETE('prog_.c')                                     :(RETURN)
-LINE 131 "DYNAMIC.lss"
*
* DYNAMIC COMPILE C SOURCE
*
COMPILE_DYNAMIC
         CC = HOST(HOST_CC)                                  :F(FRETURN)
         IDENT(CC)                                           :S(FRETURN)
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) ' '
         COPT = HOST(HOST_COPT) ' '
         CINC = HOST(HOST_SNOLIB_DIR)
         CINC = HOST(HOST_INCLUDE_DIR)
         CMD = CC ' -c ' COPT DL_CFLAGS ' -I' CINC ' ' SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                     :F(FRETURN)S(RETURN)
*
COMPILE_DYNAMIC_END
*
-PUBLIC LINK_DYNAMIC()
         DEFINE('LINK_DYNAMIC(OUT,OBJ,LIBS)'
+               'CMD,DL_LD,DL_EXT,DL_LDFLAGS,DSEP')  :(LINK_DYNAMIC_END)
*
LINK_DYNAMIC
         DL_LD = HOST(HOST_DL_LD)                            :F(FRETURN)
         IDENT(DL_LD)                                        :S(FRETURN)
         DL_EXT = HOST(HOST_DL_EXT)
         OUT = DIFFER(DL_EXT) OUT DL_EXT
         DL_LDFLAGS = HOST(HOST_DL_LDFLAGS) ' '
         CMD = DL_LD ' ' DL_LDFLAGS '-o ' OUT ' ' OBJ ' ' LIBS
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              :F(FRETURN)
         LINK_DYNAMIC = OUT
         DSEP = HOST(HOST_DIR_SEP)
         LINK_DYNAMIC BREAK(DSEP) DSEP                        :S(RETURN)
         LINK_DYNAMIC = '.' DSEP LINK_DYNAMIC                  :(RETURN)
LINK_DYNAMIC_END
*
* MAKE A DYNAMIC MODULE, GIVEN C SOURCES
* LIBS MAY CONTAIN BOTH OBJECTS AND LIBRARIES
*
-PUBLIC MAKE_DYNAMIC_MODULE()
         DEFINE('MAKE_DYNAMIC_MODULE(OUT,SRC,LIBS)OBJ')
                                              :(MAKE_DYNAMIC_MODULE_END)
MAKE_DYNAMIC_MODULE
         IDENT(SRC)                                         :S(MDM_LINK)
         COMPILE_DYNAMIC(SRC)                                :F(FRETURN)
         OBJ = REPL(SRC, '.o', '.c')
MDM_LINK IDENT(OBJ LIBS)                                     :S(FRETURN)
         MAKE_DYNAMIC_MODULE = LINK_DYNAMIC(OUT, OBJ, LIBS)  :F(FRETURN)
                                                               :(RETURN)
MAKE_DYNAMIC_MODULE_END
*
DYNAMIC_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>DYNAMIC - Create Dynamic Modules for CSNOBOL4</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Create dynamic modules for <font face="Source Code Pro">CSNOBOL4</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="HOST.html">HOST</a><br>
<a href="REPL.html">REPL</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
-MODULE DYNAMIC
-PUBLIC COMPILE_COBOL(), COMPILE_FORTRAN(), COMPILE_SCHEME()
-PUBLIC COMPILE_DYNAMIC(), LIBS_FORTRAN(), LIBS_COBOL(), LIBS_SCHEME()
DYNAMIC  DEFINE(&#39;COMPILE_COBOL(SRC)CMD,COBC&#39;)
         DEFINE(&#39;COMPILE_FORTRAN(SRC)CMD&#39;)
         DEFINE(&#39;COMPILE_SCHEME(SRC)CMD,CC,DL_CFLAGS,COPT&#39;)
         DEFINE(&#39;COMPILE_DYNAMIC(SRC)CMD,CC,DL_CFLAGS,COPT,CINC&#39;)
         DEFINE(&#39;LIBS_FORTRAN()&#39;)
         DEFINE(&#39;LIBS_COBOL()&#39;)
         DEFINE(&#39;LIBS_SCHEME()&#39;)                  <b>:(COMPILE_DYNAMIC_END)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Return libraries needed for <font face="Source Code Pro">FORTRAN</font> subprograms.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
LIBS_FORTRAN
         LIBS_FORTRAN = &#39;-lgfortran&#39;                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Return libraries needed for <font face="Source Code Pro">COBOL</font> subprograms. Use <font face="Source Code Pro">cob-config</font>
to provide the information needed.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
LIBS_COBOL
         LIBS_COBOL = BQ(&#39;cob-config --libs&#39;)                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Return libraries needed for <font face="Source Code Pro">SCHEME</font> subprograms.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
LIBS_SCHEME
         LIBS_SCHEME = &#39;prog_.o -lgambc -ldl -lm -lutil&#39;       <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Compile <font face="Source Code Pro">COBOL</font> source to <font face="Source Code Pro">.o</font>, prior to building <font face="Source Code Pro">.so</font> shared
object.  Uses <font face="Source Code Pro">cobc</font> to compile <font face="Source Code Pro">COBOL</font> to <font face="Source Code Pro">C</font>, and then <font face="Source Code Pro">gcc</font>
to compile <font face="Source Code Pro">C</font> to <font face="Source Code Pro">object</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DYNAMIC COMPILE COBOL SOURCE</i></font>
<font color="#818181"><i>*</i></font>
COMPILE_COBOL
         CMD = &#39;cobc -C &#39; SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         COBC = BQ(&#39;cob-config --cflags&#39;)
         SRC &#39;.cbl&#39; =
         SRC &#39;.CBL&#39; =
         CC = HOST(HOST_CC)                                  <b>:F(FRETURN)</b>
         IDENT(CC)                                           <b>:S(FRETURN)</b>
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) &#39; &#39;
         COPT = HOST(HOST_COPT) &#39; &#39;
         CMD = CC &#39; -c &#39; COPT DL_CFLAGS &#39; -DPIC -O3 &#39; COBC &#39; &#39; SRC &#39;.c&#39;
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         DELETE(SRC &#39;.c&#39;)
         DELETE(SRC &#39;.c.h&#39;)
         DELETE(SRC &#39;.c.l.h&#39;)                                  <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Compile <font face="Source Code Pro">FORTRAN</font> source to <font face="Source Code Pro">.o</font>, prior to building <font face="Source Code Pro">.so</font>
shared object. Uses <font face="Source Code Pro">gfortran</font> as the compiler. <font face="Source Code Pro">-ff2c</font> and
<font face="Source Code Pro">-std=legacy</font> used to control parameter passing, and some details
of the compilation. I am mostly interested in running older code using
<font face="Source Code Pro">FORTRAN 77</font> or earlier standards.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DYNAMIC COMPILE FORTRAN SOURCE</i></font>
<font color="#818181"><i>*</i></font>
COMPILE_FORTRAN
         CMD = &#39;gfortran -c -fpic -O3 -ff2c -std=legacy &#39; SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                     <b>:F(FRETURN)S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Only compile in a single <font face="Source Code Pro">SCHEME</font> module. In turn, that can load
other files as needed. The issue is the link file that is needed
(second invocation of <font face="Source Code Pro">gsc</font> -- yes, it should be factored out).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
COMPILE_SCHEME
         CMD = &#39;gsc -c &#39; SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              <b>:F(FRETURN)</b>
         SRC &#39;.scm&#39; = &#39;.c&#39;
         SRC &#39;.six&#39; = &#39;.c&#39;
         CMD = &#39;gsc -link -o prog_.c &#39; SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         CC = HOST(HOST_CC)                                  <b>:F(FRETURN)</b>
         IDENT(CC)                                           <b>:S(FRETURN)</b>
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) &#39; &#39;
         COPT = HOST(HOST_COPT) &#39; &#39;
         CMD = CC &#39; -c -D___LIBRARY &#39; COPT DL_CFLAGS &#39; &#39; SRC &#39; prog_.c&#39;
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         DELETE(SRC)
         DELETE(&#39;prog_.c&#39;)                                     <b>:(RETURN)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Compile <font face="Source Code Pro">C</font> source to object. Uses the same compiler used for
building <font face="Source Code Pro">CSNOBOL4</font> itself.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;DYNAMIC&raquo;&equiv;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DYNAMIC COMPILE C SOURCE</i></font>
<font color="#818181"><i>*</i></font>
COMPILE_DYNAMIC
         CC = HOST(HOST_CC)                                  <b>:F(FRETURN)</b>
         IDENT(CC)                                           <b>:S(FRETURN)</b>
         DL_CFLAGS = HOST(HOST_DL_CFLAGS) &#39; &#39;
         COPT = HOST(HOST_COPT) &#39; &#39;
         CINC = HOST(HOST_SNOLIB_DIR)
         CINC = HOST(HOST_INCLUDE_DIR)
         CMD = CC &#39; -c &#39; COPT DL_CFLAGS &#39; -I&#39; CINC &#39; &#39; SRC
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                     <b>:F(FRETURN)S(RETURN)</b>
<font color="#818181"><i>*</i></font>
COMPILE_DYNAMIC_END
<font color="#818181"><i>*</i></font>
-PUBLIC LINK_DYNAMIC()
         DEFINE(&#39;LINK_DYNAMIC(OUT,OBJ,LIBS)&#39;
+               &#39;CMD,DL_LD,DL_EXT,DL_LDFLAGS,DSEP&#39;)  <b>:(LINK_DYNAMIC_END)</b>
<font color="#818181"><i>*</i></font>
LINK_DYNAMIC
         DL_LD = HOST(HOST_DL_LD)                            <b>:F(FRETURN)</b>
         IDENT(DL_LD)                                        <b>:S(FRETURN)</b>
         DL_EXT = HOST(HOST_DL_EXT)
         OUT = DIFFER(DL_EXT) OUT DL_EXT
         DL_LDFLAGS = HOST(HOST_DL_LDFLAGS) &#39; &#39;
         CMD = DL_LD &#39; &#39; DL_LDFLAGS &#39;-o &#39; OUT &#39; &#39; OBJ &#39; &#39; LIBS
         TERMINAL = DIFFER(DYNAMIC_DEBUG) CMD
         HOST(HOST_SYSCMD, CMD)                              <b>:F(FRETURN)</b>
         LINK_DYNAMIC = OUT
         DSEP = HOST(HOST_DIR_SEP)
         LINK_DYNAMIC BREAK(DSEP) DSEP                        <b>:S(RETURN)</b>
         LINK_DYNAMIC = &#39;.&#39; DSEP LINK_DYNAMIC                  <b>:(RETURN)</b>
LINK_DYNAMIC_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAKE A DYNAMIC MODULE, GIVEN C SOURCES</i></font>
<font color="#818181"><i>* LIBS MAY CONTAIN BOTH OBJECTS AND LIBRARIES</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC MAKE_DYNAMIC_MODULE()
         DEFINE(&#39;MAKE_DYNAMIC_MODULE(OUT,SRC,LIBS)OBJ&#39;)
                                              <b>:(MAKE_DYNAMIC_MODULE_END)</b>
MAKE_DYNAMIC_MODULE
         IDENT(SRC)                                         <b>:S(MDM_LINK)</b>
         COMPILE_DYNAMIC(SRC)                                <b>:F(FRETURN)</b>
         OBJ = REPL(SRC, &#39;.o&#39;, &#39;.c&#39;)
MDM_LINK IDENT(OBJ LIBS)                                     <b>:S(FRETURN)</b>
         MAKE_DYNAMIC_MODULE = LINK_DYNAMIC(OUT, OBJ, LIBS)  <b>:F(FRETURN)</b>
                                                               <b>:(RETURN)</b>
MAKE_DYNAMIC_MODULE_END
<font color="#818181"><i>*</i></font>
DYNAMIC_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DYNAMIC.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL DYNAMIC
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    ######   #     #  #     #     #     #     #  ###   #####          *</i></font>
<font color="#818181"><i>*    #     #   #   #   ##    #    # #    ##   ##   #   #     #         *</i></font>
<font color="#818181"><i>*    #     #    # #    # #   #   #   #   # # # #   #   #               *</i></font>
<font color="#818181"><i>*    #     #     #     #  #  #  #     #  #  #  #   #   #               *</i></font>
<font color="#818181"><i>*    #     #     #     #   # #  #######  #     #   #   #               *</i></font>
<font color="#818181"><i>*    #     #     #     #    ##  #     #  #     #   #   #     #         *</i></font>
<font color="#818181"><i>*    ######      #     #     #  #     #  #     #  ###   #####          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* DYNAMIC       CREATE DYNAMICALLY LOADABLE MODULE FOR LOAD()          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE, NOVEMBER 2005                                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DYNAMIC.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;DYNAMIC&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:59 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'DYNAMIC.INC'
-LINE 188 "DYNAMIC.lss"
         &CODE = 1
         &CODE = 0
END
<h1>embed</h1>

The EMBED utility is used to preprocess snobol code that requires
inline data, or that contains embedded C or FORTRAN code.  It may
also have utility as a CGI (WEB) tool.

Adds some control cards to SNOBOL4. These are handled by [[EMBED]],
and are not passed through. All other control cards are simply
copied through:

[[
-SNOBOL SNOBOL_CODE
-EMBED C|FORTRAN|COBOL|SCHEME|DATA|FILE 'VNAME'
-END
-SNOBOLX SNOBOL_CODE
-CMNT COMMENT
]]

[[EMBED]] copies its source file, until it sees one of its controls.
[[-SNOBOL]] immediately executes its code (use [[+]] at the end of
lines to continue them). [[-SNOBOLX]] is the same, but also copies
its code to the output (allowing consistent definitions at both
times). [[-EMBED]] to [[-END]] is extracted and copied into a file,
whose name is made available to the program as [[VNAME]].

See [[P64.lss]] for an example. [[P64.lss]] is processed by
[[stangle]] into [[P64.SNO]], which is then processed by [[EMBED]]
to produce [[p64.so]], and [[P64.INC]] which is the associated INCLUDE
file. [[EMBED]] extracts the embedded [[C]] code, generating wrappers
using the [[WRAPPER]] function. and then runs the [[C]] compiler
using the [[DYNAMIC]] function to compile and produce the shared
object needed when the [[P64]] library function is used.

In effect, the building of the code is controlled by the SNOBOL4 source
itself, and the entire module is self contained. Neither [[WRAPPER]]
nor [[DYNAMIC]] need be present at run time but are only used
when the [[P64]] module itself is updated.

I am sure that other uses for [[EMBED]] will occur to the reader.
Embedding unit test cases; creation of run-time data files;
implementation of domain specific languages and more. The idea of
[[EMBED]] is to provide an approximate equivalent to LISP macros
to SNOBOL4.

Note that [[SLOAD]] is included to allow the extension of [[embed]]
driven by its using programs.

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="SLOAD.html">SLOAD</a><br>

<h2>See Also</h2>
<a href="WRAPPER.html">WRAPPER</a><br>
<a href="DYNAMIC.html">DYNAMIC</a><br>
<a href="P64.html">P64</a>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'SLOAD.INC'
@

<<embed>>=
-USES SLOAD()
         TERMINAL = 'EMBED (SUN DEC  1 16:15:39 EST 2013)'
*
         WHITE_ = SPAN(' ' CHARS_TAB) | ''
         Q_ = "'"
         QQ_ = '"'
         LEAD = DUPL(' ', 9)
*
TOP      LINE = INPUT                                            :F(END)
*
         LINE FENCE '-' ('snobol' | 'SNOBOL') (ANY('xX') | '') WHITE_
+            REM . S                                        :F(TRYEMBED)
TRYX1    REVERSE(TRIM(S)) FENCE '+' REM . X                    :F(TRYX2)
         S = REVERSE(X) ' ' INPUT                               :(TRYX1)
TRYX2    CODE = CODE(' ' S ' :(TOP)')                           :S<CODE>
         TERMINAL = 'EMBED: -SNOBOL CODE BAD: ' S                 :(END)
*
TRYEMBED LINE FENCE '-' ('embed' | 'EMBED') WHITE_ ARB . TYPE
+            WHITE_ (Q_ | QQ_) $ DELIM ARB . VNAME *DELIM     :S(STARTC)
         LINE FENCE '-' ('cmnt' | 'CMNT')                        :S(TOP)
         OUTPUT = LINE                                            :(TOP)
STARTC   FNAME = VNAME
         FNAME = ?(TYPE ? 'c' | 'C') FNAME '.c'
         FNAME = ?(TYPE ? 'fortran' | 'FORTRAN') FNAME '.FTN'
         FNAME = ?(TYPE ? 'cobol' | 'COBOL') FNAME '.CBL'
         FNAME = ?(TYPE ? 'scheme' | 'SCHEME') FNAME '.SCM'
         FNAME = ?(TYPE ? 'data' | 'DATA') FNAME '.DAT'
         OUTPUT = LEAD VNAME ' = ' Q_ FNAME Q_
         $VNAME = FNAME
         OUTPUT(.EMBED, 10,, FNAME)
*
COPYL    LINE = INPUT                                            :F(END)
         OFLAG =
         LINE FENCE '-' ('cmnt' | 'CMNT')                      :S(COPYL)
         LINE FENCE '-' ('end' | 'END')                       :S(COPYL3)
         LINE FENCE '-' ('snobol' | 'SNOBOL')
+            ((ANY('xX') *?(OFLAG = 1)) | '')
+            WHITE_ REM . SNC                                 :F(COPYL2)
*
DOMORE   REVERSE(TRIM(SNC)) FENCE '+' REM . X                :F(EXECSNC)
         SNC = REVERSE(X) ' ' INPUT                            :(DOMORE)
*
EXECSNC  OUTPUT = DIFFER(OFLAG) LEAD SNC
         CODE = CODE(' ' SNC ' :(COPYL)')                       :S<CODE>
         &CODE = 1
         TERMINAL = 'EMBED: -SNOBOL(X) CODE BAD: ' SNC            :(END)
COPYL2   EMBED = LINE                                           :(COPYL)
COPYL3   DETACH(.EMBED)
         ENDFILE(10)                                              :(TOP)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM EMBED
-TITLE EMBED
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*             #######  #     #  ######   #######  ######               *
*             #        ##   ##  #     #  #        #     #              *
*             #        # # # #  #     #  #        #     #              *
*             #####    #  #  #  ######   #####    #     #              *
*             #        #     #  #     #  #        #     #              *
*             #        #     #  #     #  #        #     #              *
*             #######  #     #  ######   #######  ######               *
*                                                                      *
* EMBED                    EMBEDDED SNOBOL CODE                        *
*                                                                      *
************************************************************************
*
* embed.lss
*
<<embed>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM EMBED
-LINE 120 "embed.lss"
-TITLE EMBED
START
-LINE 58 "embed.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'SLOAD.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*             #######  #     #  ######   #######  ######               *
*             #        ##   ##  #     #  #        #     #              *
*             #        # # # #  #     #  #        #     #              *
*             #####    #  #  #  ######   #####    #     #              *
*             #        #     #  #     #  #        #     #              *
*             #        #     #  #     #  #        #     #              *
*             #######  #     #  ######   #######  ######               *
*                                                                      *
* EMBED                    EMBEDDED SNOBOL CODE                        *
*                                                                      *
************************************************************************
*
* embed.lss
*
-LINE 63 "embed.lss"
-USES SLOAD()
         TERMINAL = 'EMBED (SUN DEC  1 16:15:39 EST 2013)'
*
         WHITE_ = SPAN(' ' CHARS_TAB) | ''
         Q_ = "'"
         QQ_ = '"'
         LEAD = DUPL(' ', 9)
*
TOP      LINE = INPUT                                            :F(END)
*
         LINE FENCE '-' ('snobol' | 'SNOBOL') (ANY('xX') | '') WHITE_
+            REM . S                                        :F(TRYEMBED)
TRYX1    REVERSE(TRIM(S)) FENCE '+' REM . X                    :F(TRYX2)
         S = REVERSE(X) ' ' INPUT                               :(TRYX1)
TRYX2    CODE = CODE(' ' S ' :(TOP)')                           :S<CODE>
         TERMINAL = 'EMBED: -SNOBOL CODE BAD: ' S                 :(END)
*
TRYEMBED LINE FENCE '-' ('embed' | 'EMBED') WHITE_ ARB . TYPE
+            WHITE_ (Q_ | QQ_) $ DELIM ARB . VNAME *DELIM     :S(STARTC)
         LINE FENCE '-' ('cmnt' | 'CMNT')                        :S(TOP)
         OUTPUT = LINE                                            :(TOP)
STARTC   FNAME = VNAME
         FNAME = ?(TYPE ? 'c' | 'C') FNAME '.c'
         FNAME = ?(TYPE ? 'fortran' | 'FORTRAN') FNAME '.FTN'
         FNAME = ?(TYPE ? 'cobol' | 'COBOL') FNAME '.CBL'
         FNAME = ?(TYPE ? 'scheme' | 'SCHEME') FNAME '.SCM'
         FNAME = ?(TYPE ? 'data' | 'DATA') FNAME '.DAT'
         OUTPUT = LEAD VNAME ' = ' Q_ FNAME Q_
         $VNAME = FNAME
         OUTPUT(.EMBED, 10,, FNAME)
*
COPYL    LINE = INPUT                                            :F(END)
         OFLAG =
         LINE FENCE '-' ('cmnt' | 'CMNT')                      :S(COPYL)
         LINE FENCE '-' ('end' | 'END')                       :S(COPYL3)
         LINE FENCE '-' ('snobol' | 'SNOBOL')
+            ((ANY('xX') *?(OFLAG = 1)) | '')
+            WHITE_ REM . SNC                                 :F(COPYL2)
*
DOMORE   REVERSE(TRIM(SNC)) FENCE '+' REM . X                :F(EXECSNC)
         SNC = REVERSE(X) ' ' INPUT                            :(DOMORE)
*
EXECSNC  OUTPUT = DIFFER(OFLAG) LEAD SNC
         CODE = CODE(' ' SNC ' :(COPYL)')                       :S<CODE>
         &CODE = 1
         TERMINAL = 'EMBED: -SNOBOL(X) CODE BAD: ' SNC            :(END)
COPYL2   EMBED = LINE                                           :(COPYL)
COPYL3   DETACH(.EMBED)
         ENDFILE(10)                                              :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>embed</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The EMBED utility is used to preprocess snobol code that requires
inline data, or that contains embedded C or FORTRAN code.  It may
also have utility as a CGI (WEB) tool.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Adds some control cards to SNOBOL4. These are handled by <font face="Source Code Pro">EMBED</font>,
and are not passed through. All other control cards are simply
copied through:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| -SNOBOL SNOBOL_CODE
| -EMBED C|FORTRAN|COBOL|SCHEME|DATA|FILE 'VNAME'
| -END
| -SNOBOLX SNOBOL_CODE
| -CMNT COMMENT
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">EMBED</font> copies its source file, until it sees one of its controls.
<font face="Source Code Pro">-SNOBOL</font> immediately executes its code (use <font face="Source Code Pro">+</font> at the end of
lines to continue them). <font face="Source Code Pro">-SNOBOLX</font> is the same, but also copies
its code to the output (allowing consistent definitions at both
times). <font face="Source Code Pro">-EMBED</font> to <font face="Source Code Pro">-END</font> is extracted and copied into a file,
whose name is made available to the program as <font face="Source Code Pro">VNAME</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
See <font face="Source Code Pro">P64.lss</font> for an example. <font face="Source Code Pro">P64.lss</font> is processed by
<font face="Source Code Pro">stangle</font> into <font face="Source Code Pro">P64.SNO</font>, which is then processed by <font face="Source Code Pro">EMBED</font>
to produce <font face="Source Code Pro">p64.so</font>, and <font face="Source Code Pro">P64.INC</font> which is the associated INCLUDE
file. <font face="Source Code Pro">EMBED</font> extracts the embedded <font face="Source Code Pro">C</font> code, generating wrappers
using the <font face="Source Code Pro">WRAPPER</font> function. and then runs the <font face="Source Code Pro">C</font> compiler
using the <font face="Source Code Pro">DYNAMIC</font> function to compile and produce the shared
object needed when the <font face="Source Code Pro">P64</font> library function is used.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
In effect, the building of the code is controlled by the SNOBOL4 source
itself, and the entire module is self contained. Neither <font face="Source Code Pro">WRAPPER</font>
nor <font face="Source Code Pro">DYNAMIC</font> need be present at run time but are only used
when the <font face="Source Code Pro">P64</font> module itself is updated.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
I am sure that other uses for <font face="Source Code Pro">EMBED</font> will occur to the reader.
Embedding unit test cases; creation of run-time data files;
implementation of domain specific languages and more. The idea of
<font face="Source Code Pro">EMBED</font> is to provide an approximate equivalent to LISP macros
to SNOBOL4.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Note that <font face="Source Code Pro">SLOAD</font> is included to allow the extension of <font face="Source Code Pro">embed</font>
driven by its using programs.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="SLOAD.html">SLOAD</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="WRAPPER.html">WRAPPER</a><br>
<a href="DYNAMIC.html">DYNAMIC</a><br>
<a href="P64.html">P64</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;SLOAD.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;embed&raquo;&equiv;</b>
-USES SLOAD()
         TERMINAL = &#39;EMBED (SUN DEC  1 16:15:39 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         WHITE_ = SPAN(&#39; &#39; CHARS_TAB) | &#39;&#39;
         Q_ = &quot;&#39;&quot;
         QQ_ = &#39;&quot;&#39;
         LEAD = DUPL(&#39; &#39;, 9)
<font color="#818181"><i>*</i></font>
TOP      LINE = INPUT                                            <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
         LINE FENCE &#39;-&#39; (&#39;snobol&#39; | &#39;SNOBOL&#39;) (ANY(&#39;xX&#39;) | &#39;&#39;) WHITE_
+            REM . S                                        <b>:F(TRYEMBED)</b>
TRYX1    REVERSE(TRIM(S)) FENCE &#39;+&#39; REM . X                    <b>:F(TRYX2)</b>
         S = REVERSE(X) &#39; &#39; INPUT                               <b>:(TRYX1)</b>
TRYX2    CODE = CODE(&#39; &#39; S &#39; :(TOP)&#39;)                           <b>:S&lt;CODE&gt;</b>
         TERMINAL = &#39;EMBED: -SNOBOL CODE BAD: &#39; S                 <b>:(END)</b>
<font color="#818181"><i>*</i></font>
TRYEMBED LINE FENCE &#39;-&#39; (&#39;embed&#39; | &#39;EMBED&#39;) WHITE_ ARB . TYPE
+            WHITE_ (Q_ | QQ_) $ DELIM ARB . VNAME *DELIM     <b>:S(STARTC)</b>
         LINE FENCE &#39;-&#39; (&#39;cmnt&#39; | &#39;CMNT&#39;)                        <b>:S(TOP)</b>
         OUTPUT = LINE                                            <b>:(TOP)</b>
STARTC   FNAME = VNAME
         FNAME = ?(TYPE ? &#39;c&#39; | &#39;C&#39;) FNAME &#39;.c&#39;
         FNAME = ?(TYPE ? &#39;fortran&#39; | &#39;FORTRAN&#39;) FNAME &#39;.FTN&#39;
         FNAME = ?(TYPE ? &#39;cobol&#39; | &#39;COBOL&#39;) FNAME &#39;.CBL&#39;
         FNAME = ?(TYPE ? &#39;scheme&#39; | &#39;SCHEME&#39;) FNAME &#39;.SCM&#39;
         FNAME = ?(TYPE ? &#39;data&#39; | &#39;DATA&#39;) FNAME &#39;.DAT&#39;
         OUTPUT = LEAD VNAME &#39; = &#39; Q_ FNAME Q_
         $VNAME = FNAME
         OUTPUT(.EMBED, 10,, FNAME)
<font color="#818181"><i>*</i></font>
COPYL    LINE = INPUT                                            <b>:F(END)</b>
         OFLAG =
         LINE FENCE &#39;-&#39; (&#39;cmnt&#39; | &#39;CMNT&#39;)                      <b>:S(COPYL)</b>
         LINE FENCE &#39;-&#39; (&#39;end&#39; | &#39;END&#39;)                       <b>:S(COPYL3)</b>
         LINE FENCE &#39;-&#39; (&#39;snobol&#39; | &#39;SNOBOL&#39;)
+            ((ANY(&#39;xX&#39;) *?(OFLAG = 1)) | &#39;&#39;)
+            WHITE_ REM . SNC                                 <b>:F(COPYL2)</b>
<font color="#818181"><i>*</i></font>
DOMORE   REVERSE(TRIM(SNC)) FENCE &#39;+&#39; REM . X                <b>:F(EXECSNC)</b>
         SNC = REVERSE(X) &#39; &#39; INPUT                            <b>:(DOMORE)</b>
<font color="#818181"><i>*</i></font>
EXECSNC  OUTPUT = DIFFER(OFLAG) LEAD SNC
         CODE = CODE(&#39; &#39; SNC &#39; :(COPYL)&#39;)                       <b>:S&lt;CODE&gt;</b>
         &amp;CODE = 1
         TERMINAL = &#39;EMBED: -SNOBOL(X) CODE BAD: &#39; SNC            <b>:(END)</b>
COPYL2   EMBED = LINE                                           <b>:(COPYL)</b>
COPYL3   DETACH(.EMBED)
         ENDFILE(10)                                              <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM EMBED
-TITLE EMBED
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             #######  #     #  ######   #######  ######               *</i></font>
<font color="#818181"><i>*             #        ##   ##  #     #  #        #     #              *</i></font>
<font color="#818181"><i>*             #        # # # #  #     #  #        #     #              *</i></font>
<font color="#818181"><i>*             #####    #  #  #  ######   #####    #     #              *</i></font>
<font color="#818181"><i>*             #        #     #  #     #  #        #     #              *</i></font>
<font color="#818181"><i>*             #        #     #  #     #  #        #     #              *</i></font>
<font color="#818181"><i>*             #######  #     #  ######   #######  ######               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* EMBED                    EMBEDDED SNOBOL CODE                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* embed.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;embed&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 19:59:59 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>ENDCARD - A card with END</h1>

An [[END]] card for use with [[-M]] (multi-file).

<h2>Uses</h2>

<<INCLUDES>>=
@

<<ENDCARD>>=
END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
         &CODE = 1
         &CODE = 0
-INCLUDE 'ENDCARD.INC'
@

<<>>=
-MODULE ENDCARD
-STITL ENDCARD
-EJECT
************************************************************************
*                                                                      *
*    #######  #     #  ######    #####      #     ######   ######      *
*    #        ##    #  #     #  #     #    # #    #     #  #     #     *
*    #        # #   #  #     #  #         #   #   #     #  #     #     *
*    #####    #  #  #  #     #  #        #     #  ######   #     #     *
*    #        #   # #  #     #  #        #######  #   #    #     #     *
*    #        #    ##  #     #  #     #  #     #  #    #   #     #     *
*    #######  #     #  ######    #####   #     #  #     #  ######      *
*                                                                      *
* ENDCARD      AN END CARD FOR USE WITH -M (MULTI-FILE)                *
*                                                                      *
************************************************************************
*
* ENDCARD.lss
*
* CE: .MSNOBOL4;
*
<<ENDCARD>>
@
-MODULE ENDCARD
-STITL ENDCARD
-EJECT
-LINE 26 "ENDCARD.lss"
************************************************************************
*                                                                      *
*    #######  #     #  ######    #####      #     ######   ######      *
*    #        ##    #  #     #  #     #    # #    #     #  #     #     *
*    #        # #   #  #     #  #         #   #   #     #  #     #     *
*    #####    #  #  #  #     #  #        #     #  ######   #     #     *
*    #        #   # #  #     #  #        #######  #   #    #     #     *
*    #        #    ##  #     #  #     #  #     #  #    #   #     #     *
*    #######  #     #  ######    #####   #     #  #     #  ######      *
*                                                                      *
* ENDCARD      AN END CARD FOR USE WITH -M (MULTI-FILE)                *
*                                                                      *
************************************************************************
*
* ENDCARD.lss
*
* CE: .MSNOBOL4;
*
-LINE 11 "ENDCARD.lss"
END
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ENDCARD - A card with END</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
An <font face="Source Code Pro">END</font> card for use with <font face="Source Code Pro">-M</font> (multi-file).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ENDCARD&raquo;&equiv;</b>
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
         &amp;CODE = 1
         &amp;CODE = 0
-INCLUDE &#39;ENDCARD.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE ENDCARD
-STITL ENDCARD
-EJECT
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    #######  #     #  ######    #####      #     ######   ######      *</i></font>
<font color="#818181"><i>*    #        ##    #  #     #  #     #    # #    #     #  #     #     *</i></font>
<font color="#818181"><i>*    #        # #   #  #     #  #         #   #   #     #  #     #     *</i></font>
<font color="#818181"><i>*    #####    #  #  #  #     #  #        #     #  ######   #     #     *</i></font>
<font color="#818181"><i>*    #        #   # #  #     #  #        #######  #   #    #     #     *</i></font>
<font color="#818181"><i>*    #        #    ##  #     #  #     #  #     #  #    #   #     #     *</i></font>
<font color="#818181"><i>*    #######  #     #  ######    #####   #     #  #     #  ######      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ENDCARD      AN END CARD FOR USE WITH -M (MULTI-FILE)                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ENDCARD.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ENDCARD&raquo;</b>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:00 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
         &CODE = 1
-LINE 18 "ENDCARD.lss"
         &CODE = 0
-INCLUDE 'ENDCARD.INC'
<h1>FASTBAL - Pattern to match balanced strings</h1>

[[FASTBAL(PARENS,QTS,S)]] will return a pattern which will match all
non-NULL balanced strings where [[PARENS]] is used to specify paired
brackets in nested fashion and [[QTS]] specifies characters to be
used as quotes.  Bracket characters within quotes are ignored for
balancing purposes.  [[S]] specifies other special characters that
BREAK should stop at.

[[FASTBAL('(<[]>)',"'" '"',',)')]] will scan for arguments in a
function call in SNOBOL4 source.

<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>

<h2>See Also</h2>
<a href="BALX.html">BALX</a>

<<INCLUDES>>=
-INCLUDE 'UNIQUE.INC'
@

<<FASTBAL>>=
-MODULE FASTBAL
-PUBLIC FASTBAL()
         DEFINE('FASTBAL(PARENS,QTS,S)NAME,IBAL,SPCHARS,ELEM'
+               ',LPS,Q,LP,RP')                           :(FASTBAL_END)
*
FASTBAL  NAME = UNIQUE()
         IBAL = CONVERT(NAME, 'EXPRESSION')
         IBAL = DIFFER(S, NULL) FASTBAL(PARENS, QTS)
         SPCHARS = PARENS QTS S
@

Anything not starting with [[PARENS]] or [[QTS]] to any special

'ABCD,' (NOTANY(',)') BREAK(',)')) $ TERMINAL -> ABCD

<<FASTBAL>>=
         ELEM = NOTANY(PARENS QTS) BREAK(SPCHARS)
@

Add quotes:

'ABCD' (Q BREAK(Q) Q) $ TERMINAL -> 'ABCD'

<<FASTBAL>>=
FASTBAL_1
         QTS LEN(1) . Q  =                                 :F(FASTBAL_2)
         ELEM = Q BREAK(Q) Q | ELEM                         :(FASTBAL_1)
@

Add parentheses. First peel off the first character to [[LP]], the
middle to [[PARENS]], and the last to [[RP]]. Then, add the expression
[ recurse ]. [[IBAL]] is an expression that refers to a unique variable
(which hasn't been set to anything as yet).

<<FASTBAL>>=
FASTBAL_2
         PARENS LEN(1) . LP RTAB(1) . PARENS LEN(1) . RP   :F(FASTBAL_3)
         ELEM = LP IBAL RP | ELEM                           :(FASTBAL_2)
@

Build the pattern - any characters up to a special, followed by an
arbitrary number of [[ELEM]]s (which may be zero). The shortest will
be returned.

'ABC,DEF' BREAK(',()') $ TERMINAL -> ABC

This pattern is then assigned to the variable referenced by name
(assigned a unique name, eg. [[U1_]]), which then "fills in" the
recursive part.

'X,Y) ((FASTBAL('()', '"', ',)')) ')') $ TERMINAL -> X,Y)

'X,Y) ((FASTBAL('()', '"', ',)'))) $ TERMINAL -> X

<<FASTBAL>>=
FASTBAL_3
         FASTBAL = BREAK(SPCHARS) ARBNO(ELEM)
         $NAME = FASTBAL                                       :(RETURN)
*
FASTBAL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FASTBAL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL FASTBAL
-EJECT
*
************************************************************************
*                                                                      *
*    #######     #      #####   #######  ######      #     #           *
*    #          # #    #     #     #     #     #    # #    #           *
*    #         #   #   #           #     #     #   #   #   #           *
*    #####    #     #   #####      #     ######   #     #  #           *
*    #        #######        #     #     #     #  #######  #           *
*    #        #     #  #     #     #     #     #  #     #  #           *
*    #        #     #   #####      #     ######   #     #  #######     *
*                                                                      *
* FASTBAL                                                              *
*                                                                      *
************************************************************************
*
* FASTBAL.lss
*
<<FASTBAL>>
*
* CE: .MSNOBOL4;
@
-LINE 20 "FASTBAL.lss"
-INCLUDE 'UNIQUE.INC'
-STITL FASTBAL
-EJECT
-LINE 99 "FASTBAL.lss"
*
************************************************************************
*                                                                      *
*    #######     #      #####   #######  ######      #     #           *
*    #          # #    #     #     #     #     #    # #    #           *
*    #         #   #   #           #     #     #   #   #   #           *
*    #####    #     #   #####      #     ######   #     #  #           *
*    #        #######        #     #     #     #  #######  #           *
*    #        #     #  #     #     #     #     #  #     #  #           *
*    #        #     #   #####      #     ######   #     #  #######     *
*                                                                      *
* FASTBAL                                                              *
*                                                                      *
************************************************************************
*
* FASTBAL.lss
*
-LINE 24 "FASTBAL.lss"
-MODULE FASTBAL
-PUBLIC FASTBAL()
         DEFINE('FASTBAL(PARENS,QTS,S)NAME,IBAL,SPCHARS,ELEM'
+               ',LPS,Q,LP,RP')                           :(FASTBAL_END)
*
FASTBAL  NAME = UNIQUE()
         IBAL = CONVERT(NAME, 'EXPRESSION')
         IBAL = DIFFER(S, NULL) FASTBAL(PARENS, QTS)
         SPCHARS = PARENS QTS S
-LINE 40 "FASTBAL.lss"
         ELEM = NOTANY(PARENS QTS) BREAK(SPCHARS)
-LINE 48 "FASTBAL.lss"
FASTBAL_1
         QTS LEN(1) . Q  =                                 :F(FASTBAL_2)
         ELEM = Q BREAK(Q) Q | ELEM                         :(FASTBAL_1)
-LINE 59 "FASTBAL.lss"
FASTBAL_2
         PARENS LEN(1) . LP RTAB(1) . PARENS LEN(1) . RP   :F(FASTBAL_3)
         ELEM = LP IBAL RP | ELEM                           :(FASTBAL_2)
-LINE 79 "FASTBAL.lss"
FASTBAL_3
         FASTBAL = BREAK(SPCHARS) ARBNO(ELEM)
         $NAME = FASTBAL                                       :(RETURN)
*
FASTBAL_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FASTBAL - Pattern to match balanced strings</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FASTBAL(PARENS,QTS,S)</font> will return a pattern which will match all
non-NULL balanced strings where <font face="Source Code Pro">PARENS</font> is used to specify paired
brackets in nested fashion and <font face="Source Code Pro">QTS</font> specifies characters to be
used as quotes.  Bracket characters within quotes are ignored for
balancing purposes.  <font face="Source Code Pro">S</font> specifies other special characters that
BREAK should stop at.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FASTBAL('(<[]>)',"'" '"',',)')</font> will scan for arguments in a
function call in SNOBOL4 source.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="BALX.html">BALX</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FASTBAL&raquo;&equiv;</b>
-MODULE FASTBAL
-PUBLIC FASTBAL()
         DEFINE(&#39;FASTBAL(PARENS,QTS,S)NAME,IBAL,SPCHARS,ELEM&#39;
+               &#39;,LPS,Q,LP,RP&#39;)                           <b>:(FASTBAL_END)</b>
<font color="#818181"><i>*</i></font>
FASTBAL  NAME = UNIQUE()
         IBAL = CONVERT(NAME, &#39;EXPRESSION&#39;)
         IBAL = DIFFER(S, NULL) FASTBAL(PARENS, QTS)
         SPCHARS = PARENS QTS S
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Anything not starting with <font face="Source Code Pro">PARENS</font> or <font face="Source Code Pro">QTS</font> to any special
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
'ABCD,' (NOTANY(',)') BREAK(',)')) $ TERMINAL -> ABCD
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FASTBAL&raquo;&equiv;</b>
         ELEM = NOTANY(PARENS QTS) BREAK(SPCHARS)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Add quotes:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
'ABCD' (Q BREAK(Q) Q) $ TERMINAL -> 'ABCD'
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FASTBAL&raquo;&equiv;</b>
FASTBAL_1
         QTS LEN(1) . Q  =                                 <b>:F(FASTBAL_2)</b>
         ELEM = Q BREAK(Q) Q | ELEM                         <b>:(FASTBAL_1)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Add parentheses. First peel off the first character to <font face="Source Code Pro">LP</font>, the
middle to <font face="Source Code Pro">PARENS</font>, and the last to <font face="Source Code Pro">RP</font>. Then, add the expression
[ recurse ]. <font face="Source Code Pro">IBAL</font> is an expression that refers to a unique variable
(which hasn't been set to anything as yet).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FASTBAL&raquo;&equiv;</b>
FASTBAL_2
         PARENS LEN(1) . LP RTAB(1) . PARENS LEN(1) . RP   <b>:F(FASTBAL_3)</b>
         ELEM = LP IBAL RP | ELEM                           <b>:(FASTBAL_2)</b>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Build the pattern - any characters up to a special, followed by an
arbitrary number of <font face="Source Code Pro">ELEM</font>s (which may be zero). The shortest will
be returned.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
'ABC,DEF' BREAK(',()') $ TERMINAL -> ABC
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This pattern is then assigned to the variable referenced by name
(assigned a unique name, eg. <font face="Source Code Pro">U1_</font>), which then "fills in" the
recursive part.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
'X,Y) ((FASTBAL('()', '"', ',)')) ')') $ TERMINAL -> X,Y)
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
'X,Y) ((FASTBAL('()', '"', ',)'))) $ TERMINAL -> X
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FASTBAL&raquo;&equiv;</b>
FASTBAL_3
         FASTBAL = BREAK(SPCHARS) ARBNO(ELEM)
         $NAME = FASTBAL                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FASTBAL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FASTBAL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL FASTBAL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    #######     #      #####   #######  ######      #     #           *</i></font>
<font color="#818181"><i>*    #          # #    #     #     #     #     #    # #    #           *</i></font>
<font color="#818181"><i>*    #         #   #   #           #     #     #   #   #   #           *</i></font>
<font color="#818181"><i>*    #####    #     #   #####      #     ######   #     #  #           *</i></font>
<font color="#818181"><i>*    #        #######        #     #     #     #  #######  #           *</i></font>
<font color="#818181"><i>*    #        #     #  #     #     #     #     #  #     #  #           *</i></font>
<font color="#818181"><i>*    #        #     #   #####      #     ######   #     #  #######     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FASTBAL                                                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FASTBAL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FASTBAL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:00 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FASTBAL.INC'
-LINE 90 "FASTBAL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>FCGI - FCGI (Fast CGI) Support Functions</h1>

[[FCGI]] support functions. Need to suck in CGI to actually handle
requests. This should be a wrapper for CGI. Note that logging, header
and body creation is different. But, should be consistent with however
CGI normally does things. If getpeername fails, use CGI straight-up

This is the simplest possible implementation of [[FCGI]]. This is
going to provide a speed-up in that the script will not need
re-compilation. But, this is not the initial goal. Initial goal is
simple functionality.

After we have baseline function, we will refactor the code to provide
services for CGI. CGI will then call into FCGI to do needed data
transmissions.

When this is functional, we will work on performance.

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="FFI.html">FFI</a><br>
<a href="JSON.html">JSON</a><br>
<a href="LOGIC.html">LOGIC</a><br>
<a href="TIME.html">TIME</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'FFI.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'LOGIC.INC'
-INCLUDE 'TIME.INC'
@

<<FCGI>>=
-MODULE FCGI
         FCGI_LOGUNIT = IO_FINDUNIT()
         OUTPUT(.FCGI_LOG, FCGI_LOGUNIT, 'W', 
+               '|/usr/bin/logger -n localhost -t FCGI')
         STDIN_FILENO = 0
         FCGI_LISTENSOCK_FILENO = STDIN_FILENO
*
         FCGI_BEGIN_REQUEST     =  1
         FCGI_ABORT_REQUEST     =  2
         FCGI_END_REQUEST       =  3
         FCGI_PARAMS            =  4
         FCGI_STDIN             =  5
         FCGI_STDOUT            =  6
         FCGI_STDERR            =  7
         FCGI_DATA              =  8
         FCGI_GET_VALUES        =  9
         FCGI_GET_VALUES_RESULT = 10
         FCGI_UNKNOWN_TYPE      = 11
*
         FCGI_RESPONDER  = 1
         FCGI_AUTHORIZER = 2
         FCGI_FILTER     = 3
*
-PUBLIC FCGI_REQUEST_COMPLETE, FCGI_CANT_MPX_CONN, FCGI_OVERLOADED
-PUBLIC FCGI_UNKNOWN_ROLE
         FCGI_REQUEST_COMPLETE = 0
         FCGI_CANT_MPX_CONN    = 1
         FCGI_OVERLOADED       = 2
         FCGI_UNKNOWN_ROLE     = 3
*
* getpeername RETURNS PEER NAME FOR STDIN IF RUNNING UNDER FCGI. IT
* ACTUALLY RETURNS TRANSPORT END-POINT NOT CONNECTED. IF IT ISN'T A
* SOCKET AT ALL, DEFINITELY CGI CASE.
*
         PEER = BQ('/usr/bin/getpeername 2>&1')             :F(NOT_FCGI)
         PEER 'Socket operation on non-socket'              :S(NOT_FCGI)
*
         FCGI_LOG = 'FCGI'
*
* INFORM CGI THAT FAST CGI IS IN USE. DEFINE THE ACCEPT() FUNCTION.
* LISTEN() HAS ALREADY BEEN DONE IN THE WEB SERVER.
*
         USE_FCGI = 1
NOT_FCGI FCGI_LOG = IDENT(USER_FCGI) 'NORMAL CGI'
         FFI_ACCEPT = FFI_NEW('I', 'I,P,P')
         FFI_SET_CALLP(FFI_ACCEPT, DLSYM(0, 'accept'))
-PUBLIC FCGI_ACCEPT(), ACCEPT(), FCGI_SEND(), FCGI_SEND_ERR(),
-PUBLIC FCGI_END()
         DEFINE('FCGI_ACCEPT()')
         DEFINE('ACCEPT(SOCKET,P1,P2)')
         DEFINE('FCGI_NAMES(T,A)')
         DEFINE('FCGI_SEND(S)')
         DEFINE('FCGI_SEND_ERR(S)')
         DEFINE('FCGI_SEND_(D,S)B')
         DEFINE('FCGI_END(APP_STATUS,PROT_STATUS)S,B0,B1,B2,B3')
         DEFINE('FCGI_GET()')                               :(FCGI_END_)
*
ACCEPT   CLEAR_ERRNO()
         FFI_PAR_N_INTEGER(FFI_ACCEPT, 1, SOCKET)
         FFI_PAR_N_PTR(FFI_ACCEPT, 2, P1)
         FFI_PAR_N_PTR(FFI_ACCEPT, 3, P2)
         ACCEPT = FFI_CALL_INTEGER(FFI_ACCEPT)                 :(RETURN)
*
* IF THE DATA TO SEND IS 0...65535 BYTES, SEND IT. IF GREATER,
* SEND THE FIRST 65535, AND LOOP FOR THE REST
*
FCGI_SEND_
         LT(SIZE(S), 65536)                              :S(FCGI_SEND_2)
         S LEN(65535) . B REM . S
         FCGI_SEND_(D, B)                                  :(FCGI_SEND_)
FCGI_SEND_2
         FCGI_LOG = 'FCGI_SEND: '  D ' ' SIZE(S)
         S = CHAR(1) CHAR(D)
+            CHAR(FCGI_REQUESTID / 256) CHAR(REMDR(FCGI_REQUESTID, 256))
+            CHAR(SIZE(S) / 256) CHAR(REMDR(SIZE(S), 256))
+            CHAR(0) CHAR(0) S
         FCGI_OUT = S                                          :(RETURN)
*
FCGI_SEND
         FCGI_SEND_(FCGI_STDOUT, S)                            :(RETURN)
*
FCGI_SEND_ERR
         FCGI_SEND_(FCGI_STDERR, S)                            :(RETURN)
*
FCGI_END FCGI_LOG = 'FCGI_END: ' APP_STATUS ' ' PROT_STATUS
         B3 = APP_STATUS / 16777216
         APP_STATUS = REMDR(APP_STATUS, 16777216)
         B2 = APP_STATUS / 65536
         APP_STATUS = REMDR(APP_STATUS, 65536)
         B1 = APP_STATUS / 256
         B0 = REMDR(APP_STATUS, 256)
         S = CHAR(B3) CHAR(B2) CHAR(B1) CHAR(B0) CHAR(PROT_STATUS)
+            CHAR(0) CHAR(0) CHAR(0)
         B1 = FCGI_REQUESTID / 256
         B0 = REMDR(FCGI_REQUESTID, 256)
         S = CHAR(1) CHAR(FCGI_END_REQUEST) CHAR(B1) CHAR(B0)
+            CHAR(0) CHAR(8) CHAR(0) CHAR(0) S
         FCGI_OUT = S                                          :(RETURN)
*
FCGI_GET VERSION = ORD(FCGI)
         FCGI_LOG = DIFFER(VERSION, 1) 'VERSION <> 1'            :S(END)
         TYPE = ORD(FCGI)
         REQUESTID = ORD(FCGI) * 256
         REQUESTID = REQUESTID + ORD(FCGI)
         CONTENTLENGTH = ORD(FCGI) * 256
         CONTENTLENGTH = CONTENTLENGTH + ORD(FCGI)
         PADDINGLENGTH = ORD(FCGI)
         RESERVED = ORD(FCGI)
*
* WE COULD READ THIS IN ONE GULP, AND AVOID CONVERTING TO ARRAY AND
* THEN BACK INTO STRING.
*
         FCGI_GET = NE(CONTENTLENGTH) ARRAY(CONTENTLENGTH)
         I = 1
FCGI_4   GT(I, CONTENTLENGTH)                                 :S(FCGI_5)
         FCGI_GET<I> = ORD(FCGI)
         I = I + 1                                             :(FCGI_4)
FCGI_5   I = 1
FCGI_6   GT(I, PADDINGLENGTH)                                 :S(RETURN)
         S = FCGI
         I = I + 1                                             :(FCGI_6)
*
* EXTRACT NAMES FROM ARRAY. TWO LENGTH FIELDS, EITHER 1 OR 4 BYTES,
* THEN THE ACTUAL NAME AND DATA.
*
FCGI_NAMES
         I = 1
FCGI_NAMES_7
         NL = A<I>
         EQ(AND(NL, 128))                               :S(FCGI_NAMES_2)
         NL = AND(A<I>, 127) * 16777216 +
+             A<I + 1> * 65536 +
+             A<I + 2> * 256 +
+             A<I + 3>
         I = I + 3
FCGI_NAMES_2
         I = I + 1
         DL = A<I>
         EQ(AND(NL, 128))                               :S(FCGI_NAMES_3)
         DL = AND(A<I>, 127) * 16777216 +
+             A<I + 1> * 65536 +
+             A<I + 2> * 256 +
+             A<I + 3>
         I = I + 3
FCGI_NAMES_3
         I = I + 1
         NM =
         DA =
FCGI_NAMES_4
         EQ(NL)                                         :S(FCGI_NAMES_5)
         NM = NM CHAR(A<I>)
         I = I + 1
         NL = NL - 1                                     :(FCGI_NAMES_4)
FCGI_NAMES_5
         EQ(DL)                                         :S(FCGI_NAMES_6)
         DA = DA CHAR(A<I>)
         I = I + 1
         DL = DL - 1                                     :(FCGI_NAMES_5)
FCGI_NAMES_6
         T<NM> = DA
         A<I>                                  :F(RETURN)S(FCGI_NAMES_7)
*
* MAIN FCGI FUNCTION
*
FCGI_ACCEPT
         IDENT(USE_FCGI)                                      :S(RETURN)
         FCGI_LOG = 'FCGI_ACCEPT: WAITING'
         SOCKET = ACCEPT(FCGI_LISTENSOCK_FILENO, 0, 0)
         FCGI_LOG = 'AFTER ACCEPT'
         GE(SOCKET)                                           :S(FCGI_2)
*
* ON ERROR IN ACCEPT, WE DISPLAY ERRNO AND EXIT THE PROCESS
*
         ERRNO = GET_ERRNO()
         FCGI_LOG = 'ACCEPT: ERRNO = ' ERRNO                      :(END)
*
* READ AND DIGEST PACKETS FROM SOCKET. CLEAN UP OLD INSTANCE I/O
* (FCGI IS GOING TO STAY AROUND EXECUTING REQUESTS). tHEN
* OPEN THE SOCKET PASSED TO US BY ACCEPT().
*
FCGI_2   IDENT(FCGI_INSTANCE_UNIT)                            :S(FCGI_8)
         DETACH(.FCGI)
         DETACH(.FCGI_OUT)
         ENDFILE(FCGI_INSTANCE_UNIT)
FCGI_8   FCGI_LOG = 'SOCKET = ' SOCKET
         FCGI_INSTANCE_UNIT = IO_FINDUNIT()
         FCGI_LOG = 'UNIT = ' FCGI_INSTANCE_UNIT
         INPUT(.FCGI, FCGI_INSTANCE_UNIT, 'U,B,1', '/dev/fd/' SOCKET)
         OUTPUT(.FCGI_OUT, FCGI_INSTANCE_UNIT, 'W,B,1')
*
         FCGI_ENV = TABLE()
         FCGI_IN =
         FCGI_REQUESTID =
*
* PACKET LOOP
*
FCGI_PLOOP
         CONTENT = FCGI_GET()
         FCGI_REQUESTID = IDENT(FCGI_REQUESTID) REQUESTID
         EQ(REQUESTID, FCGI_REQUESTID)                  :S(FCGI_PLOOP_2)
         FCGI_LOG = 'ONLY SINGLE REQUESTID SUPPORTED'             :(END)
*
* WE DO NOT MULTIPLEX REQUESTID, NEED TO SET INDICATION OF THAT
* IN FCGI_GET().
*
FCGI_PLOOP_2
         EQ(TYPE, FCGI_BEGIN_REQUEST)                        :F(FCGI_10)
         FCGI_LOG = 'FCGI_BEGIN_REQUEST'
         FCGI_ROLE = CONTENT<1> * 256 + CONTENT<2>
         FCGI_LOG = NE(FCGI_ROLE, FCGI_RESPONDER)
+           'ROLE NOT RESPONDER'                                 :S(END)
         FCGI_FLAGS = CONTENT<3>
         FCGI_REQUESTID = REQUESTID                        :(FCGI_PLOOP)
*
FCGI_10  EQ(TYPE, FCGI_PARAMS)                               :F(FCGI_11)
         FCGI_LOG = 'FCGI_PARAMS'
         IDENT(CONTENT)                                   :S(FCGI_PLOOP)
         FCGI_NAMES(FCGI_ENV, CONTENT)                     :(FCGI_PLOOP)
*
FCGI_11  EQ(TYPE, FCGI_STDIN)                                :F(FCGI_12)
         FCGI_LOG = 'FCGI_STDIN'
         IDENT(CONTENT)                                      :S(FCGI_GO)
         I = 1
* FIXME: WE READ IT AS A STRING, CONVERT TO ARRAY OF SMALL INTEGERS,
* AND THEN MAKE IT A STRING AGAIN. THIS IS DONE BECAUSE WE ARE GOING
* TO DO PACKET DISASSEMBLY, AND THAT IS ARGUABLY EASIER IN THE SMALL
* INTEGER SPACE. STILL, IT SHOULD BE FIXED.
FCGI_13  FCGI_IN = FCGI_IN CHAR(CONTENT<I>)               :F(FCGI_PLOOP)
         I = I + 1                                            :(FCGI_13)
*
FCGI_12
         FCGI_LOG = 'BAD TYPE: ' TYPE                             :(END)
*
FCGI_GO
         FCGI_LOG = 'FCGI_GO'
*
* HERE WE ILLUSTRATE AN INTERESTING TECHNIQUE. SINCE JSON_ENCODE WILL
* TRAVERSE TABLES AND ARRAYS, WE CAN USE IT TO EXAMINE VARIABLES BY
* SENDING THE JSON ENCODING TO A LOG FILE.
*
         FCGI_LOG = 'FCGI_ENV: '
         FCGI_LOG = JSON_ENCODE(FCGI_ENV)
*
* BUG ALERT: IF THIS IS NOT DONE, GETTIMEOFDAY(), GMTIME() ETC.
* FAULT ON THE SECOND PASS THROUGH FCGI. HAPPENS WITH CSNOBOL4 1.5
*
* TRY TO ISOLATE THIS FURTHER.
*
         T = GETTIMEOFDAY()
                                                               :(RETURN)
*
FCGI_END_
@

<<unit_test>>=
#!/usr/bin/bash
         export "SNOLIB=/export/home/fred/snolib/snolib"; export "SNOPATH=/export/home/fred/snolib/snolib"
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'FCGI.INC'
*
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL FCGI
-EJECT
*
************************************************************************
*                                                                      *
*                    #######   #####    #####   ###                    *
*                    #        #     #  #     #   #                     *
*                    #        #        #         #                     *
*                    #####    #        #  ####   #                     *
*                    #        #        #     #   #                     *
*                    #        #     #  #     #   #                     *
*                    #         #####    #####   ###                    *
*                                                                      *
* FCGI                   FCGI SUPPORT FUNCTIONS                        *
*                                                                      *
************************************************************************
*
* FCGI.lss
*
<<FCGI>>
*
* CE: .F.MSNOBOL4;
@
-LINE 28 "FCGI.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'FFI.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'LOGIC.INC'
-INCLUDE 'TIME.INC'
-STITL FCGI
-EJECT
-LINE 306 "FCGI.lss"
*
************************************************************************
*                                                                      *
*                    #######   #####    #####   ###                    *
*                    #        #     #  #     #   #                     *
*                    #        #        #         #                     *
*                    #####    #        #  ####   #                     *
*                    #        #        #     #   #                     *
*                    #        #     #  #     #   #                     *
*                    #         #####    #####   ###                    *
*                                                                      *
* FCGI                   FCGI SUPPORT FUNCTIONS                        *
*                                                                      *
************************************************************************
*
* FCGI.lss
*
-LINE 37 "FCGI.lss"
-MODULE FCGI
         FCGI_LOGUNIT = IO_FINDUNIT()
         OUTPUT(.FCGI_LOG, FCGI_LOGUNIT, 'W',
+               '|/usr/bin/logger -n localhost -t FCGI')
         STDIN_FILENO = 0
         FCGI_LISTENSOCK_FILENO = STDIN_FILENO
*
         FCGI_BEGIN_REQUEST     =  1
         FCGI_ABORT_REQUEST     =  2
         FCGI_END_REQUEST       =  3
         FCGI_PARAMS            =  4
         FCGI_STDIN             =  5
         FCGI_STDOUT            =  6
         FCGI_STDERR            =  7
         FCGI_DATA              =  8
         FCGI_GET_VALUES        =  9
         FCGI_GET_VALUES_RESULT = 10
         FCGI_UNKNOWN_TYPE      = 11
*
         FCGI_RESPONDER  = 1
         FCGI_AUTHORIZER = 2
         FCGI_FILTER     = 3
*
-PUBLIC FCGI_REQUEST_COMPLETE, FCGI_CANT_MPX_CONN, FCGI_OVERLOADED
-PUBLIC FCGI_UNKNOWN_ROLE
         FCGI_REQUEST_COMPLETE = 0
         FCGI_CANT_MPX_CONN    = 1
         FCGI_OVERLOADED       = 2
         FCGI_UNKNOWN_ROLE     = 3
*
* getpeername RETURNS PEER NAME FOR STDIN IF RUNNING UNDER FCGI. IT
* ACTUALLY RETURNS TRANSPORT END-POINT NOT CONNECTED. IF IT ISN'T A
* SOCKET AT ALL, DEFINITELY CGI CASE.
*
         PEER = BQ('/usr/bin/getpeername 2>&1')             :F(NOT_FCGI)
         PEER 'Socket operation on non-socket'              :S(NOT_FCGI)
*
         FCGI_LOG = 'FCGI'
*
* INFORM CGI THAT FAST CGI IS IN USE. DEFINE THE ACCEPT() FUNCTION.
* LISTEN() HAS ALREADY BEEN DONE IN THE WEB SERVER.
*
         USE_FCGI = 1
NOT_FCGI FCGI_LOG = IDENT(USER_FCGI) 'NORMAL CGI'
         FFI_ACCEPT = FFI_NEW('I', 'I,P,P')
         FFI_SET_CALLP(FFI_ACCEPT, DLSYM(0, 'accept'))
-PUBLIC FCGI_ACCEPT(), ACCEPT(), FCGI_SEND(), FCGI_SEND_ERR(),
-PUBLIC FCGI_END()
         DEFINE('FCGI_ACCEPT()')
         DEFINE('ACCEPT(SOCKET,P1,P2)')
         DEFINE('FCGI_NAMES(T,A)')
         DEFINE('FCGI_SEND(S)')
         DEFINE('FCGI_SEND_ERR(S)')
         DEFINE('FCGI_SEND_(D,S)B')
         DEFINE('FCGI_END(APP_STATUS,PROT_STATUS)S,B0,B1,B2,B3')
         DEFINE('FCGI_GET()')                               :(FCGI_END_)
*
ACCEPT   CLEAR_ERRNO()
         FFI_PAR_N_INTEGER(FFI_ACCEPT, 1, SOCKET)
         FFI_PAR_N_PTR(FFI_ACCEPT, 2, P1)
         FFI_PAR_N_PTR(FFI_ACCEPT, 3, P2)
         ACCEPT = FFI_CALL_INTEGER(FFI_ACCEPT)                 :(RETURN)
*
* IF THE DATA TO SEND IS 0...65535 BYTES, SEND IT. IF GREATER,
* SEND THE FIRST 65535, AND LOOP FOR THE REST
*
FCGI_SEND_
         LT(SIZE(S), 65536)                              :S(FCGI_SEND_2)
         S LEN(65535) . B REM . S
         FCGI_SEND_(D, B)                                  :(FCGI_SEND_)
FCGI_SEND_2
         FCGI_LOG = 'FCGI_SEND: '  D ' ' SIZE(S)
         S = CHAR(1) CHAR(D)
+            CHAR(FCGI_REQUESTID / 256) CHAR(REMDR(FCGI_REQUESTID, 256))
+            CHAR(SIZE(S) / 256) CHAR(REMDR(SIZE(S), 256))
+            CHAR(0) CHAR(0) S
         FCGI_OUT = S                                          :(RETURN)
*
FCGI_SEND
         FCGI_SEND_(FCGI_STDOUT, S)                            :(RETURN)
*
FCGI_SEND_ERR
         FCGI_SEND_(FCGI_STDERR, S)                            :(RETURN)
*
FCGI_END FCGI_LOG = 'FCGI_END: ' APP_STATUS ' ' PROT_STATUS
         B3 = APP_STATUS / 16777216
         APP_STATUS = REMDR(APP_STATUS, 16777216)
         B2 = APP_STATUS / 65536
         APP_STATUS = REMDR(APP_STATUS, 65536)
         B1 = APP_STATUS / 256
         B0 = REMDR(APP_STATUS, 256)
         S = CHAR(B3) CHAR(B2) CHAR(B1) CHAR(B0) CHAR(PROT_STATUS)
+            CHAR(0) CHAR(0) CHAR(0)
         B1 = FCGI_REQUESTID / 256
         B0 = REMDR(FCGI_REQUESTID, 256)
         S = CHAR(1) CHAR(FCGI_END_REQUEST) CHAR(B1) CHAR(B0)
+            CHAR(0) CHAR(8) CHAR(0) CHAR(0) S
         FCGI_OUT = S                                          :(RETURN)
*
FCGI_GET VERSION = ORD(FCGI)
         FCGI_LOG = DIFFER(VERSION, 1) 'VERSION <> 1'            :S(END)
         TYPE = ORD(FCGI)
         REQUESTID = ORD(FCGI) * 256
         REQUESTID = REQUESTID + ORD(FCGI)
         CONTENTLENGTH = ORD(FCGI) * 256
         CONTENTLENGTH = CONTENTLENGTH + ORD(FCGI)
         PADDINGLENGTH = ORD(FCGI)
         RESERVED = ORD(FCGI)
*
* WE COULD READ THIS IN ONE GULP, AND AVOID CONVERTING TO ARRAY AND
* THEN BACK INTO STRING.
*
         FCGI_GET = NE(CONTENTLENGTH) ARRAY(CONTENTLENGTH)
         I = 1
FCGI_4   GT(I, CONTENTLENGTH)                                 :S(FCGI_5)
         FCGI_GET<I> = ORD(FCGI)
         I = I + 1                                             :(FCGI_4)
FCGI_5   I = 1
FCGI_6   GT(I, PADDINGLENGTH)                                 :S(RETURN)
         S = FCGI
         I = I + 1                                             :(FCGI_6)
*
* EXTRACT NAMES FROM ARRAY. TWO LENGTH FIELDS, EITHER 1 OR 4 BYTES,
* THEN THE ACTUAL NAME AND DATA.
*
FCGI_NAMES
         I = 1
FCGI_NAMES_7
         NL = A<I>
         EQ(AND(NL, 128))                               :S(FCGI_NAMES_2)
         NL = AND(A<I>, 127) * 16777216 +
+             A<I + 1> * 65536 +
+             A<I + 2> * 256 +
+             A<I + 3>
         I = I + 3
FCGI_NAMES_2
         I = I + 1
         DL = A<I>
         EQ(AND(NL, 128))                               :S(FCGI_NAMES_3)
         DL = AND(A<I>, 127) * 16777216 +
+             A<I + 1> * 65536 +
+             A<I + 2> * 256 +
+             A<I + 3>
         I = I + 3
FCGI_NAMES_3
         I = I + 1
         NM =
         DA =
FCGI_NAMES_4
         EQ(NL)                                         :S(FCGI_NAMES_5)
         NM = NM CHAR(A<I>)
         I = I + 1
         NL = NL - 1                                     :(FCGI_NAMES_4)
FCGI_NAMES_5
         EQ(DL)                                         :S(FCGI_NAMES_6)
         DA = DA CHAR(A<I>)
         I = I + 1
         DL = DL - 1                                     :(FCGI_NAMES_5)
FCGI_NAMES_6
         T<NM> = DA
         A<I>                                  :F(RETURN)S(FCGI_NAMES_7)
*
* MAIN FCGI FUNCTION
*
FCGI_ACCEPT
         IDENT(USE_FCGI)                                      :S(RETURN)
         FCGI_LOG = 'FCGI_ACCEPT: WAITING'
         SOCKET = ACCEPT(FCGI_LISTENSOCK_FILENO, 0, 0)
         FCGI_LOG = 'AFTER ACCEPT'
         GE(SOCKET)                                           :S(FCGI_2)
*
* ON ERROR IN ACCEPT, WE DISPLAY ERRNO AND EXIT THE PROCESS
*
         ERRNO = GET_ERRNO()
         FCGI_LOG = 'ACCEPT: ERRNO = ' ERRNO                      :(END)
*
* READ AND DIGEST PACKETS FROM SOCKET. CLEAN UP OLD INSTANCE I/O
* (FCGI IS GOING TO STAY AROUND EXECUTING REQUESTS). tHEN
* OPEN THE SOCKET PASSED TO US BY ACCEPT().
*
FCGI_2   IDENT(FCGI_INSTANCE_UNIT)                            :S(FCGI_8)
         DETACH(.FCGI)
         DETACH(.FCGI_OUT)
         ENDFILE(FCGI_INSTANCE_UNIT)
FCGI_8   FCGI_LOG = 'SOCKET = ' SOCKET
         FCGI_INSTANCE_UNIT = IO_FINDUNIT()
         FCGI_LOG = 'UNIT = ' FCGI_INSTANCE_UNIT
         INPUT(.FCGI, FCGI_INSTANCE_UNIT, 'U,B,1', '/dev/fd/' SOCKET)
         OUTPUT(.FCGI_OUT, FCGI_INSTANCE_UNIT, 'W,B,1')
*
         FCGI_ENV = TABLE()
         FCGI_IN =
         FCGI_REQUESTID =
*
* PACKET LOOP
*
FCGI_PLOOP
         CONTENT = FCGI_GET()
         FCGI_REQUESTID = IDENT(FCGI_REQUESTID) REQUESTID
         EQ(REQUESTID, FCGI_REQUESTID)                  :S(FCGI_PLOOP_2)
         FCGI_LOG = 'ONLY SINGLE REQUESTID SUPPORTED'             :(END)
*
* WE DO NOT MULTIPLEX REQUESTID, NEED TO SET INDICATION OF THAT
* IN FCGI_GET().
*
FCGI_PLOOP_2
         EQ(TYPE, FCGI_BEGIN_REQUEST)                        :F(FCGI_10)
         FCGI_LOG = 'FCGI_BEGIN_REQUEST'
         FCGI_ROLE = CONTENT<1> * 256 + CONTENT<2>
         FCGI_LOG = NE(FCGI_ROLE, FCGI_RESPONDER)
+           'ROLE NOT RESPONDER'                                 :S(END)
         FCGI_FLAGS = CONTENT<3>
         FCGI_REQUESTID = REQUESTID                        :(FCGI_PLOOP)
*
FCGI_10  EQ(TYPE, FCGI_PARAMS)                               :F(FCGI_11)
         FCGI_LOG = 'FCGI_PARAMS'
         IDENT(CONTENT)                                   :S(FCGI_PLOOP)
         FCGI_NAMES(FCGI_ENV, CONTENT)                     :(FCGI_PLOOP)
*
FCGI_11  EQ(TYPE, FCGI_STDIN)                                :F(FCGI_12)
         FCGI_LOG = 'FCGI_STDIN'
         IDENT(CONTENT)                                      :S(FCGI_GO)
         I = 1
* FIXME: WE READ IT AS A STRING, CONVERT TO ARRAY OF SMALL INTEGERS,
* AND THEN MAKE IT A STRING AGAIN. THIS IS DONE BECAUSE WE ARE GOING
* TO DO PACKET DISASSEMBLY, AND THAT IS ARGUABLY EASIER IN THE SMALL
* INTEGER SPACE. STILL, IT SHOULD BE FIXED.
FCGI_13  FCGI_IN = FCGI_IN CHAR(CONTENT<I>)               :F(FCGI_PLOOP)
         I = I + 1                                            :(FCGI_13)
*
FCGI_12
         FCGI_LOG = 'BAD TYPE: ' TYPE                             :(END)
*
FCGI_GO
         FCGI_LOG = 'FCGI_GO'
*
* HERE WE ILLUSTRATE AN INTERESTING TECHNIQUE. SINCE JSON_ENCODE WILL
* TRAVERSE TABLES AND ARRAYS, WE CAN USE IT TO EXAMINE VARIABLES BY
* SENDING THE JSON ENCODING TO A LOG FILE.
*
         FCGI_LOG = 'FCGI_ENV: '
         FCGI_LOG = JSON_ENCODE(FCGI_ENV)
*
* BUG ALERT: IF THIS IS NOT DONE, GETTIMEOFDAY(), GMTIME() ETC.
* FAULT ON THE SECOND PASS THROUGH FCGI. HAPPENS WITH CSNOBOL4 1.5
*
* TRY TO ISOLATE THIS FURTHER.
*
         T = GETTIMEOFDAY()
                                                               :(RETURN)
*
FCGI_END_
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FCGI - FCGI (Fast CGI) Support Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FCGI</font> support functions. Need to suck in CGI to actually handle
requests. This should be a wrapper for CGI. Note that logging, header
and body creation is different. But, should be consistent with however
CGI normally does things. If getpeername fails, use CGI straight-up
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This is the simplest possible implementation of <font face="Source Code Pro">FCGI</font>. This is
going to provide a speed-up in that the script will not need
re-compilation. But, this is not the initial goal. Initial goal is
simple functionality.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
After we have baseline function, we will refactor the code to provide
services for CGI. CGI will then call into FCGI to do needed data
transmissions.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
When this is functional, we will work on performance.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="FFI.html">FFI</a><br>
<a href="JSON.html">JSON</a><br>
<a href="LOGIC.html">LOGIC</a><br>
<a href="TIME.html">TIME</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CSNOBOL4.INC&#39;
-INCLUDE &#39;FFI.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;LOGIC.INC&#39;
-INCLUDE &#39;TIME.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FCGI&raquo;&equiv;</b>
-MODULE FCGI
         FCGI_LOGUNIT = IO_FINDUNIT()
         OUTPUT(.FCGI_LOG, FCGI_LOGUNIT, &#39;W&#39;,
+               &#39;|/usr/bin/logger -n localhost -t FCGI&#39;)
         STDIN_FILENO = 0
         FCGI_LISTENSOCK_FILENO = STDIN_FILENO
<font color="#818181"><i>*</i></font>
         FCGI_BEGIN_REQUEST     =  1
         FCGI_ABORT_REQUEST     =  2
         FCGI_END_REQUEST       =  3
         FCGI_PARAMS            =  4
         FCGI_STDIN             =  5
         FCGI_STDOUT            =  6
         FCGI_STDERR            =  7
         FCGI_DATA              =  8
         FCGI_GET_VALUES        =  9
         FCGI_GET_VALUES_RESULT = 10
         FCGI_UNKNOWN_TYPE      = 11
<font color="#818181"><i>*</i></font>
         FCGI_RESPONDER  = 1
         FCGI_AUTHORIZER = 2
         FCGI_FILTER     = 3
<font color="#818181"><i>*</i></font>
-PUBLIC FCGI_REQUEST_COMPLETE, FCGI_CANT_MPX_CONN, FCGI_OVERLOADED
-PUBLIC FCGI_UNKNOWN_ROLE
         FCGI_REQUEST_COMPLETE = 0
         FCGI_CANT_MPX_CONN    = 1
         FCGI_OVERLOADED       = 2
         FCGI_UNKNOWN_ROLE     = 3
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* getpeername RETURNS PEER NAME FOR STDIN IF RUNNING UNDER FCGI. IT</i></font>
<font color="#818181"><i>* ACTUALLY RETURNS TRANSPORT END-POINT NOT CONNECTED. IF IT ISN&#39;T A</i></font>
<font color="#818181"><i>* SOCKET AT ALL, DEFINITELY CGI CASE.</i></font>
<font color="#818181"><i>*</i></font>
         PEER = BQ(&#39;/usr/bin/getpeername 2&gt;&amp;1&#39;)             <b>:F(NOT_FCGI)</b>
         PEER &#39;Socket operation on non-socket&#39;              <b>:S(NOT_FCGI)</b>
<font color="#818181"><i>*</i></font>
         FCGI_LOG = &#39;FCGI&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INFORM CGI THAT FAST CGI IS IN USE. DEFINE THE ACCEPT() FUNCTION.</i></font>
<font color="#818181"><i>* LISTEN() HAS ALREADY BEEN DONE IN THE WEB SERVER.</i></font>
<font color="#818181"><i>*</i></font>
         USE_FCGI = 1
NOT_FCGI FCGI_LOG = IDENT(USER_FCGI) &#39;NORMAL CGI&#39;
         FFI_ACCEPT = FFI_NEW(&#39;I&#39;, &#39;I,P,P&#39;)
         FFI_SET_CALLP(FFI_ACCEPT, DLSYM(0, &#39;accept&#39;))
-PUBLIC FCGI_ACCEPT(), ACCEPT(), FCGI_SEND(), FCGI_SEND_ERR(),
-PUBLIC FCGI_END()
         DEFINE(&#39;FCGI_ACCEPT()&#39;)
         DEFINE(&#39;ACCEPT(SOCKET,P1,P2)&#39;)
         DEFINE(&#39;FCGI_NAMES(T,A)&#39;)
         DEFINE(&#39;FCGI_SEND(S)&#39;)
         DEFINE(&#39;FCGI_SEND_ERR(S)&#39;)
         DEFINE(&#39;FCGI_SEND_(D,S)B&#39;)
         DEFINE(&#39;FCGI_END(APP_STATUS,PROT_STATUS)S,B0,B1,B2,B3&#39;)
         DEFINE(&#39;FCGI_GET()&#39;)                               <b>:(FCGI_END_)</b>
<font color="#818181"><i>*</i></font>
ACCEPT   CLEAR_ERRNO()
         FFI_PAR_N_INTEGER(FFI_ACCEPT, 1, SOCKET)
         FFI_PAR_N_PTR(FFI_ACCEPT, 2, P1)
         FFI_PAR_N_PTR(FFI_ACCEPT, 3, P2)
         ACCEPT = FFI_CALL_INTEGER(FFI_ACCEPT)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF THE DATA TO SEND IS 0...65535 BYTES, SEND IT. IF GREATER,</i></font>
<font color="#818181"><i>* SEND THE FIRST 65535, AND LOOP FOR THE REST</i></font>
<font color="#818181"><i>*</i></font>
FCGI_SEND_
         LT(SIZE(S), 65536)                              <b>:S(FCGI_SEND_2)</b>
         S LEN(65535) . B REM . S
         FCGI_SEND_(D, B)                                  <b>:(FCGI_SEND_)</b>
FCGI_SEND_2
         FCGI_LOG = &#39;FCGI_SEND: &#39;  D &#39; &#39; SIZE(S)
         S = CHAR(1) CHAR(D)
+            CHAR(FCGI_REQUESTID / 256) CHAR(REMDR(FCGI_REQUESTID, 256))
+            CHAR(SIZE(S) / 256) CHAR(REMDR(SIZE(S), 256))
+            CHAR(0) CHAR(0) S
         FCGI_OUT = S                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FCGI_SEND
         FCGI_SEND_(FCGI_STDOUT, S)                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FCGI_SEND_ERR
         FCGI_SEND_(FCGI_STDERR, S)                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FCGI_END FCGI_LOG = &#39;FCGI_END: &#39; APP_STATUS &#39; &#39; PROT_STATUS
         B3 = APP_STATUS / 16777216
         APP_STATUS = REMDR(APP_STATUS, 16777216)
         B2 = APP_STATUS / 65536
         APP_STATUS = REMDR(APP_STATUS, 65536)
         B1 = APP_STATUS / 256
         B0 = REMDR(APP_STATUS, 256)
         S = CHAR(B3) CHAR(B2) CHAR(B1) CHAR(B0) CHAR(PROT_STATUS)
+            CHAR(0) CHAR(0) CHAR(0)
         B1 = FCGI_REQUESTID / 256
         B0 = REMDR(FCGI_REQUESTID, 256)
         S = CHAR(1) CHAR(FCGI_END_REQUEST) CHAR(B1) CHAR(B0)
+            CHAR(0) CHAR(8) CHAR(0) CHAR(0) S
         FCGI_OUT = S                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FCGI_GET VERSION = ORD(FCGI)
         FCGI_LOG = DIFFER(VERSION, 1) &#39;VERSION &lt;&gt; 1&#39;            <b>:S(END)</b>
         TYPE = ORD(FCGI)
         REQUESTID = ORD(FCGI) * 256
         REQUESTID = REQUESTID + ORD(FCGI)
         CONTENTLENGTH = ORD(FCGI) * 256
         CONTENTLENGTH = CONTENTLENGTH + ORD(FCGI)
         PADDINGLENGTH = ORD(FCGI)
         RESERVED = ORD(FCGI)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE COULD READ THIS IN ONE GULP, AND AVOID CONVERTING TO ARRAY AND</i></font>
<font color="#818181"><i>* THEN BACK INTO STRING.</i></font>
<font color="#818181"><i>*</i></font>
         FCGI_GET = NE(CONTENTLENGTH) ARRAY(CONTENTLENGTH)
         I = 1
FCGI_4   GT(I, CONTENTLENGTH)                                 <b>:S(FCGI_5)</b>
         FCGI_GET&lt;I&gt; = ORD(FCGI)
         I = I + 1                                             <b>:(FCGI_4)</b>
FCGI_5   I = 1
FCGI_6   GT(I, PADDINGLENGTH)                                 <b>:S(RETURN)</b>
         S = FCGI
         I = I + 1                                             <b>:(FCGI_6)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EXTRACT NAMES FROM ARRAY. TWO LENGTH FIELDS, EITHER 1 OR 4 BYTES,</i></font>
<font color="#818181"><i>* THEN THE ACTUAL NAME AND DATA.</i></font>
<font color="#818181"><i>*</i></font>
FCGI_NAMES
         I = 1
FCGI_NAMES_7
         NL = A&lt;I&gt;
         EQ(AND(NL, 128))                               <b>:S(FCGI_NAMES_2)</b>
         NL = AND(A&lt;I&gt;, 127) * 16777216 +
+             A&lt;I + 1&gt; * 65536 +
+             A&lt;I + 2&gt; * 256 +
+             A&lt;I + 3&gt;
         I = I + 3
FCGI_NAMES_2
         I = I + 1
         DL = A&lt;I&gt;
         EQ(AND(NL, 128))                               <b>:S(FCGI_NAMES_3)</b>
         DL = AND(A&lt;I&gt;, 127) * 16777216 +
+             A&lt;I + 1&gt; * 65536 +
+             A&lt;I + 2&gt; * 256 +
+             A&lt;I + 3&gt;
         I = I + 3
FCGI_NAMES_3
         I = I + 1
         NM =
         DA =
FCGI_NAMES_4
         EQ(NL)                                         <b>:S(FCGI_NAMES_5)</b>
         NM = NM CHAR(A&lt;I&gt;)
         I = I + 1
         NL = NL - 1                                     <b>:(FCGI_NAMES_4)</b>
FCGI_NAMES_5
         EQ(DL)                                         <b>:S(FCGI_NAMES_6)</b>
         DA = DA CHAR(A&lt;I&gt;)
         I = I + 1
         DL = DL - 1                                     <b>:(FCGI_NAMES_5)</b>
FCGI_NAMES_6
         T&lt;NM&gt; = DA
         A&lt;I&gt;                                  <b>:F(RETURN)S(FCGI_NAMES_7)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAIN FCGI FUNCTION</i></font>
<font color="#818181"><i>*</i></font>
FCGI_ACCEPT
         IDENT(USE_FCGI)                                      <b>:S(RETURN)</b>
         FCGI_LOG = &#39;FCGI_ACCEPT: WAITING&#39;
         SOCKET = ACCEPT(FCGI_LISTENSOCK_FILENO, 0, 0)
         FCGI_LOG = &#39;AFTER ACCEPT&#39;
         GE(SOCKET)                                           <b>:S(FCGI_2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ON ERROR IN ACCEPT, WE DISPLAY ERRNO AND EXIT THE PROCESS</i></font>
<font color="#818181"><i>*</i></font>
         ERRNO = GET_ERRNO()
         FCGI_LOG = &#39;ACCEPT: ERRNO = &#39; ERRNO                      <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READ AND DIGEST PACKETS FROM SOCKET. CLEAN UP OLD INSTANCE I/O</i></font>
<font color="#818181"><i>* (FCGI IS GOING TO STAY AROUND EXECUTING REQUESTS). tHEN</i></font>
<font color="#818181"><i>* OPEN THE SOCKET PASSED TO US BY ACCEPT().</i></font>
<font color="#818181"><i>*</i></font>
FCGI_2   IDENT(FCGI_INSTANCE_UNIT)                            <b>:S(FCGI_8)</b>
         DETACH(.FCGI)
         DETACH(.FCGI_OUT)
         ENDFILE(FCGI_INSTANCE_UNIT)
FCGI_8   FCGI_LOG = &#39;SOCKET = &#39; SOCKET
         FCGI_INSTANCE_UNIT = IO_FINDUNIT()
         FCGI_LOG = &#39;UNIT = &#39; FCGI_INSTANCE_UNIT
         INPUT(.FCGI, FCGI_INSTANCE_UNIT, &#39;U,B,1&#39;, &#39;/dev/fd/&#39; SOCKET)
         OUTPUT(.FCGI_OUT, FCGI_INSTANCE_UNIT, &#39;W,B,1&#39;)
<font color="#818181"><i>*</i></font>
         FCGI_ENV = TABLE()
         FCGI_IN =
         FCGI_REQUESTID =
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PACKET LOOP</i></font>
<font color="#818181"><i>*</i></font>
FCGI_PLOOP
         CONTENT = FCGI_GET()
         FCGI_REQUESTID = IDENT(FCGI_REQUESTID) REQUESTID
         EQ(REQUESTID, FCGI_REQUESTID)                  <b>:S(FCGI_PLOOP_2)</b>
         FCGI_LOG = &#39;ONLY SINGLE REQUESTID SUPPORTED&#39;             <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE DO NOT MULTIPLEX REQUESTID, NEED TO SET INDICATION OF THAT</i></font>
<font color="#818181"><i>* IN FCGI_GET().</i></font>
<font color="#818181"><i>*</i></font>
FCGI_PLOOP_2
         EQ(TYPE, FCGI_BEGIN_REQUEST)                        <b>:F(FCGI_10)</b>
         FCGI_LOG = &#39;FCGI_BEGIN_REQUEST&#39;
         FCGI_ROLE = CONTENT&lt;1&gt; * 256 + CONTENT&lt;2&gt;
         FCGI_LOG = NE(FCGI_ROLE, FCGI_RESPONDER)
+           &#39;ROLE NOT RESPONDER&#39;                                 <b>:S(END)</b>
         FCGI_FLAGS = CONTENT&lt;3&gt;
         FCGI_REQUESTID = REQUESTID                        <b>:(FCGI_PLOOP)</b>
<font color="#818181"><i>*</i></font>
FCGI_10  EQ(TYPE, FCGI_PARAMS)                               <b>:F(FCGI_11)</b>
         FCGI_LOG = &#39;FCGI_PARAMS&#39;
         IDENT(CONTENT)                                   <b>:S(FCGI_PLOOP)</b>
         FCGI_NAMES(FCGI_ENV, CONTENT)                     <b>:(FCGI_PLOOP)</b>
<font color="#818181"><i>*</i></font>
FCGI_11  EQ(TYPE, FCGI_STDIN)                                <b>:F(FCGI_12)</b>
         FCGI_LOG = &#39;FCGI_STDIN&#39;
         IDENT(CONTENT)                                      <b>:S(FCGI_GO)</b>
         I = 1
<font color="#818181"><i>* FIXME: WE READ IT AS A STRING, CONVERT TO ARRAY OF SMALL INTEGERS,</i></font>
<font color="#818181"><i>* AND THEN MAKE IT A STRING AGAIN. THIS IS DONE BECAUSE WE ARE GOING</i></font>
<font color="#818181"><i>* TO DO PACKET DISASSEMBLY, AND THAT IS ARGUABLY EASIER IN THE SMALL</i></font>
<font color="#818181"><i>* INTEGER SPACE. STILL, IT SHOULD BE FIXED.</i></font>
FCGI_13  FCGI_IN = FCGI_IN CHAR(CONTENT&lt;I&gt;)               <b>:F(FCGI_PLOOP)</b>
         I = I + 1                                            <b>:(FCGI_13)</b>
<font color="#818181"><i>*</i></font>
FCGI_12
         FCGI_LOG = &#39;BAD TYPE: &#39; TYPE                             <b>:(END)</b>
<font color="#818181"><i>*</i></font>
FCGI_GO
         FCGI_LOG = &#39;FCGI_GO&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HERE WE ILLUSTRATE AN INTERESTING TECHNIQUE. SINCE JSON_ENCODE WILL</i></font>
<font color="#818181"><i>* TRAVERSE TABLES AND ARRAYS, WE CAN USE IT TO EXAMINE VARIABLES BY</i></font>
<font color="#818181"><i>* SENDING THE JSON ENCODING TO A LOG FILE.</i></font>
<font color="#818181"><i>*</i></font>
         FCGI_LOG = &#39;FCGI_ENV: &#39;
         FCGI_LOG = JSON_ENCODE(FCGI_ENV)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BUG ALERT: IF THIS IS NOT DONE, GETTIMEOFDAY(), GMTIME() ETC.</i></font>
<font color="#818181"><i>* FAULT ON THE SECOND PASS THROUGH FCGI. HAPPENS WITH CSNOBOL4 1.5</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TRY TO ISOLATE THIS FURTHER.</i></font>
<font color="#818181"><i>*</i></font>
         T = GETTIMEOFDAY()
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FCGI_END_
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         export &quot;SNOLIB=/export/home/fred/snolib/snolib&quot;; export &quot;SNOPATH=/export/home/fred/snolib/snolib&quot;
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FCGI.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL FCGI
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #######   #####    #####   ###                    *</i></font>
<font color="#818181"><i>*                    #        #     #  #     #   #                     *</i></font>
<font color="#818181"><i>*                    #        #        #         #                     *</i></font>
<font color="#818181"><i>*                    #####    #        #  ####   #                     *</i></font>
<font color="#818181"><i>*                    #        #        #     #   #                     *</i></font>
<font color="#818181"><i>*                    #        #     #  #     #   #                     *</i></font>
<font color="#818181"><i>*                    #         #####    #####   ###                    *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FCGI                   FCGI SUPPORT FUNCTIONS                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FCGI.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FCGI&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:44 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         export "SNOLIB=/export/home/fred/snolib/snolib"; export "SNOPATH=/export/home/fred/snolib/snolib"
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-LINE 295 "FCGI.lss"
-INCLUDE 'FCGI.INC'
*
         &CODE = 1
         &CODE = 0
END
<h1>FENCE - Match pattern once</h1>

Returns a pattern that only matches pattern P in a forward scan (once). This
means alternatives within P are discarded if P matches.

In a system implementation of FENCE(), alternatives really are
discarded. What happens here is that the first match for P sets
a flag that causes failure of other alternatives. In reality, all
alternatives in P are tested (possibly causing all kinds of side
effects). This shortcoming will be most problematic if alternatives
within P involve ABORT, FENCE, unevaluated expressions or unconditional
value assignment.

[[
'abbc' ('b' | rem)
    abbc
    b
    bbc
    b
    bc
    c
'abbc' fence('b' | rem)
    abbc
    b
    bbc
    bc
    c
]]

<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>

<<INCLUDES>>=
-INCLUDE 'UNIQUE.INC'
@

<<FENCE>>=
-MODULE FENCE
-PUBLIC FENCE()
        DEFINE('FENCE(P)N')                                 :(FENCE_END)
*
FENCE   N = UNIQUE()
        FENCE = EVAL('@' N
+                    ' P '
+                    ' "" $ *$(.' N ' DIFFER(' N '))'
+                   )                                          :(RETURN)
*
FENCE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FENCE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL FENCE
-EJECT
*
************************************************************************
*                                                                      *
*             #######  #######  #     #   #####   #######              *
*             #        #        ##    #  #     #  #                    *
*             #        #        # #   #  #        #                    *
*             #####    #####    #  #  #  #        #####                *
*             #        #        #   # #  #        #                    *
*             #        #        #    ##  #     #  #                    *
*             #        #######  #     #   #####   #######              *
*                                                                      *
************************************************************************
*
* FENCE.lss
*
<<FENCE>>
*
* CE: .MSNOBOL4;
@
-LINE 34 "FENCE.lss"
-INCLUDE 'UNIQUE.INC'
-STITL FENCE
-EJECT
-LINE 64 "FENCE.lss"
*
************************************************************************
*                                                                      *
*             #######  #######  #     #   #####   #######              *
*             #        #        ##    #  #     #  #                    *
*             #        #        # #   #  #        #                    *
*             #####    #####    #  #  #  #        #####                *
*             #        #        #   # #  #        #                    *
*             #        #        #    ##  #     #  #                    *
*             #        #######  #     #   #####   #######              *
*                                                                      *
************************************************************************
*
* FENCE.lss
*
-LINE 38 "FENCE.lss"
-MODULE FENCE
-PUBLIC FENCE()
        DEFINE('FENCE(P)N')                                 :(FENCE_END)
*
FENCE   N = UNIQUE()
        FENCE = EVAL('@' N
+                    ' P '
+                    ' "" $ *$(.' N ' DIFFER(' N '))'
+                   )                                          :(RETURN)
*
FENCE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FENCE - Match pattern once</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Returns a pattern that only matches pattern P in a forward scan (once). This
means alternatives within P are discarded if P matches.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
In a system implementation of FENCE(), alternatives really are
discarded. What happens here is that the first match for P sets
a flag that causes failure of other alternatives. In reality, all
alternatives in P are tested (possibly causing all kinds of side
effects). This shortcoming will be most problematic if alternatives
within P involve ABORT, FENCE, unevaluated expressions or unconditional
value assignment.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| 'abbc' ('b' | rem)
|     abbc
|     b
|     bbc
|     b
|     bc
|     c
| 'abbc' fence('b' | rem)
|     abbc
|     b
|     bbc
|     bc
|     c
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FENCE&raquo;&equiv;</b>
-MODULE FENCE
-PUBLIC FENCE()
        DEFINE(&#39;FENCE(P)N&#39;)                                 <b>:(FENCE_END)</b>
<font color="#818181"><i>*</i></font>
FENCE   N = UNIQUE()
        FENCE = EVAL(&#39;@&#39; N
+                    &#39; P &#39;
+                    &#39; &quot;&quot; $ *$(.&#39; N &#39; DIFFER(&#39; N &#39;))&#39;
+                   )                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FENCE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FENCE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL FENCE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             #######  #######  #     #   #####   #######              *</i></font>
<font color="#818181"><i>*             #        #        ##    #  #     #  #                    *</i></font>
<font color="#818181"><i>*             #        #        # #   #  #        #                    *</i></font>
<font color="#818181"><i>*             #####    #####    #  #  #  #        #####                *</i></font>
<font color="#818181"><i>*             #        #        #   # #  #        #                    *</i></font>
<font color="#818181"><i>*             #        #        #    ##  #     #  #                    *</i></font>
<font color="#818181"><i>*             #        #######  #     #   #####   #######              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FENCE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FENCE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:01 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FENCE.INC'
-LINE 55 "FENCE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>FFI - Foreign Function Interface</h1>

An interface to [[libffi]] providing a Foreign Function Interface
(FFI) for SNOBOL4.

<h2>Uses</h2>

When building, the following INCLUDEs are also needed:

<a href="BQ.html">BQ</a><br>
<a href="DYNAMIC.html">DYNAMIC</a><br>
<a href="WRAPPER.html">WRAPPER</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="SEQ.html">SEQ</a>

<<INCLUDES>>=
@

<<FFI>>=
-MODULE FFI
-CASE 1
-PLUSOPS 1
@

When building ffi.so the following INCLUDES are needed.

<<FFI>>=
-SNOBOL SLOAD('BQ.INC')
-SNOBOL SLOAD('DYNAMIC.INC')
-SNOBOL SLOAD('WRAPPER.INC')
-SNOBOL SLOAD('CRACK.INC')
-SNOBOL SLOAD('SEQ.INC')
-SNOBOL TERMINAL = 'FFI (MON NOV 11 12:50:40 EST 2013)'
@

<<FFI>>=
-EMBED C 'ffi'
@

<<FFI,TYPE=C>>=
-SNOBOL WRAPPER_STARTFILE(.EMBED)

#include <ffi.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>

static int errors;
static ffi_status ffi_error;

@

Interpret types - these are expressed as strings, separated by comma.
Spaces are ignored.

[[
U8, U16, U32, U64
S8, S16, S32, S64
F, D, E for FLOAT, DOUBLE, EXTENDED (E is LONG DOUBLE)
C, T, I, L, P for CHAR, SHORT, INT, LONG, POINTER
]]

Default is SIGNED, 32 bit
Examine string encoded type in [[**s]], return ffi_type pointer,
or NULL. Increment [[errors]] on an error.

<<FFI,TYPE=C>>=

static void *interpret_ptype(char **s)
{
    int w = 32;
    int t = 2;
    if (**s == ',')
	++(*s);
    if (**s == 0)
	return NULL;
    for (; **s && (**s != ','); ++(*s)) {
	switch (**s) {
	case ' ':
	case '3':
	case '6':         break;
	case 'v':
	case 'V': t =  0; break;
	case 'u':
	case 'U': t =  1; break;
	case 's':
	case 'S': t =  2; break;
	case 'f':
	case 'F': t =  3; break;
	case 'd':
	case 'D': t =  4; break;
	case 'p':
	case 'P': t =  5; break;
	case 'e':
	case 'E': t =  6; break;
	case 'c':
	case 'C':
	case '8': w =  8; break;
	case '1': w = 16; break;
	case 'i':
	case 'I':
	case '2': w = 32; break;
	case 'l':
	case 'L':
	case '4': w = 64; break;
	default: ++errors; return NULL;
	}
    }
    switch (t) {
    case 0: return &ffi_type_void;
    case 1: switch (w) {
	    case  8: return &ffi_type_uint8;
	    case 16: return &ffi_type_uint16;
	    case 32: return &ffi_type_uint32;
	    case 64: return &ffi_type_uint64;
	    default: ++errors; return NULL;
	    }
    case 2: switch (w) {
	    case  8: return &ffi_type_sint8;
	    case 16: return &ffi_type_sint16;
	    case 32: return &ffi_type_sint32;
	    case 64: return &ffi_type_sint64;
	    default: +errors; return NULL;
	    }
    case 3: return &ffi_type_float;
    case 4: return &ffi_type_double;
    case 5: return &ffi_type_pointer;
    case 6: return &ffi_type_longdouble;
    default: ++errors; return NULL;
    }
    ++errors;
    return NULL;
}

@

Structure describing an FFI call. Contains the [[ffi_cif]],
vectors for the argument types, argument pointers [[arg_ptrs]], the
[[result]] and its type ([[result_type]]), [[nargs]] - number of
arguments, and a vector which indicates whether [[free()]] is needed
on the parameter after the call returns.

<<FFI,TYPE=C>>=

typedef struct {
    ffi_cif *cif;
    ffi_type **arg_types;
    ffi_arg *arg_values;
    void **arg_ptrs;
    int *arg_needfree;
    ffi_type *result_type;
    ffi_arg result;
    int nargs;
    void *callp;
} ffi_t;

@

Create a new FFI descriptor, given return type [[*r]] with argument
types [[*s]]. Return 0 on error, else the new descriptor.

<<FFI,TYPE=C>>=

static long ffi_new(char *r, char *s)
{
    ffi_t *ffip;
    int n = 0;
    char *s2 = s;
    ffi_error = FFI_OK;
    ffip = malloc(sizeof(ffi_t));
    if (ffip == NULL) {
	return 0;
    }
    ffip->result_type = interpret_ptype(&r);
    if (ffip->result_type == NULL) {
	return 0;
    }
    errors = 0;
    while (interpret_ptype(&s)) {
	++n;
	if (errors)
	    return 0;
    }
    ffip->nargs = n;
    if (n == 0)
	n = 1;
    ffip->cif = malloc(sizeof(ffi_cif));
    ffip->arg_types = malloc((n + 1) * (sizeof(ffi_type *)));
    ffip->arg_values = malloc((n + 1) * (sizeof(ffi_arg)));
    ffip->arg_needfree = malloc((n + 1) * (sizeof(int)));
    ffip->arg_ptrs = malloc((n + 1) * (sizeof(void *)));
    if ((ffip->arg_types == NULL) ||
	(ffip->arg_values == NULL) ||
	(ffip->arg_ptrs == NULL) ||
	(ffip->arg_needfree == NULL) ||
	(ffip->cif == NULL))
	return 0;
    s = s2;
    n = 0;
    while ((ffip->arg_types[n] = interpret_ptype(&s)) != NULL) {
	ffip->arg_ptrs[n] = &ffip->arg_values[n];
	ffip->arg_needfree[n] = 0;
	++n;
    }
    ffi_error = ffi_prep_cif(ffip->cif,
			     FFI_DEFAULT_ABI,
			     ffip->nargs,
			     ffip->result_type,
			     ffip->arg_types);
    if (ffi_error != FFI_OK)
	return 0;
    return (long)ffip;
}

-SNOBOL C_WRAPPER_PROTO('FFI_NEW(STRING,STRING)LONG', .EMBED)

@

Clear FFI descriptor after a call has been made. Deallocates
([[free()]]) any parameters indicated by [[arg_needfree]].

<<FFI,TYPE=C>>=

static void ffi_clear(long p)
{
    ffi_t *ffip = (void *)p;
    int i;
    for (i = 0; i < ffip->nargs; ++i) {
	if (ffip->arg_needfree[i]) {
	    free((void *)ffip->arg_values[i]);
	    ffip->arg_needfree[i] = 0;
	}
    }
}

-SNOBOL C_WRAPPER_PROTO('FFI_CLEAR(LONG)', .EMBED)

@

Destroy FFI descriptor.

<<FFI,TYPE=C>>=

static void ffi_free(long p)
{
    ffi_t *ffip = (void *)p;
    free(ffip->arg_values);
    free(ffip->arg_types);
    free(ffip->arg_needfree);
    free(ffip->cif);
    free(ffip);
}

-SNOBOL C_WRAPPER_PROTO('FFI_FREE(LONG)', .EMBED)

@

Indicate that parameter [[n]] (counting from 1) requires deallocation
([[free()]]) after call.

<<FFI,TYPE=C>>=

static int ffi_par_n_needfree(long p,int n)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_needfree[n - 1] = 1;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_NEEDFREE(LONG,INTEGER)PREDICATE',   +
           .EMBED)

@

Set value of parameter [[n]] to integer [[v]] (32 bit).

<<FFI,TYPE=C>>=

static int ffi_par_n_integer(long p, int n, int v)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_values[n - 1] = v;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_INTEGER('                       +
                        'LONG,INTEGER,INTEGER)PREDICATE', .EMBED)

@

Set value of parameter [[n]] to double [[v]]. Nominally type [[double]]
but this should be useable to get a REAL parameter into a double.

<<FFI,TYPE=C>>=

static int ffi_par_n_real(long p, int n, double v)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_values[n - 1] = v;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_REAL('                              +
                        'LONG,INTEGER,REAL)PREDICATE', .EMBED)

@

Set value of parameter [[n]] to 64 bit [[p]]. [[p2]] will be the
FFI descriptor and [[p]] the 64 bit long or pointer argument.

<<FFI,TYPE=C>>=

static int ffi_par_n_ptr(long p, int n, long p2)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_values[n - 1] = (long)p2;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_PTR(LONG,INTEGER,LONG)PREDICATE',   +
                        .EMBED)

@

Set value of parameter [[n]] to float [[f]].

<<FFI,TYPE=C>>=

static int ffi_par_n_f(long p, int n, double f)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_values[n - 1] = (float)f;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_F(LONG,INTEGER,REAL)PREDICATE',     +
                        .EMBED)

@

Set value of parameter [[n]] to double [[d]].

<<FFI,TYPE=C>>=

static int ffi_par_n_d(long p, int n, double d)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_values[n - 1] = (double)d;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_D(LONG,INTEGER,REAL)PREDICATE',     +
                        .EMBED)

@

Set value of parameter [[n]] to long double [[ld]].

<<FFI,TYPE=C>>=

static int ffi_par_n_ld(long p, int n, double d)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
	return 0;
    ffip->arg_values[n - 1] = (long double)d;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_LD(LONG,INTEGER,REAL)PREDICATE',    +
                        .EMBED)

@

Set value of parameter [[n]] to string [[s]]. Uses [[strdup()]] to make
a copy of the string, and marks it for [[free()]] after call returns.

<<FFI,TYPE=C>>=

static int ffi_par_n_string(long p, int n, char *s)
{
    ffi_t *ffip = (void *)p;
    if ((n < 1) || (n > ffip->nargs))
        return 0;
    ffip->arg_values[n - 1] = (long)strdup(s);
    if (ffip->arg_values[n - 1] == (long)NULL)
        return 0;
    ffip->arg_needfree[n - 1] = 1;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO('FFI_PAR_N_STRING('                            +
                        'LONG,INTEGER,STRING)PREDICATE', .EMBED)

@

Set pointer to function in FFI descriptor.

<<FFI,TYPE=C>>=

/* CIF in P2, FN in P */
static void ffi_set_callp(long p2, long p)
{
    ffi_t *ffip = (void *)p2;
    ffip->callp = (void *)p;
}

-SNOBOL C_WRAPPER_PROTO('FFI_SET_CALLP(LONG,LONG)', .EMBED)

@

Call FFI function.

<<FFI,TYPE=C>>=

static void call_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip->cif, FFI_FN(ffip->callp),
	     &ffip->result, ffip->arg_ptrs);
}

-SNOBOL C_WRAPPER_PROTO('CALL_FFI(LONG)', .EMBED)

/* Return address of call result, use peek_() function to retrieve */
static long ffi_resultp(long p)
{
    ffi_t *ffip = (void *)p;
    return (long)(&(ffip->result));
}

-SNOBOL C_WRAPPER_PROTO('FFI_RESULTP(LONG)LONG', .EMBED)

@

Simplified calls, actually returning result (instead of just leaving
it in the ffi structure).

<<FFI,TYPE=C>>=

static int call_integer_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip->cif, FFI_FN(ffip->callp),
	     &ffip->result, ffip->arg_ptrs);
    return ffip->result;
}

-SNOBOL C_WRAPPER_PROTO('CALL_INTEGER_FFI(LONG)INTEGER', .EMBED)

static long call_ptr_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip->cif, FFI_FN(ffip->callp),
	     &ffip->result, ffip->arg_ptrs);
    return ffip->result;
}

-SNOBOL C_WRAPPER_PROTO('CALL_PTR_FFI(LONG)LONG', .EMBED)

static double call_real_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip->cif, FFI_FN(ffip->callp),
	     &ffip->result, ffip->arg_ptrs);
    return ffip->result;
}

-SNOBOL C_WRAPPER_PROTO('CALL_REAL_FFI(LONG)REAL', .EMBED)

static char *call_string_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip->cif, FFI_FN(ffip->callp),
	     &ffip->result, ffip->arg_ptrs);
    return (char *)ffip->result;
}

-SNOBOL C_WRAPPER_PROTO('CALL_STRING_FFI(LONG)STRING', .EMBED)

@

DL (Dynamic Library) functions, Open, close, retrieve error and
resolve symbols in an external library (or within the program itself,
if a handle of NULL is used).

<<FFI,TYPE=C>>=

/* DL functions
 */
static long dlopen_(char *s, int n) { return (long)dlopen(s, n); }

-SNOBOL C_WRAPPER_PROTO('DLOPEN_(STRING,INTEGER)LONG', .EMBED)

static char *dlerror_(void)
{
    char *s = dlerror();
    if (s == NULL) return "";
    return s;
}

-SNOBOL C_WRAPPER_PROTO('DLERROR_()STRING', .EMBED)

static long dlsym_(long p, char *s)
{
    return (long)dlsym((void *)p, s);
}

-SNOBOL C_WRAPPER_PROTO('DLSYM_(LONG,STRING)LONG', .EMBED)

static int dlclose_(long p) { return dlclose((void *)p); }

-SNOBOL C_WRAPPER_PROTO('DLCLOSE_(LONG)INTEGER', .EMBED)

-END
@

Build ffi.so.

<<FFI>>=
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(ffi) :F(ERROR) ;
-SNOBOL LIBS = '-lffi -ldl'
-SNOBOL OBJECTS = ffi ; OBJECTS '.c' = '.o'
-SNOBOL LINK_DYNAMIC('./ffi', OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS FFI.SO
-CMNT -SNOBOL A = CRACK(ffi ' ' OBJECTS, ' ')
-CMNT -SNOBOL SEQ(' DELETE(A<K>) ', .K)
@

Actually [[LOAD()]] the functions defined into CSNOBOL4.

<<FFI>>=
         LOAD('FFI_FREE(INTEGER)', 'ffi.so')
         LOAD('FFI_CLEAR(INTEGER)', 'ffi.so')
         LOAD('FFI_NEW(STRING,STRING)INTEGER', 'ffi.so')
         LOAD('FFI_PAR_N_NEEDFREE(INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_INTEGER(INTEGER,INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_PTR(INTEGER,INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_REAL(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_PAR_N_STRING(INTEGER,INTEGER,STRING)', 'ffi.so')
         LOAD('FFI_PAR_N_P(INTEGER,INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_F(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_PAR_N_D(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_PAR_N_LD(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_SET_CALLP(INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_RESULTP(INTEGER)INTEGER', 'ffi.so')
         LOAD('CALL_FFI(INTEGER)', 'ffi.so')
         LOAD('CALL_INTEGER_FFI(INTEGER)INTEGER', 'ffi.so')
         LOAD('CALL_PTR_FFI(INTEGER)INTEGER', 'ffi.so')
         LOAD('CALL_REAL_FFI(INTEGER)REAL', 'ffi.so')
         LOAD('CALL_STRING_FFI(INTEGER)STRING', 'ffi.so')
*
         RTLD_LAZY   = 1
         RTLD_NOW    = 2
         RTLD_GLOBAL = 256
         RTLD_LOCAL  = 0
*
         LOAD('DLOPEN_(STRING,INTEGER)INTEGER', 'ffi.so')
         LOAD('DLERROR_()STRING', 'ffi.so')
         LOAD('DLSYM_(INTEGER,STRING)', 'ffi.so')
         LOAD('DLCLOSE_(INTEGER)INTEGER', 'ffi.so')
*
@

The actual API for FFI.

<<FFI>>=
-PUBLIC DLOPEN(), DLERROR(), DLSYM(), DLCLOSE()
*
         DEFINE('DLOPEN(S,I)')
         DEFINE('DLERROR()')
         DEFINE('DLSYM(H,S)')
         DEFINE('DLCLOSE(H)')
*
-PUBLIC FFI_NEW(), FFI_FREE(), FFI_CLEAR(), FFI_PAR_N_NEEDFREE()
-PUBLIC FFI_PAR_N_INTEGER(), FFI_PAR_N_PTR(), FFI_PAR_N_REAL()
-PUBLIC FFI_PAR_N_STRING(),  FFI_SET_CALLP()
-PUBLIC FFI_CALL_VOID(), FFI_CALL_INTEGER(), FFI_CALL_REAL()
-PUBLIC FFI_CALL_STRING(), FFI_CALL_PTR(), CALL_FFI(), FFI_RESULTP()
*
         DEFINE('FFI_CALL_INTEGER(FFI)')
         DEFINE('FFI_CALL_REAL(FFI)')
         DEFINE('FFI_CALL_STRING(FFI)')
         DEFINE('FFI_CALL_PTR(FFI)')
         DEFINE('FFI_CALL_VOID(FFI)')                         :(FFI_END)
*
DLOPEN   DLOPEN = DLOPEN_(S, I)                                :(RETURN)
*
DLERROR  DLERROR = DLERROR_()                                  :(RETURN)
*
DLSYM    DLSYM = DLSYM_(H, S)                                  :(RETURN)
*
DLCLOSE  DLCLOSE = DLCLOSE_(H)                                 :(RETURN)
*
FFI_CALL_VOID
         CALL_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_INTEGER
         FFI_CALL_INTEGER = CALL_INTEGER_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_REAL
         FFI_CALL_REAL = CALL_REAL_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_STRING
         FFI_CALL_STRING = CALL_STRING_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_PTR
         FFI_CALL_PTR = CALL_PTR_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FFI.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL FFI
-EJECT
*
************************************************************************
*                                                                      *
*                         #######  #######  ###                        *
*                         #        #         #                         *
*                         #        #         #                         *
*                         #####    #####     #                         *
*                         #        #         #                         *
*                         #        #         #                         *
*                         #        #        ###                        *
*                                                                      *
* FFI                  FOREIGN FUNCTION INTERFACE                      *
*                                                                      *
************************************************************************
*
* FFI.lss
*
<<FFI>>
*
* CE: .F.MSNOBOL4;
@
-LINE 17 "FFI.lss"
-STITL FFI
-EJECT
-LINE 647 "FFI.lss"
*
************************************************************************
*                                                                      *
*                         #######  #######  ###                        *
*                         #        #         #                         *
*                         #        #         #                         *
*                         #####    #####     #                         *
*                         #        #         #                         *
*                         #        #         #                         *
*                         #        #        ###                        *
*                                                                      *
* FFI                  FOREIGN FUNCTION INTERFACE                      *
*                                                                      *
************************************************************************
*
* FFI.lss
*
-LINE 20 "FFI.lss"
-MODULE FFI
-CASE 1
-PLUSOPS 1
-LINE 28 "FFI.lss"
-LINE 29 "FFI.lss"
-LINE 30 "FFI.lss"
-LINE 31 "FFI.lss"
-LINE 32 "FFI.lss"
-LINE 33 "FFI.lss"
-LINE 34 "FFI.lss"
-LINE 37 "FFI.lss"
         ffi = 'ffi.c'
-LINE 534 "FFI.lss"
-LINE 535 "FFI.lss"
-LINE 536 "FFI.lss"
-LINE 537 "FFI.lss"
-LINE 538 "FFI.lss"
-LINE 539 "FFI.lss"
-LINE 549 "FFI.lss"
         LOAD('FFI_FREE(INTEGER)', 'ffi.so')
         LOAD('FFI_CLEAR(INTEGER)', 'ffi.so')
         LOAD('FFI_NEW(STRING,STRING)INTEGER', 'ffi.so')
         LOAD('FFI_PAR_N_NEEDFREE(INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_INTEGER(INTEGER,INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_PTR(INTEGER,INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_REAL(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_PAR_N_STRING(INTEGER,INTEGER,STRING)', 'ffi.so')
         LOAD('FFI_PAR_N_P(INTEGER,INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_PAR_N_F(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_PAR_N_D(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_PAR_N_LD(INTEGER,INTEGER,REAL)', 'ffi.so')
         LOAD('FFI_SET_CALLP(INTEGER,INTEGER)', 'ffi.so')
         LOAD('FFI_RESULTP(INTEGER)INTEGER', 'ffi.so')
         LOAD('CALL_FFI(INTEGER)', 'ffi.so')
         LOAD('CALL_INTEGER_FFI(INTEGER)INTEGER', 'ffi.so')
         LOAD('CALL_PTR_FFI(INTEGER)INTEGER', 'ffi.so')
         LOAD('CALL_REAL_FFI(INTEGER)REAL', 'ffi.so')
         LOAD('CALL_STRING_FFI(INTEGER)STRING', 'ffi.so')
*
         RTLD_LAZY   = 1
         RTLD_NOW    = 2
         RTLD_GLOBAL = 256
         RTLD_LOCAL  = 0
*
         LOAD('DLOPEN_(STRING,INTEGER)INTEGER', 'ffi.so')
         LOAD('DLERROR_()STRING', 'ffi.so')
         LOAD('DLSYM_(INTEGER,STRING)', 'ffi.so')
         LOAD('DLCLOSE_(INTEGER)INTEGER', 'ffi.so')
*
-LINE 584 "FFI.lss"
-PUBLIC DLOPEN(), DLERROR(), DLSYM(), DLCLOSE()
*
         DEFINE('DLOPEN(S,I)')
         DEFINE('DLERROR()')
         DEFINE('DLSYM(H,S)')
         DEFINE('DLCLOSE(H)')
*
-PUBLIC FFI_NEW(), FFI_FREE(), FFI_CLEAR(), FFI_PAR_N_NEEDFREE()
-PUBLIC FFI_PAR_N_INTEGER(), FFI_PAR_N_PTR(), FFI_PAR_N_REAL()
-PUBLIC FFI_PAR_N_STRING(),  FFI_SET_CALLP()
-PUBLIC FFI_CALL_VOID(), FFI_CALL_INTEGER(), FFI_CALL_REAL()
-PUBLIC FFI_CALL_STRING(), FFI_CALL_PTR(), CALL_FFI(), FFI_RESULTP()
*
         DEFINE('FFI_CALL_INTEGER(FFI)')
         DEFINE('FFI_CALL_REAL(FFI)')
         DEFINE('FFI_CALL_STRING(FFI)')
         DEFINE('FFI_CALL_PTR(FFI)')
         DEFINE('FFI_CALL_VOID(FFI)')                         :(FFI_END)
*
DLOPEN   DLOPEN = DLOPEN_(S, I)                                :(RETURN)
*
DLERROR  DLERROR = DLERROR_()                                  :(RETURN)
*
DLSYM    DLSYM = DLSYM_(H, S)                                  :(RETURN)
*
DLCLOSE  DLCLOSE = DLCLOSE_(H)                                 :(RETURN)
*
FFI_CALL_VOID
         CALL_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_INTEGER
         FFI_CALL_INTEGER = CALL_INTEGER_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_REAL
         FFI_CALL_REAL = CALL_REAL_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_STRING
         FFI_CALL_STRING = CALL_STRING_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_CALL_PTR
         FFI_CALL_PTR = CALL_PTR_FFI(FFI)
         FFI_CLEAR(FFI)                                        :(RETURN)
*
FFI_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FFI - Foreign Function Interface</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
An interface to <font face="Source Code Pro">libffi</font> providing a Foreign Function Interface
(FFI) for SNOBOL4.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
When building, the following INCLUDEs are also needed:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<a href="BQ.html">BQ</a><br>
<a href="DYNAMIC.html">DYNAMIC</a><br>
<a href="WRAPPER.html">WRAPPER</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="SEQ.html">SEQ</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI&raquo;&equiv;</b>
-MODULE FFI
-CASE 1
-PLUSOPS 1
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
When building ffi.so the following INCLUDES are needed.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI&raquo;&equiv;</b>
-SNOBOL SLOAD(&#39;BQ.INC&#39;)
-SNOBOL SLOAD(&#39;DYNAMIC.INC&#39;)
-SNOBOL SLOAD(&#39;WRAPPER.INC&#39;)
-SNOBOL SLOAD(&#39;CRACK.INC&#39;)
-SNOBOL SLOAD(&#39;SEQ.INC&#39;)
-SNOBOL TERMINAL = &#39;FFI (MON NOV 11 12:50:40 EST 2013)&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI&raquo;&equiv;</b>
-EMBED C &#39;ffi&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>
-SNOBOL WRAPPER_STARTFILE(.EMBED)

<font color="#818181"><i>#include &lt;ffi.h&gt;</i></font>
<font color="#818181"><i>#include &lt;stdio.h&gt;</i></font>
<font color="#818181"><i>#include &lt;stdlib.h&gt;</i></font>
<font color="#818181"><i>#include &lt;string.h&gt;</i></font>
<font color="#818181"><i>#include &lt;dlfcn.h&gt;</i></font>

static int errors;
static ffi_status ffi_error;

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Interpret types - these are expressed as strings, separated by comma.
Spaces are ignored.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| U8, U16, U32, U64
| S8, S16, S32, S64
| F, D, E for FLOAT, DOUBLE, EXTENDED (E is LONG DOUBLE)
| C, T, I, L, P for CHAR, SHORT, INT, LONG, POINTER
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Default is SIGNED, 32 bit
Examine string encoded type in <font face="Source Code Pro">**s</font>, return ffi_type pointer,
or NULL. Increment <font face="Source Code Pro">errors</font> on an error.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static void *interpret_ptype(char **s)
{
    int w = 32;
    int t = 2;
    if (**s == &#39;,&#39;)
	++(*s);
    if (**s == 0)
	return NULL;
    for (; **s &amp;&amp; (**s != &#39;,&#39;); ++(*s)) {
	switch (**s) {
	case &#39; &#39;:
	case &#39;3&#39;:
	case &#39;6&#39;:         break;
	case &#39;v&#39;:
	case &#39;V&#39;: t =  0; break;
	case &#39;u&#39;:
	case &#39;U&#39;: t =  1; break;
	case &#39;s&#39;:
	case &#39;S&#39;: t =  2; break;
	case &#39;f&#39;:
	case &#39;F&#39;: t =  3; break;
	case &#39;d&#39;:
	case &#39;D&#39;: t =  4; break;
	case &#39;p&#39;:
	case &#39;P&#39;: t =  5; break;
	case &#39;e&#39;:
	case &#39;E&#39;: t =  6; break;
	case &#39;c&#39;:
	case &#39;C&#39;:
	case &#39;8&#39;: w =  8; break;
	case &#39;1&#39;: w = 16; break;
	case &#39;i&#39;:
	case &#39;I&#39;:
	case &#39;2&#39;: w = 32; break;
	case &#39;l&#39;:
	case &#39;L&#39;:
	case &#39;4&#39;: w = 64; break;
	default: ++errors; return NULL;
	}
    }
    switch (t) {
    case 0: return &amp;ffi_type_void;
    case 1: switch (w) {
	    case  8: return &amp;ffi_type_uint8;
	    case 16: return &amp;ffi_type_uint16;
	    case 32: return &amp;ffi_type_uint32;
	    case 64: return &amp;ffi_type_uint64;
	    default: ++errors; return NULL;
	    }
    case 2: switch (w) {
	    case  8: return &amp;ffi_type_sint8;
	    case 16: return &amp;ffi_type_sint16;
	    case 32: return &amp;ffi_type_sint32;
	    case 64: return &amp;ffi_type_sint64;
	    default: +errors; return NULL;
	    }
    case 3: return &amp;ffi_type_float;
    case 4: return &amp;ffi_type_double;
    case 5: return &amp;ffi_type_pointer;
    case 6: return &amp;ffi_type_longdouble;
    default: ++errors; return NULL;
    }
    ++errors;
    return NULL;
}

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Structure describing an FFI call. Contains the <font face="Source Code Pro">ffi_cif</font>,
vectors for the argument types, argument pointers <font face="Source Code Pro">arg_ptrs</font>, the
<font face="Source Code Pro">result</font> and its type (<font face="Source Code Pro">result_type</font>), <font face="Source Code Pro">nargs</font> - number of
arguments, and a vector which indicates whether <font face="Source Code Pro">free()</font> is needed
on the parameter after the call returns.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

typedef struct {
    ffi_cif *cif;
    ffi_type **arg_types;
    ffi_arg *arg_values;
    void **arg_ptrs;
    int *arg_needfree;
    ffi_type *result_type;
    ffi_arg result;
    int nargs;
    void *callp;
} ffi_t;

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Create a new FFI descriptor, given return type <font face="Source Code Pro">*r</font> with argument
types <font face="Source Code Pro">*s</font>. Return 0 on error, else the new descriptor.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static long ffi_new(char *r, char *s)
{
    ffi_t *ffip;
    int n = 0;
    char *s2 = s;
    ffi_error = FFI_OK;
    ffip = malloc(sizeof(ffi_t));
    if (ffip == NULL) {
	return 0;
    }
    ffip-&gt;result_type = interpret_ptype(&amp;r);
    if (ffip-&gt;result_type == NULL) {
	return 0;
    }
    errors = 0;
    while (interpret_ptype(&amp;s)) {
	++n;
	if (errors)
	    return 0;
    }
    ffip-&gt;nargs = n;
    if (n == 0)
	n = 1;
    ffip-&gt;cif = malloc(sizeof(ffi_cif));
    ffip-&gt;arg_types = malloc((n + 1) * (sizeof(ffi_type *)));
    ffip-&gt;arg_values = malloc((n + 1) * (sizeof(ffi_arg)));
    ffip-&gt;arg_needfree = malloc((n + 1) * (sizeof(int)));
    ffip-&gt;arg_ptrs = malloc((n + 1) * (sizeof(void *)));
    if ((ffip-&gt;arg_types == NULL) ||
	(ffip-&gt;arg_values == NULL) ||
	(ffip-&gt;arg_ptrs == NULL) ||
	(ffip-&gt;arg_needfree == NULL) ||
	(ffip-&gt;cif == NULL))
	return 0;
    s = s2;
    n = 0;
    while ((ffip-&gt;arg_types[n] = interpret_ptype(&amp;s)) != NULL) {
	ffip-&gt;arg_ptrs[n] = &amp;ffip-&gt;arg_values[n];
	ffip-&gt;arg_needfree[n] = 0;
	++n;
    }
    ffi_error = ffi_prep_cif(ffip-&gt;cif,
			     FFI_DEFAULT_ABI,
			     ffip-&gt;nargs,
			     ffip-&gt;result_type,
			     ffip-&gt;arg_types);
    if (ffi_error != FFI_OK)
	return 0;
    return (long)ffip;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_NEW(STRING,STRING)LONG&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Clear FFI descriptor after a call has been made. Deallocates
(<font face="Source Code Pro">free()</font>) any parameters indicated by <font face="Source Code Pro">arg_needfree</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static void ffi_clear(long p)
{
    ffi_t *ffip = (void *)p;
    int i;
    for (i = 0; i &lt; ffip-&gt;nargs; ++i) {
	if (ffip-&gt;arg_needfree[i]) {
	    free((void *)ffip-&gt;arg_values[i]);
	    ffip-&gt;arg_needfree[i] = 0;
	}
    }
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_CLEAR(LONG)&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Destroy FFI descriptor.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static void ffi_free(long p)
{
    ffi_t *ffip = (void *)p;
    free(ffip-&gt;arg_values);
    free(ffip-&gt;arg_types);
    free(ffip-&gt;arg_needfree);
    free(ffip-&gt;cif);
    free(ffip);
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_FREE(LONG)&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Indicate that parameter <font face="Source Code Pro">n</font> (counting from 1) requires deallocation
(<font face="Source Code Pro">free()</font>) after call.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_needfree(long p,int n)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_needfree[n - 1] = 1;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_NEEDFREE(LONG,INTEGER)PREDICATE&#39;,   +
           .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to integer <font face="Source Code Pro">v</font> (32 bit).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_integer(long p, int n, int v)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_values[n - 1] = v;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_INTEGER(&#39;                       +
                        &#39;LONG,INTEGER,INTEGER)PREDICATE&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to double <font face="Source Code Pro">v</font>. Nominally type <font face="Source Code Pro">double</font>
but this should be useable to get a REAL parameter into a double.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_real(long p, int n, double v)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_values[n - 1] = v;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_REAL(&#39;                              +
                        &#39;LONG,INTEGER,REAL)PREDICATE&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to 64 bit <font face="Source Code Pro">p</font>. <font face="Source Code Pro">p2</font> will be the
FFI descriptor and <font face="Source Code Pro">p</font> the 64 bit long or pointer argument.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_ptr(long p, int n, long p2)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_values[n - 1] = (long)p2;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_PTR(LONG,INTEGER,LONG)PREDICATE&#39;,   +
                        .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to float <font face="Source Code Pro">f</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_f(long p, int n, double f)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_values[n - 1] = (float)f;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_F(LONG,INTEGER,REAL)PREDICATE&#39;,     +
                        .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to double <font face="Source Code Pro">d</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_d(long p, int n, double d)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_values[n - 1] = (double)d;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_D(LONG,INTEGER,REAL)PREDICATE&#39;,     +
                        .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to long double <font face="Source Code Pro">ld</font>.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_ld(long p, int n, double d)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
	return 0;
    ffip-&gt;arg_values[n - 1] = (long double)d;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_LD(LONG,INTEGER,REAL)PREDICATE&#39;,    +
                        .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set value of parameter <font face="Source Code Pro">n</font> to string <font face="Source Code Pro">s</font>. Uses <font face="Source Code Pro">strdup()</font> to make
a copy of the string, and marks it for <font face="Source Code Pro">free()</font> after call returns.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int ffi_par_n_string(long p, int n, char *s)
{
    ffi_t *ffip = (void *)p;
    if ((n &lt; 1) || (n &gt; ffip-&gt;nargs))
        return 0;
    ffip-&gt;arg_values[n - 1] = (long)strdup(s);
    if (ffip-&gt;arg_values[n - 1] == (long)NULL)
        return 0;
    ffip-&gt;arg_needfree[n - 1] = 1;
    return 1;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_PAR_N_STRING(&#39;                            +
                        &#39;LONG,INTEGER,STRING)PREDICATE&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Set pointer to function in FFI descriptor.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

/* CIF in P2, FN in P */
static void ffi_set_callp(long p2, long p)
{
    ffi_t *ffip = (void *)p2;
    ffip-&gt;callp = (void *)p;
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_SET_CALLP(LONG,LONG)&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Call FFI function.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static void call_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip-&gt;cif, FFI_FN(ffip-&gt;callp),
	     &amp;ffip-&gt;result, ffip-&gt;arg_ptrs);
}

-SNOBOL C_WRAPPER_PROTO(&#39;CALL_FFI(LONG)&#39;, .EMBED)

/* Return address of call result, use peek_() function to retrieve */
static long ffi_resultp(long p)
{
    ffi_t *ffip = (void *)p;
    return (long)(&amp;(ffip-&gt;result));
}

-SNOBOL C_WRAPPER_PROTO(&#39;FFI_RESULTP(LONG)LONG&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Simplified calls, actually returning result (instead of just leaving
it in the ffi structure).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

static int call_integer_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip-&gt;cif, FFI_FN(ffip-&gt;callp),
	     &amp;ffip-&gt;result, ffip-&gt;arg_ptrs);
    return ffip-&gt;result;
}

-SNOBOL C_WRAPPER_PROTO(&#39;CALL_INTEGER_FFI(LONG)INTEGER&#39;, .EMBED)

static long call_ptr_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip-&gt;cif, FFI_FN(ffip-&gt;callp),
	     &amp;ffip-&gt;result, ffip-&gt;arg_ptrs);
    return ffip-&gt;result;
}

-SNOBOL C_WRAPPER_PROTO(&#39;CALL_PTR_FFI(LONG)LONG&#39;, .EMBED)

static double call_real_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip-&gt;cif, FFI_FN(ffip-&gt;callp),
	     &amp;ffip-&gt;result, ffip-&gt;arg_ptrs);
    return ffip-&gt;result;
}

-SNOBOL C_WRAPPER_PROTO(&#39;CALL_REAL_FFI(LONG)REAL&#39;, .EMBED)

static char *call_string_ffi(long p)
{
    ffi_t *ffip = (void *)p;
    ffi_call(ffip-&gt;cif, FFI_FN(ffip-&gt;callp),
	     &amp;ffip-&gt;result, ffip-&gt;arg_ptrs);
    return (char *)ffip-&gt;result;
}

-SNOBOL C_WRAPPER_PROTO(&#39;CALL_STRING_FFI(LONG)STRING&#39;, .EMBED)

<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
DL (Dynamic Library) functions, Open, close, retrieve error and
resolve symbols in an external library (or within the program itself,
if a handle of NULL is used).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI,TYPE=C&raquo;&equiv;</b>

/* DL functions
 */
static long dlopen_(char *s, int n) { return (long)dlopen(s, n); }

-SNOBOL C_WRAPPER_PROTO(&#39;DLOPEN_(STRING,INTEGER)LONG&#39;, .EMBED)

static char *dlerror_(void)
{
    char *s = dlerror();
    if (s == NULL) return &quot;&quot;;
    return s;
}

-SNOBOL C_WRAPPER_PROTO(&#39;DLERROR_()STRING&#39;, .EMBED)

static long dlsym_(long p, char *s)
{
    return (long)dlsym((void *)p, s);
}

-SNOBOL C_WRAPPER_PROTO(&#39;DLSYM_(LONG,STRING)LONG&#39;, .EMBED)

static int dlclose_(long p) { return dlclose((void *)p); }

-SNOBOL C_WRAPPER_PROTO(&#39;DLCLOSE_(LONG)INTEGER&#39;, .EMBED)

-END
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Build ffi.so.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI&raquo;&equiv;</b>
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(ffi) :F(ERROR) ;
-SNOBOL LIBS = &#39;-lffi -ldl&#39;
-SNOBOL OBJECTS = ffi ; OBJECTS &#39;.c&#39; = &#39;.o&#39;
-SNOBOL LINK_DYNAMIC(&#39;./ffi&#39;, OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON&#39;T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS FFI.SO
-CMNT -SNOBOL A = CRACK(ffi &#39; &#39; OBJECTS, &#39; &#39;)
-CMNT -SNOBOL SEQ(&#39; DELETE(A&lt;K&gt;) &#39;, .K)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Actually <font face="Source Code Pro">LOAD()</font> the functions defined into CSNOBOL4.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI&raquo;&equiv;</b>
         LOAD(&#39;FFI_FREE(INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_CLEAR(INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_NEW(STRING,STRING)INTEGER&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_NEEDFREE(INTEGER,INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_INTEGER(INTEGER,INTEGER,INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_PTR(INTEGER,INTEGER,INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_REAL(INTEGER,INTEGER,REAL)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_STRING(INTEGER,INTEGER,STRING)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_P(INTEGER,INTEGER,INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_F(INTEGER,INTEGER,REAL)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_D(INTEGER,INTEGER,REAL)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_PAR_N_LD(INTEGER,INTEGER,REAL)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_SET_CALLP(INTEGER,INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;FFI_RESULTP(INTEGER)INTEGER&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;CALL_FFI(INTEGER)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;CALL_INTEGER_FFI(INTEGER)INTEGER&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;CALL_PTR_FFI(INTEGER)INTEGER&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;CALL_REAL_FFI(INTEGER)REAL&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;CALL_STRING_FFI(INTEGER)STRING&#39;, &#39;ffi.so&#39;)
<font color="#818181"><i>*</i></font>
         RTLD_LAZY   = 1
         RTLD_NOW    = 2
         RTLD_GLOBAL = 256
         RTLD_LOCAL  = 0
<font color="#818181"><i>*</i></font>
         LOAD(&#39;DLOPEN_(STRING,INTEGER)INTEGER&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;DLERROR_()STRING&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;DLSYM_(INTEGER,STRING)&#39;, &#39;ffi.so&#39;)
         LOAD(&#39;DLCLOSE_(INTEGER)INTEGER&#39;, &#39;ffi.so&#39;)
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
The actual API for FFI.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FFI&raquo;&equiv;</b>
-PUBLIC DLOPEN(), DLERROR(), DLSYM(), DLCLOSE()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;DLOPEN(S,I)&#39;)
         DEFINE(&#39;DLERROR()&#39;)
         DEFINE(&#39;DLSYM(H,S)&#39;)
         DEFINE(&#39;DLCLOSE(H)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC FFI_NEW(), FFI_FREE(), FFI_CLEAR(), FFI_PAR_N_NEEDFREE()
-PUBLIC FFI_PAR_N_INTEGER(), FFI_PAR_N_PTR(), FFI_PAR_N_REAL()
-PUBLIC FFI_PAR_N_STRING(),  FFI_SET_CALLP()
-PUBLIC FFI_CALL_VOID(), FFI_CALL_INTEGER(), FFI_CALL_REAL()
-PUBLIC FFI_CALL_STRING(), FFI_CALL_PTR(), CALL_FFI(), FFI_RESULTP()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;FFI_CALL_INTEGER(FFI)&#39;)
         DEFINE(&#39;FFI_CALL_REAL(FFI)&#39;)
         DEFINE(&#39;FFI_CALL_STRING(FFI)&#39;)
         DEFINE(&#39;FFI_CALL_PTR(FFI)&#39;)
         DEFINE(&#39;FFI_CALL_VOID(FFI)&#39;)                         <b>:(FFI_END)</b>
<font color="#818181"><i>*</i></font>
DLOPEN   DLOPEN = DLOPEN_(S, I)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DLERROR  DLERROR = DLERROR_()                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DLSYM    DLSYM = DLSYM_(H, S)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DLCLOSE  DLCLOSE = DLCLOSE_(H)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FFI_CALL_VOID
         CALL_FFI(FFI)
         FFI_CLEAR(FFI)                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FFI_CALL_INTEGER
         FFI_CALL_INTEGER = CALL_INTEGER_FFI(FFI)
         FFI_CLEAR(FFI)                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FFI_CALL_REAL
         FFI_CALL_REAL = CALL_REAL_FFI(FFI)
         FFI_CLEAR(FFI)                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FFI_CALL_STRING
         FFI_CALL_STRING = CALL_STRING_FFI(FFI)
         FFI_CLEAR(FFI)                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FFI_CALL_PTR
         FFI_CALL_PTR = CALL_PTR_FFI(FFI)
         FFI_CLEAR(FFI)                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FFI_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FFI.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL FFI
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                         #######  #######  ###                        *</i></font>
<font color="#818181"><i>*                         #        #         #                         *</i></font>
<font color="#818181"><i>*                         #        #         #                         *</i></font>
<font color="#818181"><i>*                         #####    #####     #                         *</i></font>
<font color="#818181"><i>*                         #        #         #                         *</i></font>
<font color="#818181"><i>*                         #        #         #                         *</i></font>
<font color="#818181"><i>*                         #        #        ###                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FFI                  FOREIGN FUNCTION INTERFACE                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FFI.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FFI&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Mon Jun  9 13:53:11 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FFI.INC'
-LINE 638 "FFI.lss"
         &CODE = 1
         &CODE = 0
END
<h1>FIND - Find extreme</h1>

[[FIND(A,PRED)]] will search array [[A]] for an extreme element. The
type of extreme element will be determined by the predicate [[PRED]].

[[
    Examples: FIND(A,'GE')
              FIND(A,'~LGT')
]]

<h2>Uses</h2>

<<INCLUDES>>=
@

<<FIND>>=
-MODULE FIND
-PUBLIC FIND()
         DEFINE('FIND(A,PRED)EX,I,MAX,TEST')                 :(FIND_END)
*
FIND     EX = CONVERT(PRED '(MAX,TEST)', 'EXPRESSION')
         FIND = 1
         MAX = A<FIND>
         I = 1
FIND_1   I = I + 1
         TEST = A<I>                                          :F(RETURN)
         EVAL(EX)                                             :S(FIND_1)
         MAX = TEST
         FIND = I                                              :(FIND_1)
*
FIND_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FIND.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL FIND
-EJECT
*
************************************************************************
*                                                                      *
*                    #######  ###  #     #  ######                     *
*                    #         #   ##    #  #     #                    *
*                    #         #   # #   #  #     #                    *
*                    #####     #   #  #  #  #     #                    *
*                    #         #   #   # #  #     #                    *
*                    #         #   #    ##  #     #                    *
*                    #        ###  #     #  ######                     *
*                                                                      *
* FIND                       FIND EXTREME                              *
*                                                                      *
************************************************************************
*
* FIND.lss
*
<<FIND>>
*
* CE: .MSNOBOL4;
@
-STITL FIND
-EJECT
*
-LINE 47 "FIND.lss"
************************************************************************
*                                                                      *
*                    #######  ###  #     #  ######                     *
*                    #         #   ##    #  #     #                    *
*                    #         #   # #   #  #     #                    *
*                    #####     #   #  #  #  #     #                    *
*                    #         #   #   # #  #     #                    *
*                    #         #   #    ##  #     #                    *
*                    #        ###  #     #  ######                     *
*                                                                      *
* FIND                       FIND EXTREME                              *
*                                                                      *
************************************************************************
*
* FIND.lss
*
-LINE 17 "FIND.lss"
-MODULE FIND
-PUBLIC FIND()
         DEFINE('FIND(A,PRED)EX,I,MAX,TEST')                 :(FIND_END)
*
FIND     EX = CONVERT(PRED '(MAX,TEST)', 'EXPRESSION')
         FIND = 1
         MAX = A<FIND>
         I = 1
FIND_1   I = I + 1
         TEST = A<I>                                          :F(RETURN)
         EVAL(EX)                                             :S(FIND_1)
         MAX = TEST
         FIND = I                                              :(FIND_1)
*
FIND_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FIND - Find extreme</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FIND(A,PRED)</font> will search array <font face="Source Code Pro">A</font> for an extreme element. The
type of extreme element will be determined by the predicate <font face="Source Code Pro">PRED</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     Examples: FIND(A,'GE')
|               FIND(A,'~LGT')
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FIND&raquo;&equiv;</b>
-MODULE FIND
-PUBLIC FIND()
         DEFINE(&#39;FIND(A,PRED)EX,I,MAX,TEST&#39;)                 <b>:(FIND_END)</b>
<font color="#818181"><i>*</i></font>
FIND     EX = CONVERT(PRED &#39;(MAX,TEST)&#39;, &#39;EXPRESSION&#39;)
         FIND = 1
         MAX = A&lt;FIND&gt;
         I = 1
FIND_1   I = I + 1
         TEST = A&lt;I&gt;                                          <b>:F(RETURN)</b>
         EVAL(EX)                                             <b>:S(FIND_1)</b>
         MAX = TEST
         FIND = I                                              <b>:(FIND_1)</b>
<font color="#818181"><i>*</i></font>
FIND_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FIND.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL FIND
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #######  ###  #     #  ######                     *</i></font>
<font color="#818181"><i>*                    #         #   ##    #  #     #                    *</i></font>
<font color="#818181"><i>*                    #         #   # #   #  #     #                    *</i></font>
<font color="#818181"><i>*                    #####     #   #  #  #  #     #                    *</i></font>
<font color="#818181"><i>*                    #         #   #   # #  #     #                    *</i></font>
<font color="#818181"><i>*                    #         #   #    ##  #     #                    *</i></font>
<font color="#818181"><i>*                    #        ###  #     #  ######                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FIND                       FIND EXTREME                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIND.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FIND&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:02 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FIND.INC'
-LINE 38 "FIND.lss"
         &CODE = 1
         &CODE = 0
END
<h1>FLOOR - FLOOR and CEIL functions</h1>

[[FLOOR(X)]] will return the largest integer not greater than [[X]].

[[CEIL(X)]] will return the smallest integer not less than [[X]].

<h2>Uses</h2>
<a href="DEXP.html">DEXP</a><br>

<<INCLUDES>>=
-INCLUDE 'DEXP.INC'
@

<<FLOOR>>=
-MODULE FLOOR
-PUBLIC FLOOR(), CEIL()
         DEFINE('FLOOR(X)')
         DEXP('CEIL(X) = -FLOOR(-X)')                       :(FLOOR_END)
*
FLOOR    FLOOR = CONVERT(X, 'INTEGER')
         GE(X, 0)                                             :S(RETURN)
         FLOOR = NE(X, FLOOR) FLOOR - 1                        :(RETURN)
*
FLOOR_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FLOOR.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL FLOOR
-EJECT
*
************************************************************************
*                                                                      *
*              #######  #        #######  #######  ######              *
*              #        #        #     #  #     #  #     #             *
*              #        #        #     #  #     #  #     #             *
*              #####    #        #     #  #     #  ######              *
*              #        #        #     #  #     #  #   #               *
*              #        #        #     #  #     #  #    #              *
*              #        #######  #######  #######  #     #             *
*                                                                      *
* FLOOR              FLOOR AND CEIL FUNCTIONS                          *
*                                                                      *
************************************************************************
*
* FLOOR.lss
*
<<FLOOR>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "FLOOR.lss"
-INCLUDE 'DEXP.INC'
-STITL FLOOR
-EJECT
-LINE 40 "FLOOR.lss"
*
************************************************************************
*                                                                      *
*              #######  #        #######  #######  ######              *
*              #        #        #     #  #     #  #     #             *
*              #        #        #     #  #     #  #     #             *
*              #####    #        #     #  #     #  ######              *
*              #        #        #     #  #     #  #   #               *
*              #        #        #     #  #     #  #    #              *
*              #        #######  #######  #######  #     #             *
*                                                                      *
* FLOOR              FLOOR AND CEIL FUNCTIONS                          *
*                                                                      *
************************************************************************
*
* FLOOR.lss
*
-LINE 15 "FLOOR.lss"
-MODULE FLOOR
-PUBLIC FLOOR(), CEIL()
         DEFINE('FLOOR(X)')
         DEXP('CEIL(X) = -FLOOR(-X)')                       :(FLOOR_END)
*
FLOOR    FLOOR = CONVERT(X, 'INTEGER')
         GE(X, 0)                                             :S(RETURN)
         FLOOR = NE(X, FLOOR) FLOOR - 1                        :(RETURN)
*
FLOOR_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FLOOR - FLOOR and CEIL functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FLOOR(X)</font> will return the largest integer not greater than <font face="Source Code Pro">X</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CEIL(X)</font> will return the smallest integer not less than <font face="Source Code Pro">X</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="DEXP.html">DEXP</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;DEXP.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FLOOR&raquo;&equiv;</b>
-MODULE FLOOR
-PUBLIC FLOOR(), CEIL()
         DEFINE(&#39;FLOOR(X)&#39;)
         DEXP(&#39;CEIL(X) = -FLOOR(-X)&#39;)                       <b>:(FLOOR_END)</b>
<font color="#818181"><i>*</i></font>
FLOOR    FLOOR = CONVERT(X, &#39;INTEGER&#39;)
         GE(X, 0)                                             <b>:S(RETURN)</b>
         FLOOR = NE(X, FLOOR) FLOOR - 1                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FLOOR_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FLOOR.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL FLOOR
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*              #######  #        #######  #######  ######              *</i></font>
<font color="#818181"><i>*              #        #        #     #  #     #  #     #             *</i></font>
<font color="#818181"><i>*              #        #        #     #  #     #  #     #             *</i></font>
<font color="#818181"><i>*              #####    #        #     #  #     #  ######              *</i></font>
<font color="#818181"><i>*              #        #        #     #  #     #  #   #               *</i></font>
<font color="#818181"><i>*              #        #        #     #  #     #  #    #              *</i></font>
<font color="#818181"><i>*              #        #######  #######  #######  #     #             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FLOOR              FLOOR AND CEIL FUNCTIONS                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FLOOR.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FLOOR&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:03 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FLOOR.INC'
-LINE 31 "FLOOR.lss"
         &CODE = 1
         &CODE = 0
END
<h1>FOREACH - Apply procedure to each element</h1>

[[foreach(x,proc)]] applies procedure [[proc]] to each element of
[[x]], where [[x]] may be an array, table or expression that
produces a sequence of values.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<foreach>>=
# Apply procedure proc to each element of x, where x may be an array,
# table, or expression that produces a sequence of values.
#
//-MODULE FOREACH
//-PUBLIC FOREACH()
procedure foreach(x, proc) a, i {
   i = datatype(x)
   if (i :: 'ARRAY') {
      i = 1
      prototype(x) ? fence && break(':') . i
      while (a = x[i]) {
	 if (~apply(proc, a))
	    freturn
	 i = i + 1
      }
   } else if (i :: 'TABLE') {
      if (~(x = convert(x, 'ARRAY')))
	 freturn
      x = sort(x)
      i = 1
      while (a = x[i, 2]) {
	 if (~apply(proc, a, x[i, 1]))
	    freturn
	 i = i + 1
      }
   } else if (i :: 'EXPRESSION') {
      while (a = eval(x)) {
	 if (~apply(proc, a))
	    freturn
      }
   } else {
      if (apply(proc, x))
	 return
      else
	 freturn
   }
}
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FOREACH.INC'
-INCLUDE 'DEXP.INC'
-INCLUDE 'CRACK.INC'
         &CODE = 1
         X = %'1,2,3'
         DEXP('F(X) = (S = S + X)')
         S = 0
         FOREACH(X, .F)
         EQ(S, 6)                                                :F(END)
         &CODE = 0                                                :(END)
END
@

<<>>=
-SNOCONE
-STITL FOREACH
-EJECT
#
########################################################################
#                                                                      #
#                                                                      #
#    #######  #######  ######   #######     #      #####   #     #     #
#    #        #     #  #     #  #          # #    #     #  #     #     #
#    #        #     #  #     #  #         #   #   #        #     #     #
#    #####    #     #  ######   #####    #     #  #        #######     #
#    #        #     #  #   #    #        #######  #        #     #     #
#    #        #     #  #    #   #        #     #  #     #  #     #     #
#    #        #######  #     #  #######  #     #   #####   #     #     #
#                                                                      #
# FOREACH            APPLY PROC TO EACH ELEMENT                        #
#                                                                      #
########################################################################
#
# FOREACH.lss
#

<<foreach>>

# ce: .msnocone;
@
-PLUSOPS 1 
  :(FOREACH.1)
-SNOCONE 
-STITL FOREACH 
-EJECT 
-LINE 72 "FOREACH.lss" 
-LINE 13 "FOREACH.lss" 
-LINE 19 "FOREACH.lss"
  :(foreach.END)
-LINE 20
foreach i = datatype(x)
-LINE 21
 IDENT(i,'ARRAY') :F(FOREACH.2)
-LINE 22
 i = 1
-LINE 23
 prototype(x) ? fence break(':') . i
-LINE 24
FOREACH.3 a = x<i> :F(FOREACH.4)
-LINE 25
 apply(proc,a) :S(FOREACH.5)F(FRETURN)
-LINE 27
FOREACH.5 i = i + 1 :(FOREACH.3)
-LINE 29
FOREACH.4  :(FOREACH.6)
FOREACH.2 IDENT(i,'TABLE') :F(FOREACH.7)
-LINE 30
 x = convert(x,'ARRAY') :S(FOREACH.8)F(FRETURN)
-LINE 32
FOREACH.8 x = sort(x)
-LINE 33
 i = 1
-LINE 34
FOREACH.9 a = x<i,2> :F(FOREACH.10)
-LINE 35
 apply(proc,a,x<i,1>) :S(FOREACH.11)F(FRETURN)
-LINE 37
FOREACH.11 i = i + 1 :(FOREACH.9)
-LINE 39
FOREACH.10  :(FOREACH.12)
FOREACH.7 IDENT(i,'EXPRESSION') :F(FOREACH.13)
-LINE 40
FOREACH.14 a = eval(x) :F(FOREACH.15)
-LINE 41
 apply(proc,a) :S(FOREACH.16)F(FRETURN)
-LINE 43
FOREACH.16  :(FOREACH.14)
-LINE 44
FOREACH.15  :(FOREACH.17)
-LINE 45
FOREACH.13 apply(proc,x) :S(RETURN)F(FOREACH.18)
-LINE 48
FOREACH.18  :(FRETURN)
FOREACH.19 
FOREACH.17 
FOREACH.12 
-LINE 50
FOREACH.6  :(RETURN)
foreach.END 
FOREACH.1 
-MODULE FOREACH 
-PUBLIC FOREACH() 
 DEFINE('foreach(x,proc)a,i')
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FOREACH - Apply procedure to each element</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">foreach(x,proc)</font> applies procedure <font face="Source Code Pro">proc</font> to each element of
<font face="Source Code Pro">x</font>, where <font face="Source Code Pro">x</font> may be an array, table or expression that
produces a sequence of values.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;foreach&raquo;&equiv;</b>
<font color="#818181"><i># Apply procedure proc to each element of x, where x may be an array,</i></font>
<font color="#818181"><i># table, or expression that produces a sequence of values.</i></font>
<font color="#818181"><i>#</i></font>
//-MODULE FOREACH
//-PUBLIC FOREACH()
procedure foreach(x, proc) a, i {
   i = datatype(x)
   if (i :: &#39;ARRAY&#39;) {
      i = 1
      prototype(x) ? fence &amp;&amp; break(&#39;:&#39;) . i
      while (a = x[i]) {
	 if (~apply(proc, a))
	    freturn
	 i = i + 1
      }
   } else if (i :: &#39;TABLE&#39;) {
      if (~(x = convert(x, &#39;ARRAY&#39;)))
	 freturn
      x = sort(x)
      i = 1
      while (a = x[i, 2]) {
	 if (~apply(proc, a, x[i, 1]))
	    freturn
	 i = i + 1
      }
   } else if (i :: &#39;EXPRESSION&#39;) {
      while (a = eval(x)) {
	 if (~apply(proc, a))
	    freturn
      }
   } else {
      if (apply(proc, x))
	 return
      else
	 freturn
   }
}
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FOREACH.INC&#39;
-INCLUDE &#39;DEXP.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
         &amp;CODE = 1
         X = %&#39;1,2,3&#39;
         DEXP(&#39;F(X) = (S = S + X)&#39;)
         S = 0
         FOREACH(X, .F)
         EQ(S, 6)                                                <b>:F(END)</b>
         &amp;CODE = 0                                                <b>:(END)</b>
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-SNOCONE
-STITL FOREACH
-EJECT
<font color="#818181"><i>#</i></font>
<font color="#818181"><i>########################################################################</i></font>
<font color="#818181"><i>#                                                                      #</i></font>
<font color="#818181"><i>#                                                                      #</i></font>
<font color="#818181"><i>#    #######  #######  ######   #######     #      #####   #     #     #</i></font>
<font color="#818181"><i>#    #        #     #  #     #  #          # #    #     #  #     #     #</i></font>
<font color="#818181"><i>#    #        #     #  #     #  #         #   #   #        #     #     #</i></font>
<font color="#818181"><i>#    #####    #     #  ######   #####    #     #  #        #######     #</i></font>
<font color="#818181"><i>#    #        #     #  #   #    #        #######  #        #     #     #</i></font>
<font color="#818181"><i>#    #        #     #  #    #   #        #     #  #     #  #     #     #</i></font>
<font color="#818181"><i>#    #        #######  #     #  #######  #     #   #####   #     #     #</i></font>
<font color="#818181"><i>#                                                                      #</i></font>
<font color="#818181"><i># FOREACH            APPLY PROC TO EACH ELEMENT                        #</i></font>
<font color="#818181"><i>#                                                                      #</i></font>
<font color="#818181"><i>########################################################################</i></font>
<font color="#818181"><i>#</i></font>
<font color="#818181"><i># FOREACH.lss</i></font>
<font color="#818181"><i>#</i></font>

<b>&laquo;foreach&raquo;</b>

<font color="#818181"><i># ce: .msnocone;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:39 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FOREACH.INC'
-LINE 56 "FOREACH.lss"
-INCLUDE 'DEXP.INC'
-INCLUDE 'CRACK.INC'
         &CODE = 1
         X = %'1,2,3'
         DEXP('F(X) = (S = S + X)')
         S = 0
         FOREACH(X, .F)
         EQ(S, 6)                                                :F(END)
         &CODE = 0                                                :(END)
END
<H1>FOR - Sequence statement</H1>

[[F = FOR_COMPILE(INIT,TEST,INCR,STMT); FOR(F)]] is a generalization
of [[SEQ()]].  This implements the [[C]] [[for]] loop
[[for(init;test;updt)stmt]].

[[SEQ()]] can be expressed in terms of [[FOR()]]. [[SEQ(S,.V,L,H)]]
is easily translated to

[[
FOR(FOR_COMPILE(' V = L',' LE(V,H)',' V = V + 1',S))
]]

But, [[FOR]] allows for list traversals, etc. as well as simple
counted loops. [[SEQ()]] uses a variable reference for it's counting
variable. This allows the variable to be inspected on termination
from the loop. We don't know what the variable will be, so $V is
used. [[FOR()]] doesn't, because it will compile the test and update
statements as well. As a result, the variable used is under explicit
control of the caller.

[[FOR]] is divided into two parts: [[FOR_COMPILE()]] and [[FOR()]].
The idea is to save the compilation time in inner loops. The four
pieces of the [[FOR]] loop are compiled into a [[CODE_]] [[DATA]]
record, which is passed to [[FOR(F)]] for actual execution. This
saves significant time. The [[CODE_]] type can be produced by any
number of [[COMPILE]] operations. We define [[FOR]], [[WHILE]], [[IF]],
[[STMT]] primitives. [[STMT]] create a [[CODE_]] consisting of a single
"statement". [[PROG2]] concatenates two [[CODE_]] structures.

{{
A similar optimization could be made to [[SEQ()]]. Given that [[SEQ()]]
is a stable [[API]], this won't be done.
}}

Usage (for caching compilation) would similar to:

[[
F = IDENT(F) FOR_COMPILE(...)
FOR(F)
]]

Of course, arbitrary combinations and nesting of [[CODE_]] may be done.
Function calls within these must be made by primitive statements.

INCR and INIT are not allowed to fail. Failure in these code pieces
will result in a branch to ERROR. Failure of STMT results in FRETURN,
failure of TEST results in RETURN. Normal FOR() exit should be via
failure of TEST, resulting in a RETURN.

This component also implements [[WHILE]] and [[IF]].

<h2>Uses</h2>

<h2>See Also</h2>
<a href="SEQ.html">SEQ</a>

<<INCLUDES>>=
@

<<FOR>>=
-MODULE FOR
-PUBLIC CODE_(), WHILE_COMPILE(), IF_COMPILE(), FOR_COMPILE()
-PUBLIC STMT_COMPILE(), PROG2_COMPILE(), SET_RVAL(), EVAL_CODE_()
-PUBLIC FOR(), WHILE()
         DATA('CODE_(TYPE,INIT,TEST,INCR,STMT,ELSE,'
+                        'INIT_,TEST_,INCR_,STMT_,ELSE_)')
         DEFINE('WHILE_COMPILE(TEST_,STMT_)')
         DEFINE('IF_COMPILE(TEST_,STMT_,ELSE_)')
         DEFINE('FOR_COMPILE(INIT_,TEST_,INCR_,STMT_)')
         DEFINE('STMT_COMPILE(STMT_)')
         DEFINE('PROG2_COMPILE(INIT_,STMT_)')
         DEFINE('SET_RVAL(R)')
         DEFINE('EVAL_CODE_(F_)')
*
         OPSYN('FOR', 'EVAL_CODE_')
         OPSYN('WHILE', 'EVAL_CODE_')                         :(FOR_END)
*
SET_RVAL EVAL_CODE_ = R
         SET_RVAL = R                                          :(RETURN)
*
PROG2_COMPILE
         PROG2_COMPILE = CODE_('PROG2')
         INIT_(PROG2_COMPILE) = INIT_
         STMT_(PROG2_COMPILE) = STMT_
         INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
+           ' EVAL_CODE_(INIT_(F_))'
         INIT(PROG2_COMPILE) = 
+           CODE(INIT_ ' :<STMT(F_)>')                         :F(ERROR)
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(PROG2_COMPILE) =
+           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
*
STMT_COMPILE
         STMT_COMPILE = CODE_('STMT')
         STMT_(STMT_COMPILE) = STMT_
         INIT(STMT_COMPILE) = CODE(' :<STMT(F_)>')
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(STMT_COMPILE) =
+           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
*
IF_COMPILE
         IF_COMPILE = CODE_('IF')
         TEST_(IF_COMPILE) = TEST_
         STMT_(IF_COMPILE) = STMT_
         ELSE_(IF_COMPILE) = ELSE_
         INIT(IF_COMPILE) = CODE(' :<TEST(F_)>')
         TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
+           ' EVAL_CODE_(TEST_(F_))'
         TEST(IF_COMPILE) =
+           CODE(TEST_ ' :S<STMT(F_)>F<ELSE(F_)>')             :F(ERROR)
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(IF_COMPILE) =
+           CODE(STMT_ ' :S(RETURN)F(FRETURN)')                :F(ERROR)
         ELSE_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(ELSE_(F_))'
         ELSE(IF_COMPILE) =
+           CODE(ELSE_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
*
WHILE_COMPILE
         WHILE_COMPILE = FOR_COMPILE(, TEST_,, STMT_)
         TYPE(WHILE_COMPILE) = 'WHILE'                         :(RETURN)
*
FOR_COMPILE
         FOR_COMPILE = CODE_('FOR')
         TEST_(FOR_COMPILE) = TEST_
         STMT_(FOR_COMPILE) = STMT_
         INCR_(FOR_COMPILE) = INCR_
         INIT_(FOR_COMPILE) = INIT_
         TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
+           ' EVAL_CODE_(TEST_(F_))'
         TEST(FOR_COMPILE) =
+           CODE(TEST_ ' :S<STMT(F_)>F(RETURN)')               :F(ERROR)
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(FOR_COMPILE) =
+           CODE(STMT_ ' :S<INCR(F_)>F(FRETURN)')              :F(ERROR)
         INCR_ = IDENT(DATATYPE(INCR_), 'CODE_')
+           ' EVAL_CODE_(INCR_(F_))'
         INCR(FOR_COMPILE) =
+           CODE(INCR_ ' :S<TEST(F_)>F(ERROR)')                :F(ERROR)
         INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
+           ' EVAL_CODE_(INIT_(F_))'
         INIT(FOR_COMPILE) =
+           CODE(INIT_ ' :S<TEST(F_)>F(ERROR)')       :S(RETURN)F(ERROR)
*
EVAL_CODE_                                                   :<INIT(F_)>
*
FOR_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FOR.INC'
-INCLUDE 'TIMER.INC'
-INCLUDE 'DDT.INC'
         &CODE = 1
*
* THE INIT CAN BE IN THE FOR(), OR OUTSIDE. THE STATEMENT MAY BE
* EMPTY, AS MAY BE THE UPDT AND TEST.
*
         FOR(FOR_COMPILE(' I = 1',
+                        ' LT(I, 5)',
+                        ' I = I + 1',
+                        ' OUTPUT = I'))
*
         FOR_S =
+        "FOR(FOR_COMPILE(' I = 1',' LT(I, 5)',' I = I + 1', ' D = I'))"
         TIMER(' ' FOR_S)
*
         S =
+ ' I = 1;'
+ 'LUP LT(I, 5) :F(LUP2);'
+ ' I = I + 1 :(LUP);'
+ 'LUP2'
         TIMER(S)
*
         F = FOR_COMPILE(
+           ' I = 1',
+           ' LT(I, 5)',
+           ' I = I + 1')
         TIMER(' FOR(F)')
*
         W = WHILE_COMPILE(
+           ' LT(I, 5)',
+           ' OUTPUT = "WHILE: " I; I = I + 1')
         I = 1
         WHILE(W)
*
* IFS IS THE IF STATEMENT.
*
         OUTPUT = '** IF TEST'
         IFS = IF_COMPILE(
+           ' EQ(REMDR(I, 2))',
+           ' OUTPUT = I " is even"',
+           ' OUTPUT = I " is odd"')
         I = 1
         EVAL_CODE_(IFS)
         I = 2
         EVAL_CODE_(IFS)
*
* EVALUATE THE IF STATEMENT 'IFS' IN THE CONTEXT OF A FOR LOOP
*
         OUTPUT = '** IF IN FOR'
         F = FOR_COMPILE(
+           ' I = 1 ',
+           ' LT(I, 5)',
+           ' I = I + 1',
+           IFS)
         EVAL_CODE_(F)
*
* COMPILE AND EVALUATE TWO SIMPLE STATEMENTS
*
         OUTPUT = '** TWO SIMPLE STATEMENTS'
         S1 = STMT_COMPILE(' OUTPUT = "S1"; I = 3')
         S2 = STMT_COMPILE(' OUTPUT = "S2"; I = I + 4')
         EVAL_CODE_(S1)
         OUTPUT = I
         EVAL_CODE_(S2)
         OUTPUT = I
*
* COMPILE AND EVALUATE A VALUE RETURN
*
         OUTPUT = '** RVAL'
         R = STMT_COMPILE(' OUTPUT = "SET_RVAL(" I ")"; SET_RVAL(I)')
         OUTPUT = EVAL_CODE_(R)
*
* COMBINE S1 AND S2 AND EVALUATE
*
         OUTPUT = '** PROG2'
         I = -10
         S3 = PROG2_COMPILE(S1, S2)
         EVAL_CODE_(S3)
         OUTPUT = I
*
* COMBINE WITH VALUE RETURN
*
         OUTPUT = '** PROG2 + RVAL'
         S4 = PROG2_COMPILE(S3, R)
         I = -10
         OUTPUT = EVAL_CODE_(S4)
         OUTPUT = 'I = ' I
*
         &CODE = 0
END
@

<<>>=
-STITL FOR
-EJECT
*
************************************************************************
*                                                                      *
*                      #######  #######  ######                        *
*                      #        #     #  #     #                       *
*                      #        #     #  #     #                       *
*                      #####    #     #  ######                        *
*                      #        #     #  #   #                         *
*                      #        #     #  #    #                        *
*                      #        #######  #     #                       *
*                                                                      *
* FOR                         FOR LOOP                                 *
*                                                                      *
************************************************************************
*
* FOR.lss
*
<<FOR>>
*
* CE: .MSNOBOL4;
@
-STITL FOR
-EJECT
*
-LINE 256 "FOR.lss"
************************************************************************
*                                                                      *
*                      #######  #######  ######                        *
*                      #        #     #  #     #                       *
*                      #        #     #  #     #                       *
*                      #####    #     #  ######                        *
*                      #        #     #  #   #                         *
*                      #        #     #  #    #                        *
*                      #        #######  #     #                       *
*                                                                      *
* FOR                         FOR LOOP                                 *
*                                                                      *
************************************************************************
*
* FOR.lss
*
-LINE 62 "FOR.lss"
-MODULE FOR
-PUBLIC CODE_(), WHILE_COMPILE(), IF_COMPILE(), FOR_COMPILE()
-PUBLIC STMT_COMPILE(), PROG2_COMPILE(), SET_RVAL(), EVAL_CODE_()
-PUBLIC FOR(), WHILE()
         DATA('CODE_(TYPE,INIT,TEST,INCR,STMT,ELSE,'
+                        'INIT_,TEST_,INCR_,STMT_,ELSE_)')
         DEFINE('WHILE_COMPILE(TEST_,STMT_)')
         DEFINE('IF_COMPILE(TEST_,STMT_,ELSE_)')
         DEFINE('FOR_COMPILE(INIT_,TEST_,INCR_,STMT_)')
         DEFINE('STMT_COMPILE(STMT_)')
         DEFINE('PROG2_COMPILE(INIT_,STMT_)')
         DEFINE('SET_RVAL(R)')
         DEFINE('EVAL_CODE_(F_)')
*
         OPSYN('FOR', 'EVAL_CODE_')
         OPSYN('WHILE', 'EVAL_CODE_')                         :(FOR_END)
*
SET_RVAL EVAL_CODE_ = R
         SET_RVAL = R                                          :(RETURN)
*
PROG2_COMPILE
         PROG2_COMPILE = CODE_('PROG2')
         INIT_(PROG2_COMPILE) = INIT_
         STMT_(PROG2_COMPILE) = STMT_
         INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
+           ' EVAL_CODE_(INIT_(F_))'
         INIT(PROG2_COMPILE) =
+           CODE(INIT_ ' :<STMT(F_)>')                         :F(ERROR)
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(PROG2_COMPILE) =
+           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
*
STMT_COMPILE
         STMT_COMPILE = CODE_('STMT')
         STMT_(STMT_COMPILE) = STMT_
         INIT(STMT_COMPILE) = CODE(' :<STMT(F_)>')
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(STMT_COMPILE) =
+           CODE(STMT_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
*
IF_COMPILE
         IF_COMPILE = CODE_('IF')
         TEST_(IF_COMPILE) = TEST_
         STMT_(IF_COMPILE) = STMT_
         ELSE_(IF_COMPILE) = ELSE_
         INIT(IF_COMPILE) = CODE(' :<TEST(F_)>')
         TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
+           ' EVAL_CODE_(TEST_(F_))'
         TEST(IF_COMPILE) =
+           CODE(TEST_ ' :S<STMT(F_)>F<ELSE(F_)>')             :F(ERROR)
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(IF_COMPILE) =
+           CODE(STMT_ ' :S(RETURN)F(FRETURN)')                :F(ERROR)
         ELSE_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(ELSE_(F_))'
         ELSE(IF_COMPILE) =
+           CODE(ELSE_ ' :S(RETURN)F(FRETURN)')       :S(RETURN)F(ERROR)
*
WHILE_COMPILE
         WHILE_COMPILE = FOR_COMPILE(, TEST_,, STMT_)
         TYPE(WHILE_COMPILE) = 'WHILE'                         :(RETURN)
*
FOR_COMPILE
         FOR_COMPILE = CODE_('FOR')
         TEST_(FOR_COMPILE) = TEST_
         STMT_(FOR_COMPILE) = STMT_
         INCR_(FOR_COMPILE) = INCR_
         INIT_(FOR_COMPILE) = INIT_
         TEST_ = IDENT(DATATYPE(TEST_), 'CODE_')
+           ' EVAL_CODE_(TEST_(F_))'
         TEST(FOR_COMPILE) =
+           CODE(TEST_ ' :S<STMT(F_)>F(RETURN)')               :F(ERROR)
         STMT_ = IDENT(DATATYPE(STMT_), 'CODE_')
+           ' EVAL_CODE_ = EVAL_CODE_(STMT_(F_))'
         STMT(FOR_COMPILE) =
+           CODE(STMT_ ' :S<INCR(F_)>F(FRETURN)')              :F(ERROR)
         INCR_ = IDENT(DATATYPE(INCR_), 'CODE_')
+           ' EVAL_CODE_(INCR_(F_))'
         INCR(FOR_COMPILE) =
+           CODE(INCR_ ' :S<TEST(F_)>F(ERROR)')                :F(ERROR)
         INIT_ = IDENT(DATATYPE(INIT_), 'CODE_')
+           ' EVAL_CODE_(INIT_(F_))'
         INIT(FOR_COMPILE) =
+           CODE(INIT_ ' :S<TEST(F_)>F(ERROR)')       :S(RETURN)F(ERROR)
*
EVAL_CODE_                                                   :<INIT(F_)>
*
FOR_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>FOR - Sequence statement</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">F = FOR_COMPILE(INIT,TEST,INCR,STMT); FOR(F)</font> is a generalization
of <font face="Source Code Pro">SEQ()</font>.  This implements the <font face="Source Code Pro">C</font> <font face="Source Code Pro">for</font> loop
<font face="Source Code Pro">for(init;test;updt)stmt</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SEQ()</font> can be expressed in terms of <font face="Source Code Pro">FOR()</font>. <font face="Source Code Pro">SEQ(S,.V,L,H)</font>
is easily translated to
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| FOR(FOR_COMPILE(' V = L',' LE(V,H)',' V = V + 1',S))
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
But, <font face="Source Code Pro">FOR</font> allows for list traversals, etc. as well as simple
counted loops. <font face="Source Code Pro">SEQ()</font> uses a variable reference for it's counting
variable. This allows the variable to be inspected on termination
from the loop. We don't know what the variable will be, so $V is
used. <font face="Source Code Pro">FOR()</font> doesn't, because it will compile the test and update
statements as well. As a result, the variable used is under explicit
control of the caller.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FOR</font> is divided into two parts: <font face="Source Code Pro">FOR_COMPILE()</font> and <font face="Source Code Pro">FOR()</font>.
The idea is to save the compilation time in inner loops. The four
pieces of the <font face="Source Code Pro">FOR</font> loop are compiled into a <font face="Source Code Pro">CODE_</font> <font face="Source Code Pro">DATA</font>
record, which is passed to <font face="Source Code Pro">FOR(F)</font> for actual execution. This
saves significant time. The <font face="Source Code Pro">CODE_</font> type can be produced by any
number of <font face="Source Code Pro">COMPILE</font> operations. We define <font face="Source Code Pro">FOR</font>, <font face="Source Code Pro">WHILE</font>, <font face="Source Code Pro">IF</font>,
<font face="Source Code Pro">STMT</font> primitives. <font face="Source Code Pro">STMT</font> create a <font face="Source Code Pro">CODE_</font> consisting of a single
"statement". <font face="Source Code Pro">PROG2</font> concatenates two <font face="Source Code Pro">CODE_</font> structures.
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
A similar optimization could be made to <font face="Source Code Pro">SEQ()</font>. Given that <font face="Source Code Pro">SEQ()</font>
is a stable <font face="Source Code Pro">API</font>, this won't be done.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
Usage (for caching compilation) would similar to:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| F = IDENT(F) FOR_COMPILE(...)
| FOR(F)
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Of course, arbitrary combinations and nesting of <font face="Source Code Pro">CODE_</font> may be done.
Function calls within these must be made by primitive statements.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
INCR and INIT are not allowed to fail. Failure in these code pieces
will result in a branch to ERROR. Failure of STMT results in FRETURN,
failure of TEST results in RETURN. Normal FOR() exit should be via
failure of TEST, resulting in a RETURN.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This component also implements <font face="Source Code Pro">WHILE</font> and <font face="Source Code Pro">IF</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="SEQ.html">SEQ</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FOR&raquo;&equiv;</b>
-MODULE FOR
-PUBLIC CODE_(), WHILE_COMPILE(), IF_COMPILE(), FOR_COMPILE()
-PUBLIC STMT_COMPILE(), PROG2_COMPILE(), SET_RVAL(), EVAL_CODE_()
-PUBLIC FOR(), WHILE()
         DATA(&#39;CODE_(TYPE,INIT,TEST,INCR,STMT,ELSE,&#39;
+                        &#39;INIT_,TEST_,INCR_,STMT_,ELSE_)&#39;)
         DEFINE(&#39;WHILE_COMPILE(TEST_,STMT_)&#39;)
         DEFINE(&#39;IF_COMPILE(TEST_,STMT_,ELSE_)&#39;)
         DEFINE(&#39;FOR_COMPILE(INIT_,TEST_,INCR_,STMT_)&#39;)
         DEFINE(&#39;STMT_COMPILE(STMT_)&#39;)
         DEFINE(&#39;PROG2_COMPILE(INIT_,STMT_)&#39;)
         DEFINE(&#39;SET_RVAL(R)&#39;)
         DEFINE(&#39;EVAL_CODE_(F_)&#39;)
<font color="#818181"><i>*</i></font>
         OPSYN(&#39;FOR&#39;, &#39;EVAL_CODE_&#39;)
         OPSYN(&#39;WHILE&#39;, &#39;EVAL_CODE_&#39;)                         <b>:(FOR_END)</b>
<font color="#818181"><i>*</i></font>
SET_RVAL EVAL_CODE_ = R
         SET_RVAL = R                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
PROG2_COMPILE
         PROG2_COMPILE = CODE_(&#39;PROG2&#39;)
         INIT_(PROG2_COMPILE) = INIT_
         STMT_(PROG2_COMPILE) = STMT_
         INIT_ = IDENT(DATATYPE(INIT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_(INIT_(F_))&#39;
         INIT(PROG2_COMPILE) =
+           CODE(INIT_ &#39; :&lt;STMT(F_)&gt;&#39;)                         <b>:F(ERROR)</b>
         STMT_ = IDENT(DATATYPE(STMT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_ = EVAL_CODE_(STMT_(F_))&#39;
         STMT(PROG2_COMPILE) =
+           CODE(STMT_ &#39; :S(RETURN)F(FRETURN)&#39;)       <b>:S(RETURN)F(ERROR)</b>
<font color="#818181"><i>*</i></font>
STMT_COMPILE
         STMT_COMPILE = CODE_(&#39;STMT&#39;)
         STMT_(STMT_COMPILE) = STMT_
         INIT(STMT_COMPILE) = CODE(&#39; :&lt;STMT(F_)&gt;&#39;)
         STMT_ = IDENT(DATATYPE(STMT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_ = EVAL_CODE_(STMT_(F_))&#39;
         STMT(STMT_COMPILE) =
+           CODE(STMT_ &#39; :S(RETURN)F(FRETURN)&#39;)       <b>:S(RETURN)F(ERROR)</b>
<font color="#818181"><i>*</i></font>
IF_COMPILE
         IF_COMPILE = CODE_(&#39;IF&#39;)
         TEST_(IF_COMPILE) = TEST_
         STMT_(IF_COMPILE) = STMT_
         ELSE_(IF_COMPILE) = ELSE_
         INIT(IF_COMPILE) = CODE(&#39; :&lt;TEST(F_)&gt;&#39;)
         TEST_ = IDENT(DATATYPE(TEST_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_(TEST_(F_))&#39;
         TEST(IF_COMPILE) =
+           CODE(TEST_ &#39; :S&lt;STMT(F_)&gt;F&lt;ELSE(F_)&gt;&#39;)             <b>:F(ERROR)</b>
         STMT_ = IDENT(DATATYPE(STMT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_ = EVAL_CODE_(STMT_(F_))&#39;
         STMT(IF_COMPILE) =
+           CODE(STMT_ &#39; :S(RETURN)F(FRETURN)&#39;)                <b>:F(ERROR)</b>
         ELSE_ = IDENT(DATATYPE(STMT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_ = EVAL_CODE_(ELSE_(F_))&#39;
         ELSE(IF_COMPILE) =
+           CODE(ELSE_ &#39; :S(RETURN)F(FRETURN)&#39;)       <b>:S(RETURN)F(ERROR)</b>
<font color="#818181"><i>*</i></font>
WHILE_COMPILE
         WHILE_COMPILE = FOR_COMPILE(, TEST_,, STMT_)
         TYPE(WHILE_COMPILE) = &#39;WHILE&#39;                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FOR_COMPILE
         FOR_COMPILE = CODE_(&#39;FOR&#39;)
         TEST_(FOR_COMPILE) = TEST_
         STMT_(FOR_COMPILE) = STMT_
         INCR_(FOR_COMPILE) = INCR_
         INIT_(FOR_COMPILE) = INIT_
         TEST_ = IDENT(DATATYPE(TEST_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_(TEST_(F_))&#39;
         TEST(FOR_COMPILE) =
+           CODE(TEST_ &#39; :S&lt;STMT(F_)&gt;F(RETURN)&#39;)               <b>:F(ERROR)</b>
         STMT_ = IDENT(DATATYPE(STMT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_ = EVAL_CODE_(STMT_(F_))&#39;
         STMT(FOR_COMPILE) =
+           CODE(STMT_ &#39; :S&lt;INCR(F_)&gt;F(FRETURN)&#39;)              <b>:F(ERROR)</b>
         INCR_ = IDENT(DATATYPE(INCR_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_(INCR_(F_))&#39;
         INCR(FOR_COMPILE) =
+           CODE(INCR_ &#39; :S&lt;TEST(F_)&gt;F(ERROR)&#39;)                <b>:F(ERROR)</b>
         INIT_ = IDENT(DATATYPE(INIT_), &#39;CODE_&#39;)
+           &#39; EVAL_CODE_(INIT_(F_))&#39;
         INIT(FOR_COMPILE) =
+           CODE(INIT_ &#39; :S&lt;TEST(F_)&gt;F(ERROR)&#39;)       <b>:S(RETURN)F(ERROR)</b>
<font color="#818181"><i>*</i></font>
EVAL_CODE_                                                   <b>:&lt;INIT(F_)&gt;</b>
<font color="#818181"><i>*</i></font>
FOR_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FOR.INC&#39;
-INCLUDE &#39;TIMER.INC&#39;
-INCLUDE &#39;DDT.INC&#39;
         &amp;CODE = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THE INIT CAN BE IN THE FOR(), OR OUTSIDE. THE STATEMENT MAY BE</i></font>
<font color="#818181"><i>* EMPTY, AS MAY BE THE UPDT AND TEST.</i></font>
<font color="#818181"><i>*</i></font>
         FOR(FOR_COMPILE(&#39; I = 1&#39;,
+                        &#39; LT(I, 5)&#39;,
+                        &#39; I = I + 1&#39;,
+                        &#39; OUTPUT = I&#39;))
<font color="#818181"><i>*</i></font>
         FOR_S =
+        &quot;FOR(FOR_COMPILE(&#39; I = 1&#39;,&#39; LT(I, 5)&#39;,&#39; I = I + 1&#39;, &#39; D = I&#39;))&quot;
         TIMER(&#39; &#39; FOR_S)
<font color="#818181"><i>*</i></font>
         S =
+ &#39; I = 1;&#39;
+ &#39;LUP LT(I, 5) :F(LUP2);&#39;
+ &#39; I = I + 1 :(LUP);&#39;
+ &#39;LUP2&#39;
         TIMER(S)
<font color="#818181"><i>*</i></font>
         F = FOR_COMPILE(
+           &#39; I = 1&#39;,
+           &#39; LT(I, 5)&#39;,
+           &#39; I = I + 1&#39;)
         TIMER(&#39; FOR(F)&#39;)
<font color="#818181"><i>*</i></font>
         W = WHILE_COMPILE(
+           &#39; LT(I, 5)&#39;,
+           &#39; OUTPUT = &quot;WHILE: &quot; I; I = I + 1&#39;)
         I = 1
         WHILE(W)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IFS IS THE IF STATEMENT.</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = &#39;** IF TEST&#39;
         IFS = IF_COMPILE(
+           &#39; EQ(REMDR(I, 2))&#39;,
+           &#39; OUTPUT = I &quot; is even&quot;&#39;,
+           &#39; OUTPUT = I &quot; is odd&quot;&#39;)
         I = 1
         EVAL_CODE_(IFS)
         I = 2
         EVAL_CODE_(IFS)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EVALUATE THE IF STATEMENT &#39;IFS&#39; IN THE CONTEXT OF A FOR LOOP</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = &#39;** IF IN FOR&#39;
         F = FOR_COMPILE(
+           &#39; I = 1 &#39;,
+           &#39; LT(I, 5)&#39;,
+           &#39; I = I + 1&#39;,
+           IFS)
         EVAL_CODE_(F)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMPILE AND EVALUATE TWO SIMPLE STATEMENTS</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = &#39;** TWO SIMPLE STATEMENTS&#39;
         S1 = STMT_COMPILE(&#39; OUTPUT = &quot;S1&quot;; I = 3&#39;)
         S2 = STMT_COMPILE(&#39; OUTPUT = &quot;S2&quot;; I = I + 4&#39;)
         EVAL_CODE_(S1)
         OUTPUT = I
         EVAL_CODE_(S2)
         OUTPUT = I
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMPILE AND EVALUATE A VALUE RETURN</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = &#39;** RVAL&#39;
         R = STMT_COMPILE(&#39; OUTPUT = &quot;SET_RVAL(&quot; I &quot;)&quot;; SET_RVAL(I)&#39;)
         OUTPUT = EVAL_CODE_(R)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMBINE S1 AND S2 AND EVALUATE</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = &#39;** PROG2&#39;
         I = -10
         S3 = PROG2_COMPILE(S1, S2)
         EVAL_CODE_(S3)
         OUTPUT = I
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMBINE WITH VALUE RETURN</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = &#39;** PROG2 + RVAL&#39;
         S4 = PROG2_COMPILE(S3, R)
         I = -10
         OUTPUT = EVAL_CODE_(S4)
         OUTPUT = &#39;I = &#39; I
<font color="#818181"><i>*</i></font>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL FOR
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      #######  #######  ######                        *</i></font>
<font color="#818181"><i>*                      #        #     #  #     #                       *</i></font>
<font color="#818181"><i>*                      #        #     #  #     #                       *</i></font>
<font color="#818181"><i>*                      #####    #     #  ######                        *</i></font>
<font color="#818181"><i>*                      #        #     #  #   #                         *</i></font>
<font color="#818181"><i>*                      #        #     #  #    #                        *</i></font>
<font color="#818181"><i>*                      #        #######  #     #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FOR                         FOR LOOP                                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FOR.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FOR&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:46 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FOR.INC'
-LINE 159 "FOR.lss"
-INCLUDE 'TIMER.INC'
-INCLUDE 'DDT.INC'
         &CODE = 1
*
* THE INIT CAN BE IN THE FOR(), OR OUTSIDE. THE STATEMENT MAY BE
* EMPTY, AS MAY BE THE UPDT AND TEST.
*
         FOR(FOR_COMPILE(' I = 1',
+                        ' LT(I, 5)',
+                        ' I = I + 1',
+                        ' OUTPUT = I'))
*
         FOR_S =
+        "FOR(FOR_COMPILE(' I = 1',' LT(I, 5)',' I = I + 1', ' D = I'))"
         TIMER(' ' FOR_S)
*
         S =
+ ' I = 1;'
+ 'LUP LT(I, 5) :F(LUP2);'
+ ' I = I + 1 :(LUP);'
+ 'LUP2'
         TIMER(S)
*
         F = FOR_COMPILE(
+           ' I = 1',
+           ' LT(I, 5)',
+           ' I = I + 1')
         TIMER(' FOR(F)')
*
         W = WHILE_COMPILE(
+           ' LT(I, 5)',
+           ' OUTPUT = "WHILE: " I; I = I + 1')
         I = 1
         WHILE(W)
*
* IFS IS THE IF STATEMENT.
*
         OUTPUT = '** IF TEST'
         IFS = IF_COMPILE(
+           ' EQ(REMDR(I, 2))',
+           ' OUTPUT = I " is even"',
+           ' OUTPUT = I " is odd"')
         I = 1
         EVAL_CODE_(IFS)
         I = 2
         EVAL_CODE_(IFS)
*
* EVALUATE THE IF STATEMENT 'IFS' IN THE CONTEXT OF A FOR LOOP
*
         OUTPUT = '** IF IN FOR'
         F = FOR_COMPILE(
+           ' I = 1 ',
+           ' LT(I, 5)',
+           ' I = I + 1',
+           IFS)
         EVAL_CODE_(F)
*
* COMPILE AND EVALUATE TWO SIMPLE STATEMENTS
*
         OUTPUT = '** TWO SIMPLE STATEMENTS'
         S1 = STMT_COMPILE(' OUTPUT = "S1"; I = 3')
         S2 = STMT_COMPILE(' OUTPUT = "S2"; I = I + 4')
         EVAL_CODE_(S1)
         OUTPUT = I
         EVAL_CODE_(S2)
         OUTPUT = I
*
* COMPILE AND EVALUATE A VALUE RETURN
*
         OUTPUT = '** RVAL'
         R = STMT_COMPILE(' OUTPUT = "SET_RVAL(" I ")"; SET_RVAL(I)')
         OUTPUT = EVAL_CODE_(R)
*
* COMBINE S1 AND S2 AND EVALUATE
*
         OUTPUT = '** PROG2'
         I = -10
         S3 = PROG2_COMPILE(S1, S2)
         EVAL_CODE_(S3)
         OUTPUT = I
*
* COMBINE WITH VALUE RETURN
*
         OUTPUT = '** PROG2 + RVAL'
         S4 = PROG2_COMPILE(S3, R)
         I = -10
         OUTPUT = EVAL_CODE_(S4)
         OUTPUT = 'I = ' I
*
         &CODE = 0
END
<h1>FREEZE - FREEZE and THAW for SPITBOL</h1>

<h2>Uses</h2>
<a href="SYSTEM.html">SYSTEM</a><br>

<<INCLUDES>>= 
-INCLUDE 'SYSTEM.INC'
@

<<FREEZE>>=
-MODULE FREEZE
         SYSTEM() 'CSNOBOL4'                              :S(FREEZE_END)
-PUBLIC FREEZE(), THAW()
         DEFINE('FREEZE(X)')
         DEFINE('THAW(X)')                                 :(FREEZE_END)
*
FREEZE
THAW                                                           :(RETURN)
*
FREEZE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FREEZE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL FREEZE
-EJECT
*
************************************************************************
*                                                                      *
*         #######  ######   #######  #######  #######  #######         *
*         #        #     #  #        #             #   #               *
*         #        #     #  #        #            #    #               *
*         #####    ######   #####    #####      #      #####           *
*         #        #   #    #        #         #       #               *
*         #        #    #   #        #        #        #               *
*         #        #     #  #######  #######  #######  #######         *
*                                                                      *
* FREEZE            FREEZE AND THAW FOR SPITBOL                        *
*                                                                      *
************************************************************************
*
* FREEZE.lss
*
<<FREEZE>>
*
* CE: .MSNOBOL4;
@
-LINE 7 "FREEZE.lss"
-INCLUDE 'SYSTEM.INC'
-STITL FREEZE
-EJECT
-LINE 36 "FREEZE.lss"
*
************************************************************************
*                                                                      *
*         #######  ######   #######  #######  #######  #######         *
*         #        #     #  #        #             #   #               *
*         #        #     #  #        #            #    #               *
*         #####    ######   #####    #####      #      #####           *
*         #        #   #    #        #         #       #               *
*         #        #    #   #        #        #        #               *
*         #        #     #  #######  #######  #######  #######         *
*                                                                      *
* FREEZE            FREEZE AND THAW FOR SPITBOL                        *
*                                                                      *
************************************************************************
*
* FREEZE.lss
*
-LINE 11 "FREEZE.lss"
-MODULE FREEZE
         SYSTEM() 'CSNOBOL4'                              :S(FREEZE_END)
-PUBLIC FREEZE(), THAW()
         DEFINE('FREEZE(X)')
         DEFINE('THAW(X)')                                 :(FREEZE_END)
*
FREEZE
THAW                                                           :(RETURN)
*
FREEZE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>FREEZE - FREEZE and THAW for SPITBOL</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SYSTEM.html">SYSTEM</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SYSTEM.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;FREEZE&raquo;&equiv;</b>
-MODULE FREEZE
         SYSTEM() &#39;CSNOBOL4&#39;                              <b>:S(FREEZE_END)</b>
-PUBLIC FREEZE(), THAW()
         DEFINE(&#39;FREEZE(X)&#39;)
         DEFINE(&#39;THAW(X)&#39;)                                 <b>:(FREEZE_END)</b>
<font color="#818181"><i>*</i></font>
FREEZE
THAW                                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FREEZE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;FREEZE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL FREEZE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         #######  ######   #######  #######  #######  #######         *</i></font>
<font color="#818181"><i>*         #        #     #  #        #             #   #               *</i></font>
<font color="#818181"><i>*         #        #     #  #        #            #    #               *</i></font>
<font color="#818181"><i>*         #####    ######   #####    #####      #      #####           *</i></font>
<font color="#818181"><i>*         #        #   #    #        #         #       #               *</i></font>
<font color="#818181"><i>*         #        #    #   #        #        #        #               *</i></font>
<font color="#818181"><i>*         #        #     #  #######  #######  #######  #######         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* FREEZE            FREEZE AND THAW FOR SPITBOL                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FREEZE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;FREEZE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:47 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'FREEZE.INC'
-LINE 27 "FREEZE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>GCD - Greatest Common Divisor</h1>

[[GCD(I,J)]] returns the GCD of [[I]] and [[J]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<GCD>>=
-MODULE GCD
-PUBLIC GCD()
         DEFINE('GCD(I,J)')                                   :(GCD_END)
*
GCD      EQ(I)                                               :S(FRETURN)
         EQ(J)                                               :S(FRETURN)
GCD.1    GCD = REMDR(I, J)
         GCD = EQ(GCD) J                                      :S(RETURN)
         I = J
         J = GCD                                                :(GCD.1)
*
GCD_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'GCD.INC'
         &CODE = 1
         EQ(GCD(1071, 1029), 21)                                 :F(END)
         &CODE = 0
END
@

<<>>=
-STITL AGT
-EJECT
*
************************************************************************
*                                                                      *
*                       #####    #####   ######                        *
*                      #     #  #     #  #     #                       *
*                      #        #        #     #                       *
*                      #  ####  #        #     #                       *
*                      #     #  #        #     #                       *
*                      #     #  #     #  #     #                       *
*                       #####    #####   ######                        *
*                                                                      *
* GCD                   GREATEST COMMON DIVISOR                        *
*                                                                      *
************************************************************************
*
* GCD.lss
*
<<GCD>>
*
* CE: .MSNOBOL4;
@
-STITL AGT
-EJECT
*
-LINE 39 "GCD.lss"
************************************************************************
*                                                                      *
*                       #####    #####   ######                        *
*                      #     #  #     #  #     #                       *
*                      #        #        #     #                       *
*                      #  ####  #        #     #                       *
*                      #     #  #        #     #                       *
*                      #     #  #     #  #     #                       *
*                       #####    #####   ######                        *
*                                                                      *
* GCD                   GREATEST COMMON DIVISOR                        *
*                                                                      *
************************************************************************
*
* GCD.lss
*
-LINE 11 "GCD.lss"
-MODULE GCD
-PUBLIC GCD()
         DEFINE('GCD(I,J)')                                   :(GCD_END)
*
GCD      EQ(I)                                               :S(FRETURN)
         EQ(J)                                               :S(FRETURN)
GCD.1    GCD = REMDR(I, J)
         GCD = EQ(GCD) J                                      :S(RETURN)
         I = J
         J = GCD                                                :(GCD.1)
*
GCD_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>GCD - Greatest Common Divisor</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">GCD(I,J)</font> returns the GCD of <font face="Source Code Pro">I</font> and <font face="Source Code Pro">J</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;GCD&raquo;&equiv;</b>
-MODULE GCD
-PUBLIC GCD()
         DEFINE(&#39;GCD(I,J)&#39;)                                   <b>:(GCD_END)</b>
<font color="#818181"><i>*</i></font>
GCD      EQ(I)                                               <b>:S(FRETURN)</b>
         EQ(J)                                               <b>:S(FRETURN)</b>
GCD.1    GCD = REMDR(I, J)
         GCD = EQ(GCD) J                                      <b>:S(RETURN)</b>
         I = J
         J = GCD                                                <b>:(GCD.1)</b>
<font color="#818181"><i>*</i></font>
GCD_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;GCD.INC&#39;
         &amp;CODE = 1
         EQ(GCD(1071, 1029), 21)                                 <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL AGT
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                       #####    #####   ######                        *</i></font>
<font color="#818181"><i>*                      #     #  #     #  #     #                       *</i></font>
<font color="#818181"><i>*                      #        #        #     #                       *</i></font>
<font color="#818181"><i>*                      #  ####  #        #     #                       *</i></font>
<font color="#818181"><i>*                      #     #  #        #     #                       *</i></font>
<font color="#818181"><i>*                      #     #  #     #  #     #                       *</i></font>
<font color="#818181"><i>*                       #####    #####   ######                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* GCD                   GREATEST COMMON DIVISOR                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GCD.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;GCD&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:42 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'GCD.INC'
-LINE 29 "GCD.lss"
         &CODE = 1
         EQ(GCD(1071, 1029), 21)                                 :F(END)
         &CODE = 0
END
<h1>GETKEY - Get key, including special keys</h1>

Since [[ESC]] is used by most terminals as function/arrow key leadin,
[[ESC]] is not usable in the program. We cannot easily get around this,
because [[C-MAINBOL]] does not allow timeouts on input operations.

A solution is to define [[ESC]] as [[ESC-ESC]], which will not match
any of leadin sequences.

The following controls are not easily available

<ul>
<li>^C &ndash; terminates the application</li>
<li>^Z &ndash; backgrounds the application</li>
<li>^S &ndash; flow control</li>
<li>^Q &ndash; flow control</li>
</ul>

These keys can be used by the application, if [[stty raw]] is put
into effect. Make sure that any additional channels to the terminal
are closed before issuing [[stty]]:

[[
    HOST(HOST_SYSCMD, 'stty -echo raw')
    OUTPUT(.T_OUT, 10, 'T', '/dev/stdout')
    INPUT(.T_IN, 11, 'CQ', '/dev/stdin')
.
    ENDFILE(10)
    DETACH(.T_OUT)
    ENDFILE(11)
    DETACH(.T_IN)
    HOST(HOST_SYSCMD, 'stty echo cooked')
]]

New key definitions are added to this file as they are needed by
applications.

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
@

<<GETKEY>>=
-MODULE GETKEY
-PUBLIC GETKEY()
         DEFINE('GETKEY(IN)KEY,M')
*
GETKEY_INIT
*
-PUBLIC KEY_ESC, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_PAGEDN
-PUBLIC KEY_PAGEUP, KEY_HOME, KEY_END, KEY_INS
         KEY_ESC    = CHARS_ESC CHARS_ESC
         KEY_LEFT   = BQ('tput kcub1')
         KEY_RIGHT  = BQ('tput kcuf1')
         KEY_UP     = BQ('tput kcuu1')
         KEY_DOWN   = BQ('tput kcud1')
         KEY_PAGEDN = BQ('tput knp')
         KEY_PAGEUP = BQ('tput kpp')
         KEY_HOME   = BQ('tput khome')
         KEY_END    = BQ('tput kend')
         KEY_INS    = BQ('tput kich1')
@

xterm weirdness - kcub1 returns ESC O D

Repair this in the sequences where it happens, and skip for non-xterm
terminals. Note that xterm-256color is the normaL xterm definition
in use by my windowing system, and linux is the normal full-screen
console type.

<<GETKEY>>=
         BQ('echo $TERM') 'xterm'                         :F(GETKEY_END)
         KEY_LEFT   = REPLACE(KEY_LEFT,  'O', '[')
         KEY_RIGHT  = REPLACE(KEY_RIGHT, 'O', '[')
         KEY_UP     = REPLACE(KEY_UP,    'O', '[')
         KEY_DOWN   = REPLACE(KEY_DOWN,  'O', '[')
         KEY_HOME   = REPLACE(KEY_HOME,  'O', '[')
         KEY_END    = REPLACE(KEY_END,   'O', '[')
         KEY_INS    = REPLACE(KEY_INS,   'O', '[')
                                                           :(GETKEY_END)
*
GETKEY   &INPUT = 1; KEY =
GK1      M = ; KEY = KEY $IN
*
GK2      M = ?(KEY_UP ? FENCE KEY) 1                             :F(GK3)
         EQ(SIZE(KEY), SIZE(KEY_UP))                             :S(GKR)
*
GK3      M = ?(KEY_DOWN ? FENCE KEY) 1                           :F(GK4)
         EQ(SIZE(KEY), SIZE(KEY_DOWN))                           :S(GKR)
*
GK4      M = ?(KEY_RIGHT ? FENCE KEY) 1                          :F(GK5)
         EQ(SIZE(KEY), SIZE(KEY_RIGHT))                          :S(GKR)
*
GK5      M = ?(KEY_LEFT ? FENCE KEY) 1                           :F(GK6)
         EQ(SIZE(KEY), SIZE(KEY_LEFT))                           :S(GKR)
*
GK6      M = ?(KEY_PAGEDN ? FENCE KEY) 1                         :F(GK7)
         EQ(SIZE(KEY), SIZE(KEY_PAGEDN))                         :S(GKR)
*
GK7      M = ?(KEY_PAGEUP ? FENCE KEY) 1                         :F(GK8)
         EQ(SIZE(KEY), SIZE(KEY_PAGEUP))                         :S(GKR)
*
GK8      M = ?(KEY_HOME ? FENCE KEY) 1                           :F(GK9)
         EQ(SIZE(KEY), SIZE(KEY_HOME))                           :S(GKR)
*
GK9      M = ?(KEY_END ? FENCE KEY) 1                           :F(GK10)
         EQ(SIZE(KEY), SIZE(KEY_END))                            :S(GKR)
*
GK10     M = ?(KEY_INS ? FENCE KEY) 1                           :F(GK11)
         EQ(SIZE(KEY), SIZE(KEY_INS))                            :S(GKR)
*
GK11     M = ?(KEY_ESC ? FENCE KEY) 1                           :F(GK12)
         EQ(SIZE(KEY), SIZE(KEY_ESC))                            :S(GKR)
+                                                                 F(GK1)
@

If we have a match so far, add another keystroke. Note that this is
broken if the user manually types an escape sequence on the keyboard
(again, no timeout is possible).

<<GETKEY>>=
GK12     DIFFER(M)                                               :S(GK1)
GKR      GETKEY = KEY                                          :(RETURN)
*
         CODE('GETKEY_INIT')
*
GETKEY_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'GETKEY.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL GETKEY
-EJECT
*
************************************************************************
*                                                                      *
*           #####   #######  #######  #    #  #######  #     #         *
*          #     #  #           #     #   #   #         #   #          *
*          #        #           #     #  #    #          # #           *
*          #  ####  #####       #     ###     #####       #            *
*          #     #  #           #     #  #    #           #            *
*          #     #  #           #     #   #   #           #            *
*           #####   #######     #     #    #  #######     #            *
*                                                                      *
* GETKEY      GET KEY, INCLUDING ARROWS AND FUNCTION KEYS              *
*                                                                      *
************************************************************************
*
* GETKEY.lss
*
<<GETKEY>>
*
* CE: .MSNOBOL4;
@
-LINE 43 "GETKEY.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-STITL GETKEY
-EJECT
-LINE 147 "GETKEY.lss"
*
************************************************************************
*                                                                      *
*           #####   #######  #######  #    #  #######  #     #         *
*          #     #  #           #     #   #   #         #   #          *
*          #        #           #     #  #    #          # #           *
*          #  ####  #####       #     ###     #####       #            *
*          #     #  #           #     #  #    #           #            *
*          #     #  #           #     #   #   #           #            *
*           #####   #######     #     #    #  #######     #            *
*                                                                      *
* GETKEY      GET KEY, INCLUDING ARROWS AND FUNCTION KEYS              *
*                                                                      *
************************************************************************
*
* GETKEY.lss
*
-LINE 48 "GETKEY.lss"
-MODULE GETKEY
-PUBLIC GETKEY()
         DEFINE('GETKEY(IN)KEY,M')
*
GETKEY_INIT
*
-PUBLIC KEY_ESC, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_PAGEDN
-PUBLIC KEY_PAGEUP, KEY_HOME, KEY_END, KEY_INS
         KEY_ESC    = CHARS_ESC CHARS_ESC
         KEY_LEFT   = BQ('tput kcub1')
         KEY_RIGHT  = BQ('tput kcuf1')
         KEY_UP     = BQ('tput kcuu1')
         KEY_DOWN   = BQ('tput kcud1')
         KEY_PAGEDN = BQ('tput knp')
         KEY_PAGEUP = BQ('tput kpp')
         KEY_HOME   = BQ('tput khome')
         KEY_END    = BQ('tput kend')
         KEY_INS    = BQ('tput kich1')
-LINE 76 "GETKEY.lss"
         BQ('echo $TERM') 'xterm'                         :F(GETKEY_END)
         KEY_LEFT   = REPLACE(KEY_LEFT,  'O', '[')
         KEY_RIGHT  = REPLACE(KEY_RIGHT, 'O', '[')
         KEY_UP     = REPLACE(KEY_UP,    'O', '[')
         KEY_DOWN   = REPLACE(KEY_DOWN,  'O', '[')
         KEY_HOME   = REPLACE(KEY_HOME,  'O', '[')
         KEY_END    = REPLACE(KEY_END,   'O', '[')
         KEY_INS    = REPLACE(KEY_INS,   'O', '[')
                                                           :(GETKEY_END)
*
GETKEY   &INPUT = 1; KEY =
GK1      M = ; KEY = KEY $IN
*
GK2      M = ?(KEY_UP ? FENCE KEY) 1                             :F(GK3)
         EQ(SIZE(KEY), SIZE(KEY_UP))                             :S(GKR)
*
GK3      M = ?(KEY_DOWN ? FENCE KEY) 1                           :F(GK4)
         EQ(SIZE(KEY), SIZE(KEY_DOWN))                           :S(GKR)
*
GK4      M = ?(KEY_RIGHT ? FENCE KEY) 1                          :F(GK5)
         EQ(SIZE(KEY), SIZE(KEY_RIGHT))                          :S(GKR)
*
GK5      M = ?(KEY_LEFT ? FENCE KEY) 1                           :F(GK6)
         EQ(SIZE(KEY), SIZE(KEY_LEFT))                           :S(GKR)
*
GK6      M = ?(KEY_PAGEDN ? FENCE KEY) 1                         :F(GK7)
         EQ(SIZE(KEY), SIZE(KEY_PAGEDN))                         :S(GKR)
*
GK7      M = ?(KEY_PAGEUP ? FENCE KEY) 1                         :F(GK8)
         EQ(SIZE(KEY), SIZE(KEY_PAGEUP))                         :S(GKR)
*
GK8      M = ?(KEY_HOME ? FENCE KEY) 1                           :F(GK9)
         EQ(SIZE(KEY), SIZE(KEY_HOME))                           :S(GKR)
*
GK9      M = ?(KEY_END ? FENCE KEY) 1                           :F(GK10)
         EQ(SIZE(KEY), SIZE(KEY_END))                            :S(GKR)
*
GK10     M = ?(KEY_INS ? FENCE KEY) 1                           :F(GK11)
         EQ(SIZE(KEY), SIZE(KEY_INS))                            :S(GKR)
*
GK11     M = ?(KEY_ESC ? FENCE KEY) 1                           :F(GK12)
         EQ(SIZE(KEY), SIZE(KEY_ESC))                            :S(GKR)
+                                                                 F(GK1)
-LINE 126 "GETKEY.lss"
GK12     DIFFER(M)                                               :S(GK1)
GKR      GETKEY = KEY                                          :(RETURN)
*
         CODE('GETKEY_INIT')
*
GETKEY_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>GETKEY - Get key, including special keys</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Since <font face="Source Code Pro">ESC</font> is used by most terminals as function/arrow key leadin,
<font face="Source Code Pro">ESC</font> is not usable in the program. We cannot easily get around this,
because <font face="Source Code Pro">C-MAINBOL</font> does not allow timeouts on input operations.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
A solution is to define <font face="Source Code Pro">ESC</font> as <font face="Source Code Pro">ESC-ESC</font>, which will not match
any of leadin sequences.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The following controls are not easily available
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<ul>
<li>^C &ndash; terminates the application</li>
<li>^Z &ndash; backgrounds the application</li>
<li>^S &ndash; flow control</li>
<li>^Q &ndash; flow control</li>
</ul>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
These keys can be used by the application, if <font face="Source Code Pro">stty raw</font> is put
into effect. Make sure that any additional channels to the terminal
are closed before issuing <font face="Source Code Pro">stty</font>:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     HOST(HOST_SYSCMD, 'stty -echo raw')
|     OUTPUT(.T_OUT, 10, 'T', '/dev/stdout')
|     INPUT(.T_IN, 11, 'CQ', '/dev/stdin')
| .
|     ENDFILE(10)
|     DETACH(.T_OUT)
|     ENDFILE(11)
|     DETACH(.T_IN)
|     HOST(HOST_SYSCMD, 'stty echo cooked')
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
New key definitions are added to this file as they are needed by
applications.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;GETKEY&raquo;&equiv;</b>
-MODULE GETKEY
-PUBLIC GETKEY()
         DEFINE(&#39;GETKEY(IN)KEY,M&#39;)
<font color="#818181"><i>*</i></font>
GETKEY_INIT
<font color="#818181"><i>*</i></font>
-PUBLIC KEY_ESC, KEY_LEFT, KEY_RIGHT, KEY_UP, KEY_DOWN, KEY_PAGEDN
-PUBLIC KEY_PAGEUP, KEY_HOME, KEY_END, KEY_INS
         KEY_ESC    = CHARS_ESC CHARS_ESC
         KEY_LEFT   = BQ(&#39;tput kcub1&#39;)
         KEY_RIGHT  = BQ(&#39;tput kcuf1&#39;)
         KEY_UP     = BQ(&#39;tput kcuu1&#39;)
         KEY_DOWN   = BQ(&#39;tput kcud1&#39;)
         KEY_PAGEDN = BQ(&#39;tput knp&#39;)
         KEY_PAGEUP = BQ(&#39;tput kpp&#39;)
         KEY_HOME   = BQ(&#39;tput khome&#39;)
         KEY_END    = BQ(&#39;tput kend&#39;)
         KEY_INS    = BQ(&#39;tput kich1&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
xterm weirdness - kcub1 returns ESC O D
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Repair this in the sequences where it happens, and skip for non-xterm
terminals. Note that xterm-256color is the normaL xterm definition
in use by my windowing system, and linux is the normal full-screen
console type.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;GETKEY&raquo;&equiv;</b>
         BQ(&#39;echo $TERM&#39;) &#39;xterm&#39;                         <b>:F(GETKEY_END)</b>
         KEY_LEFT   = REPLACE(KEY_LEFT,  &#39;O&#39;, &#39;[&#39;)
         KEY_RIGHT  = REPLACE(KEY_RIGHT, &#39;O&#39;, &#39;[&#39;)
         KEY_UP     = REPLACE(KEY_UP,    &#39;O&#39;, &#39;[&#39;)
         KEY_DOWN   = REPLACE(KEY_DOWN,  &#39;O&#39;, &#39;[&#39;)
         KEY_HOME   = REPLACE(KEY_HOME,  &#39;O&#39;, &#39;[&#39;)
         KEY_END    = REPLACE(KEY_END,   &#39;O&#39;, &#39;[&#39;)
         KEY_INS    = REPLACE(KEY_INS,   &#39;O&#39;, &#39;[&#39;)
                                                           <b>:(GETKEY_END)</b>
<font color="#818181"><i>*</i></font>
GETKEY   &amp;INPUT = 1; KEY =
GK1      M = ; KEY = KEY $IN
<font color="#818181"><i>*</i></font>
GK2      M = ?(KEY_UP ? FENCE KEY) 1                             <b>:F(GK3)</b>
         EQ(SIZE(KEY), SIZE(KEY_UP))                             <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK3      M = ?(KEY_DOWN ? FENCE KEY) 1                           <b>:F(GK4)</b>
         EQ(SIZE(KEY), SIZE(KEY_DOWN))                           <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK4      M = ?(KEY_RIGHT ? FENCE KEY) 1                          <b>:F(GK5)</b>
         EQ(SIZE(KEY), SIZE(KEY_RIGHT))                          <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK5      M = ?(KEY_LEFT ? FENCE KEY) 1                           <b>:F(GK6)</b>
         EQ(SIZE(KEY), SIZE(KEY_LEFT))                           <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK6      M = ?(KEY_PAGEDN ? FENCE KEY) 1                         <b>:F(GK7)</b>
         EQ(SIZE(KEY), SIZE(KEY_PAGEDN))                         <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK7      M = ?(KEY_PAGEUP ? FENCE KEY) 1                         <b>:F(GK8)</b>
         EQ(SIZE(KEY), SIZE(KEY_PAGEUP))                         <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK8      M = ?(KEY_HOME ? FENCE KEY) 1                           <b>:F(GK9)</b>
         EQ(SIZE(KEY), SIZE(KEY_HOME))                           <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK9      M = ?(KEY_END ? FENCE KEY) 1                           <b>:F(GK10)</b>
         EQ(SIZE(KEY), SIZE(KEY_END))                            <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK10     M = ?(KEY_INS ? FENCE KEY) 1                           <b>:F(GK11)</b>
         EQ(SIZE(KEY), SIZE(KEY_INS))                            <b>:S(GKR)</b>
<font color="#818181"><i>*</i></font>
GK11     M = ?(KEY_ESC ? FENCE KEY) 1                           <b>:F(GK12)</b>
         EQ(SIZE(KEY), SIZE(KEY_ESC))                            <b>:S(GKR)</b>
+                                                                 F(GK1)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
If we have a match so far, add another keystroke. Note that this is
broken if the user manually types an escape sequence on the keyboard
(again, no timeout is possible).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;GETKEY&raquo;&equiv;</b>
GK12     DIFFER(M)                                               <b>:S(GK1)</b>
GKR      GETKEY = KEY                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
         CODE(&#39;GETKEY_INIT&#39;)
<font color="#818181"><i>*</i></font>
GETKEY_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;GETKEY.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL GETKEY
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*           #####   #######  #######  #    #  #######  #     #         *</i></font>
<font color="#818181"><i>*          #     #  #           #     #   #   #         #   #          *</i></font>
<font color="#818181"><i>*          #        #           #     #  #    #          # #           *</i></font>
<font color="#818181"><i>*          #  ####  #####       #     ###     #####       #            *</i></font>
<font color="#818181"><i>*          #     #  #           #     #  #    #           #            *</i></font>
<font color="#818181"><i>*          #     #  #           #     #   #   #           #            *</i></font>
<font color="#818181"><i>*           #####   #######     #     #    #  #######     #            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* GETKEY      GET KEY, INCLUDING ARROWS AND FUNCTION KEYS              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GETKEY.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;GETKEY&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:03 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'GETKEY.INC'
-LINE 138 "GETKEY.lss"
         &CODE = 1
         &CODE = 0
END
<h1>GOTOS - Keep the last 10 or so gotos of a program</h1>

The following trace function will give the last 10 or so gotos of a
SNOBOL4 program before it ends. This history is kept in the form of
a string so that it will get dumped if execution ends abnormally.
You can also send all error conditions to the statement:

[[
    ERROR OUTPUT = GOTOS_QUEUE
]]

The string [[GOTOS_QUEUE]] will have entries in the form:

[[
    F1>T1;F2>T2;...
]]

where entries are delimited by the semicolon.  [[FN]] is the 'from'
statement where a goto was made to the 'to' statement, [[TN]]. The most
recent goto is at the beginning of the string, and ages to the right.

From a note in the Dec., 1975 newsletter of SIGPLAN from Gideon Yuval,
Computer Science Dept., Hebrew University, Jerusalem, Israel.

 Copyright 1985 - Catspaw, Incorporated

<h2>Uses</h2>

<<INCLUDES>>=
@

<<GOTOS>>=
-MODULE GOTOS
-PUBLIC GOTOS_()
         DEFINE('GOTOS_()')
         GOTOS_LENGTH = 119
         GOTOS_QUEUE = DUPL('.', GOTOS_LENGTH)
         GOTOS_PAT = POS(0) LEN(GOTOS_LENGTH) . GOTOS_QUEUE
         TRACE('STCOUNT', 'KEYWORD',, 'GOTOS_')
         &TRACE = 999999999
         &DUMP = 1                                          :(GOTOS_END)
*
GOTOS_   GOTOS_NO = &LASTNO
         EQ(GOTOS_LAST, GOTOS_NO)                             :S(RETURN)
         GOTOS_LAST = EQ(GOTOS_NO, GOTOS_LAST + 1) GOTOS_NO   :S(RETURN)
         (GOTOS_LAST '>' GOTOS_NO ';' GOTOS_QUEUE) ? GOTOS_PAT
         GOTOS_LAST = GOTOS_NO                                 :(RETURN)
*
GOTOS_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'GOTOS.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL GOTOS
-EJECT
*
************************************************************************
*                                                                      *
*              #####   #######  #######  #######   #####               *
*             #     #  #     #     #     #     #  #     #              *
*             #        #     #     #     #     #  #                    *
*             #  ####  #     #     #     #     #   #####               *
*             #     #  #     #     #     #     #        #              *
*             #     #  #     #     #     #     #  #     #              *
*              #####   #######     #     #######   #####               *
*                                                                      *
* GOTOS        KEEP THE LAST 10 OR SO GOTOS OF A PROGRAM               *
*                                                                      *
************************************************************************
*
* GOTOS.lss
*
<<GOTOS>>
*
* CE: .MSNOBOL4;
@
-STITL GOTOS
-EJECT
*
-LINE 65 "GOTOS.lss"
************************************************************************
*                                                                      *
*              #####   #######  #######  #######   #####               *
*             #     #  #     #     #     #     #  #     #              *
*             #        #     #     #     #     #  #                    *
*             #  ####  #     #     #     #     #   #####               *
*             #     #  #     #     #     #     #        #              *
*             #     #  #     #     #     #     #  #     #              *
*              #####   #######     #     #######   #####               *
*                                                                      *
* GOTOS        KEEP THE LAST 10 OR SO GOTOS OF A PROGRAM               *
*                                                                      *
************************************************************************
*
* GOTOS.lss
*
-LINE 33 "GOTOS.lss"
-MODULE GOTOS
-PUBLIC GOTOS_()
         DEFINE('GOTOS_()')
         GOTOS_LENGTH = 119
         GOTOS_QUEUE = DUPL('.', GOTOS_LENGTH)
         GOTOS_PAT = POS(0) LEN(GOTOS_LENGTH) . GOTOS_QUEUE
         TRACE('STCOUNT', 'KEYWORD',, 'GOTOS_')
         &TRACE = 999999999
         &DUMP = 1                                          :(GOTOS_END)
*
GOTOS_   GOTOS_NO = &LASTNO
         EQ(GOTOS_LAST, GOTOS_NO)                             :S(RETURN)
         GOTOS_LAST = EQ(GOTOS_NO, GOTOS_LAST + 1) GOTOS_NO   :S(RETURN)
         (GOTOS_LAST '>' GOTOS_NO ';' GOTOS_QUEUE) ? GOTOS_PAT
         GOTOS_LAST = GOTOS_NO                                 :(RETURN)
*
GOTOS_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>GOTOS - Keep the last 10 or so gotos of a program</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The following trace function will give the last 10 or so gotos of a
SNOBOL4 program before it ends. This history is kept in the form of
a string so that it will get dumped if execution ends abnormally.
You can also send all error conditions to the statement:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     ERROR OUTPUT = GOTOS_QUEUE
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The string <font face="Source Code Pro">GOTOS_QUEUE</font> will have entries in the form:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     F1>T1;F2>T2;...
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
where entries are delimited by the semicolon.  <font face="Source Code Pro">FN</font> is the 'from'
statement where a goto was made to the 'to' statement, <font face="Source Code Pro">TN</font>. The most
recent goto is at the beginning of the string, and ages to the right.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
From a note in the Dec., 1975 newsletter of SIGPLAN from Gideon Yuval,
Computer Science Dept., Hebrew University, Jerusalem, Israel.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
 Copyright 1985 - Catspaw, Incorporated
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;GOTOS&raquo;&equiv;</b>
-MODULE GOTOS
-PUBLIC GOTOS_()
         DEFINE(&#39;GOTOS_()&#39;)
         GOTOS_LENGTH = 119
         GOTOS_QUEUE = DUPL(&#39;.&#39;, GOTOS_LENGTH)
         GOTOS_PAT = POS(0) LEN(GOTOS_LENGTH) . GOTOS_QUEUE
         TRACE(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;,, &#39;GOTOS_&#39;)
         &amp;TRACE = 999999999
         &amp;DUMP = 1                                          <b>:(GOTOS_END)</b>
<font color="#818181"><i>*</i></font>
GOTOS_   GOTOS_NO = &amp;LASTNO
         EQ(GOTOS_LAST, GOTOS_NO)                             <b>:S(RETURN)</b>
         GOTOS_LAST = EQ(GOTOS_NO, GOTOS_LAST + 1) GOTOS_NO   <b>:S(RETURN)</b>
         (GOTOS_LAST &#39;&gt;&#39; GOTOS_NO &#39;;&#39; GOTOS_QUEUE) ? GOTOS_PAT
         GOTOS_LAST = GOTOS_NO                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
GOTOS_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;GOTOS.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL GOTOS
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*              #####   #######  #######  #######   #####               *</i></font>
<font color="#818181"><i>*             #     #  #     #     #     #     #  #     #              *</i></font>
<font color="#818181"><i>*             #        #     #     #     #     #  #                    *</i></font>
<font color="#818181"><i>*             #  ####  #     #     #     #     #   #####               *</i></font>
<font color="#818181"><i>*             #     #  #     #     #     #     #        #              *</i></font>
<font color="#818181"><i>*             #     #  #     #     #     #     #  #     #              *</i></font>
<font color="#818181"><i>*              #####   #######     #     #######   #####               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* GOTOS        KEEP THE LAST 10 OR SO GOTOS OF A PROGRAM               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GOTOS.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;GOTOS&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:04 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'GOTOS.INC'
-LINE 56 "GOTOS.lss"
         &CODE = 1
         &CODE = 0
END
<h1>HASH - Create table from string</h1>

Creates a [[TABLE]] from a string. Named after Perl's hash.

Converts string in the form [['NAME=VALUE,NAME2=VALUE2...']] into a
[[TABLE]] where the [[NAME]] is the key and the [[VALUE]] is the data.
Can be passed the name separator (default [[=]]) and item separator
(default [[,]]). Names may not contain the name separator, and values
may not contain the item separator.

[[TABLE]]s are used to represent rows in PSQL. [[HASH()]] attempts
to make it easier to construct simple tables. It is [[OPSYN]]'d to
[[#]] to make it's use more convenient.

[[COPYT(T)]] returns a copy of table [[T]]. [[MERGET(T1,T2)]]
merges two tables together. Entries in [[T2]] override entries in
[[T1]]. The returned table is a new table. Neither [[T1]] nor [[T2]]
are changed. [[KEYST(T)]] returns an array of the keys in
table [[T]]. [[PRUNET(T)]] returns a pruned table. This is a new
table with only non-IDENT elements inserted.

The full call to [[HASH()]]is
[[
HASH(S,E,P,TS,TI,FK,FD,SP) where
S is the string to break into table entries
E is the equals separator (default =)
P is the record separator (default ,)
TS is the default number of table entries (default 10)
TS is the table growth amount (default 10)
FK() is applied to each key prior to adding the item to the table
     (default HASH_3, which simply returns its argument).
FD() is applied to each value before being inserted (default HASH_3).
SP is a multi-entry separator. If NULL, new entries overwrite old
     ones. Otherwise, the entries are concatenated with the separator.
]]

[[FK()]] may be something like [[TRIMB()]], or a function to uppercase
or lowercase the key. This is supplied because table keys match case
sensitive, whereas normal variables are insensitive.

[[FD()]] takes one or two arguments [[FD(V,K)]], where [[V]] is the
value and [[K]] is the key. [[FD()]] can even recursively process
its value to produce another table!

Degenerate cases are supported. [[#'XXX,NAME=YYY']] will create a
table with a [[NULL]] key with value [['XXX']] and key [['NAME']] with
a value of [['YYY']].  [[#'']] is pretty much the same as [[TABLE()]].

<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<h2>See Also</h2>
<a href="PSQL.html">PSQL</a>

<<INCLUDES>>=
-INCLUDE 'BRKREM.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'VDIFFER.INC'
@

<<HASH>>=
-MODULE HASH
-PUBLIC HASH(), COPYT(), MERGET(), KEYST(), #1
-PUBLIC PRUNET()
*
         DEFINE('HASH(S,E,P,TS,TI,FK,FV,SP)K,V,C')
         DEFINE('HASH_3(S)')
         DEFINE('COPYT(T)')
         DEFINE('MERGET(T1,T2)A,I')
         DEFINE('KEYST(T)A,N,I')
         DEFINE('PRUNET(T)A,I')
         OPSYN('#', 'HASH', 1)                               :(HASH_END)
*
PRUNET
         PRUNET = TABLE()
         A = KEYST(T)                                         :F(RETURN)
         SEQ( ' PRUNET<A<I>> = VDIFFER(T<A<I>>)', .I)          :(RETURN)
*
HASH     HASH = TABLE(TS, TI)
         E = IDENT(E) '='
         P = IDENT(P) ','
         FK = IDENT(FK) 'HASH_3'
         FV = IDENT(FV) 'HASH_3'
HASH_2   IDENT(S)                                             :S(RETURN)
         S POS(0) BREAK(E P) LEN(1) . C                       :F(HASH_5)
         C E                                                  :F(HASH_5)
         S POS(0) BREAK(E) . K E =                            :S(HASH_4)
HASH_5   K =
HASH_4   S POS(0) BRKREM(P) . V (P | RPOS(0)) =               :F(RETURN)
         K = APPLY(FK, K)
         V = APPLY(FV, V)
         HASH<K> = VDIFFER(HASH<K>) VDIFFER(SP) V             :S(HASH_2) 
         HASH<K> = V                                           :(HASH_2)
*
HASH_3   HASH_3 = S                                            :(RETURN)
*
COPYT
         COPYT = CONVERT(CONVERT(T, 'ARRAY'), 'TABLE')         :(RETURN)
*
MERGET
         MERGET = COPYT(T1)
         A = CONVERT(T2, 'ARRAY')
         SEQ(' MERGET<A<I, 1>> = A<I, 2> ', .I)                :(RETURN)
*
KEYST    A = CONVERT(T, 'ARRAY')                             :F(FRETURN)
         PROTOTYPE(A) BREAK(',') . N                         :F(FRETURN)
         KEYST = ARRAY(N)
         SEQ(' KEYST<I> = A<I,1> ', .I)                        :(RETURN)
*
HASH_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HASH.INC'
         &CODE = 1
         H = #'FIRST=BOB,LAST=LOBLAW'
         IDENT(H<'FIRST'>, 'BOB')                                :F(END)
         IDENT(H<'LAST'>, 'LOBLAW')                              :F(END)
         T = COPYT(H)
         IDENT(T<'FIRST'>, 'BOB')                                :F(END)
         T<'FIRST'> = 'FRED'
         IDENT(H<'FIRST'>, 'BOB')                                :F(END)
         T2 = #'ADDRESS=SOMEWHERE'
         T3 = MERGET(T, T2)
         IDENT(T3<'FIRST'>, 'FRED')                              :F(END)
         IDENT(T3<'LAST'>, 'LOBLAW')                             :F(END)
         IDENT(T3<'ADDRESS'>, 'SOMEWHERE')                       :F(END)
         H = #'XXX,NAME=VALUE'
         IDENT(H<NULL>, 'XXX')                                   :F(END)
         IDENT(H<'NAME'>, 'VALUE')                               :F(END)
         A = KEYST(T3)                                           :F(END)
         A = SORT(A)                                             :F(END)
         IDENT(A<1>, 'ADDRESS')                                  :F(END)
         IDENT(A<2>, 'FIRST')                                    :F(END)
         IDENT(A<3>, 'LAST')                                     :F(END)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL HASH
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                  #     #     #      #####   #     #                  *
*                  #     #    # #    #     #  #     #                  *
*                  #     #   #   #   #        #     #                  *
*                  #######  #     #   #####   #######                  *
*                  #     #  #######        #  #     #                  *
*                  #     #  #     #  #     #  #     #                  *
*                  #     #  #     #   #####   #     #                  *
*                                                                      *
* HASH                   INITIALIZE A TABLE                            *
*                                                                      *
************************************************************************
*
* HASH.lss
*
<<HASH>>
*
* CE: .MSNOBOL4;
@
-LINE 58 "HASH.lss"
-INCLUDE 'BRKREM.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'VDIFFER.INC'
-STITL HASH
-EJECT
-LINE 148 "HASH.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*                  #     #     #      #####   #     #                  *
*                  #     #    # #    #     #  #     #                  *
*                  #     #   #   #   #        #     #                  *
*                  #######  #     #   #####   #######                  *
*                  #     #  #######        #  #     #                  *
*                  #     #  #     #  #     #  #     #                  *
*                  #     #  #     #   #####   #     #                  *
*                                                                      *
* HASH                   INITIALIZE A TABLE                            *
*                                                                      *
************************************************************************
*
* HASH.lss
*
-LINE 64 "HASH.lss"
-MODULE HASH
-PUBLIC HASH(), COPYT(), MERGET(), KEYST(), #1
-PUBLIC PRUNET()
*
         DEFINE('HASH(S,E,P,TS,TI,FK,FV,SP)K,V,C')
         DEFINE('HASH_3(S)')
         DEFINE('COPYT(T)')
         DEFINE('MERGET(T1,T2)A,I')
         DEFINE('KEYST(T)A,N,I')
         DEFINE('PRUNET(T)A,I')
         OPSYN('#', 'HASH', 1)                               :(HASH_END)
*
PRUNET
         PRUNET = TABLE()
         A = KEYST(T)                                         :F(RETURN)
         SEQ( ' PRUNET<A<I>> = VDIFFER(T<A<I>>)', .I)          :(RETURN)
*
HASH     HASH = TABLE(TS, TI)
         E = IDENT(E) '='
         P = IDENT(P) ','
         FK = IDENT(FK) 'HASH_3'
         FV = IDENT(FV) 'HASH_3'
HASH_2   IDENT(S)                                             :S(RETURN)
         S POS(0) BREAK(E P) LEN(1) . C                       :F(HASH_5)
         C E                                                  :F(HASH_5)
         S POS(0) BREAK(E) . K E =                            :S(HASH_4)
HASH_5   K =
HASH_4   S POS(0) BRKREM(P) . V (P | RPOS(0)) =               :F(RETURN)
         K = APPLY(FK, K)
         V = APPLY(FV, V)
         HASH<K> = VDIFFER(HASH<K>) VDIFFER(SP) V             :S(HASH_2)
         HASH<K> = V                                           :(HASH_2)
*
HASH_3   HASH_3 = S                                            :(RETURN)
*
COPYT
         COPYT = CONVERT(CONVERT(T, 'ARRAY'), 'TABLE')         :(RETURN)
*
MERGET
         MERGET = COPYT(T1)
         A = CONVERT(T2, 'ARRAY')
         SEQ(' MERGET<A<I, 1>> = A<I, 2> ', .I)                :(RETURN)
*
KEYST    A = CONVERT(T, 'ARRAY')                             :F(FRETURN)
         PROTOTYPE(A) BREAK(',') . N                         :F(FRETURN)
         KEYST = ARRAY(N)
         SEQ(' KEYST<I> = A<I,1> ', .I)                        :(RETURN)
*
HASH_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>HASH - Create table from string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Creates a <font face="Source Code Pro">TABLE</font> from a string. Named after Perl's hash.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Converts string in the form <font face="Source Code Pro">'NAME=VALUE,NAME2=VALUE2...'</font> into a
<font face="Source Code Pro">TABLE</font> where the <font face="Source Code Pro">NAME</font> is the key and the <font face="Source Code Pro">VALUE</font> is the data.
Can be passed the name separator (default <font face="Source Code Pro">=</font>) and item separator
(default <font face="Source Code Pro">,</font>). Names may not contain the name separator, and values
may not contain the item separator.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TABLE</font>s are used to represent rows in PSQL. <font face="Source Code Pro">HASH()</font> attempts
to make it easier to construct simple tables. It is <font face="Source Code Pro">OPSYN</font>'d to
<font face="Source Code Pro">#</font> to make it's use more convenient.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">COPYT(T)</font> returns a copy of table <font face="Source Code Pro">T</font>. <font face="Source Code Pro">MERGET(T1,T2)</font>
merges two tables together. Entries in <font face="Source Code Pro">T2</font> override entries in
<font face="Source Code Pro">T1</font>. The returned table is a new table. Neither <font face="Source Code Pro">T1</font> nor <font face="Source Code Pro">T2</font>
are changed. <font face="Source Code Pro">KEYST(T)</font> returns an array of the keys in
table <font face="Source Code Pro">T</font>. <font face="Source Code Pro">PRUNET(T)</font> returns a pruned table. This is a new
table with only non-IDENT elements inserted.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The full call to <font face="Source Code Pro">HASH()</font>is
</font></p><pre><font face="Source Code Pro">
| HASH(S,E,P,TS,TI,FK,FD,SP) where
| S is the string to break into table entries
| E is the equals separator (default =)
| P is the record separator (default ,)
| TS is the default number of table entries (default 10)
| TS is the table growth amount (default 10)
| FK() is applied to each key prior to adding the item to the table
|      (default HASH_3, which simply returns its argument).
| FD() is applied to each value before being inserted (default HASH_3).
| SP is a multi-entry separator. If NULL, new entries overwrite old
|      ones. Otherwise, the entries are concatenated with the separator.
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FK()</font> may be something like <font face="Source Code Pro">TRIMB()</font>, or a function to uppercase
or lowercase the key. This is supplied because table keys match case
sensitive, whereas normal variables are insensitive.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">FD()</font> takes one or two arguments <font face="Source Code Pro">FD(V,K)</font>, where <font face="Source Code Pro">V</font> is the
value and <font face="Source Code Pro">K</font> is the key. <font face="Source Code Pro">FD()</font> can even recursively process
its value to produce another table!
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Degenerate cases are supported. <font face="Source Code Pro">#'XXX,NAME=YYY'</font> will create a
table with a <font face="Source Code Pro">NULL</font> key with value <font face="Source Code Pro">'XXX'</font> and key <font face="Source Code Pro">'NAME'</font> with
a value of <font face="Source Code Pro">'YYY'</font>.  <font face="Source Code Pro">#''</font> is pretty much the same as <font face="Source Code Pro">TABLE()</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="PSQL.html">PSQL</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BRKREM.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HASH&raquo;&equiv;</b>
-MODULE HASH
-PUBLIC HASH(), COPYT(), MERGET(), KEYST(), #1
-PUBLIC PRUNET()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;HASH(S,E,P,TS,TI,FK,FV,SP)K,V,C&#39;)
         DEFINE(&#39;HASH_3(S)&#39;)
         DEFINE(&#39;COPYT(T)&#39;)
         DEFINE(&#39;MERGET(T1,T2)A,I&#39;)
         DEFINE(&#39;KEYST(T)A,N,I&#39;)
         DEFINE(&#39;PRUNET(T)A,I&#39;)
         OPSYN(&#39;#&#39;, &#39;HASH&#39;, 1)                               <b>:(HASH_END)</b>
<font color="#818181"><i>*</i></font>
PRUNET
         PRUNET = TABLE()
         A = KEYST(T)                                         <b>:F(RETURN)</b>
         SEQ( &#39; PRUNET&lt;A&lt;I&gt;&gt; = VDIFFER(T&lt;A&lt;I&gt;&gt;)&#39;, .I)          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
HASH     HASH = TABLE(TS, TI)
         E = IDENT(E) &#39;=&#39;
         P = IDENT(P) &#39;,&#39;
         FK = IDENT(FK) &#39;HASH_3&#39;
         FV = IDENT(FV) &#39;HASH_3&#39;
HASH_2   IDENT(S)                                             <b>:S(RETURN)</b>
         S POS(0) BREAK(E P) LEN(1) . C                       <b>:F(HASH_5)</b>
         C E                                                  <b>:F(HASH_5)</b>
         S POS(0) BREAK(E) . K E =                            <b>:S(HASH_4)</b>
HASH_5   K =
HASH_4   S POS(0) BRKREM(P) . V (P | RPOS(0)) =               <b>:F(RETURN)</b>
         K = APPLY(FK, K)
         V = APPLY(FV, V)
         HASH&lt;K&gt; = VDIFFER(HASH&lt;K&gt;) VDIFFER(SP) V             <b>:S(HASH_2)</b>
         HASH&lt;K&gt; = V                                           <b>:(HASH_2)</b>
<font color="#818181"><i>*</i></font>
HASH_3   HASH_3 = S                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
COPYT
         COPYT = CONVERT(CONVERT(T, &#39;ARRAY&#39;), &#39;TABLE&#39;)         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MERGET
         MERGET = COPYT(T1)
         A = CONVERT(T2, &#39;ARRAY&#39;)
         SEQ(&#39; MERGET&lt;A&lt;I, 1&gt;&gt; = A&lt;I, 2&gt; &#39;, .I)                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
KEYST    A = CONVERT(T, &#39;ARRAY&#39;)                             <b>:F(FRETURN)</b>
         PROTOTYPE(A) BREAK(&#39;,&#39;) . N                         <b>:F(FRETURN)</b>
         KEYST = ARRAY(N)
         SEQ(&#39; KEYST&lt;I&gt; = A&lt;I,1&gt; &#39;, .I)                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
HASH_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;HASH.INC&#39;
         &amp;CODE = 1
         H = #&#39;FIRST=BOB,LAST=LOBLAW&#39;
         IDENT(H&lt;&#39;FIRST&#39;&gt;, &#39;BOB&#39;)                                <b>:F(END)</b>
         IDENT(H&lt;&#39;LAST&#39;&gt;, &#39;LOBLAW&#39;)                              <b>:F(END)</b>
         T = COPYT(H)
         IDENT(T&lt;&#39;FIRST&#39;&gt;, &#39;BOB&#39;)                                <b>:F(END)</b>
         T&lt;&#39;FIRST&#39;&gt; = &#39;FRED&#39;
         IDENT(H&lt;&#39;FIRST&#39;&gt;, &#39;BOB&#39;)                                <b>:F(END)</b>
         T2 = #&#39;ADDRESS=SOMEWHERE&#39;
         T3 = MERGET(T, T2)
         IDENT(T3&lt;&#39;FIRST&#39;&gt;, &#39;FRED&#39;)                              <b>:F(END)</b>
         IDENT(T3&lt;&#39;LAST&#39;&gt;, &#39;LOBLAW&#39;)                             <b>:F(END)</b>
         IDENT(T3&lt;&#39;ADDRESS&#39;&gt;, &#39;SOMEWHERE&#39;)                       <b>:F(END)</b>
         H = #&#39;XXX,NAME=VALUE&#39;
         IDENT(H&lt;NULL&gt;, &#39;XXX&#39;)                                   <b>:F(END)</b>
         IDENT(H&lt;&#39;NAME&#39;&gt;, &#39;VALUE&#39;)                               <b>:F(END)</b>
         A = KEYST(T3)                                           <b>:F(END)</b>
         A = SORT(A)                                             <b>:F(END)</b>
         IDENT(A&lt;1&gt;, &#39;ADDRESS&#39;)                                  <b>:F(END)</b>
         IDENT(A&lt;2&gt;, &#39;FIRST&#39;)                                    <b>:F(END)</b>
         IDENT(A&lt;3&gt;, &#39;LAST&#39;)                                     <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL HASH
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #     #     #      #####   #     #                  *</i></font>
<font color="#818181"><i>*                  #     #    # #    #     #  #     #                  *</i></font>
<font color="#818181"><i>*                  #     #   #   #   #        #     #                  *</i></font>
<font color="#818181"><i>*                  #######  #     #   #####   #######                  *</i></font>
<font color="#818181"><i>*                  #     #  #######        #  #     #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #     #  #     #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #   #####   #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* HASH                   INITIALIZE A TABLE                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HASH.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;HASH&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 05:53:30 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HASH.INC'
-LINE 119 "HASH.lss"
         &CODE = 1
         H = #'FIRST=BOB,LAST=LOBLAW'
         IDENT(H<'FIRST'>, 'BOB')                                :F(END)
         IDENT(H<'LAST'>, 'LOBLAW')                              :F(END)
         T = COPYT(H)
         IDENT(T<'FIRST'>, 'BOB')                                :F(END)
         T<'FIRST'> = 'FRED'
         IDENT(H<'FIRST'>, 'BOB')                                :F(END)
         T2 = #'ADDRESS=SOMEWHERE'
         T3 = MERGET(T, T2)
         IDENT(T3<'FIRST'>, 'FRED')                              :F(END)
         IDENT(T3<'LAST'>, 'LOBLAW')                             :F(END)
         IDENT(T3<'ADDRESS'>, 'SOMEWHERE')                       :F(END)
         H = #'XXX,NAME=VALUE'
         IDENT(H<NULL>, 'XXX')                                   :F(END)
         IDENT(H<'NAME'>, 'VALUE')                               :F(END)
         A = KEYST(T3)                                           :F(END)
         A = SORT(A)                                             :F(END)
         IDENT(A<1>, 'ADDRESS')                                  :F(END)
         IDENT(A<2>, 'FIRST')                                    :F(END)
         IDENT(A<3>, 'LAST')                                     :F(END)
         &CODE = 0
END
<h1>HEX - Return hex for string</h1>

[[HEX(S)]] will return the hexadecimal (internal) representation of
the string [[S]].

<h2>Uses</h2>
<a href="BLEND.html">BLEND</a><br>

<h2>See Also</h2>
<a href="CH.html">CH</a>

<<INCLUDES>>=
-INCLUDE 'BLEND.INC'
@

<<HEX>>=
-MODULE HEX
-PUBLIC HEX()
         DEFINE('HEX(S)S2')
*
         H = '0123456789ABCDEF'
         HEX_2ND = DUPL(H, 16)
HEX_1    H LEN(1) . T =                                      :F(HEX_END)
         HEX_1ST = HEX_1ST DUPL(T, 16)                          :(HEX_1)
*
HEX      IDENT(S)                                             :S(RETURN)
         LE(SIZE(S), 128)                                      :S(HEX_2)
         S LEN(128) . S REM . S2
         HEX = HEX(S) HEX(S2)                                  :(RETURN)
HEX_2    HEX = BLEND(REPLACE(S, &ALPHABET, HEX_1ST),
+           REPLACE(S, &ALPHABET, HEX_2ND))                    :(RETURN)
*
HEX_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HEX.INC'
         &CODE = 1
         OUTPUT = HEX('0')
         OUTPUT = HEX(&ALPHABET)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL HEX
-EJECT
*
************************************************************************
*                                                                      *
*                      #     #  #######  #     #                       *
*                      #     #  #         #   #                        *
*                      #     #  #          # #                         *
*                      #######  #####       #                          *
*                      #     #  #          # #                         *
*                      #     #  #         #   #                        *
*                      #     #  #######  #     #                       *
*                                                                      *
* HEX                    RETURN HEX FOR STRING                         *
*                                                                      *
************************************************************************
*
* HEX.lss
*
<<HEX>>
*
* CE: .MSNOBOL4;
@
-LINE 13 "HEX.lss"
-INCLUDE 'BLEND.INC'
-STITL HEX
-EJECT
-LINE 51 "HEX.lss"
*
************************************************************************
*                                                                      *
*                      #     #  #######  #     #                       *
*                      #     #  #         #   #                        *
*                      #     #  #          # #                         *
*                      #######  #####       #                          *
*                      #     #  #          # #                         *
*                      #     #  #         #   #                        *
*                      #     #  #######  #     #                       *
*                                                                      *
* HEX                    RETURN HEX FOR STRING                         *
*                                                                      *
************************************************************************
*
* HEX.lss
*
-LINE 17 "HEX.lss"
-MODULE HEX
-PUBLIC HEX()
         DEFINE('HEX(S)S2')
*
         H = '0123456789ABCDEF'
         HEX_2ND = DUPL(H, 16)
HEX_1    H LEN(1) . T =                                      :F(HEX_END)
         HEX_1ST = HEX_1ST DUPL(T, 16)                          :(HEX_1)
*
HEX      IDENT(S)                                             :S(RETURN)
         LE(SIZE(S), 128)                                      :S(HEX_2)
         S LEN(128) . S REM . S2
         HEX = HEX(S) HEX(S2)                                  :(RETURN)
HEX_2    HEX = BLEND(REPLACE(S, &ALPHABET, HEX_1ST),
+           REPLACE(S, &ALPHABET, HEX_2ND))                    :(RETURN)
*
HEX_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>HEX - Return hex for string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">HEX(S)</font> will return the hexadecimal (internal) representation of
the string <font face="Source Code Pro">S</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BLEND.html">BLEND</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="CH.html">CH</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BLEND.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HEX&raquo;&equiv;</b>
-MODULE HEX
-PUBLIC HEX()
         DEFINE(&#39;HEX(S)S2&#39;)
<font color="#818181"><i>*</i></font>
         H = &#39;0123456789ABCDEF&#39;
         HEX_2ND = DUPL(H, 16)
HEX_1    H LEN(1) . T =                                      <b>:F(HEX_END)</b>
         HEX_1ST = HEX_1ST DUPL(T, 16)                          <b>:(HEX_1)</b>
<font color="#818181"><i>*</i></font>
HEX      IDENT(S)                                             <b>:S(RETURN)</b>
         LE(SIZE(S), 128)                                      <b>:S(HEX_2)</b>
         S LEN(128) . S REM . S2
         HEX = HEX(S) HEX(S2)                                  <b>:(RETURN)</b>
HEX_2    HEX = BLEND(REPLACE(S, &amp;ALPHABET, HEX_1ST),
+           REPLACE(S, &amp;ALPHABET, HEX_2ND))                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
HEX_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;HEX.INC&#39;
         &amp;CODE = 1
         OUTPUT = HEX(&#39;0&#39;)
         OUTPUT = HEX(&amp;ALPHABET)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL HEX
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      #     #  #######  #     #                       *</i></font>
<font color="#818181"><i>*                      #     #  #         #   #                        *</i></font>
<font color="#818181"><i>*                      #     #  #          # #                         *</i></font>
<font color="#818181"><i>*                      #######  #####       #                          *</i></font>
<font color="#818181"><i>*                      #     #  #          # #                         *</i></font>
<font color="#818181"><i>*                      #     #  #         #   #                        *</i></font>
<font color="#818181"><i>*                      #     #  #######  #     #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* HEX                    RETURN HEX FOR STRING                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HEX.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;HEX&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:04 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HEX.INC'
-LINE 40 "HEX.lss"
         &CODE = 1
         OUTPUT = HEX('0')
         OUTPUT = HEX(&ALPHABET)
         &CODE = 0
END
<h1>HOST - HOST() function codes</h1>

Symbolic defines for [[HOST]] functions.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<HOST>>=
-MODULE HOST
HOST
@

<<HOST>>=
%SET(NONEED,0)
%SET(CSNOBOL4,(?(SYSTEM ? 'CSNOBOL4') 1))
*
* MACRO SPITBOL
*
-PUBLIC HOST_SYSINFO, HOST_PARAMS
* ARCH:OS:SNOBOL_VERSION
         HOST_SYSINFO = ''
* ARGUMENT FROM -u OR ENTIRE COMMAND LINE
         HOST_PARAMS = 0
*
* CATSPAW SPITBOL
*
-PUBLIC HOST_SYSCMD, HOST_ARGN, HOST_FIRSTARG, HOST_GETENV
* EXEC ARG AS SHELL COMMAND, RETURN STATUS
         HOST_SYSCMD = 1
* N'TH TOKEN ON COMMAND LINE (INTEGER)
         HOST_ARGN = 2
* INDEX OF 1ST USER COMMAND LINE ARG TOKEN
         HOST_FIRSTARG = 3
* RETURNS ENVIRONMENT VARIABLE, OR FAILS
         HOST_GETENV = 4
%IF(CSNOBOL4)
%IF(NONEED)
*
* CSNOBOL4
*
-PUBLIC HOST_CONFIG_HOST, HOST_CONFIG_DATE, HOST_BUILD_DATE
-PUBIC HOST_BUILD_DIR, HOST_BUILD_FILES
* HOST WHERE CONFIGURE SCRIPT WAS RUN
         HOST_CONFIG_HOST = 2001
* DATE WHEN CONFIGURE SCRIPT WAS RUN
         HOST_CONFIG_DATE = 2002
* DATE WHEN CSNOBOL4 BUILT
         HOST_BUILD_DATE = 2100
* DIRECTORY WHERE CSNOBOL4 BUILT
         HOST_BUILD_DIR = 2101
* NAMES OF FILES USED TO BUILD CSNOBOL4
         HOST_BUILD_FILES = 2102
%ENDIF
*
-PUBLIC HOST_SNOLIB_DIR
* DEFAULT SNOLIB DIR (-INCLUDE, LOAD())
         HOST_SNOLIB_DIR = 2200
%IF(NONEED)
*
-PUBLIC HOST_SNOLIB_FILE
* DEFAULT FILE FOR LOAD()
         HOST_SNOLIB_FILE = 2201
%ENDIF
*
-PUBLIC HOST_CC, HOST_COPT
* C COMPILER USED TO BUILD CSNOBOL4
         HOST_CC = 2202
* C OPTIMIZER FLAGS USED TO BUILD CSNOBOL4
         HOST_COPT = 2203
%IF(NONEED)
*
-PUBLIC HOST_SO_EXT, HOST_SO_CFLAGS, HOST_SO_LD, HOST_SO_LDFLAGS
* SHARED OBJECT LIBRARY EXTENSION
         HOST_SO_EXT = 2204
* C COMPILER FLAGS FOR SHARED OBJECTS
         HOST_SO_CFLAGS = 2205
* SHARED OBJECT FILE LOAD COMMAND
         HOST_SO_LD = 2206
* SHARED OBJECT FILE LOAD SWITCHES
         HOST_SO_LDFLAGS = 2207
%ENDIF
*
-PUBLIC HOST_DL_EXT, HOST_DL_CFLAGS, HOST_DL_LD,HOST_DL_LDFLAGS
* DYNAMIC LOADABLE LIBRARY EXTENSION
         HOST_DL_EXT = 2208
* C COMPILER FLAGS FOR DYNAMIC LOADABLES
         HOST_DL_CFLAGS = 2209
* DYNAMIC LOADABLE FILE LOAD COMMAND
         HOST_DL_LD = 2210
* DYNAMIC LOADABLE FILE LOAD SWITCHES
         HOST_DL_LDFLAGS = 2211
*
-PUBLIC HOST_DIR_SEP, HOST_PATH_SEP
* DIRECTORY SEPARATOR CHAR (MAY BE EMPTY)
         HOST_DIR_SEP = 2212
* PATH SEPARATOR CHARACTER
         HOST_PATH_SEP = 2213
*
* CSNOBOL4 1.5
*
-PUBLIC HOST_DEF_SNOPATH, HOST_INCUDE_DIR
* DEFAULT LIBRARY SEARCH PATH
         HOST_DEF_SNOPATH = 2214
* PATH FOR C HEADERS
         HOST_INCLUDE_DIR = 2215
*
-PUBLIC HOST_INTEGER_BITS, HOST_REAL_BITS, HOST_POINTER_BITS
-PUBLIC HOST_LONG_BITS, HOST_DESCR_BITS, HOST_SPEC_BITS, HOST_CHAR_BITS
* NUMBER OF BITS FOR SNOBOL4 INTEGER TYPE
         HOST_INTEGER_BITS = 2300
* NUMBER OF BITS FOR SNOBOL4 REAL TYPE
         HOST_REAL_BITS = 2301
* NUMBER OF BITS FOR C POINTER TYPE
         HOST_POINTER_BITS = 2302
* NUMBER OF BITS FOR C LONG TYPE
         HOST_LONG_BITS = 2303
* NUMBER OF BITS FOR SIL 'DESCRIPTOR' TYPE
         HOST_DESCR_BITS = 2304
* NUMBER OF BITS FOR SIL 'SPECIFIER' TYPE
         HOST_SPEC_BITS = 2305
* NUMBER OF BITS FOR C CHAR TYPE
         HOST_CHAR_BITS = 2306
*
-PUBLIC HOST_DYNAMIC_SIZE, HOST_PMSTACK_SIZE, HOST_ISTACK_SIZE
* SIZE OF 'DYNAMIC' STORAGE IN DESCRIPTORS
         HOST_DYNAMIC_SIZE = 2400
* SIZE OF PATTERN MATCH STACK IN DESCRS
         HOST_PMSTACK_SIZE = 2401
* SIZE OF INTERPRETER STACK IN DESCRIPTORS
         HOST_ISTACK_SIZE = 2402
%ENDIF
*
    CODE('HOST')
*
HOST_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HOST.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL HOST
-EJECT
*
************************************************************************
*                                                                      *
*                 #     #  #######   #####   #######                   *
*                 #     #  #     #  #     #     #                      *
*                 #     #  #     #  #           #                      *
*                 #######  #     #   #####      #                      *
*                 #     #  #     #        #     #                      *
*                 #     #  #     #  #     #     #                      *
*                 #     #  #######   #####      #                      *
*                                                                      *
* HOST               HOST() FUNCTION CODES                             *
*                                                                      *
************************************************************************
*
* HOST.lss
*
<<HOST>>
*
* CE: .MSNOBOL4;
@
-STITL HOST
-EJECT
*
-LINE 153 "HOST.lss"
************************************************************************
*                                                                      *
*                 #     #  #######   #####   #######                   *
*                 #     #  #     #  #     #     #                      *
*                 #     #  #     #  #           #                      *
*                 #######  #     #   #####      #                      *
*                 #     #  #     #        #     #                      *
*                 #     #  #     #  #     #     #                      *
*                 #     #  #######   #####      #                      *
*                                                                      *
* HOST               HOST() FUNCTION CODES                             *
*                                                                      *
************************************************************************
*
* HOST.lss
*
-LINE 11 "HOST.lss"
-MODULE HOST
HOST
-LINE 16 "HOST.lss"
*
* MACRO SPITBOL
*
-PUBLIC HOST_SYSINFO, HOST_PARAMS
* ARCH:OS:SNOBOL_VERSION
         HOST_SYSINFO = ''
* ARGUMENT FROM -u OR ENTIRE COMMAND LINE
         HOST_PARAMS = 0
*
* CATSPAW SPITBOL
*
-PUBLIC HOST_SYSCMD, HOST_ARGN, HOST_FIRSTARG, HOST_GETENV
* EXEC ARG AS SHELL COMMAND, RETURN STATUS
         HOST_SYSCMD = 1
* N'TH TOKEN ON COMMAND LINE (INTEGER)
         HOST_ARGN = 2
* INDEX OF 1ST USER COMMAND LINE ARG TOKEN
         HOST_FIRSTARG = 3
* RETURNS ENVIRONMENT VARIABLE, OR FAILS
         HOST_GETENV = 4
*
-PUBLIC HOST_SNOLIB_DIR
* DEFAULT SNOLIB DIR (-INCLUDE, LOAD())
         HOST_SNOLIB_DIR = 2200
*
-PUBLIC HOST_CC, HOST_COPT
* C COMPILER USED TO BUILD CSNOBOL4
         HOST_CC = 2202
* C OPTIMIZER FLAGS USED TO BUILD CSNOBOL4
         HOST_COPT = 2203
*
-PUBLIC HOST_DL_EXT, HOST_DL_CFLAGS, HOST_DL_LD,HOST_DL_LDFLAGS
* DYNAMIC LOADABLE LIBRARY EXTENSION
         HOST_DL_EXT = 2208
* C COMPILER FLAGS FOR DYNAMIC LOADABLES
         HOST_DL_CFLAGS = 2209
* DYNAMIC LOADABLE FILE LOAD COMMAND
         HOST_DL_LD = 2210
* DYNAMIC LOADABLE FILE LOAD SWITCHES
         HOST_DL_LDFLAGS = 2211
*
-PUBLIC HOST_DIR_SEP, HOST_PATH_SEP
* DIRECTORY SEPARATOR CHAR (MAY BE EMPTY)
         HOST_DIR_SEP = 2212
* PATH SEPARATOR CHARACTER
         HOST_PATH_SEP = 2213
*
* CSNOBOL4 1.5
*
-PUBLIC HOST_DEF_SNOPATH, HOST_INCUDE_DIR
* DEFAULT LIBRARY SEARCH PATH
         HOST_DEF_SNOPATH = 2214
* PATH FOR C HEADERS
         HOST_INCLUDE_DIR = 2215
*
-PUBLIC HOST_INTEGER_BITS, HOST_REAL_BITS, HOST_POINTER_BITS
-PUBLIC HOST_LONG_BITS, HOST_DESCR_BITS, HOST_SPEC_BITS, HOST_CHAR_BITS
* NUMBER OF BITS FOR SNOBOL4 INTEGER TYPE
         HOST_INTEGER_BITS = 2300
* NUMBER OF BITS FOR SNOBOL4 REAL TYPE
         HOST_REAL_BITS = 2301
* NUMBER OF BITS FOR C POINTER TYPE
         HOST_POINTER_BITS = 2302
* NUMBER OF BITS FOR C LONG TYPE
         HOST_LONG_BITS = 2303
* NUMBER OF BITS FOR SIL 'DESCRIPTOR' TYPE
         HOST_DESCR_BITS = 2304
* NUMBER OF BITS FOR SIL 'SPECIFIER' TYPE
         HOST_SPEC_BITS = 2305
* NUMBER OF BITS FOR C CHAR TYPE
         HOST_CHAR_BITS = 2306
*
-PUBLIC HOST_DYNAMIC_SIZE, HOST_PMSTACK_SIZE, HOST_ISTACK_SIZE
* SIZE OF 'DYNAMIC' STORAGE IN DESCRIPTORS
         HOST_DYNAMIC_SIZE = 2400
* SIZE OF PATTERN MATCH STACK IN DESCRS
         HOST_PMSTACK_SIZE = 2401
* SIZE OF INTERPRETER STACK IN DESCRIPTORS
         HOST_ISTACK_SIZE = 2402
*
    CODE('HOST')
*
HOST_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>HOST - HOST() function codes</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Symbolic defines for <font face="Source Code Pro">HOST</font> functions.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HOST&raquo;&equiv;</b>
-MODULE HOST
HOST
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HOST&raquo;&equiv;</b>
%SET(NONEED,0)
%SET(CSNOBOL4,(?(SYSTEM ? &#39;CSNOBOL4&#39;) 1))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MACRO SPITBOL</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_SYSINFO, HOST_PARAMS
<font color="#818181"><i>* ARCH:OS:SNOBOL_VERSION</i></font>
         HOST_SYSINFO = &#39;&#39;
<font color="#818181"><i>* ARGUMENT FROM -u OR ENTIRE COMMAND LINE</i></font>
         HOST_PARAMS = 0
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CATSPAW SPITBOL</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_SYSCMD, HOST_ARGN, HOST_FIRSTARG, HOST_GETENV
<font color="#818181"><i>* EXEC ARG AS SHELL COMMAND, RETURN STATUS</i></font>
         HOST_SYSCMD = 1
<font color="#818181"><i>* N&#39;TH TOKEN ON COMMAND LINE (INTEGER)</i></font>
         HOST_ARGN = 2
<font color="#818181"><i>* INDEX OF 1ST USER COMMAND LINE ARG TOKEN</i></font>
         HOST_FIRSTARG = 3
<font color="#818181"><i>* RETURNS ENVIRONMENT VARIABLE, OR FAILS</i></font>
         HOST_GETENV = 4
%IF(CSNOBOL4)
%IF(NONEED)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CSNOBOL4</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_CONFIG_HOST, HOST_CONFIG_DATE, HOST_BUILD_DATE
-PUBIC HOST_BUILD_DIR, HOST_BUILD_FILES
<font color="#818181"><i>* HOST WHERE CONFIGURE SCRIPT WAS RUN</i></font>
         HOST_CONFIG_HOST = 2001
<font color="#818181"><i>* DATE WHEN CONFIGURE SCRIPT WAS RUN</i></font>
         HOST_CONFIG_DATE = 2002
<font color="#818181"><i>* DATE WHEN CSNOBOL4 BUILT</i></font>
         HOST_BUILD_DATE = 2100
<font color="#818181"><i>* DIRECTORY WHERE CSNOBOL4 BUILT</i></font>
         HOST_BUILD_DIR = 2101
<font color="#818181"><i>* NAMES OF FILES USED TO BUILD CSNOBOL4</i></font>
         HOST_BUILD_FILES = 2102
%ENDIF
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_SNOLIB_DIR
<font color="#818181"><i>* DEFAULT SNOLIB DIR (-INCLUDE, LOAD())</i></font>
         HOST_SNOLIB_DIR = 2200
%IF(NONEED)
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_SNOLIB_FILE
<font color="#818181"><i>* DEFAULT FILE FOR LOAD()</i></font>
         HOST_SNOLIB_FILE = 2201
%ENDIF
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_CC, HOST_COPT
<font color="#818181"><i>* C COMPILER USED TO BUILD CSNOBOL4</i></font>
         HOST_CC = 2202
<font color="#818181"><i>* C OPTIMIZER FLAGS USED TO BUILD CSNOBOL4</i></font>
         HOST_COPT = 2203
%IF(NONEED)
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_SO_EXT, HOST_SO_CFLAGS, HOST_SO_LD, HOST_SO_LDFLAGS
<font color="#818181"><i>* SHARED OBJECT LIBRARY EXTENSION</i></font>
         HOST_SO_EXT = 2204
<font color="#818181"><i>* C COMPILER FLAGS FOR SHARED OBJECTS</i></font>
         HOST_SO_CFLAGS = 2205
<font color="#818181"><i>* SHARED OBJECT FILE LOAD COMMAND</i></font>
         HOST_SO_LD = 2206
<font color="#818181"><i>* SHARED OBJECT FILE LOAD SWITCHES</i></font>
         HOST_SO_LDFLAGS = 2207
%ENDIF
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_DL_EXT, HOST_DL_CFLAGS, HOST_DL_LD,HOST_DL_LDFLAGS
<font color="#818181"><i>* DYNAMIC LOADABLE LIBRARY EXTENSION</i></font>
         HOST_DL_EXT = 2208
<font color="#818181"><i>* C COMPILER FLAGS FOR DYNAMIC LOADABLES</i></font>
         HOST_DL_CFLAGS = 2209
<font color="#818181"><i>* DYNAMIC LOADABLE FILE LOAD COMMAND</i></font>
         HOST_DL_LD = 2210
<font color="#818181"><i>* DYNAMIC LOADABLE FILE LOAD SWITCHES</i></font>
         HOST_DL_LDFLAGS = 2211
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_DIR_SEP, HOST_PATH_SEP
<font color="#818181"><i>* DIRECTORY SEPARATOR CHAR (MAY BE EMPTY)</i></font>
         HOST_DIR_SEP = 2212
<font color="#818181"><i>* PATH SEPARATOR CHARACTER</i></font>
         HOST_PATH_SEP = 2213
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CSNOBOL4 1.5</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_DEF_SNOPATH, HOST_INCUDE_DIR
<font color="#818181"><i>* DEFAULT LIBRARY SEARCH PATH</i></font>
         HOST_DEF_SNOPATH = 2214
<font color="#818181"><i>* PATH FOR C HEADERS</i></font>
         HOST_INCLUDE_DIR = 2215
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_INTEGER_BITS, HOST_REAL_BITS, HOST_POINTER_BITS
-PUBLIC HOST_LONG_BITS, HOST_DESCR_BITS, HOST_SPEC_BITS, HOST_CHAR_BITS
<font color="#818181"><i>* NUMBER OF BITS FOR SNOBOL4 INTEGER TYPE</i></font>
         HOST_INTEGER_BITS = 2300
<font color="#818181"><i>* NUMBER OF BITS FOR SNOBOL4 REAL TYPE</i></font>
         HOST_REAL_BITS = 2301
<font color="#818181"><i>* NUMBER OF BITS FOR C POINTER TYPE</i></font>
         HOST_POINTER_BITS = 2302
<font color="#818181"><i>* NUMBER OF BITS FOR C LONG TYPE</i></font>
         HOST_LONG_BITS = 2303
<font color="#818181"><i>* NUMBER OF BITS FOR SIL &#39;DESCRIPTOR&#39; TYPE</i></font>
         HOST_DESCR_BITS = 2304
<font color="#818181"><i>* NUMBER OF BITS FOR SIL &#39;SPECIFIER&#39; TYPE</i></font>
         HOST_SPEC_BITS = 2305
<font color="#818181"><i>* NUMBER OF BITS FOR C CHAR TYPE</i></font>
         HOST_CHAR_BITS = 2306
<font color="#818181"><i>*</i></font>
-PUBLIC HOST_DYNAMIC_SIZE, HOST_PMSTACK_SIZE, HOST_ISTACK_SIZE
<font color="#818181"><i>* SIZE OF &#39;DYNAMIC&#39; STORAGE IN DESCRIPTORS</i></font>
         HOST_DYNAMIC_SIZE = 2400
<font color="#818181"><i>* SIZE OF PATTERN MATCH STACK IN DESCRS</i></font>
         HOST_PMSTACK_SIZE = 2401
<font color="#818181"><i>* SIZE OF INTERPRETER STACK IN DESCRIPTORS</i></font>
         HOST_ISTACK_SIZE = 2402
%ENDIF
<font color="#818181"><i>*</i></font>
    CODE(&#39;HOST&#39;)
<font color="#818181"><i>*</i></font>
HOST_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;HOST.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL HOST
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 #     #  #######   #####   #######                   *</i></font>
<font color="#818181"><i>*                 #     #  #     #  #     #     #                      *</i></font>
<font color="#818181"><i>*                 #     #  #     #  #           #                      *</i></font>
<font color="#818181"><i>*                 #######  #     #   #####      #                      *</i></font>
<font color="#818181"><i>*                 #     #  #     #        #     #                      *</i></font>
<font color="#818181"><i>*                 #     #  #     #  #     #     #                      *</i></font>
<font color="#818181"><i>*                 #     #  #######   #####      #                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* HOST               HOST() FUNCTION CODES                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HOST.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;HOST&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:05 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HOST.INC'
-LINE 144 "HOST.lss"
         &CODE = 1
         &CODE = 0
END
<h1>HTMLESC - HTML, JS and URL escaping</h1>

HTML (web) escaping. Provides three functions to escape a string in
HTML, JS and URL encodings.

<h2>Uses</h2>
<a href="CH.html">CH</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HEX.html">HEX</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SDIFF.html">SDIFF</a><br>

<<INCLUDES>>=
-INCLUDE 'CH.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'HEX.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SDIFF.INC'
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HTMLESC.INC'
         &CODE = 1
         IDENT(HTML_ESCAPE('&<>"' "'"), '&amp;&lt;&gt;&quot;&#39;')
+                                                                :F(END)
         IDENT(JS_ESCAPE('\' "'" '"' CHARS_NL CHARS_CR),
+                        '\\' "\'" '\"\n\r')                     :F(END)
         IDENT(URL_ESCAPE(' +!@#'), '+%2B%21%40%23')             :F(END)
         IDENT(URL_DECODE('AB%20+%21'), 'AB  !')                 :F(END)
         &CODE = 0
END
@

Escape HTML characters. Some claim that > never has to be escaped.
Others claim that / should be escaped. Note 39 is decimal!

<<HTML_ESCAPE>>=
-PUBLIC HTML_ESCAPE()
         DEFINE('HTML_ESCAPE(S)')                     :(END_HTML_ESCAPE)
*
HTML_ESCAPE
         S = REPL(S, '&', '&amp;')
         S = REPL(S, '<', '&lt;',)
         S = REPL(S, '>', '&gt;',)
         S = REPL(S, '"', '&quot;')
         S = REPL(S, "'", '&#39;')
         HTML_ESCAPE = S                                       :(RETURN)
*
END_HTML_ESCAPE
@

Escape JS characters.

<<JS_ESCAPE>>=
-PUBLIC JS_ESCAPE()
         DEFINE('JS_ESCAPE(S)')                         :(END_JS_ESCAPE)
*
JS_ESCAPE
         S = REPL(S, '\', '\\')
         S = REPL(S, "'", "\'")
         S = REPL(S, '"', '\"')
         S = REPL(S, CHARS_NL, '\n')
         S = REPL(S, CHARS_CR, '\r')
         JS_ESCAPE = S                                         :(RETURN)
*
END_JS_ESCAPE
@

Escape URL characters. Space could be escaped as %20. We complement
the characters allowed, yielding the characters that need to be
escaped by doing a set difference between the complete alphabet and
the good character set. This is done at function definition time
(into global [[URL_BAD]]).

<<URL_ESCAPE>>=
-PUBLIC URL_ESCAPE(), URL_DECODE()
         DEFINE('URL_ESCAPE(S)L,C,R')
         DEFINE('URL_DECODE(S)L,C,R')
         URL_BAD = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789' '_-~.')
         URL_HEX = ANY('0123456789abcdefABCDEF')
+                                                      :(END_URL_ESCAPE)
*
URL_DECODE_2
         S = R
URL_DECODE
         C =
         S BREAK("+%") . L LEN(1) . C REM . R
         URL_DECODE = IDENT(C) URL_DECODE S                   :S(RETURN)
         URL_DECODE = IDENT(C, '+') URL_DECODE L ' '    :S(URL_DECODE_2)
         URL_DECODE = URL_DECODE L
         R (URL_HEX URL_HEX) . C =                      :F(URL_DECODE_2)
         URL_DECODE = URL_DECODE CH(C)                   :(URL_DECODE_2)
*
URL_ESCAPE
         S BREAK(URL_BAD) . L LEN(1) . C REM . R             :F(URLESC2)
         URL_ESCAPE = IDENT(C, ' ') URL_ESCAPE L '+'
         URL_ESCAPE = DIFFER(C, ' ') URL_ESCAPE L '%' HEX(C)
         S = R                                             :(URL_ESCAPE)
URLESC2  URL_ESCAPE = URL_ESCAPE S                             :(RETURN)
*
END_URL_ESCAPE
@

<<>>=
-MODULE HTMLESC
<<INCLUDES>>
-STITL HTMLESC
-EJECT
*
************************************************************************
*                                                                      *
*    #     #  #######  #     #  #        #######   #####    #####      *
*    #     #     #     ##   ##  #        #        #     #  #     #     *
*    #     #     #     # # # #  #        #        #        #           *
*    #######     #     #  #  #  #        #####     #####   #           *
*    #     #     #     #     #  #        #              #  #           *
*    #     #     #     #     #  #        #        #     #  #     #     *
*    #     #     #     #     #  #######  #######   #####    #####      *
*                                                                      *
* HTMLESC             HTML (JS, URL) ESCAPING                          *
*                                                                      *
************************************************************************
*
* HTMLESC.lss
*
<<HTML_ESCAPE>>
*
<<JS_ESCAPE>>
*
<<URL_ESCAPE>>
*
* CE: .MSNOBOL4;
-MODULE HTMLESC
-LINE 14 "HTMLESC.lss"
-INCLUDE 'CH.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'HEX.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SDIFF.INC'
-STITL HTMLESC
-LINE 110 "HTMLESC.lss"
-EJECT
*
************************************************************************
*                                                                      *
*    #     #  #######  #     #  #        #######   #####    #####      *
*    #     #     #     ##   ##  #        #        #     #  #     #     *
*    #     #     #     # # # #  #        #        #        #           *
*    #######     #     #  #  #  #        #####     #####   #           *
*    #     #     #     #     #  #        #              #  #           *
*    #     #     #     #     #  #        #        #     #  #     #     *
*    #     #     #     #     #  #######  #######   #####    #####      *
*                                                                      *
* HTMLESC             HTML (JS, URL) ESCAPING                          *
*                                                                      *
************************************************************************
*
* HTMLESC.lss
*
-LINE 40 "HTMLESC.lss"
-PUBLIC HTML_ESCAPE()
         DEFINE('HTML_ESCAPE(S)')                     :(END_HTML_ESCAPE)
*
HTML_ESCAPE
         S = REPL(S, '&', '&amp;')
         S = REPL(S, '<', '&lt;',)
         S = REPL(S, '>', '&gt;',)
         S = REPL(S, '"', '&quot;')
         S = REPL(S, "'", '&#39;')
         HTML_ESCAPE = S                                       :(RETURN)
*
END_HTML_ESCAPE
*
-LINE 57 "HTMLESC.lss"
-PUBLIC JS_ESCAPE()
         DEFINE('JS_ESCAPE(S)')                         :(END_JS_ESCAPE)
*
JS_ESCAPE
         S = REPL(S, '\', '\\')
         S = REPL(S, "'", "\'")
         S = REPL(S, '"', '\"')
         S = REPL(S, CHARS_NL, '\n')
         S = REPL(S, CHARS_CR, '\r')
         JS_ESCAPE = S                                         :(RETURN)
*
END_JS_ESCAPE
*
-LINE 78 "HTMLESC.lss"
-PUBLIC URL_ESCAPE(), URL_DECODE()
         DEFINE('URL_ESCAPE(S)L,C,R')
         DEFINE('URL_DECODE(S)L,C,R')
         URL_BAD = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789' '_-~.')
         URL_HEX = ANY('0123456789abcdefABCDEF')
+                                                      :(END_URL_ESCAPE)
*
URL_DECODE_2
         S = R
URL_DECODE
         C =
         S BREAK("+%") . L LEN(1) . C REM . R
         URL_DECODE = IDENT(C) URL_DECODE S                   :S(RETURN)
         URL_DECODE = IDENT(C, '+') URL_DECODE L ' '    :S(URL_DECODE_2)
         URL_DECODE = URL_DECODE L
         R (URL_HEX URL_HEX) . C =                      :F(URL_DECODE_2)
         URL_DECODE = URL_DECODE CH(C)                   :(URL_DECODE_2)
*
URL_ESCAPE
         S BREAK(URL_BAD) . L LEN(1) . C REM . R             :F(URLESC2)
         URL_ESCAPE = IDENT(C, ' ') URL_ESCAPE L '+'
         URL_ESCAPE = DIFFER(C, ' ') URL_ESCAPE L '%' HEX(C)
         S = R                                             :(URL_ESCAPE)
URLESC2  URL_ESCAPE = URL_ESCAPE S                             :(RETURN)
*
END_URL_ESCAPE
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>HTMLESC - HTML, JS and URL escaping</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
HTML (web) escaping. Provides three functions to escape a string in
HTML, JS and URL encodings.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CH.html">CH</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HEX.html">HEX</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SDIFF.html">SDIFF</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CH.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;HEX.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
-INCLUDE &#39;SDIFF.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;HTMLESC.INC&#39;
         &amp;CODE = 1
         IDENT(HTML_ESCAPE(&#39;&amp;&lt;&gt;&quot;&#39; &quot;&#39;&quot;), &#39;&amp;amp;&amp;lt;&amp;gt;&amp;quot;&amp;#39;&#39;)
+                                                                <b>:F(END)</b>
         IDENT(JS_ESCAPE(&#39;\&#39; &quot;&#39;&quot; &#39;&quot;&#39; CHARS_NL CHARS_CR),
+                        &#39;\\&#39; &quot;\&#39;&quot; &#39;\&quot;\n\r&#39;)                     <b>:F(END)</b>
         IDENT(URL_ESCAPE(&#39; +!@#&#39;), &#39;+%2B%21%40%23&#39;)             <b>:F(END)</b>
         IDENT(URL_DECODE(&#39;AB%20+%21&#39;), &#39;AB  !&#39;)                 <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Escape HTML characters. Some claim that > never has to be escaped.
Others claim that / should be escaped. Note 39 is decimal!
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;HTML_ESCAPE&raquo;&equiv;</b>
-PUBLIC HTML_ESCAPE()
         DEFINE(&#39;HTML_ESCAPE(S)&#39;)                     <b>:(END_HTML_ESCAPE)</b>
<font color="#818181"><i>*</i></font>
HTML_ESCAPE
         S = REPL(S, &#39;&amp;&#39;, &#39;&amp;amp;&#39;)
         S = REPL(S, &#39;&lt;&#39;, &#39;&amp;lt;&#39;,)
         S = REPL(S, &#39;&gt;&#39;, &#39;&amp;gt;&#39;,)
         S = REPL(S, &#39;&quot;&#39;, &#39;&amp;quot;&#39;)
         S = REPL(S, &quot;&#39;&quot;, &#39;&amp;#39;&#39;)
         HTML_ESCAPE = S                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_HTML_ESCAPE
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Escape JS characters.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JS_ESCAPE&raquo;&equiv;</b>
-PUBLIC JS_ESCAPE()
         DEFINE(&#39;JS_ESCAPE(S)&#39;)                         <b>:(END_JS_ESCAPE)</b>
<font color="#818181"><i>*</i></font>
JS_ESCAPE
         S = REPL(S, &#39;\&#39;, &#39;\\&#39;)
         S = REPL(S, &quot;&#39;&quot;, &quot;\&#39;&quot;)
         S = REPL(S, &#39;&quot;&#39;, &#39;\&quot;&#39;)
         S = REPL(S, CHARS_NL, &#39;\n&#39;)
         S = REPL(S, CHARS_CR, &#39;\r&#39;)
         JS_ESCAPE = S                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_JS_ESCAPE
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Escape URL characters. Space could be escaped as %20. We complement
the characters allowed, yielding the characters that need to be
escaped by doing a set difference between the complete alphabet and
the good character set. This is done at function definition time
(into global <font face="Source Code Pro">URL_BAD</font>).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;URL_ESCAPE&raquo;&equiv;</b>
-PUBLIC URL_ESCAPE(), URL_DECODE()
         DEFINE(&#39;URL_ESCAPE(S)L,C,R&#39;)
         DEFINE(&#39;URL_DECODE(S)L,C,R&#39;)
         URL_BAD = SDIFF(&amp;ALPHABET, &amp;UCASE &amp;LCASE &#39;0123456789&#39; &#39;_-~.&#39;)
         URL_HEX = ANY(&#39;0123456789abcdefABCDEF&#39;)
+                                                      <b>:(END_URL_ESCAPE)</b>
<font color="#818181"><i>*</i></font>
URL_DECODE_2
         S = R
URL_DECODE
         C =
         S BREAK(&quot;+%&quot;) . L LEN(1) . C REM . R
         URL_DECODE = IDENT(C) URL_DECODE S                   <b>:S(RETURN)</b>
         URL_DECODE = IDENT(C, &#39;+&#39;) URL_DECODE L &#39; &#39;    <b>:S(URL_DECODE_2)</b>
         URL_DECODE = URL_DECODE L
         R (URL_HEX URL_HEX) . C =                      <b>:F(URL_DECODE_2)</b>
         URL_DECODE = URL_DECODE CH(C)                   <b>:(URL_DECODE_2)</b>
<font color="#818181"><i>*</i></font>
URL_ESCAPE
         S BREAK(URL_BAD) . L LEN(1) . C REM . R             <b>:F(URLESC2)</b>
         URL_ESCAPE = IDENT(C, &#39; &#39;) URL_ESCAPE L &#39;+&#39;
         URL_ESCAPE = DIFFER(C, &#39; &#39;) URL_ESCAPE L &#39;%&#39; HEX(C)
         S = R                                             <b>:(URL_ESCAPE)</b>
URLESC2  URL_ESCAPE = URL_ESCAPE S                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_URL_ESCAPE
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE HTMLESC
<b>&laquo;INCLUDES&raquo;</b>
-STITL HTMLESC
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    #     #  #######  #     #  #        #######   #####    #####      *</i></font>
<font color="#818181"><i>*    #     #     #     ##   ##  #        #        #     #  #     #     *</i></font>
<font color="#818181"><i>*    #     #     #     # # # #  #        #        #        #           *</i></font>
<font color="#818181"><i>*    #######     #     #  #  #  #        #####     #####   #           *</i></font>
<font color="#818181"><i>*    #     #     #     #     #  #        #              #  #           *</i></font>
<font color="#818181"><i>*    #     #     #     #     #  #        #        #     #  #     #     *</i></font>
<font color="#818181"><i>*    #     #     #     #     #  #######  #######   #####    #####      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* HTMLESC             HTML (JS, URL) ESCAPING                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HTMLESC.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;HTML_ESCAPE&raquo;</b>
<font color="#818181"><i>*</i></font>
<b>&laquo;JS_ESCAPE&raquo;</b>
<font color="#818181"><i>*</i></font>
<b>&laquo;URL_ESCAPE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
</pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:34 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HTMLESC.INC'
-LINE 25 "HTMLESC.lss"
         &CODE = 1
         IDENT(HTML_ESCAPE('&<>"' "'"), '&amp;&lt;&gt;&quot;&#39;')
+                                                                :F(END)
         IDENT(JS_ESCAPE('\' "'" '"' CHARS_NL CHARS_CR),
+                        '\\' "\'" '\"\n\r')                     :F(END)
         IDENT(URL_ESCAPE(' +!@#'), '+%2B%21%40%23')             :F(END)
         IDENT(URL_DECODE('AB%20+%21'), 'AB  !')                 :F(END)
         &CODE = 0
END
<h1>HTMLTMPL - HTML Template</h1>

HTML template. Template is compiled and expanded. Template may contain
if/else unless/else loop include var. Each started with tmpl_ as a
tag or in an html comment. each may have attributes: name, default,
escape. name is the default attribute. Escape may be url, html,
js or none.

The template is read in (usually with readfile), compiled with
tmpl_compile, and expanded with tmpl_interpret. The arguments for
tmpl_interpret are in a table. Array variable is needed for loop. Each
array element is a table with the new variables. These typically come
from a database.

Very little error checking is done. In future we assume that some form
of template caching will be done.

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="HTMLESC.html">HTMLESC</a><br>
<a href="LAST.html">LAST</a><br>
<a href="LINK.html">LINK</a><br>
<a href="READFILE.html">READFILE</a><br>
<a href="REVL.html">REVL</a><br>
<a href="SWAP.html">SWAP</a><br>

<<INCLUDES>>=
//-INCLUDE 'CHARS.INC'
//-INCLUDE 'HTMLESC.INC'
//-INCLUDE 'LAST.INC'
//-INCLUDE 'LINK.INC'
//-INCLUDE 'READFILE.INC'
//-INCLUDE 'REVL.INC'
//-INCLUDE 'SWAP.INC'
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HTMLTMPL.INC'
-INCLUDE 'TIMER.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'TIMER.INC'
*
         &CODE = 1
*        TMPL_INIT()
         S = READFILE("sample.tmpl")
         OUTPUT = S
         P = TMPL_COMPILE(S)                                     :F(END)
* VARIABLES ARE IN A TABLE. SCALAR VARIABLES ARE THE SIMPLEST CASE.
* NOTE THAT TEMPLATE VARIABLES MAY BE DEFAULTED.
         A = TABLE()
         A["var"] = "AB"
         A["var2"] = "CD"
* TEMPLATE LOOPS NEED AN ARRAY VARIABLE. EACH ENTRY OF THE ARRAY IS
* A TABLE WITH THE VARIABLES NEEDED.
         R = ARRAY(3)
         R[1] = #'FIRST=F1 x,LAST=L1'
         R[2] = #'FIRST=F2,LAST=L2'
         R[3] = #'FIRST=F3,LAST=L3'
         A["var3"] = R
         S = TMPL_INTERPRET(P, A)                                :F(END)
         OUTPUT = S
         TIMER(' S = READFILE("sample.tmpl") ')
         TIMER(' P = TMPL_COMPILE(S) ')
         TIMER(' S = TMPL_INTERPRET(P, A) ')
         &CODE = 0
END
@

<<htmltmpl>>=

# A compiled template is a list of template tokens

struct tmpl_token { token_type, token_end, token_args } 


//-USES HTML_ESCAPE(), JS_ESCAPE(), URL_ESCAPE()

# Initialize patterns for HTML template module

//-PUBLIC TMPL_INIT()
procedure tmpl_init() {

   # Directory for template includes

   tmpl_dir = "./"

   # Patterns to break template into tokens

   tmpl_ws = span(" " && chars_tab) | ""
   tmpl = ("/" | "") . h &&
          any("Tt") && any("Mm") && any("Pp") && any("Ll") && "_"
   tmpl_tag = tmpl && span(&ucase && &lcase) . tag
   tmpl_c = "<!-- " && tmpl_ws && tmpl_tag && arb . arg && " -->"
   tmpl_t = "<" && tmpl_tag && break(">") . arg && ">"
   tmpl_piece = pos(0) && breakx("<") . l && (tmpl_t | tmpl_c) . p &&
                rem . r
   tmpl_keys = "var if unless else loop include "

   # Patterns to parse arguments for template token

   tmpl_arg_var = tmpl_ws && (any(&lcase && &ucase) && span(
      &lcase && &ucase && '0123456789' && "_")) . n && tmpl_ws
   tmpl_qval = '"' && break('"') . v && '"'
   tmpl_sval = break(" " && chars_tab) . v
   tmpl_arg_p = ((tmpl_arg_var && "=") | "") && tmpl_ws &&
      (tmpl_qval | tmpl_sval | (rem . v))
}

# Compile template

//-PUBLIC TMPL_COMPILE()
procedure tmpl_compile(s) l {
   if (~(l = tmpl_tokenize(s)))
      freturn
   if (~(l = tmpl_parse(l)))
      freturn
   return l
}

# Interpret template p with arguments a. interpret_tmpl() is
# recursive, so the results are collected into tmpl_interpret.

//-PUBLIC TMPL_INTERPRET()
procedure tmpl_interpret(p, a) {
   interpret_tmpl(p, a)
}

# Default var value escape procedure

procedure none_escape(s) {
   none_escape = s
}

# Recursive interpret template

procedure interpret_tmpl(p, a) p1 p2 v n t e i {
   for (p, p :!: "", p = next(p)) {
      v = value(value(p))
      if (token_type(v) :: "text") {
# text - text from template
	 tmpl_interpret = tmpl_interpret && token_args(v)
      } else {
	 t = token_args(v)
	 n = a[t["name"]]
	 if (token_type(v) :: "var") {
# var - (name, default, escape)
	    if (n :: "")
	       n = t["default"]
	    e = t["escape"]
	    e = ident(e) "none"
	    e = e && "_escape"
	    v = &errlimit; &errlimit = 1; n = apply(e, n); &errlimit = v
	    tmpl_interpret = tmpl_interpret && n
	 } else if ("if unless" ? token_type(v)) {
# if/unless - (name) else
	    p1 = value(next(value(p)))
	    p2 = next(next(value(p)))
	    if (token_type(v) :: "unless")
	       swap(.p1, .p2)
	    if ((n :!: "") || ne(+n, 0))
	       interpret_tmpl(p1, a)
	    else
	       interpret_tmpl(p2, a)
	 } else if (token_type(v) :: "loop") {
# loop - (name)
	    if (datatype(n) :: "ARRAY") {
	       p1 = value(next(value(p)))
	       for (i = 1, n[i], i = i + 1)
		  interpret_tmpl(p1, n[i]);
	    }
	 }
      }
   }
}

# Parse the template, given token list. Separate from tmpl_seq() because
# we want to ensure that all tokens are consumed.

procedure tmpl_parse(l) r {
   if (l :: "")
      return
   if (~(r = tmpl_seq()))
      freturn
   if (l :!: "")
      freturn
   return r
}

# Parse a sequence of tokens from tmpl_tokenize(), into a list
# structure that can be passed to tmpl_interpret()

procedure tmpl_seq() r v v2 p1 p2 {
   while (l :!: "") {
      v = value(l)
      if ("text var" ? token_type(v)) {
	 r = link(link(v), r)
	 l = next(l)
      } else if ("if unless loop" ? token_type(v)) {
	 if (token_end(v) :!: "")
	    return revl(r)
	 l = next(l)
	 if (~(p1 = tmpl_seq()))
	    freturn
	 if (l :: "")
	    freturn
	 p2 = ""
	 v2 = value(l)
	 if ("if unless loop" ? token_type(v2)) {
	    l = next(l)
	 } else if (token_type(v2) :: "else") {
	    l = next(l)
	    if (~(p2 = tmpl_seq()))
	       freturn
	    if (l :: "")
	       freturn
	    l = next(l)
	 } else
	    freturn
	 r = link(link(v, link(p1, p2)), r)
      } else if (token_type(v) :: "else") {
	 return revl(r)
      } else
	 freturn
   }
   return revl(r)
}

# Tokenize the string into a list of tokens

procedure tmpl_tokenize(s) l r p tag r h n t {
   n = .tmpl_tokenize
   while (s :!: "") {
      if (s ? tmpl_piece) {
	 tag = replace(tag, &ucase, &lcase)
	 if (tmpl_keys ? (tag && " ")) {
	    if (l :!: "") {
	       $n = link(tmpl_token("text", "", l)); n = .next($n)
	    }
	    if (tag :: "include") {
               # include tags - read the named file from the tmpl_dir
               # directory, tokenize it and graft the new token list to
               # the list we are building. Walk to the end of the new
               # list with last()
	       if (~(t = tmpl_parse_args(arg)))
		  freturn
	       if (s = readfile(tmpl_dir && t['name'])) {
		  if (~($n = tmpl_tokenize(s)))
		     freturn
		  n = .last(tmpl_tokenize)
	       }
	    } else {
	       t = tmpl_token(tag, h, tmpl_parse_args(arg))
	       $n = link(t); n = .next($n)
	    }
	 } else {
	    $n = link(tmpl_token("text", "", l && p)); n = .next($n)
	 }
	 s = r
      } else {
	 $n = link(tmpl_token("text", "", s)); n = .next($n)
	 s = ""
      }
   }
}

# Parse the arguments for the token. Any arguments are possible,
# only name= default= and escape= will matter.

procedure tmpl_parse_args(s) n v {
   tmpl_parse_args = table()
   while (s :!: "") {
      n = ""
      v = ""
      if ((s ? tmpl_arg_p) = "") {
	 n = replace(n, &ucase, &lcase)
	 n = ident(n) && "name"
	 tmpl_parse_args[n] = v
      } else
	 freturn
   }
   return
}

// tmpl_init()
@

<<>>=
-MODULE HTMLTMPL
-SNOCONE
<<htmltmpl>>

# ce: .f.msnocone;
@
-PLUSOPS 1 
  :(HTMLTMPL.1)
-MODULE HTMLTMPL 
-SNOCONE 
-LINE 72 "HTMLTMPL.lss" 
-LINE 84 "HTMLTMPL.lss"
  :(tmpl_init.END)
-LINE 88
tmpl_init tmpl_dir = "./"
-LINE 92
 tmpl_ws = span(" " chars_tab) | ""
-LINE 93
 tmpl = ("/" | "") . h any("Tt") any("Mm") any("Pp") any("Ll") "_"
-LINE 95
 tmpl_tag = tmpl span(&ucase &lcase) . tag
-LINE 96
 tmpl_c = "<!-- " tmpl_ws tmpl_tag arb . arg " -->"
-LINE 97
 tmpl_t = "<" tmpl_tag break(">") . arg ">"
-LINE 98
 tmpl_piece = pos(0) breakx("<") . l (tmpl_t | tmpl_c) . p rem . r
-LINE 100
 tmpl_keys = "var if unless else loop include "
-LINE 104
 tmpl_arg_var = tmpl_ws (any(&lcase &ucase) span(&lcase 
+&ucase '0123456789' "_")) . n tmpl_ws
-LINE 106
 tmpl_qval = '"' break('"') . v '"'
-LINE 107
 tmpl_sval = break(" " chars_tab) . v
-LINE 108
 tmpl_arg_p = (tmpl_arg_var "=" | "") tmpl_ws (tmpl_qval 
+| tmpl_sval | rem . v) :(RETURN)
-LINE 115
tmpl_init.END  :(tmpl_compile.END)
-LINE 116
tmpl_compile l = tmpl_tokenize(s) :S(HTMLTMPL.2)F(FRETURN)
-LINE 118
HTMLTMPL.2 l = tmpl_parse(l) :S(HTMLTMPL.3)F(FRETURN)
-LINE 120
HTMLTMPL.3 tmpl_compile = l :(RETURN)
-LINE 127
tmpl_compile.END  :(tmpl_interpret.END)
-LINE 128
tmpl_interpret interpret_tmpl(p,a) :(RETURN)
-LINE 133
tmpl_interpret.END  :(none_escape.END)
-LINE 134
none_escape none_escape = s :(RETURN)
-LINE 139
none_escape.END  :(interpret_tmpl.END)
-LINE 140
interpret_tmpl p
HTMLTMPL.4 DIFFER(p,"") :F(HTMLTMPL.5)
-LINE 141
 v = value(value(p))
-LINE 142
 IDENT(token_type(v),"text") :F(HTMLTMPL.6)
-LINE 144
 tmpl_interpret = tmpl_interpret token_args(v) :(HTMLTMPL.7)
-LINE 146
HTMLTMPL.6 t = token_args(v)
-LINE 147
 n = a<t<"name">>
-LINE 148
 IDENT(token_type(v),"var") :F(HTMLTMPL.8)
-LINE 150
 IDENT(n,"") :F(HTMLTMPL.9)
-LINE 151
 n = t<"default">
-LINE 152
HTMLTMPL.9 e = t<"escape">
-LINE 154
 e = e "_escape"
-LINE 155
 v = &errlimit
 &errlimit = 1
 n = apply(e,n)
 &errlimit = v
-LINE 156
 tmpl_interpret = tmpl_interpret n :(HTMLTMPL.10)
-LINE 157
HTMLTMPL.8 "if unless" ? token_type(v) :F(HTMLTMPL.11)
-LINE 159
 p1 = value(next(value(p)))
-LINE 160
 p2 = next(next(value(p)))
-LINE 161
 IDENT(token_type(v),"unless") :F(HTMLTMPL.12)
-LINE 162
 swap(.p1,.p2)
-LINE 163
HTMLTMPL.12 (DIFFER(n,""),ne(+n,0)) :F(HTMLTMPL.13)
-LINE 164
 interpret_tmpl(p1,a) :(HTMLTMPL.14)
-LINE 166
HTMLTMPL.13 interpret_tmpl(p2,a)
-LINE 167
HTMLTMPL.14  :(HTMLTMPL.15)
HTMLTMPL.11 IDENT(token_type(v),"loop") :F(HTMLTMPL.16)
-LINE 169
 IDENT(datatype(n),"ARRAY") :F(HTMLTMPL.17)
-LINE 170
 p1 = value(next(value(p)))
-LINE 171
 i = 1
HTMLTMPL.18 n<i> :F(HTMLTMPL.19)
-LINE 172
 interpret_tmpl(p1,n<i>)
 i = i + 1 :(HTMLTMPL.18)
HTMLTMPL.19 
HTMLTMPL.17 
HTMLTMPL.16 
HTMLTMPL.15 
HTMLTMPL.10 
-LINE 176
HTMLTMPL.7 p = next(p) :(HTMLTMPL.4)
-LINE 177
HTMLTMPL.5  :(RETURN)
-LINE 182
interpret_tmpl.END  :(tmpl_parse.END)
-LINE 183
tmpl_parse IDENT(l,"") :S(RETURN)F(HTMLTMPL.20)
-LINE 185
HTMLTMPL.20 r = tmpl_seq() :S(HTMLTMPL.21)F(FRETURN)
-LINE 187
HTMLTMPL.21 DIFFER(l,"") :S(FRETURN)F(HTMLTMPL.22)
-LINE 189
HTMLTMPL.22 tmpl_parse = r :(RETURN)
-LINE 195
tmpl_parse.END  :(tmpl_seq.END)
-LINE 196
tmpl_seq DIFFER(l,"") :F(HTMLTMPL.23)
-LINE 197
 v = value(l)
-LINE 198
 "text var" ? token_type(v) :F(HTMLTMPL.24)
-LINE 199
 r = link(link(v),r)
-LINE 200
 l = next(l) :(HTMLTMPL.25)
-LINE 201
HTMLTMPL.24 "if unless loop" ? token_type(v) :F(HTMLTMPL.26)
-LINE 202
 DIFFER(token_end(v),"") :F(HTMLTMPL.27)
-LINE 203
 tmpl_seq = revl(r) :(RETURN)
-LINE 204
HTMLTMPL.27 l = next(l)
-LINE 205
 p1 = tmpl_seq() :S(HTMLTMPL.28)F(FRETURN)
-LINE 207
HTMLTMPL.28 IDENT(l,"") :S(FRETURN)F(HTMLTMPL.29)
-LINE 209
HTMLTMPL.29 p2 = ""
-LINE 210
 v2 = value(l)
-LINE 211
 "if unless loop" ? token_type(v2) :F(HTMLTMPL.30)
-LINE 212
 l = next(l) :(HTMLTMPL.31)
-LINE 213
HTMLTMPL.30 IDENT(token_type(v2),"else") :F(HTMLTMPL.32)
-LINE 214
 l = next(l)
-LINE 215
 p2 = tmpl_seq() :S(HTMLTMPL.33)F(FRETURN)
-LINE 217
HTMLTMPL.33 IDENT(l,"") :S(FRETURN)F(HTMLTMPL.34)
-LINE 219
HTMLTMPL.34 l = next(l) :(HTMLTMPL.35)
-LINE 221
HTMLTMPL.32  :(FRETURN)
HTMLTMPL.35 
-LINE 222
HTMLTMPL.31 r = link(link(v,link(p1,p2)),r) :(HTMLTMPL.36)
-LINE 223
HTMLTMPL.26 IDENT(token_type(v),"else") :F(HTMLTMPL.37)
-LINE 224
 tmpl_seq = revl(r) :(RETURN)
-LINE 226
HTMLTMPL.37  :(FRETURN)
HTMLTMPL.38 
HTMLTMPL.36 
-LINE 227
HTMLTMPL.25  :(tmpl_seq)
-LINE 228
HTMLTMPL.23 tmpl_seq = revl(r) :(RETURN)
-LINE 233
tmpl_seq.END  :(tmpl_tokenize.END)
-LINE 234
tmpl_tokenize n = .tmpl_tokenize
-LINE 235
HTMLTMPL.39 DIFFER(s,"") :F(HTMLTMPL.40)
-LINE 236
 s ? tmpl_piece :F(HTMLTMPL.41)
-LINE 237
 tag = replace(tag,&ucase,&lcase)
-LINE 238
 tmpl_keys ? tag " " :F(HTMLTMPL.42)
-LINE 239
 DIFFER(l,"") :F(HTMLTMPL.43)
-LINE 240
 $n = link(tmpl_token("text","",l))
 n = .next($n)
-LINE 242
HTMLTMPL.43 IDENT(tag,"include") :F(HTMLTMPL.44)
-LINE 247
 t = tmpl_parse_args(arg) :S(HTMLTMPL.45)F(FRETURN)
-LINE 249
HTMLTMPL.45 s = readfile(tmpl_dir t<'name'>) :F(HTMLTMPL.46)
-LINE 250
 $n = tmpl_tokenize(s) :S(HTMLTMPL.47)F(FRETURN)
-LINE 252
HTMLTMPL.47 n = .last(tmpl_tokenize)
-LINE 254
HTMLTMPL.46  :(HTMLTMPL.48)
-LINE 255
HTMLTMPL.44 t = tmpl_token(tag,h,tmpl_parse_args(arg))
-LINE 256
 $n = link(t)
 n = .next($n)
-LINE 258
HTMLTMPL.48  :(HTMLTMPL.49)
-LINE 259
HTMLTMPL.42 $n = link(tmpl_token("text","",l p))
 n = .next($n)
-LINE 261
HTMLTMPL.49 s = r :(HTMLTMPL.50)
-LINE 263
HTMLTMPL.41 $n = link(tmpl_token("text","",s))
 n = .next($n)
-LINE 264
 s = ""
-LINE 266
HTMLTMPL.50  :(HTMLTMPL.39)
-LINE 267
HTMLTMPL.40  :(RETURN)
-LINE 272
tmpl_tokenize.END  :(tmpl_parse_args.END)
-LINE 273
tmpl_parse_args tmpl_parse_args = table()
-LINE 274
HTMLTMPL.51 DIFFER(s,"") :F(HTMLTMPL.52)
-LINE 275
 n = ""
-LINE 276
 v = ""
-LINE 277
 s ? tmpl_arg_p = "" :F(HTMLTMPL.53)
-LINE 278
 n = replace(n,&ucase,&lcase)
-LINE 279
 n = ident(n) "name"
-LINE 280
 tmpl_parse_args<n> = v :(HTMLTMPL.54)
-LINE 282
HTMLTMPL.53  :(FRETURN)
-LINE 283
HTMLTMPL.54  :(HTMLTMPL.51)
-LINE 284
HTMLTMPL.52  :(RETURN)
tmpl_parse_args.END 
-LINE 293 "HTMLTMPL.lss" 
HTMLTMPL.1 
 DATA('tmpl_token(token_type,token_end,token_args)')
-USES HTML_ESCAPE(), JS_ESCAPE(), URL_ESCAPE() 
-PUBLIC TMPL_INIT() 
 DEFINE('tmpl_init()')
-PUBLIC TMPL_COMPILE() 
 DEFINE('tmpl_compile(s)l')
-PUBLIC TMPL_INTERPRET() 
 DEFINE('tmpl_interpret(p,a)')
 DEFINE('none_escape(s)')
 DEFINE('interpret_tmpl(p,a)p1,p2,v,n,t,e,i')
 DEFINE('tmpl_parse(l)r')
 DEFINE('tmpl_seq()r,v,v2,p1,p2')
 DEFINE('tmpl_tokenize(s)l,r,p,tag,r,h,n,t')
 DEFINE('tmpl_parse_args(s)n,v')
  tmpl_init()
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>HTMLTMPL - HTML Template</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
HTML template. Template is compiled and expanded. Template may contain
if/else unless/else loop include var. Each started with tmpl_ as a
tag or in an html comment. each may have attributes: name, default,
escape. name is the default attribute. Escape may be url, html,
js or none.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The template is read in (usually with readfile), compiled with
tmpl_compile, and expanded with tmpl_interpret. The arguments for
tmpl_interpret are in a table. Array variable is needed for loop. Each
array element is a table with the new variables. These typically come
from a database.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Very little error checking is done. In future we assume that some form
of template caching will be done.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="HTMLESC.html">HTMLESC</a><br>
<a href="LAST.html">LAST</a><br>
<a href="LINK.html">LINK</a><br>
<a href="READFILE.html">READFILE</a><br>
<a href="REVL.html">REVL</a><br>
<a href="SWAP.html">SWAP</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
//-INCLUDE &#39;CHARS.INC&#39;
//-INCLUDE &#39;HTMLESC.INC&#39;
//-INCLUDE &#39;LAST.INC&#39;
//-INCLUDE &#39;LINK.INC&#39;
//-INCLUDE &#39;READFILE.INC&#39;
//-INCLUDE &#39;REVL.INC&#39;
//-INCLUDE &#39;SWAP.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;HTMLTMPL.INC&#39;
-INCLUDE &#39;TIMER.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;TIMER.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
<font color="#818181"><i>*        TMPL_INIT()</i></font>
         S = READFILE(&quot;sample.tmpl&quot;)
         OUTPUT = S
         P = TMPL_COMPILE(S)                                     <b>:F(END)</b>
<font color="#818181"><i>* VARIABLES ARE IN A TABLE. SCALAR VARIABLES ARE THE SIMPLEST CASE.</i></font>
<font color="#818181"><i>* NOTE THAT TEMPLATE VARIABLES MAY BE DEFAULTED.</i></font>
         A = TABLE()
         A[&quot;var&quot;] = &quot;AB&quot;
         A[&quot;var2&quot;] = &quot;CD&quot;
<font color="#818181"><i>* TEMPLATE LOOPS NEED AN ARRAY VARIABLE. EACH ENTRY OF THE ARRAY IS</i></font>
<font color="#818181"><i>* A TABLE WITH THE VARIABLES NEEDED.</i></font>
         R = ARRAY(3)
         R[1] = #&#39;FIRST=F1 x,LAST=L1&#39;
         R[2] = #&#39;FIRST=F2,LAST=L2&#39;
         R[3] = #&#39;FIRST=F3,LAST=L3&#39;
         A[&quot;var3&quot;] = R
         S = TMPL_INTERPRET(P, A)                                <b>:F(END)</b>
         OUTPUT = S
         TIMER(&#39; S = READFILE(&quot;sample.tmpl&quot;) &#39;)
         TIMER(&#39; P = TMPL_COMPILE(S) &#39;)
         TIMER(&#39; S = TMPL_INTERPRET(P, A) &#39;)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;htmltmpl&raquo;&equiv;</b>

<font color="#818181"><i># A compiled template is a list of template tokens</i></font>

struct tmpl_token { token_type, token_end, token_args }


//-USES HTML_ESCAPE(), JS_ESCAPE(), URL_ESCAPE()

<font color="#818181"><i># Initialize patterns for HTML template module</i></font>

//-PUBLIC TMPL_INIT()
procedure tmpl_init() {

   # Directory for template includes

   tmpl_dir = &quot;./&quot;

   # Patterns to break template into tokens

   tmpl_ws = span(&quot; &quot; &amp;&amp; chars_tab) | &quot;&quot;
   tmpl = (&quot;/&quot; | &quot;&quot;) . h &amp;&amp;
          any(&quot;Tt&quot;) &amp;&amp; any(&quot;Mm&quot;) &amp;&amp; any(&quot;Pp&quot;) &amp;&amp; any(&quot;Ll&quot;) &amp;&amp; &quot;_&quot;
   tmpl_tag = tmpl &amp;&amp; span(&amp;ucase &amp;&amp; &amp;lcase) . tag
   tmpl_c = &quot;&lt;!-- &quot; &amp;&amp; tmpl_ws &amp;&amp; tmpl_tag &amp;&amp; arb . arg &amp;&amp; &quot; --&gt;&quot;
   tmpl_t = &quot;&lt;&quot; &amp;&amp; tmpl_tag &amp;&amp; break(&quot;&gt;&quot;) . arg &amp;&amp; &quot;&gt;&quot;
   tmpl_piece = pos(0) &amp;&amp; breakx(&quot;&lt;&quot;) . l &amp;&amp; (tmpl_t | tmpl_c) . p &amp;&amp;
                rem . r
   tmpl_keys = &quot;var if unless else loop include &quot;

   # Patterns to parse arguments for template token

   tmpl_arg_var = tmpl_ws &amp;&amp; (any(&amp;lcase &amp;&amp; &amp;ucase) &amp;&amp; span(
      &amp;lcase &amp;&amp; &amp;ucase &amp;&amp; &#39;0123456789&#39; &amp;&amp; &quot;_&quot;)) . n &amp;&amp; tmpl_ws
   tmpl_qval = &#39;&quot;&#39; &amp;&amp; break(&#39;&quot;&#39;) . v &amp;&amp; &#39;&quot;&#39;
   tmpl_sval = break(&quot; &quot; &amp;&amp; chars_tab) . v
   tmpl_arg_p = ((tmpl_arg_var &amp;&amp; &quot;=&quot;) | &quot;&quot;) &amp;&amp; tmpl_ws &amp;&amp;
      (tmpl_qval | tmpl_sval | (rem . v))
}

<font color="#818181"><i># Compile template</i></font>

//-PUBLIC TMPL_COMPILE()
procedure tmpl_compile(s) l {
   if (~(l = tmpl_tokenize(s)))
      freturn
   if (~(l = tmpl_parse(l)))
      freturn
   return l
}

<font color="#818181"><i># Interpret template p with arguments a. interpret_tmpl() is</i></font>
<font color="#818181"><i># recursive, so the results are collected into tmpl_interpret.</i></font>

//-PUBLIC TMPL_INTERPRET()
procedure tmpl_interpret(p, a) {
   interpret_tmpl(p, a)
}

<font color="#818181"><i># Default var value escape procedure</i></font>

procedure none_escape(s) {
   none_escape = s
}

<font color="#818181"><i># Recursive interpret template</i></font>

procedure interpret_tmpl(p, a) p1 p2 v n t e i {
   for (p, p :!: &quot;&quot;, p = next(p)) {
      v = value(value(p))
      if (token_type(v) :: &quot;text&quot;) {
<font color="#818181"><i># text - text from template</i></font>
	 tmpl_interpret = tmpl_interpret &amp;&amp; token_args(v)
      } else {
	 t = token_args(v)
	 n = a[t[&quot;name&quot;]]
	 if (token_type(v) :: &quot;var&quot;) {
<font color="#818181"><i># var - (name, default, escape)</i></font>
	    if (n :: &quot;&quot;)
	       n = t[&quot;default&quot;]
	    e = t[&quot;escape&quot;]
	    e = ident(e) &quot;none&quot;
	    e = e &amp;&amp; &quot;_escape&quot;
	    v = &amp;errlimit; &amp;errlimit = 1; n = apply(e, n); &amp;errlimit = v
	    tmpl_interpret = tmpl_interpret &amp;&amp; n
	 } else if (&quot;if unless&quot; ? token_type(v)) {
<font color="#818181"><i># if/unless - (name) else</i></font>
	    p1 = value(next(value(p)))
	    p2 = next(next(value(p)))
	    if (token_type(v) :: &quot;unless&quot;)
	       swap(.p1, .p2)
	    if ((n :!: &quot;&quot;) || ne(+n, 0))
	       interpret_tmpl(p1, a)
	    else
	       interpret_tmpl(p2, a)
	 } else if (token_type(v) :: &quot;loop&quot;) {
<font color="#818181"><i># loop - (name)</i></font>
	    if (datatype(n) :: &quot;ARRAY&quot;) {
	       p1 = value(next(value(p)))
	       for (i = 1, n[i], i = i + 1)
		  interpret_tmpl(p1, n[i]);
	    }
	 }
      }
   }
}

<font color="#818181"><i># Parse the template, given token list. Separate from tmpl_seq() because</i></font>
<font color="#818181"><i># we want to ensure that all tokens are consumed.</i></font>

procedure tmpl_parse(l) r {
   if (l :: &quot;&quot;)
      return
   if (~(r = tmpl_seq()))
      freturn
   if (l :!: &quot;&quot;)
      freturn
   return r
}

<font color="#818181"><i># Parse a sequence of tokens from tmpl_tokenize(), into a list</i></font>
<font color="#818181"><i># structure that can be passed to tmpl_interpret()</i></font>

procedure tmpl_seq() r v v2 p1 p2 {
   while (l :!: &quot;&quot;) {
      v = value(l)
      if (&quot;text var&quot; ? token_type(v)) {
	 r = link(link(v), r)
	 l = next(l)
      } else if (&quot;if unless loop&quot; ? token_type(v)) {
	 if (token_end(v) :!: &quot;&quot;)
	    return revl(r)
	 l = next(l)
	 if (~(p1 = tmpl_seq()))
	    freturn
	 if (l :: &quot;&quot;)
	    freturn
	 p2 = &quot;&quot;
	 v2 = value(l)
	 if (&quot;if unless loop&quot; ? token_type(v2)) {
	    l = next(l)
	 } else if (token_type(v2) :: &quot;else&quot;) {
	    l = next(l)
	    if (~(p2 = tmpl_seq()))
	       freturn
	    if (l :: &quot;&quot;)
	       freturn
	    l = next(l)
	 } else
	    freturn
	 r = link(link(v, link(p1, p2)), r)
      } else if (token_type(v) :: &quot;else&quot;) {
	 return revl(r)
      } else
	 freturn
   }
   return revl(r)
}

<font color="#818181"><i># Tokenize the string into a list of tokens</i></font>

procedure tmpl_tokenize(s) l r p tag r h n t {
   n = .tmpl_tokenize
   while (s :!: &quot;&quot;) {
      if (s ? tmpl_piece) {
	 tag = replace(tag, &amp;ucase, &amp;lcase)
	 if (tmpl_keys ? (tag &amp;&amp; &quot; &quot;)) {
	    if (l :!: &quot;&quot;) {
	       $n = link(tmpl_token(&quot;text&quot;, &quot;&quot;, l)); n = .next($n)
	    }
	    if (tag :: &quot;include&quot;) {
               # include tags - read the named file from the tmpl_dir
               # directory, tokenize it and graft the new token list to
               # the list we are building. Walk to the end of the new
               # list with last()
	       if (~(t = tmpl_parse_args(arg)))
		  freturn
	       if (s = readfile(tmpl_dir &amp;&amp; t[&#39;name&#39;])) {
		  if (~($n = tmpl_tokenize(s)))
		     freturn
		  n = .last(tmpl_tokenize)
	       }
	    } else {
	       t = tmpl_token(tag, h, tmpl_parse_args(arg))
	       $n = link(t); n = .next($n)
	    }
	 } else {
	    $n = link(tmpl_token(&quot;text&quot;, &quot;&quot;, l &amp;&amp; p)); n = .next($n)
	 }
	 s = r
      } else {
	 $n = link(tmpl_token(&quot;text&quot;, &quot;&quot;, s)); n = .next($n)
	 s = &quot;&quot;
      }
   }
}

<font color="#818181"><i># Parse the arguments for the token. Any arguments are possible,</i></font>
<font color="#818181"><i># only name= default= and escape= will matter.</i></font>

procedure tmpl_parse_args(s) n v {
   tmpl_parse_args = table()
   while (s :!: &quot;&quot;) {
      n = &quot;&quot;
      v = &quot;&quot;
      if ((s ? tmpl_arg_p) = &quot;&quot;) {
	 n = replace(n, &amp;ucase, &amp;lcase)
	 n = ident(n) &amp;&amp; &quot;name&quot;
	 tmpl_parse_args[n] = v
      } else
	 freturn
   }
   return
}

// tmpl_init()
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE HTMLTMPL
-SNOCONE
<b>&laquo;htmltmpl&raquo;</b>

<font color="#818181"><i># ce: .f.msnocone;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:43 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'HTMLTMPL.INC'
-LINE 41 "HTMLTMPL.lss"
-INCLUDE 'TIMER.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'TIMER.INC'
*
         &CODE = 1
*        TMPL_INIT()
         S = READFILE("sample.tmpl")
         OUTPUT = S
         P = TMPL_COMPILE(S)                                     :F(END)
* VARIABLES ARE IN A TABLE. SCALAR VARIABLES ARE THE SIMPLEST CASE.
* NOTE THAT TEMPLATE VARIABLES MAY BE DEFAULTED.
         A = TABLE()
         A["var"] = "AB"
         A["var2"] = "CD"
* TEMPLATE LOOPS NEED AN ARRAY VARIABLE. EACH ENTRY OF THE ARRAY IS
* A TABLE WITH THE VARIABLES NEEDED.
         R = ARRAY(3)
         R[1] = #'FIRST=F1 x,LAST=L1'
         R[2] = #'FIRST=F2,LAST=L2'
         R[3] = #'FIRST=F3,LAST=L3'
         A["var3"] = R
         S = TMPL_INTERPRET(P, A)                                :F(END)
         OUTPUT = S
         TIMER(' S = READFILE("sample.tmpl") ')
         TIMER(' P = TMPL_COMPILE(S) ')
         TIMER(' S = TMPL_INTERPRET(P, A) ')
         &CODE = 0
END
<h1>ifs - IF Statement Processor</h1>

Conditional names begin with a letter, followed by zero or more
letters, digits, underscore or period.

Operators are [[OR]], [[AND]], [[NE]] and [[EQ]].

Conditional names are assigned integer values with the %SET directive:
[[%SET(NAME,VALUE)]]. Note that % can be changed ([[IFSLC='*']]).
The [[VALUE]] may be a number, or a parenthesized SNOBOL4 expression.
This allows [[HOST()]] functions to be used (for example).

Files may be included with a [[%INCLUDE(FILE)]] directive. Included
files may be nested.

[[%*(A COMMENT)]] is a single line comment. Block comments are
trivially done with [[%IF]]. Line comment usually documents [[%SET]].

Conditionals and directives must begin in column one, or preceeded by
white space. Expressions must be fully parenthesized.

[[
    %* (A SAMPLE COMMENT)
    %SET(NAME1,1)
    %SET(NAME2,0)
    %SET(NAME3,1)
    %SET(NAME4,1)
    %SET(NAME5,HOST(HOST_POINTER_BITS))
    %INCLUDE(FILE)
    %IF ((NAME1 OR NAME2) EQ NAME3)
      %IF (NAME4)
      %ENDIF
    %ELSE
    %ENDIF
]]

Reads from standard input and writes standard output performing the
conditionals. Conditionals may be nested.

May be used in batch files - returns [[&CODE = 1]] if error (syntax,
unclosed [[%IF]] at EOF). Returns [[&CODE = 0]] if ok.

IFS is useful because it does not strip [[C]] or [[C++]] comments. It
can be used for multiple source languages. It only does include and
conditionals, and no other macro expansion.

<h2>Environment Variables</h2>
<ul>
<li>IFSDIR=dir/for/includes</li>
<li>IFSLC=% change lead-in character</li>
<li>LSS=SNOBOL4|C|ASM generate line directives</li>
</ul>

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="FASTBAL.html">FASTBAL</a><br>
<a href="HOST.html">HOST</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'FASTBAL.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'SYSTEM.INC'
-INCLUDE 'VDIFFER.INC'
@

<<IFS>>=
-PLUSOPS 1
*
         TERMINAL = 'IFS (WED NOV  6 13:40:26 EST 2013)'
*
* SYSTEM() FAILS IF ANCHORED
*
         SYSTEM = SYSTEM()
*
         &ANCHOR = 1
         &CODE = 1
*
* USEFUL CONSTANTS
*
         LC = '%'
         LC = HOST(HOST_GETENV, 'IFSLC')
         WHITE = SPAN(' ' CHARS_HT)
         OPT_WS = WHITE | NULL
         NAME = ANY(&LCASE &UCASE)
+               (SPAN(&LCASE &UCASE &DIGITS '_.') | NULL)
*
* SYMTBL TRACKS DEFINED CONDITIONAL SYMBOLS. (UNDEFINED SYMBOLS ARE
* ASSIGNED NULL VALUES IN SYMTBL.)
*
         SYMTBL = TABLE(101)
*
* STATESTK MAINTAINS ALL STATE INFORMATION WHILE PROCESSING CONDITIONAL
* STATEMENTS. NESTLEVEL INDEXES THE TOP ENTRY. ANOTHER VARIABLE, TOP,
* HAS A COPY OF SAVESTK<NESTLEVEL>.
*
         STATESTK = TABLE()
         INCNAME = TABLE()
         INCSTACK = TABLE()
         INCLNNO = TABLE()
         NESTLEVEL = 0
         TOP =
*
* EACH STATE ENTRY IN STATESTK CONTAINS STATE INFORMATION ABOUT THE
* PROCESSING FOR EACH ACTIVE %IF. THE STATE IS MAINTAINED AS 2 FIELDS:
*
*     RESULT  THE RESULT OF THE %IF EXPRESSION EVALUATION-
*             TRUE, FALSE, OR BYPASS
*
*     MODE    WHETHER PROCESSING THEN OR ELSE PORTION OF %IF
*
         DATA('STATE(RESULT,MODE)')
         FALSE = 0
         TRUE = 1
         BYPASS = 2
         ELSE = 0
         THEN = 1
*
* PROCESSREC IS INDEXED BY THE CURRENT RESULT AND MODE TO DETERMINE
* WHETHER OR NOT A STATEMENT SHOULD BE PROCESSED AND WRITTEN TO THE
* OUTPUT FILE. DEFAULT VALUE IS 0 -- IGNORE STATEMENT.
*
        PROCESSREC = ARRAY(FALSE ':' BYPASS ',' ELSE ':' THEN, 0)
        PROCESSREC<TRUE, THEN> = 1
        PROCESSREC<FALSE, ELSE> = 1
*
*  FUNCTIONS
*
*
*  OUTPUT = PROCESS(INPUT)
*
*  PROCESS LINE IN THE CONTEXT OF CURRENT CONDITIONALS.
*  FAILS IF LINE IS TO BE IGNORED. OTHERWISE IT RETURNS THE INPUT.
*
        DEFINE('PROCESS(PROCESS)CONDCMD,CONDEXP')
*
*  P_CONDASM BREAKS UP CONDITIONAL ASSEMBLY DIRECTIVES.
*
         P_CONDASM = OPT_WS LC (
+           (('IF' | 'if') . CONDCMD OPT_WS BAL . CONDEXP 
+                            OPT_WS RPOS(0)) |
+           (('ENDIF' | 'endif') . CONDCMD) |
+           (('ELSE' | 'else') . CONDCMD) )               :(PROCESS_END)
*
PROCESS PROCESS ? P_CONDASM                                 :S($CONDCMD)
*
*  PROCESS STATEMENTS OTHER THAN CONDITIONAL DIRECTIVES.
*
         EQ(NESTLEVEL, 0)                                     :S(RETURN)
         EQ(PROCESSREC<RESULT(TOP), MODE(TOP)>, 0)  :S(FRETURN)F(RETURN)
*
*  PROCESS %IF (EXPRESSION)
*
IF       EQ(NESTLEVEL)                                          :S(IFOK)
*
* HERE FOR NESTED %IF
*
         NE(PROCESSREC<RESULT(TOP), MODE(TOP)>)                 :S(IFOK)
         NESTLEVEL = NESTLEVEL + 1
         TOP = STATESTK<NESTLEVEL> = STATE(BYPASS, THEN)      :(FRETURN)
*
* HERE FOR %IF TO BE PROCESSED NORMALLY.
*
IFOK     NESTLEVEL = NESTLEVEL + 1
         TOP = STATESTK<NESTLEVEL> = STATE(
+           (EQ(EVALUATE(CONDEXP), 1) TRUE, FALSE),
+           THEN)                                             :(FRETURN)
*
* PROCESS %ELSE
*
ELSE     MODE(TOP) = NE(NESTLEVEL) ELSE                      :S(FRETURN)
         TERMINAL = LC 'ELSE ENCOUNTERED OUTSIDE OF ' LC 'IF,' REPORT()
+                                                                 :(END)
*
* PROCESS %ENDIF
*
ENDIF    NESTLEVEL = NE(NESTLEVEL) NESTLEVEL - 1           :F(ENDIF_ERR)
         TOP = (NE(NESTLEVEL) STATESTK<NESTLEVEL>, '')        :(FRETURN)
ENDIF_ERR
         TERMINAL = LC 'ENDIF ENCOUNTERED OUTSIDE OF ' LC 'IF,'
+           REPORT()                                              :(END)
*
PROCESS_END
*
* EVALUATE AN ARGUMENT OF THE FORM '(OPERAND OPR OPERAND)'
*
         DEFINE('EVALUATE(EXP)ARG1,ARG2,OPERATOR')
         P_OPERAND = NAME | SPAN(&DIGITS) | BAL
         P_OPERATOR = 'OR' | 'or' | 'AND' | 'and' | 'NE' 'ne' |
+                     'EQ' | 'eq'
         P_EV1 = P_OPERAND . ARG1 WHITE P_OPERATOR . OPERATOR
+           WHITE P_OPERAND . ARG2
         P_EV2 = P_OPERAND . ARG1 '' . OPERATOR . ARG2
         P_EV3 = '(' OPT_WS (P_EV1 | P_EV2) OPT_WS ')' RPOS(0)
                                                         :(EVALUATE_END)
EVALUATE EXP ? P_EV3                                         :F(EVAL_ER)
         EVALUATE = (DIFFER(OPERATOR)
+           APPLY(OPERATOR '.', OPER(ARG1), OPER(ARG2)),
+           OPER(ARG1))                                        :(RETURN)
EVAL_ER  TERMINAL = 'BAD EXPRESSION: ' EXP REPORT()               :(END)
EVALUATE_END
*
* EVALUATE AN OPERAND TO PRODUCE VALUE OF 0 OR 1
* IF ARGUMENT IS NAME, GET ITS VALUE FROM THE SYMTABLE. OTHERWISE
* IF IT IS A SIMPLE INTEGER, RETURN IT. OTHERWISE IT MUST BE
* A PARENTHESIZED EXPRESSION. CALL EVALUATE.
*
         DEFINE('OPER(ARG)')                                 :(OPER_END)
OPER     OPER = INTEGER(ARG) ARG                              :S(RETURN)
         IDENT(SUBSTR(ARG, 1, 1), '(')                        :S(OPER.1)
         OPER = SYMTBL<ARG>
         DIFFER(OPER)                                         :S(RETURN)
         TERMINAL = 'UNDEFINED OPERAND: ' ARG REPORT()            :(END)
OPER.1   OPER = EVALUATE(ARG)                                  :(RETURN)
OPER_END
*
* EQ OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('EQ.(A,B)')                                    :(EQ.END)
EQ.      EQ. = (EQ(A, B) 1, 0)                                 :(RETURN)
EQ.END
*
* NE OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('NE.(A,B)')                                    :(NE.END)
NE.      NE. = (EQ(A, B) 0, 1)                                 :(RETURN)
NE.END
*
* OR OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('OR.(A,B)')                                    :(OR.END)
OR.      OR. = (EQ(A) EQ(B) 0, 1)                              :(RETURN)
OR.END
*
* AND OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('AND.(A,B)')                                  :(AND.END)
AND.     AND. = (EQ(A, 1) EQ(B, 1) 1, 0)                       :(RETURN)
AND.END
*
* RETURN CURRENT LINE NUMBER AND FILE NAME.
*
         DEFINE('REPORT()')                                :(REPORT_END)
REPORT   REPORT = ' IN FILE ' INNAME ', LINE ' +LINENO         :(RETURN)
REPORT_END
*
* HERE'S THE 'MAIN' PROGRAM.
*
         P_SET = OPT_WS LC ('SET' | 'set') OPT_WS '(' OPT_WS NAME . ARG1
+           OPT_WS ','
+           OPT_WS FASTBAL('(<[]>)', "'" '"', ',)') . ARG2 OPT_WS ')'
         P_INCLUDE = OPT_WS LC ('INCLUDE' | 'include') OPT_WS
+           '(' BREAK(')') . ARG1 ')'
         P_COMMENT = OPT_WS LC '*' OPT_WS '(' BREAK(')') ')'
*
* LOOP UNTIL END OF INPUT.
*
* READS STANDARD INPUT, WRITES STANDARD OUTPUT.
*
         LSSTYPE = HOST(4, 'LSS')
         FN = HOST(2, HOST(3))
         INPUT(.INPUT, 10,, FN)                               :F(NONAME)
NONAME   INVAR  = .INPUT
         INNAME = 'STDIN'
         FILELEVEL = 0
*
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? 'SNOBOL4') '-LINE 1'
         LINELEAD = ?(LSSTYPE ? 'C') '#line 1'
         LINELEAD = ?(LSSTYPE ? 'ASM') '%LINE 1'
         OUTPUT = VDIFFER(LINELEAD) ' "' VDIFFER(FN) '"'
*
* MAIN LOOP READING AND WRITING FILES
*
LOOP     LINE = $INVAR                                           :F(EOF)
         LINENO = LINENO + 1
         RESULT = PROCESS(LINE)                                 :F(LOOP)
         RESULT ? P_COMMENT                                     :S(LOOP)
*
* INPUT LINE TO BE RETAINED. LOOK FOR %SET COMMAND. IF FOUND, DEFINE
* THE SYMBOL AND OMIT THE LINE FROM THE OUTPUT FILE.
*
         RESULT ? P_SET                                   :F(CK_INCLUDE)
         V = EVAL(ARG2)
         SYMTBL<ARG1> = INTEGER(V) +V                           :S(LOOP)
         TERMINAL = LC 'SET NON-NUMERIC VALUE: ' ARG2 REPORT()    :(END)
*
* CHECK FOR %INCLUDE COMMAND. STRIP ANY SURROUNDING QUOTE MARKS.
*
CK_INCLUDE
         RESULT ? P_INCLUDE                                   :F(PUTOUT)
         ARG1 ? "'" BREAK("'") . ARG1 "'" RPOS(0)
         FILELEVEL = FILELEVEL + 1
         INCSTACK<FILELEVEL> = INVAR
         INCNAME<FILELEVEL> = INNAME
         INCLNNO<FILELEVEL> = LINENO
         INVAR = 'INPUT' FILELEVEL
*
* TRY THE CURRENT DIRECTORY; IF THE FILE IS NOT THERE, TRY IFSDIR
* AND THEN SNOLIB. SHOULD DO PATH SEARCH (SEE LSINC).
*
         DS = HOST(HOST_DIR_SEP)
         INPUT(INVAR, FILELEVEL + 19,, ARG1)                    :S(INC1)
         X = HOST(HOST_GETENV, 'IFSDIR')                        :F(INC3)
         INPUT(INVAR, FILELEVEL + 19,, X DS ARG1)               :S(INC1)
INC3     X = HOST(HOST_GETENV, 'SNOLIB')                        :S(INC2)
         X = HOST(HOST_SNOLIB_DIR)
INC2     INPUT(INVAR, FILELEVEL + 19,, X DS ARG1)               :S(INC1)
         TERMINAL = LC 'INCLUDE FILE NOT FOUND: ' "'" ARG1 "'" REPORT()
+                                                                 :(END)
INC1     INNAME = ARG1
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? 'SNOBOL4') '-LINE 1 "'
         LINELEAD = ?(LSSTYPE ? 'C') '#line 1 "'
         LINELEAD = ?(LSSTYPE ? 'ASM') '%LINE 1 "'
         OUTPUT = VDIFFER(LINELEAD) INNAME '"'
INC4     LINENO = 0                                              :(LOOP)
*
* OUTPUT THE PROCESSED LINE
*
PUTOUT   OUTPUT = RESULT                                         :(LOOP)
*
* HERE ON EOF. CHECK IF INSIDE AN INCLUDE FILE.
*
EOF      EQ(FILELEVEL, 0)                                       :S(EOF2)
         ENDFILE(FILELEVEL + 19)
         INVAR = INCSTACK<FILELEVEL>
         INNAME = INCNAME<FILELEVEL>
         LINENO = INCLNNO<FILELEVEL>
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? 'SNOBOL4') '-LINE '
         LINELEAD = ?(LSSTYPE ? 'C') '#line '
         LINELEAD = ?(LSSTYPE ? 'ASM') '%LINE '
         OUTPUT = VDIFFER(LINELEAD) LINENO + 1 ' "' INNAME '"'
         FILELEVEL = FILELEVEL - 1                               :(LOOP)
*
EOF2     TERMINAL = NE(NESTLEVEL) 'EOF IN NESTED IF AT LEVEL ' NESTLEVEL
+                                                                :S(END)
         &CODE = 0                                                :(END)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM IFS
-TITLE IFS
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                         ###  #######   #####                         *
*                          #   #        #     #                        *
*                          #   #        #                              *
*                          #   #####     #####                         *
*                          #   #              #                        *
*                          #   #        #     #                        *
*                         ###  #         #####                         *
*                                                                      *
* IFS              PREPROCESS FOR %IF CONDITIONALS                     *
*                                                                      *
* CONVERTED FROM IF.SPT                                                *
*                                                                      *
************************************************************************
*
* ifs.lss
*
<<IFS>>
*
* CE: .MSNOBOL4;
@#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM IFS
-LINE 350 "ifs.lss"
-TITLE IFS
START
-LINE 62 "ifs.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'FASTBAL.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'SYSTEM.INC'
-INCLUDE 'VDIFFER.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                         ###  #######   #####                         *
*                          #   #        #     #                        *
*                          #   #        #                              *
*                          #   #####     #####                         *
*                          #   #              #                        *
*                          #   #        #     #                        *
*                         ###  #         #####                         *
*                                                                      *
* IFS              PREPROCESS FOR %IF CONDITIONALS                     *
*                                                                      *
* CONVERTED FROM IF.SPT                                                *
*                                                                      *
************************************************************************
*
* ifs.lss
*
-LINE 70 "ifs.lss"
-PLUSOPS 1
*
         TERMINAL = 'IFS (WED NOV  6 13:40:26 EST 2013)'
*
* SYSTEM() FAILS IF ANCHORED
*
         SYSTEM = SYSTEM()
*
         &ANCHOR = 1
         &CODE = 1
*
* USEFUL CONSTANTS
*
         LC = '%'
         LC = HOST(HOST_GETENV, 'IFSLC')
         WHITE = SPAN(' ' CHARS_HT)
         OPT_WS = WHITE | NULL
         NAME = ANY(&LCASE &UCASE)
+               (SPAN(&LCASE &UCASE &DIGITS '_.') | NULL)
*
* SYMTBL TRACKS DEFINED CONDITIONAL SYMBOLS. (UNDEFINED SYMBOLS ARE
* ASSIGNED NULL VALUES IN SYMTBL.)
*
         SYMTBL = TABLE(101)
*
* STATESTK MAINTAINS ALL STATE INFORMATION WHILE PROCESSING CONDITIONAL
* STATEMENTS. NESTLEVEL INDEXES THE TOP ENTRY. ANOTHER VARIABLE, TOP,
* HAS A COPY OF SAVESTK<NESTLEVEL>.
*
         STATESTK = TABLE()
         INCNAME = TABLE()
         INCSTACK = TABLE()
         INCLNNO = TABLE()
         NESTLEVEL = 0
         TOP =
*
* EACH STATE ENTRY IN STATESTK CONTAINS STATE INFORMATION ABOUT THE
* PROCESSING FOR EACH ACTIVE %IF. THE STATE IS MAINTAINED AS 2 FIELDS:
*
*     RESULT  THE RESULT OF THE %IF EXPRESSION EVALUATION-
*             TRUE, FALSE, OR BYPASS
*
*     MODE    WHETHER PROCESSING THEN OR ELSE PORTION OF %IF
*
         DATA('STATE(RESULT,MODE)')
         FALSE = 0
         TRUE = 1
         BYPASS = 2
         ELSE = 0
         THEN = 1
*
* PROCESSREC IS INDEXED BY THE CURRENT RESULT AND MODE TO DETERMINE
* WHETHER OR NOT A STATEMENT SHOULD BE PROCESSED AND WRITTEN TO THE
* OUTPUT FILE. DEFAULT VALUE IS 0 -- IGNORE STATEMENT.
*
        PROCESSREC = ARRAY(FALSE ':' BYPASS ',' ELSE ':' THEN, 0)
        PROCESSREC<TRUE, THEN> = 1
        PROCESSREC<FALSE, ELSE> = 1
*
*  FUNCTIONS
*
*
*  OUTPUT = PROCESS(INPUT)
*
*  PROCESS LINE IN THE CONTEXT OF CURRENT CONDITIONALS.
*  FAILS IF LINE IS TO BE IGNORED. OTHERWISE IT RETURNS THE INPUT.
*
        DEFINE('PROCESS(PROCESS)CONDCMD,CONDEXP')
*
*  P_CONDASM BREAKS UP CONDITIONAL ASSEMBLY DIRECTIVES.
*
         P_CONDASM = OPT_WS LC (
+           (('IF' | 'if') . CONDCMD OPT_WS BAL . CONDEXP
+                            OPT_WS RPOS(0)) |
+           (('ENDIF' | 'endif') . CONDCMD) |
+           (('ELSE' | 'else') . CONDCMD) )               :(PROCESS_END)
*
PROCESS PROCESS ? P_CONDASM                                 :S($CONDCMD)
*
*  PROCESS STATEMENTS OTHER THAN CONDITIONAL DIRECTIVES.
*
         EQ(NESTLEVEL, 0)                                     :S(RETURN)
         EQ(PROCESSREC<RESULT(TOP), MODE(TOP)>, 0)  :S(FRETURN)F(RETURN)
*
*  PROCESS %IF (EXPRESSION)
*
IF       EQ(NESTLEVEL)                                          :S(IFOK)
*
* HERE FOR NESTED %IF
*
         NE(PROCESSREC<RESULT(TOP), MODE(TOP)>)                 :S(IFOK)
         NESTLEVEL = NESTLEVEL + 1
         TOP = STATESTK<NESTLEVEL> = STATE(BYPASS, THEN)      :(FRETURN)
*
* HERE FOR %IF TO BE PROCESSED NORMALLY.
*
IFOK     NESTLEVEL = NESTLEVEL + 1
         TOP = STATESTK<NESTLEVEL> = STATE(
+           (EQ(EVALUATE(CONDEXP), 1) TRUE, FALSE),
+           THEN)                                             :(FRETURN)
*
* PROCESS %ELSE
*
ELSE     MODE(TOP) = NE(NESTLEVEL) ELSE                      :S(FRETURN)
         TERMINAL = LC 'ELSE ENCOUNTERED OUTSIDE OF ' LC 'IF,' REPORT()
+                                                                 :(END)
*
* PROCESS %ENDIF
*
ENDIF    NESTLEVEL = NE(NESTLEVEL) NESTLEVEL - 1           :F(ENDIF_ERR)
         TOP = (NE(NESTLEVEL) STATESTK<NESTLEVEL>, '')        :(FRETURN)
ENDIF_ERR
         TERMINAL = LC 'ENDIF ENCOUNTERED OUTSIDE OF ' LC 'IF,'
+           REPORT()                                              :(END)
*
PROCESS_END
*
* EVALUATE AN ARGUMENT OF THE FORM '(OPERAND OPR OPERAND)'
*
         DEFINE('EVALUATE(EXP)ARG1,ARG2,OPERATOR')
         P_OPERAND = NAME | SPAN(&DIGITS) | BAL
         P_OPERATOR = 'OR' | 'or' | 'AND' | 'and' | 'NE' 'ne' |
+                     'EQ' | 'eq'
         P_EV1 = P_OPERAND . ARG1 WHITE P_OPERATOR . OPERATOR
+           WHITE P_OPERAND . ARG2
         P_EV2 = P_OPERAND . ARG1 '' . OPERATOR . ARG2
         P_EV3 = '(' OPT_WS (P_EV1 | P_EV2) OPT_WS ')' RPOS(0)
                                                         :(EVALUATE_END)
EVALUATE EXP ? P_EV3                                         :F(EVAL_ER)
         EVALUATE = (DIFFER(OPERATOR)
+           APPLY(OPERATOR '.', OPER(ARG1), OPER(ARG2)),
+           OPER(ARG1))                                        :(RETURN)
EVAL_ER  TERMINAL = 'BAD EXPRESSION: ' EXP REPORT()               :(END)
EVALUATE_END
*
* EVALUATE AN OPERAND TO PRODUCE VALUE OF 0 OR 1
* IF ARGUMENT IS NAME, GET ITS VALUE FROM THE SYMTABLE. OTHERWISE
* IF IT IS A SIMPLE INTEGER, RETURN IT. OTHERWISE IT MUST BE
* A PARENTHESIZED EXPRESSION. CALL EVALUATE.
*
         DEFINE('OPER(ARG)')                                 :(OPER_END)
OPER     OPER = INTEGER(ARG) ARG                              :S(RETURN)
         IDENT(SUBSTR(ARG, 1, 1), '(')                        :S(OPER.1)
         OPER = SYMTBL<ARG>
         DIFFER(OPER)                                         :S(RETURN)
         TERMINAL = 'UNDEFINED OPERAND: ' ARG REPORT()            :(END)
OPER.1   OPER = EVALUATE(ARG)                                  :(RETURN)
OPER_END
*
* EQ OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('EQ.(A,B)')                                    :(EQ.END)
EQ.      EQ. = (EQ(A, B) 1, 0)                                 :(RETURN)
EQ.END
*
* NE OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('NE.(A,B)')                                    :(NE.END)
NE.      NE. = (EQ(A, B) 0, 1)                                 :(RETURN)
NE.END
*
* OR OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('OR.(A,B)')                                    :(OR.END)
OR.      OR. = (EQ(A) EQ(B) 0, 1)                              :(RETURN)
OR.END
*
* AND OPERATOR -- RETURNS 0 OR 1
*
         DEFINE('AND.(A,B)')                                  :(AND.END)
AND.     AND. = (EQ(A, 1) EQ(B, 1) 1, 0)                       :(RETURN)
AND.END
*
* RETURN CURRENT LINE NUMBER AND FILE NAME.
*
         DEFINE('REPORT()')                                :(REPORT_END)
REPORT   REPORT = ' IN FILE ' INNAME ', LINE ' +LINENO         :(RETURN)
REPORT_END
*
* HERE'S THE 'MAIN' PROGRAM.
*
         P_SET = OPT_WS LC ('SET' | 'set') OPT_WS '(' OPT_WS NAME . ARG1
+           OPT_WS ','
+           OPT_WS FASTBAL('(<[]>)', "'" '"', ',)') . ARG2 OPT_WS ')'
         P_INCLUDE = OPT_WS LC ('INCLUDE' | 'include') OPT_WS
+           '(' BREAK(')') . ARG1 ')'
         P_COMMENT = OPT_WS LC '*' OPT_WS '(' BREAK(')') ')'
*
* LOOP UNTIL END OF INPUT.
*
* READS STANDARD INPUT, WRITES STANDARD OUTPUT.
*
         LSSTYPE = HOST(4, 'LSS')
         FN = HOST(2, HOST(3))
         INPUT(.INPUT, 10,, FN)                               :F(NONAME)
NONAME   INVAR  = .INPUT
         INNAME = 'STDIN'
         FILELEVEL = 0
*
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? 'SNOBOL4') '-LINE 1'
         LINELEAD = ?(LSSTYPE ? 'C') '#line 1'
         LINELEAD = ?(LSSTYPE ? 'ASM') '%LINE 1'
         OUTPUT = VDIFFER(LINELEAD) ' "' VDIFFER(FN) '"'
*
* MAIN LOOP READING AND WRITING FILES
*
LOOP     LINE = $INVAR                                           :F(EOF)
         LINENO = LINENO + 1
         RESULT = PROCESS(LINE)                                 :F(LOOP)
         RESULT ? P_COMMENT                                     :S(LOOP)
*
* INPUT LINE TO BE RETAINED. LOOK FOR %SET COMMAND. IF FOUND, DEFINE
* THE SYMBOL AND OMIT THE LINE FROM THE OUTPUT FILE.
*
         RESULT ? P_SET                                   :F(CK_INCLUDE)
         V = EVAL(ARG2)
         SYMTBL<ARG1> = INTEGER(V) +V                           :S(LOOP)
         TERMINAL = LC 'SET NON-NUMERIC VALUE: ' ARG2 REPORT()    :(END)
*
* CHECK FOR %INCLUDE COMMAND. STRIP ANY SURROUNDING QUOTE MARKS.
*
CK_INCLUDE
         RESULT ? P_INCLUDE                                   :F(PUTOUT)
         ARG1 ? "'" BREAK("'") . ARG1 "'" RPOS(0)
         FILELEVEL = FILELEVEL + 1
         INCSTACK<FILELEVEL> = INVAR
         INCNAME<FILELEVEL> = INNAME
         INCLNNO<FILELEVEL> = LINENO
         INVAR = 'INPUT' FILELEVEL
*
* TRY THE CURRENT DIRECTORY; IF THE FILE IS NOT THERE, TRY IFSDIR
* AND THEN SNOLIB. SHOULD DO PATH SEARCH (SEE LSINC).
*
         DS = HOST(HOST_DIR_SEP)
         INPUT(INVAR, FILELEVEL + 19,, ARG1)                    :S(INC1)
         X = HOST(HOST_GETENV, 'IFSDIR')                        :F(INC3)
         INPUT(INVAR, FILELEVEL + 19,, X DS ARG1)               :S(INC1)
INC3     X = HOST(HOST_GETENV, 'SNOLIB')                        :S(INC2)
         X = HOST(HOST_SNOLIB_DIR)
INC2     INPUT(INVAR, FILELEVEL + 19,, X DS ARG1)               :S(INC1)
         TERMINAL = LC 'INCLUDE FILE NOT FOUND: ' "'" ARG1 "'" REPORT()
+                                                                 :(END)
INC1     INNAME = ARG1
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? 'SNOBOL4') '-LINE 1 "'
         LINELEAD = ?(LSSTYPE ? 'C') '#line 1 "'
         LINELEAD = ?(LSSTYPE ? 'ASM') '%LINE 1 "'
         OUTPUT = VDIFFER(LINELEAD) INNAME '"'
INC4     LINENO = 0                                              :(LOOP)
*
* OUTPUT THE PROCESSED LINE
*
PUTOUT   OUTPUT = RESULT                                         :(LOOP)
*
* HERE ON EOF. CHECK IF INSIDE AN INCLUDE FILE.
*
EOF      EQ(FILELEVEL, 0)                                       :S(EOF2)
         ENDFILE(FILELEVEL + 19)
         INVAR = INCSTACK<FILELEVEL>
         INNAME = INCNAME<FILELEVEL>
         LINENO = INCLNNO<FILELEVEL>
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? 'SNOBOL4') '-LINE '
         LINELEAD = ?(LSSTYPE ? 'C') '#line '
         LINELEAD = ?(LSSTYPE ? 'ASM') '%LINE '
         OUTPUT = VDIFFER(LINELEAD) LINENO + 1 ' "' INNAME '"'
         FILELEVEL = FILELEVEL - 1                               :(LOOP)
*
EOF2     TERMINAL = NE(NESTLEVEL) 'EOF IN NESTED IF AT LEVEL ' NESTLEVEL
+                                                                :S(END)
         &CODE = 0                                                :(END)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ifs - IF Statement Processor</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Conditional names begin with a letter, followed by zero or more
letters, digits, underscore or period.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Operators are <font face="Source Code Pro">OR</font>, <font face="Source Code Pro">AND</font>, <font face="Source Code Pro">NE</font> and <font face="Source Code Pro">EQ</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Conditional names are assigned integer values with the %SET directive:
<font face="Source Code Pro">%SET(NAME,VALUE)</font>. Note that % can be changed (<font face="Source Code Pro">IFSLC='*'</font>).
The <font face="Source Code Pro">VALUE</font> may be a number, or a parenthesized SNOBOL4 expression.
This allows <font face="Source Code Pro">HOST()</font> functions to be used (for example).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Files may be included with a <font face="Source Code Pro">%INCLUDE(FILE)</font> directive. Included
files may be nested.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">%*(A COMMENT)</font> is a single line comment. Block comments are
trivially done with <font face="Source Code Pro">%IF</font>. Line comment usually documents <font face="Source Code Pro">%SET</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Conditionals and directives must begin in column one, or preceeded by
white space. Expressions must be fully parenthesized.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     %* (A SAMPLE COMMENT)
|     %SET(NAME1,1)
|     %SET(NAME2,0)
|     %SET(NAME3,1)
|     %SET(NAME4,1)
|     %SET(NAME5,HOST(HOST_POINTER_BITS))
|     %INCLUDE(FILE)
|     %IF ((NAME1 OR NAME2) EQ NAME3)
|       %IF (NAME4)
|       %ENDIF
|     %ELSE
|     %ENDIF
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Reads from standard input and writes standard output performing the
conditionals. Conditionals may be nested.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
May be used in batch files - returns <font face="Source Code Pro">&CODE = 1</font> if error (syntax,
unclosed <font face="Source Code Pro">%IF</font> at EOF). Returns <font face="Source Code Pro">&CODE = 0</font> if ok.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
IFS is useful because it does not strip <font face="Source Code Pro">C</font> or <font face="Source Code Pro">C++</font> comments. It
can be used for multiple source languages. It only does include and
conditionals, and no other macro expansion.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Environment Variables</h2>
<ul>
<li>IFSDIR=dir/for/includes</li>
<li>IFSLC=% change lead-in character</li>
<li>LSS=SNOBOL4|C|ASM generate line directives</li>
</ul>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="FASTBAL.html">FASTBAL</a><br>
<a href="HOST.html">HOST</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;FASTBAL.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;SYSTEM.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;IFS&raquo;&equiv;</b>
-PLUSOPS 1
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;IFS (WED NOV  6 13:40:26 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SYSTEM() FAILS IF ANCHORED</i></font>
<font color="#818181"><i>*</i></font>
         SYSTEM = SYSTEM()
<font color="#818181"><i>*</i></font>
         &amp;ANCHOR = 1
         &amp;CODE = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* USEFUL CONSTANTS</i></font>
<font color="#818181"><i>*</i></font>
         LC = &#39;%&#39;
         LC = HOST(HOST_GETENV, &#39;IFSLC&#39;)
         WHITE = SPAN(&#39; &#39; CHARS_HT)
         OPT_WS = WHITE | NULL
         NAME = ANY(&amp;LCASE &amp;UCASE)
+               (SPAN(&amp;LCASE &amp;UCASE &amp;DIGITS &#39;_.&#39;) | NULL)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SYMTBL TRACKS DEFINED CONDITIONAL SYMBOLS. (UNDEFINED SYMBOLS ARE</i></font>
<font color="#818181"><i>* ASSIGNED NULL VALUES IN SYMTBL.)</i></font>
<font color="#818181"><i>*</i></font>
         SYMTBL = TABLE(101)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* STATESTK MAINTAINS ALL STATE INFORMATION WHILE PROCESSING CONDITIONAL</i></font>
<font color="#818181"><i>* STATEMENTS. NESTLEVEL INDEXES THE TOP ENTRY. ANOTHER VARIABLE, TOP,</i></font>
<font color="#818181"><i>* HAS A COPY OF SAVESTK&lt;NESTLEVEL&gt;.</i></font>
<font color="#818181"><i>*</i></font>
         STATESTK = TABLE()
         INCNAME = TABLE()
         INCSTACK = TABLE()
         INCLNNO = TABLE()
         NESTLEVEL = 0
         TOP =
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EACH STATE ENTRY IN STATESTK CONTAINS STATE INFORMATION ABOUT THE</i></font>
<font color="#818181"><i>* PROCESSING FOR EACH ACTIVE %IF. THE STATE IS MAINTAINED AS 2 FIELDS:</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*     RESULT  THE RESULT OF THE %IF EXPRESSION EVALUATION-</i></font>
<font color="#818181"><i>*             TRUE, FALSE, OR BYPASS</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*     MODE    WHETHER PROCESSING THEN OR ELSE PORTION OF %IF</i></font>
<font color="#818181"><i>*</i></font>
         DATA(&#39;STATE(RESULT,MODE)&#39;)
         FALSE = 0
         TRUE = 1
         BYPASS = 2
         ELSE = 0
         THEN = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PROCESSREC IS INDEXED BY THE CURRENT RESULT AND MODE TO DETERMINE</i></font>
<font color="#818181"><i>* WHETHER OR NOT A STATEMENT SHOULD BE PROCESSED AND WRITTEN TO THE</i></font>
<font color="#818181"><i>* OUTPUT FILE. DEFAULT VALUE IS 0 -- IGNORE STATEMENT.</i></font>
<font color="#818181"><i>*</i></font>
        PROCESSREC = ARRAY(FALSE &#39;:&#39; BYPASS &#39;,&#39; ELSE &#39;:&#39; THEN, 0)
        PROCESSREC&lt;TRUE, THEN&gt; = 1
        PROCESSREC&lt;FALSE, ELSE&gt; = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*  FUNCTIONS</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*  OUTPUT = PROCESS(INPUT)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*  PROCESS LINE IN THE CONTEXT OF CURRENT CONDITIONALS.</i></font>
<font color="#818181"><i>*  FAILS IF LINE IS TO BE IGNORED. OTHERWISE IT RETURNS THE INPUT.</i></font>
<font color="#818181"><i>*</i></font>
        DEFINE(&#39;PROCESS(PROCESS)CONDCMD,CONDEXP&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*  P_CONDASM BREAKS UP CONDITIONAL ASSEMBLY DIRECTIVES.</i></font>
<font color="#818181"><i>*</i></font>
         P_CONDASM = OPT_WS LC (
+           ((&#39;IF&#39; | &#39;if&#39;) . CONDCMD OPT_WS BAL . CONDEXP
+                            OPT_WS RPOS(0)) |
+           ((&#39;ENDIF&#39; | &#39;endif&#39;) . CONDCMD) |
+           ((&#39;ELSE&#39; | &#39;else&#39;) . CONDCMD) )               <b>:(PROCESS_END)</b>
<font color="#818181"><i>*</i></font>
PROCESS PROCESS ? P_CONDASM                                 <b>:S($CONDCMD)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*  PROCESS STATEMENTS OTHER THAN CONDITIONAL DIRECTIVES.</i></font>
<font color="#818181"><i>*</i></font>
         EQ(NESTLEVEL, 0)                                     <b>:S(RETURN)</b>
         EQ(PROCESSREC&lt;RESULT(TOP), MODE(TOP)&gt;, 0)  <b>:S(FRETURN)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*  PROCESS %IF (EXPRESSION)</i></font>
<font color="#818181"><i>*</i></font>
IF       EQ(NESTLEVEL)                                          <b>:S(IFOK)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HERE FOR NESTED %IF</i></font>
<font color="#818181"><i>*</i></font>
         NE(PROCESSREC&lt;RESULT(TOP), MODE(TOP)&gt;)                 <b>:S(IFOK)</b>
         NESTLEVEL = NESTLEVEL + 1
         TOP = STATESTK&lt;NESTLEVEL&gt; = STATE(BYPASS, THEN)      <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HERE FOR %IF TO BE PROCESSED NORMALLY.</i></font>
<font color="#818181"><i>*</i></font>
IFOK     NESTLEVEL = NESTLEVEL + 1
         TOP = STATESTK&lt;NESTLEVEL&gt; = STATE(
+           (EQ(EVALUATE(CONDEXP), 1) TRUE, FALSE),
+           THEN)                                             <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PROCESS %ELSE</i></font>
<font color="#818181"><i>*</i></font>
ELSE     MODE(TOP) = NE(NESTLEVEL) ELSE                      <b>:S(FRETURN)</b>
         TERMINAL = LC &#39;ELSE ENCOUNTERED OUTSIDE OF &#39; LC &#39;IF,&#39; REPORT()
+                                                                 <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PROCESS %ENDIF</i></font>
<font color="#818181"><i>*</i></font>
ENDIF    NESTLEVEL = NE(NESTLEVEL) NESTLEVEL - 1           <b>:F(ENDIF_ERR)</b>
         TOP = (NE(NESTLEVEL) STATESTK&lt;NESTLEVEL&gt;, &#39;&#39;)        <b>:(FRETURN)</b>
ENDIF_ERR
         TERMINAL = LC &#39;ENDIF ENCOUNTERED OUTSIDE OF &#39; LC &#39;IF,&#39;
+           REPORT()                                              <b>:(END)</b>
<font color="#818181"><i>*</i></font>
PROCESS_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EVALUATE AN ARGUMENT OF THE FORM &#39;(OPERAND OPR OPERAND)&#39;</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;EVALUATE(EXP)ARG1,ARG2,OPERATOR&#39;)
         P_OPERAND = NAME | SPAN(&amp;DIGITS) | BAL
         P_OPERATOR = &#39;OR&#39; | &#39;or&#39; | &#39;AND&#39; | &#39;and&#39; | &#39;NE&#39; &#39;ne&#39; |
+                     &#39;EQ&#39; | &#39;eq&#39;
         P_EV1 = P_OPERAND . ARG1 WHITE P_OPERATOR . OPERATOR
+           WHITE P_OPERAND . ARG2
         P_EV2 = P_OPERAND . ARG1 &#39;&#39; . OPERATOR . ARG2
         P_EV3 = &#39;(&#39; OPT_WS (P_EV1 | P_EV2) OPT_WS &#39;)&#39; RPOS(0)
                                                         <b>:(EVALUATE_END)</b>
EVALUATE EXP ? P_EV3                                         <b>:F(EVAL_ER)</b>
         EVALUATE = (DIFFER(OPERATOR)
+           APPLY(OPERATOR &#39;.&#39;, OPER(ARG1), OPER(ARG2)),
+           OPER(ARG1))                                        <b>:(RETURN)</b>
EVAL_ER  TERMINAL = &#39;BAD EXPRESSION: &#39; EXP REPORT()               <b>:(END)</b>
EVALUATE_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EVALUATE AN OPERAND TO PRODUCE VALUE OF 0 OR 1</i></font>
<font color="#818181"><i>* IF ARGUMENT IS NAME, GET ITS VALUE FROM THE SYMTABLE. OTHERWISE</i></font>
<font color="#818181"><i>* IF IT IS A SIMPLE INTEGER, RETURN IT. OTHERWISE IT MUST BE</i></font>
<font color="#818181"><i>* A PARENTHESIZED EXPRESSION. CALL EVALUATE.</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;OPER(ARG)&#39;)                                 <b>:(OPER_END)</b>
OPER     OPER = INTEGER(ARG) ARG                              <b>:S(RETURN)</b>
         IDENT(SUBSTR(ARG, 1, 1), &#39;(&#39;)                        <b>:S(OPER.1)</b>
         OPER = SYMTBL&lt;ARG&gt;
         DIFFER(OPER)                                         <b>:S(RETURN)</b>
         TERMINAL = &#39;UNDEFINED OPERAND: &#39; ARG REPORT()            <b>:(END)</b>
OPER.1   OPER = EVALUATE(ARG)                                  <b>:(RETURN)</b>
OPER_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EQ OPERATOR -- RETURNS 0 OR 1</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;EQ.(A,B)&#39;)                                    <b>:(EQ.END)</b>
EQ.      EQ. = (EQ(A, B) 1, 0)                                 <b>:(RETURN)</b>
EQ.END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NE OPERATOR -- RETURNS 0 OR 1</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;NE.(A,B)&#39;)                                    <b>:(NE.END)</b>
NE.      NE. = (EQ(A, B) 0, 1)                                 <b>:(RETURN)</b>
NE.END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OR OPERATOR -- RETURNS 0 OR 1</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;OR.(A,B)&#39;)                                    <b>:(OR.END)</b>
OR.      OR. = (EQ(A) EQ(B) 0, 1)                              <b>:(RETURN)</b>
OR.END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* AND OPERATOR -- RETURNS 0 OR 1</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;AND.(A,B)&#39;)                                  <b>:(AND.END)</b>
AND.     AND. = (EQ(A, 1) EQ(B, 1) 1, 0)                       <b>:(RETURN)</b>
AND.END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RETURN CURRENT LINE NUMBER AND FILE NAME.</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;REPORT()&#39;)                                <b>:(REPORT_END)</b>
REPORT   REPORT = &#39; IN FILE &#39; INNAME &#39;, LINE &#39; +LINENO         <b>:(RETURN)</b>
REPORT_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HERE&#39;S THE &#39;MAIN&#39; PROGRAM.</i></font>
<font color="#818181"><i>*</i></font>
         P_SET = OPT_WS LC (&#39;SET&#39; | &#39;set&#39;) OPT_WS &#39;(&#39; OPT_WS NAME . ARG1
+           OPT_WS &#39;,&#39;
+           OPT_WS FASTBAL(&#39;(&lt;[]&gt;)&#39;, &quot;&#39;&quot; &#39;&quot;&#39;, &#39;,)&#39;) . ARG2 OPT_WS &#39;)&#39;
         P_INCLUDE = OPT_WS LC (&#39;INCLUDE&#39; | &#39;include&#39;) OPT_WS
+           &#39;(&#39; BREAK(&#39;)&#39;) . ARG1 &#39;)&#39;
         P_COMMENT = OPT_WS LC &#39;*&#39; OPT_WS &#39;(&#39; BREAK(&#39;)&#39;) &#39;)&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOOP UNTIL END OF INPUT.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READS STANDARD INPUT, WRITES STANDARD OUTPUT.</i></font>
<font color="#818181"><i>*</i></font>
         LSSTYPE = HOST(4, &#39;LSS&#39;)
         FN = HOST(2, HOST(3))
         INPUT(.INPUT, 10,, FN)                               <b>:F(NONAME)</b>
NONAME   INVAR  = .INPUT
         INNAME = &#39;STDIN&#39;
         FILELEVEL = 0
<font color="#818181"><i>*</i></font>
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? &#39;SNOBOL4&#39;) &#39;-LINE 1&#39;
         LINELEAD = ?(LSSTYPE ? &#39;C&#39;) &#39;#line 1&#39;
         LINELEAD = ?(LSSTYPE ? &#39;ASM&#39;) &#39;%LINE 1&#39;
         OUTPUT = VDIFFER(LINELEAD) &#39; &quot;&#39; VDIFFER(FN) &#39;&quot;&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAIN LOOP READING AND WRITING FILES</i></font>
<font color="#818181"><i>*</i></font>
LOOP     LINE = $INVAR                                           <b>:F(EOF)</b>
         LINENO = LINENO + 1
         RESULT = PROCESS(LINE)                                 <b>:F(LOOP)</b>
         RESULT ? P_COMMENT                                     <b>:S(LOOP)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INPUT LINE TO BE RETAINED. LOOK FOR %SET COMMAND. IF FOUND, DEFINE</i></font>
<font color="#818181"><i>* THE SYMBOL AND OMIT THE LINE FROM THE OUTPUT FILE.</i></font>
<font color="#818181"><i>*</i></font>
         RESULT ? P_SET                                   <b>:F(CK_INCLUDE)</b>
         V = EVAL(ARG2)
         SYMTBL&lt;ARG1&gt; = INTEGER(V) +V                           <b>:S(LOOP)</b>
         TERMINAL = LC &#39;SET NON-NUMERIC VALUE: &#39; ARG2 REPORT()    <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CHECK FOR %INCLUDE COMMAND. STRIP ANY SURROUNDING QUOTE MARKS.</i></font>
<font color="#818181"><i>*</i></font>
CK_INCLUDE
         RESULT ? P_INCLUDE                                   <b>:F(PUTOUT)</b>
         ARG1 ? &quot;&#39;&quot; BREAK(&quot;&#39;&quot;) . ARG1 &quot;&#39;&quot; RPOS(0)
         FILELEVEL = FILELEVEL + 1
         INCSTACK&lt;FILELEVEL&gt; = INVAR
         INCNAME&lt;FILELEVEL&gt; = INNAME
         INCLNNO&lt;FILELEVEL&gt; = LINENO
         INVAR = &#39;INPUT&#39; FILELEVEL
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TRY THE CURRENT DIRECTORY; IF THE FILE IS NOT THERE, TRY IFSDIR</i></font>
<font color="#818181"><i>* AND THEN SNOLIB. SHOULD DO PATH SEARCH (SEE LSINC).</i></font>
<font color="#818181"><i>*</i></font>
         DS = HOST(HOST_DIR_SEP)
         INPUT(INVAR, FILELEVEL + 19,, ARG1)                    <b>:S(INC1)</b>
         X = HOST(HOST_GETENV, &#39;IFSDIR&#39;)                        <b>:F(INC3)</b>
         INPUT(INVAR, FILELEVEL + 19,, X DS ARG1)               <b>:S(INC1)</b>
INC3     X = HOST(HOST_GETENV, &#39;SNOLIB&#39;)                        <b>:S(INC2)</b>
         X = HOST(HOST_SNOLIB_DIR)
INC2     INPUT(INVAR, FILELEVEL + 19,, X DS ARG1)               <b>:S(INC1)</b>
         TERMINAL = LC &#39;INCLUDE FILE NOT FOUND: &#39; &quot;&#39;&quot; ARG1 &quot;&#39;&quot; REPORT()
+                                                                 <b>:(END)</b>
INC1     INNAME = ARG1
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? &#39;SNOBOL4&#39;) &#39;-LINE 1 &quot;&#39;
         LINELEAD = ?(LSSTYPE ? &#39;C&#39;) &#39;#line 1 &quot;&#39;
         LINELEAD = ?(LSSTYPE ? &#39;ASM&#39;) &#39;%LINE 1 &quot;&#39;
         OUTPUT = VDIFFER(LINELEAD) INNAME &#39;&quot;&#39;
INC4     LINENO = 0                                              <b>:(LOOP)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OUTPUT THE PROCESSED LINE</i></font>
<font color="#818181"><i>*</i></font>
PUTOUT   OUTPUT = RESULT                                         <b>:(LOOP)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HERE ON EOF. CHECK IF INSIDE AN INCLUDE FILE.</i></font>
<font color="#818181"><i>*</i></font>
EOF      EQ(FILELEVEL, 0)                                       <b>:S(EOF2)</b>
         ENDFILE(FILELEVEL + 19)
         INVAR = INCSTACK&lt;FILELEVEL&gt;
         INNAME = INCNAME&lt;FILELEVEL&gt;
         LINENO = INCLNNO&lt;FILELEVEL&gt;
         LINELEAD =
         LINELEAD = ?(LSSTYPE ? &#39;SNOBOL4&#39;) &#39;-LINE &#39;
         LINELEAD = ?(LSSTYPE ? &#39;C&#39;) &#39;#line &#39;
         LINELEAD = ?(LSSTYPE ? &#39;ASM&#39;) &#39;%LINE &#39;
         OUTPUT = VDIFFER(LINELEAD) LINENO + 1 &#39; &quot;&#39; INNAME &#39;&quot;&#39;
         FILELEVEL = FILELEVEL - 1                               <b>:(LOOP)</b>
<font color="#818181"><i>*</i></font>
EOF2     TERMINAL = NE(NESTLEVEL) &#39;EOF IN NESTED IF AT LEVEL &#39; NESTLEVEL
+                                                                <b>:S(END)</b>
         &amp;CODE = 0                                                <b>:(END)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM IFS
-TITLE IFS
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                         ###  #######   #####                         *</i></font>
<font color="#818181"><i>*                          #   #        #     #                        *</i></font>
<font color="#818181"><i>*                          #   #        #                              *</i></font>
<font color="#818181"><i>*                          #   #####     #####                         *</i></font>
<font color="#818181"><i>*                          #   #              #                        *</i></font>
<font color="#818181"><i>*                          #   #        #     #                        *</i></font>
<font color="#818181"><i>*                         ###  #         #####                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* IFS              PREPROCESS FOR %IF CONDITIONALS                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* CONVERTED FROM IF.SPT                                                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ifs.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;IFS&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:05 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>illum - Produce illuminated first character</h1>

[[illum]] takes a sentence as input. It illuminates the first
character, and outputs the character (from [[banner]]) and the rest
of the sentence boxed with UTF-8 linedraw characters.

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="TRIMB.html">TRIMB</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
@

<<ILLUM>>=
         TERMINAL = 'ILLUM (SUN NOV 24 01:32:15 EST 2013)'
*
         S = TRIMB(INPUT)                                        :F(END)
         S LEN(1) . C REM . S                                    :F(END)
         S = ' ' VDIFFER(S)
         F = BQ('banner ' C, '/')
         F = CRACK(F '/', '/')
         SEQ(' F<I> = SUBSTR(F<I>, 1, SIZE(F<I>) - 2)', .I, 2)
         W = SIZE(F<2>)
         G = I - 1
         F<1> = '' DUPL('', SIZE(F<2>) + SIZE(S)) ''
         F<2> = '' F<2> S ''
         F<3> = '' F<3> '' EQ(SIZE(S))                       :S(ILLU0)
         F<3> = '' F<3> '' DUPL('', SIZE(S) - 1) ''
ILLU0    SEQ(' F<I> = "" F<I> ""', .I, 4, G)
         F<I + 1> = '' DUPL('', W) ''
         SEQ(' OUTPUT = F<I>', .I)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM ILLUM
-TITLE ILLUM
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*               ###  #        #        #     #  #     #                *
*                #   #        #        #     #  ##   ##                *
*                #   #        #        #     #  # # # #                *
*                #   #        #        #     #  #  #  #                *
*                #   #        #        #     #  #     #                *
*                #   #        #        #     #  #     #                *
*               ###  #######  #######   #####   #     #                *
*                                                                      *
* ILLUM           PRODUCE ILLUMINATED FIRST CHARACTER                  *
*                                                                      *
************************************************************************
*
* illum.lss
*
<<ILLUM>>
*
* CE: .F.MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM ILLUM
-LINE 48 "illum.lss"
-TITLE ILLUM
START
-LINE 15 "illum.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*               ###  #        #        #     #  #     #                *
*                #   #        #        #     #  ##   ##                *
*                #   #        #        #     #  # # # #                *
*                #   #        #        #     #  #  #  #                *
*                #   #        #        #     #  #     #                *
*                #   #        #        #     #  #     #                *
*               ###  #######  #######   #####   #     #                *
*                                                                      *
* ILLUM           PRODUCE ILLUMINATED FIRST CHARACTER                  *
*                                                                      *
************************************************************************
*
* illum.lss
*
-LINE 23 "illum.lss"
         TERMINAL = 'ILLUM (SUN NOV 24 01:32:15 EST 2013)'
*
         S = TRIMB(INPUT)                                        :F(END)
         S LEN(1) . C REM . S                                    :F(END)
         S = ' ' VDIFFER(S)
         F = BQ('banner ' C, '/')
         F = CRACK(F '/', '/')
         SEQ(' F<I> = SUBSTR(F<I>, 1, SIZE(F<I>) - 2)', .I, 2)
         W = SIZE(F<2>)
         G = I - 1
         F<1> = '' DUPL('', SIZE(F<2>) + SIZE(S)) ''
         F<2> = '' F<2> S ''
         F<3> = '' F<3> '' EQ(SIZE(S))                       :S(ILLU0)
         F<3> = '' F<3> '' DUPL('', SIZE(S) - 1) ''
ILLU0    SEQ(' F<I> = "" F<I> ""', .I, 4, G)
         F<I + 1> = '' DUPL('', W) ''
         SEQ(' OUTPUT = F<I>', .I)
*
END START
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>illum - Produce illuminated first character</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">illum</font> takes a sentence as input. It illuminates the first
character, and outputs the character (from <font face="Source Code Pro">banner</font>) and the rest
of the sentence boxed with UTF-8 linedraw characters.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="TRIMB.html">TRIMB</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ILLUM&raquo;&equiv;</b>
         TERMINAL = &#39;ILLUM (SUN NOV 24 01:32:15 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         S = TRIMB(INPUT)                                        <b>:F(END)</b>
         S LEN(1) . C REM . S                                    <b>:F(END)</b>
         S = &#39; &#39; VDIFFER(S)
         F = BQ(&#39;banner &#39; C, &#39;/&#39;)
         F = CRACK(F &#39;/&#39;, &#39;/&#39;)
         SEQ(&#39; F&lt;I&gt; = SUBSTR(F&lt;I&gt;, 1, SIZE(F&lt;I&gt;) - 2)&#39;, .I, 2)
         W = SIZE(F&lt;2&gt;)
         G = I - 1
         F&lt;1&gt; = &#39;&#39; DUPL(&#39;&#39;, SIZE(F&lt;2&gt;) + SIZE(S)) &#39;&#39;
         F&lt;2&gt; = &#39;&#39; F&lt;2&gt; S &#39;&#39;
         F&lt;3&gt; = &#39;&#39; F&lt;3&gt; &#39;&#39; EQ(SIZE(S))                       <b>:S(ILLU0)</b>
         F&lt;3&gt; = &#39;&#39; F&lt;3&gt; &#39;&#39; DUPL(&#39;&#39;, SIZE(S) - 1) &#39;&#39;
ILLU0    SEQ(&#39; F&lt;I&gt; = &quot;&quot; F&lt;I&gt; &quot;&quot;&#39;, .I, 4, G)
         F&lt;I + 1&gt; = &#39;&#39; DUPL(&#39;&#39;, W) &#39;&#39;
         SEQ(&#39; OUTPUT = F&lt;I&gt;&#39;, .I)
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM ILLUM
-TITLE ILLUM
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               ###  #        #        #     #  #     #                *</i></font>
<font color="#818181"><i>*                #   #        #        #     #  ##   ##                *</i></font>
<font color="#818181"><i>*                #   #        #        #     #  # # # #                *</i></font>
<font color="#818181"><i>*                #   #        #        #     #  #  #  #                *</i></font>
<font color="#818181"><i>*                #   #        #        #     #  #     #                *</i></font>
<font color="#818181"><i>*                #   #        #        #     #  #     #                *</i></font>
<font color="#818181"><i>*               ###  #######  #######   #####   #     #                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ILLUM           PRODUCE ILLUMINATED FIRST CHARACTER                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* illum.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ILLUM&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:06 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>in72 - Process source with -INn directives</h1>

Prune source lines to -INn directives

<h2>Uses</h2>

<<INCLUDES>>=
@

<<in72>>=
         TERMINAL = 'IN72 (SUN JUN 16 14:13:20 EDT 2013)'
*
         N = 1024
         P = DUPL(' ', N)
*
TOP      S = INPUT                                               :F(END)
         S FENCE '-' ANY('iI') ANY('nN') SPAN(&DIGITS) . N     :F(NOTIN)
         P = DUPL(' ', N)
NOTIN    (S P) LEN(N) . L
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM IN72
-TITLE IN72
START
*
************************************************************************
*                                                                      *
*                      ###  #     #  #####   ###                       *
*                       #   ##    #      #  #   #                      *
*                       #   # #   #     #   #   #                      *
*                       #   #  #  #    #       #                       *
*                       #   #   # #   #       #                        *
*                       #   #    ##   #      #                         *
*                      ###  #     #   #     #####                      *
*                                                                      *
* IN72                   HANDLE -IN DIRECTIVES                         *
*                                                                      *
************************************************************************
*
* in72.lss
*
<<in72>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM IN72
-LINE 29 "in72.lss"
-TITLE IN72
START
*
************************************************************************
*                                                                      *
*                      ###  #     #  #####   ###                       *
*                       #   ##    #      #  #   #                      *
*                       #   # #   #     #   #   #                      *
*                       #   #  #  #    #       #                       *
*                       #   #   # #   #       #                        *
*                       #   #    ##   #      #                         *
*                      ###  #     #   #     #####                      *
*                                                                      *
* IN72                   HANDLE -IN DIRECTIVES                         *
*                                                                      *
************************************************************************
*
* in72.lss
*
-LINE 11 "in72.lss"
         TERMINAL = 'IN72 (SUN JUN 16 14:13:20 EDT 2013)'
*
         N = 1024
         P = DUPL(' ', N)
*
TOP      S = INPUT                                               :F(END)
         S FENCE '-' ANY('iI') ANY('nN') SPAN(&DIGITS) . N     :F(NOTIN)
         P = DUPL(' ', N)
NOTIN    (S P) LEN(N) . L
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>in72 - Process source with -INn directives</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Prune source lines to -INn directives
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;in72&raquo;&equiv;</b>
         TERMINAL = &#39;IN72 (SUN JUN 16 14:13:20 EDT 2013)&#39;
<font color="#818181"><i>*</i></font>
         N = 1024
         P = DUPL(&#39; &#39;, N)
<font color="#818181"><i>*</i></font>
TOP      S = INPUT                                               <b>:F(END)</b>
         S FENCE &#39;-&#39; ANY(&#39;iI&#39;) ANY(&#39;nN&#39;) SPAN(&amp;DIGITS) . N     <b>:F(NOTIN)</b>
         P = DUPL(&#39; &#39;, N)
NOTIN    (S P) LEN(N) . L
         OUTPUT = TRIM(L)                                         <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM IN72
-TITLE IN72
START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      ###  #     #  #####   ###                       *</i></font>
<font color="#818181"><i>*                       #   ##    #      #  #   #                      *</i></font>
<font color="#818181"><i>*                       #   # #   #     #   #   #                      *</i></font>
<font color="#818181"><i>*                       #   #  #  #    #       #                       *</i></font>
<font color="#818181"><i>*                       #   #   # #   #       #                        *</i></font>
<font color="#818181"><i>*                       #   #    ##   #      #                         *</i></font>
<font color="#818181"><i>*                      ###  #     #   #     #####                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* IN72                   HANDLE -IN DIRECTIVES                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* in72.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;in72&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Mon Jun  9 20:40:58 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>INFINIP - Infinite precision integer math</h1>

Infinite precision integer math.

<h2>Uses</h2>
<a href="REDEFINE.html">REDEFINE</a><br>
<a href="SWAP.html">SWAP</a><br>

<<INCLUDES>>=
-INCLUDE 'REDEFINE.INC'
-INCLUDE 'SWAP.INC'
@

<<INFINIP>>=
-MODULE INFINIP
         SIGN_OFF  = POS(0) '-'
         LDG_ZEROS = BREAK('123456789') | RTAB(1)
         NO_DIGITS = 4
*
-PUBLIC INFINP_START(), INFINP_STOP()
         DEFINE('XYZERO()')
         DEFINE('INFFLOAT()')
         DEFINE('SMALL()')
         DEFINE('SPLIT(NAME,PAT)')
         DEFINE('INFINIP_START()')
         DEFINE('INFINIP_STOP()')                         :(INFINIP_END)
*
INFINIP_START
         REDEFINE('-', 'MINUS(X)Y')
         REDEFINE(   , 'GT(X,Y)')
         REDEFINE(   , 'EQ(X,Y)')
         REDEFINE(   , 'GE(X,Y)')
         REDEFINE(   , 'NE(X,Y)')
         REDEFINE(   , 'LT(X,Y)')
         REDEFINE(   , 'LE(X,Y)')
         REDEFINE('-', 'DIFF(X,Y)')
         REDEFINE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
         REDEFINE('*', 'MULT(X,Y)X1,X2,K')
         REDEFINE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
         REDEFINE(   , 'REMDR(X,Y)')                           :(RETURN)
*
INFINIP_STOP
         REDEFINERESTORE('-', 'MINUS(X)Y')
         REDEFINERESTORE(   , 'GT(X,Y)')
         REDEFINERESTORE(   , 'EQ(X,Y)')
         REDEFINERESTORE(   , 'GE(X,Y)')
         REDEFINERESTORE(   , 'NE(X,Y)')
         REDEFINERESTORE(   , 'LT(X,Y)')
         REDEFINERESTORE(   , 'LE(X,Y)')
         REDEFINERESTORE('-', 'DIFF(X,Y)')
         REDEFINERESTORE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
         REDEFINERESTORE('*', 'MULT(X,Y)X1,X2,K')
         REDEFINERESTORE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
         REDEFINERESTORE(   , 'REMDR(X,Y)')                    :(RETURN)
*
* FMGW:
* ADDED XYZERO TO ALLOW '' + 1 ETC. TO WORK AS NORMAL
* INFFLOAT TO ALLOW REAL TO WORK AS NORMAL
*
* THERE IS STILL THE PROBLEM OF MIXING A LARGE INTEGER WITH A REAL IN
* ARITHMETIC. THIS WILL NOT WORK CORRECTLY. IF THE LARGE INTEGER CANNOT
* BE CONVERTED, AN ERROR WILL BE RAISED. WE SHOULD CHECK THE RANGE,
* AND CONVERT THE INTEGER TO REAL OURSELVES. THIS CAN BE DONE IN
* THE INFFLOAT() FUNCTION. NOTE THAT INFFLOAT() IS CALLED AFTER
* XYZERO(), SO BOTH X AND Y ARE (AT LEAST) 0, AND NOT THE EMPTY STRING.
*
* XYZERO() AND INFFLOAT() COULD BE MERGED, BUT ARE KEPT SEPARATE FOR
* CLARITY.
*
* INFINIP_START() AND INFINIP_STOP() ADDED TO CONTROL THE REDEFINITION
* OF OPERATIONS.
*
INFFLOAT DATATYPE(X) 'REAL'                                   :S(RETURN)
         DATATYPE(Y) 'REAL'                                   :S(RETURN)
                                                              :(FRETURN)
*
XYZERO   X = IDENT(X) 0
         Y = IDENT(Y) 0                                        :(RETURN)
*
SMALL    (LE.(SIZE(X), NO_DIGITS)
+         LE.(SIZE(Y), NO_DIGITS))                  :S(RETURN)F(FRETURN)
*
SPLIT    PAT = IDENT(PAT) LEN(SIZE($NAME) / 2)
         $NAME (PAT | '') . $(NAME 1) @SPLIT  (SPAN('0') | '')
+           REM . $(NAME 2)
         SPLIT = SIZE($NAME) - SPLIT                           :(RETURN)
*
MINUS    XYZERO()
         MINUS = INFFLOAT() MINUS.(X)                         :S(RETURN)
         MINUS = SMALL() MINUS.(X)                            :S(RETURN)
         MINUS = X
         MINUS SIGN_OFF =                                     :S(RETURN)
         MINUS = '-' X                                         :(RETURN)
*
GT       XYZERO()
         INFFLOAT()                                             :S(GT_3)
         SMALL()                                                :F(GT_1)
GT_3     GT.(X,Y)                                   :S(RETURN)F(FRETURN)
GT_1     X SIGN_OFF =                                           :F(GT_2)
         Y SIGN_OFF =                                        :F(FRETURN)
         SWAP(.X, .Y)
GT_2     Y SIGN_OFF =                                         :S(RETURN)
         LGT(LPAD(X, SIZE(Y), '0'),
+            LPAD(Y, SIZE(X), '0'))                 :S(RETURN)F(FRETURN)
*
EQ       XYZERO()
         INFFLOAT()                                             :S(EQ_2)
         SMALL()                                                :F(EQ_1)
EQ_2     EQ.(X, Y)                                  :S(RETURN)F(FRETURN)
EQ_1     IDENT(X, Y)                                :S(RETURN)F(FRETURN)
*
GE       ~(~GT(X, Y) ~EQ(X, Y))                     :S(RETURN)F(FRETURN)
*
NE       EQ(X, Y)                                   :S(FRETURN)F(RETURN)
*
LT       GE(X, Y)                                   :S(FRETURN)F(RETURN)
*
LE       GT(X, Y)                                   :S(FRETURN)F(RETURN)
*
DIFF     DIFF = X + -Y                                         :(RETURN)
*
SUM      XYZERO()
         SUM = INFFLOAT() SUM.(X, Y)                          :S(RETURN)
         SUM = SMALL() SUM.(X, Y)                             :S(RETURN)
         SUM = LT(X,0) -(-X + -Y)                             :S(RETURN)
         Y SIGN_OFF =                                          :S(SUM_1)
         (LT(X, Y) SWAP(.X, .Y))
         K = SPLIT(.X)
         Y = Y + X2
         SPLIT(.Y, RTAB(K))
         SUM = (Y1 + X1) LPAD(Y2, K, '0')                      :(RETURN)
SUM_1    SUM = GT(Y, X) -(Y - X)                              :S(RETURN)
         Y = LPAD(Y, SIZE(X), '0')
* ADD 10's COMPLEMENT OF Y
         SUM = X + 1 + REPLACE(Y, '0123456789', '9876543210')
         SUM '1' LDG_ZEROS REM . SUM                           :(RETURN)
*
MULT     XYZERO()
         MULT = INFFLOAT() MULT.(X, Y)                        :S(RETURN)
         MULT = LE(SIZE(X) + SIZE(Y), NO_DIGITS)
+           MULT.(X, Y)                                       :S(RETURN)
         MULT = LT(X, 0) -X * -Y                              :S(RETURN)
         MULT = LT(Y, 0) -(X * -Y)                            :S(RETURN)
         (GT(Y, X)  SWAP(.X, .Y))
         MULT = EQ(Y, 0) 0                                    :S(RETURN)
         K = SPLIT(.X)
         MULT = (Y * X1) DUPL('0', K)
         MULT = MULT + X2 * Y                                  :(RETURN)
*
DIV      XYZERO()
         DIV = INFFLOAT() DIV.(X, Y)                          :S(RETURN)
         DIV = SMALL() DIV.(X, Y)                             :S(RETURN)
         DIV = LT(X, 0) -(-X / Y)                             :S(RETURN)
         DIV = LT(Y, 0) -(X / -Y)                             :S(RETURN)
         DIV = GT(Y, X) 0                                     :S(RETURN)
* ORIGINAL STATEMENTS FROM BOOK:
*        KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
*        KX = SPLIT(.X, LEN(NO_DIGITS))
* SUGGESTED REPLACEMENT TO AVOID GENERATING ERROR TERMS THAT ARE
* LARGER THAN THE INCOMING NUMERATOR. SUCH A SITUATION CAN PRODUCE
* CYCLES.
         KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
         KX = SPLIT(.X, LEN(NO_DIGITS / 2) | REM)
         KX = LT.(X1, Y1) SPLIT(.X, LEN(NO_DIGITS / 2 + 1) | REM)
* END OF REPLACEMENT STATEMENTS.
         T1 = X1 / Y1
         T2 = DUPL('0', KX - KY)
         T = X - ((T1 * Y)  T2)
         DIV = T1 T2
         T = LT(T, 0) T + 1 - Y
         DIV = DIV + (T / Y)                                   :(RETURN)
*
REMDR    REMDR = X - (X / Y) * Y                               :(RETURN)
*
INFINIP_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'INFINIP.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL INFINIP
-EJECT
*
************************************************************************
*                                                                      *
*            ###  #     #  #######  ###  #     #  ###  ######          *
*             #   ##    #  #         #   ##    #   #   #     #         *
*             #   # #   #  #         #   # #   #   #   #     #         *
*             #   #  #  #  #####     #   #  #  #   #   ######          *
*             #   #   # #  #         #   #   # #   #   #               *
*             #   #    ##  #         #   #    ##   #   #               *
*            ###  #     #  #        ###  #     #  ###  #               *
*                                                                      *
* INFINIP          INFINITE PRECISION INTEGER MATH                     *
*                                                                      *
************************************************************************
*
* INFINIP.lss
*
<<INFINIP>>
*
* CE: .MSNOBOL4;
@
-LINE 10 "INFINIP.lss"
-INCLUDE 'REDEFINE.INC'
-INCLUDE 'SWAP.INC'
-STITL INFINIP
-EJECT
-LINE 191 "INFINIP.lss"
*
************************************************************************
*                                                                      *
*            ###  #     #  #######  ###  #     #  ###  ######          *
*             #   ##    #  #         #   ##    #   #   #     #         *
*             #   # #   #  #         #   # #   #   #   #     #         *
*             #   #  #  #  #####     #   #  #  #   #   ######          *
*             #   #   # #  #         #   #   # #   #   #               *
*             #   #    ##  #         #   #    ##   #   #               *
*            ###  #     #  #        ###  #     #  ###  #               *
*                                                                      *
* INFINIP          INFINITE PRECISION INTEGER MATH                     *
*                                                                      *
************************************************************************
*
* INFINIP.lss
*
-LINE 15 "INFINIP.lss"
-MODULE INFINIP
         SIGN_OFF  = POS(0) '-'
         LDG_ZEROS = BREAK('123456789') | RTAB(1)
         NO_DIGITS = 4
*
-PUBLIC INFINP_START(), INFINP_STOP()
         DEFINE('XYZERO()')
         DEFINE('INFFLOAT()')
         DEFINE('SMALL()')
         DEFINE('SPLIT(NAME,PAT)')
         DEFINE('INFINIP_START()')
         DEFINE('INFINIP_STOP()')                         :(INFINIP_END)
*
INFINIP_START
         REDEFINE('-', 'MINUS(X)Y')
         REDEFINE(   , 'GT(X,Y)')
         REDEFINE(   , 'EQ(X,Y)')
         REDEFINE(   , 'GE(X,Y)')
         REDEFINE(   , 'NE(X,Y)')
         REDEFINE(   , 'LT(X,Y)')
         REDEFINE(   , 'LE(X,Y)')
         REDEFINE('-', 'DIFF(X,Y)')
         REDEFINE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
         REDEFINE('*', 'MULT(X,Y)X1,X2,K')
         REDEFINE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
         REDEFINE(   , 'REMDR(X,Y)')                           :(RETURN)
*
INFINIP_STOP
         REDEFINERESTORE('-', 'MINUS(X)Y')
         REDEFINERESTORE(   , 'GT(X,Y)')
         REDEFINERESTORE(   , 'EQ(X,Y)')
         REDEFINERESTORE(   , 'GE(X,Y)')
         REDEFINERESTORE(   , 'NE(X,Y)')
         REDEFINERESTORE(   , 'LT(X,Y)')
         REDEFINERESTORE(   , 'LE(X,Y)')
         REDEFINERESTORE('-', 'DIFF(X,Y)')
         REDEFINERESTORE('+', 'SUM(X,Y)X1,X2,Y1,Y2,K')
         REDEFINERESTORE('*', 'MULT(X,Y)X1,X2,K')
         REDEFINERESTORE('/', 'DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY')
         REDEFINERESTORE(   , 'REMDR(X,Y)')                    :(RETURN)
*
* FMGW:
* ADDED XYZERO TO ALLOW '' + 1 ETC. TO WORK AS NORMAL
* INFFLOAT TO ALLOW REAL TO WORK AS NORMAL
*
* THERE IS STILL THE PROBLEM OF MIXING A LARGE INTEGER WITH A REAL IN
* ARITHMETIC. THIS WILL NOT WORK CORRECTLY. IF THE LARGE INTEGER CANNOT
* BE CONVERTED, AN ERROR WILL BE RAISED. WE SHOULD CHECK THE RANGE,
* AND CONVERT THE INTEGER TO REAL OURSELVES. THIS CAN BE DONE IN
* THE INFFLOAT() FUNCTION. NOTE THAT INFFLOAT() IS CALLED AFTER
* XYZERO(), SO BOTH X AND Y ARE (AT LEAST) 0, AND NOT THE EMPTY STRING.
*
* XYZERO() AND INFFLOAT() COULD BE MERGED, BUT ARE KEPT SEPARATE FOR
* CLARITY.
*
* INFINIP_START() AND INFINIP_STOP() ADDED TO CONTROL THE REDEFINITION
* OF OPERATIONS.
*
INFFLOAT DATATYPE(X) 'REAL'                                   :S(RETURN)
         DATATYPE(Y) 'REAL'                                   :S(RETURN)
                                                              :(FRETURN)
*
XYZERO   X = IDENT(X) 0
         Y = IDENT(Y) 0                                        :(RETURN)
*
SMALL    (LE.(SIZE(X), NO_DIGITS)
+         LE.(SIZE(Y), NO_DIGITS))                  :S(RETURN)F(FRETURN)
*
SPLIT    PAT = IDENT(PAT) LEN(SIZE($NAME) / 2)
         $NAME (PAT | '') . $(NAME 1) @SPLIT  (SPAN('0') | '')
+           REM . $(NAME 2)
         SPLIT = SIZE($NAME) - SPLIT                           :(RETURN)
*
MINUS    XYZERO()
         MINUS = INFFLOAT() MINUS.(X)                         :S(RETURN)
         MINUS = SMALL() MINUS.(X)                            :S(RETURN)
         MINUS = X
         MINUS SIGN_OFF =                                     :S(RETURN)
         MINUS = '-' X                                         :(RETURN)
*
GT       XYZERO()
         INFFLOAT()                                             :S(GT_3)
         SMALL()                                                :F(GT_1)
GT_3     GT.(X,Y)                                   :S(RETURN)F(FRETURN)
GT_1     X SIGN_OFF =                                           :F(GT_2)
         Y SIGN_OFF =                                        :F(FRETURN)
         SWAP(.X, .Y)
GT_2     Y SIGN_OFF =                                         :S(RETURN)
         LGT(LPAD(X, SIZE(Y), '0'),
+            LPAD(Y, SIZE(X), '0'))                 :S(RETURN)F(FRETURN)
*
EQ       XYZERO()
         INFFLOAT()                                             :S(EQ_2)
         SMALL()                                                :F(EQ_1)
EQ_2     EQ.(X, Y)                                  :S(RETURN)F(FRETURN)
EQ_1     IDENT(X, Y)                                :S(RETURN)F(FRETURN)
*
GE       ~(~GT(X, Y) ~EQ(X, Y))                     :S(RETURN)F(FRETURN)
*
NE       EQ(X, Y)                                   :S(FRETURN)F(RETURN)
*
LT       GE(X, Y)                                   :S(FRETURN)F(RETURN)
*
LE       GT(X, Y)                                   :S(FRETURN)F(RETURN)
*
DIFF     DIFF = X + -Y                                         :(RETURN)
*
SUM      XYZERO()
         SUM = INFFLOAT() SUM.(X, Y)                          :S(RETURN)
         SUM = SMALL() SUM.(X, Y)                             :S(RETURN)
         SUM = LT(X,0) -(-X + -Y)                             :S(RETURN)
         Y SIGN_OFF =                                          :S(SUM_1)
         (LT(X, Y) SWAP(.X, .Y))
         K = SPLIT(.X)
         Y = Y + X2
         SPLIT(.Y, RTAB(K))
         SUM = (Y1 + X1) LPAD(Y2, K, '0')                      :(RETURN)
SUM_1    SUM = GT(Y, X) -(Y - X)                              :S(RETURN)
         Y = LPAD(Y, SIZE(X), '0')
* ADD 10's COMPLEMENT OF Y
         SUM = X + 1 + REPLACE(Y, '0123456789', '9876543210')
         SUM '1' LDG_ZEROS REM . SUM                           :(RETURN)
*
MULT     XYZERO()
         MULT = INFFLOAT() MULT.(X, Y)                        :S(RETURN)
         MULT = LE(SIZE(X) + SIZE(Y), NO_DIGITS)
+           MULT.(X, Y)                                       :S(RETURN)
         MULT = LT(X, 0) -X * -Y                              :S(RETURN)
         MULT = LT(Y, 0) -(X * -Y)                            :S(RETURN)
         (GT(Y, X)  SWAP(.X, .Y))
         MULT = EQ(Y, 0) 0                                    :S(RETURN)
         K = SPLIT(.X)
         MULT = (Y * X1) DUPL('0', K)
         MULT = MULT + X2 * Y                                  :(RETURN)
*
DIV      XYZERO()
         DIV = INFFLOAT() DIV.(X, Y)                          :S(RETURN)
         DIV = SMALL() DIV.(X, Y)                             :S(RETURN)
         DIV = LT(X, 0) -(-X / Y)                             :S(RETURN)
         DIV = LT(Y, 0) -(X / -Y)                             :S(RETURN)
         DIV = GT(Y, X) 0                                     :S(RETURN)
* ORIGINAL STATEMENTS FROM BOOK:
*        KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
*        KX = SPLIT(.X, LEN(NO_DIGITS))
* SUGGESTED REPLACEMENT TO AVOID GENERATING ERROR TERMS THAT ARE
* LARGER THAN THE INCOMING NUMERATOR. SUCH A SITUATION CAN PRODUCE
* CYCLES.
         KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
         KX = SPLIT(.X, LEN(NO_DIGITS / 2) | REM)
         KX = LT.(X1, Y1) SPLIT(.X, LEN(NO_DIGITS / 2 + 1) | REM)
* END OF REPLACEMENT STATEMENTS.
         T1 = X1 / Y1
         T2 = DUPL('0', KX - KY)
         T = X - ((T1 * Y)  T2)
         DIV = T1 T2
         T = LT(T, 0) T + 1 - Y
         DIV = DIV + (T / Y)                                   :(RETURN)
*
REMDR    REMDR = X - (X / Y) * Y                               :(RETURN)
*
INFINIP_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>INFINIP - Infinite precision integer math</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Infinite precision integer math.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="REDEFINE.html">REDEFINE</a><br>
<a href="SWAP.html">SWAP</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;REDEFINE.INC&#39;
-INCLUDE &#39;SWAP.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INFINIP&raquo;&equiv;</b>
-MODULE INFINIP
         SIGN_OFF  = POS(0) &#39;-&#39;
         LDG_ZEROS = BREAK(&#39;123456789&#39;) | RTAB(1)
         NO_DIGITS = 4
<font color="#818181"><i>*</i></font>
-PUBLIC INFINP_START(), INFINP_STOP()
         DEFINE(&#39;XYZERO()&#39;)
         DEFINE(&#39;INFFLOAT()&#39;)
         DEFINE(&#39;SMALL()&#39;)
         DEFINE(&#39;SPLIT(NAME,PAT)&#39;)
         DEFINE(&#39;INFINIP_START()&#39;)
         DEFINE(&#39;INFINIP_STOP()&#39;)                         <b>:(INFINIP_END)</b>
<font color="#818181"><i>*</i></font>
INFINIP_START
         REDEFINE(&#39;-&#39;, &#39;MINUS(X)Y&#39;)
         REDEFINE(   , &#39;GT(X,Y)&#39;)
         REDEFINE(   , &#39;EQ(X,Y)&#39;)
         REDEFINE(   , &#39;GE(X,Y)&#39;)
         REDEFINE(   , &#39;NE(X,Y)&#39;)
         REDEFINE(   , &#39;LT(X,Y)&#39;)
         REDEFINE(   , &#39;LE(X,Y)&#39;)
         REDEFINE(&#39;-&#39;, &#39;DIFF(X,Y)&#39;)
         REDEFINE(&#39;+&#39;, &#39;SUM(X,Y)X1,X2,Y1,Y2,K&#39;)
         REDEFINE(&#39;*&#39;, &#39;MULT(X,Y)X1,X2,K&#39;)
         REDEFINE(&#39;/&#39;, &#39;DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY&#39;)
         REDEFINE(   , &#39;REMDR(X,Y)&#39;)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
INFINIP_STOP
         REDEFINERESTORE(&#39;-&#39;, &#39;MINUS(X)Y&#39;)
         REDEFINERESTORE(   , &#39;GT(X,Y)&#39;)
         REDEFINERESTORE(   , &#39;EQ(X,Y)&#39;)
         REDEFINERESTORE(   , &#39;GE(X,Y)&#39;)
         REDEFINERESTORE(   , &#39;NE(X,Y)&#39;)
         REDEFINERESTORE(   , &#39;LT(X,Y)&#39;)
         REDEFINERESTORE(   , &#39;LE(X,Y)&#39;)
         REDEFINERESTORE(&#39;-&#39;, &#39;DIFF(X,Y)&#39;)
         REDEFINERESTORE(&#39;+&#39;, &#39;SUM(X,Y)X1,X2,Y1,Y2,K&#39;)
         REDEFINERESTORE(&#39;*&#39;, &#39;MULT(X,Y)X1,X2,K&#39;)
         REDEFINERESTORE(&#39;/&#39;, &#39;DIV(X,Y)X1,X2,Y1,Y2,T,T1,T2,KX,KY&#39;)
         REDEFINERESTORE(   , &#39;REMDR(X,Y)&#39;)                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FMGW:</i></font>
<font color="#818181"><i>* ADDED XYZERO TO ALLOW &#39;&#39; + 1 ETC. TO WORK AS NORMAL</i></font>
<font color="#818181"><i>* INFFLOAT TO ALLOW REAL TO WORK AS NORMAL</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THERE IS STILL THE PROBLEM OF MIXING A LARGE INTEGER WITH A REAL IN</i></font>
<font color="#818181"><i>* ARITHMETIC. THIS WILL NOT WORK CORRECTLY. IF THE LARGE INTEGER CANNOT</i></font>
<font color="#818181"><i>* BE CONVERTED, AN ERROR WILL BE RAISED. WE SHOULD CHECK THE RANGE,</i></font>
<font color="#818181"><i>* AND CONVERT THE INTEGER TO REAL OURSELVES. THIS CAN BE DONE IN</i></font>
<font color="#818181"><i>* THE INFFLOAT() FUNCTION. NOTE THAT INFFLOAT() IS CALLED AFTER</i></font>
<font color="#818181"><i>* XYZERO(), SO BOTH X AND Y ARE (AT LEAST) 0, AND NOT THE EMPTY STRING.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* XYZERO() AND INFFLOAT() COULD BE MERGED, BUT ARE KEPT SEPARATE FOR</i></font>
<font color="#818181"><i>* CLARITY.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INFINIP_START() AND INFINIP_STOP() ADDED TO CONTROL THE REDEFINITION</i></font>
<font color="#818181"><i>* OF OPERATIONS.</i></font>
<font color="#818181"><i>*</i></font>
INFFLOAT DATATYPE(X) &#39;REAL&#39;                                   <b>:S(RETURN)</b>
         DATATYPE(Y) &#39;REAL&#39;                                   <b>:S(RETURN)</b>
                                                              <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
XYZERO   X = IDENT(X) 0
         Y = IDENT(Y) 0                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SMALL    (LE.(SIZE(X), NO_DIGITS)
+         LE.(SIZE(Y), NO_DIGITS))                  <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
SPLIT    PAT = IDENT(PAT) LEN(SIZE($NAME) / 2)
         $NAME (PAT | &#39;&#39;) . $(NAME 1) @SPLIT  (SPAN(&#39;0&#39;) | &#39;&#39;)
+           REM . $(NAME 2)
         SPLIT = SIZE($NAME) - SPLIT                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MINUS    XYZERO()
         MINUS = INFFLOAT() MINUS.(X)                         <b>:S(RETURN)</b>
         MINUS = SMALL() MINUS.(X)                            <b>:S(RETURN)</b>
         MINUS = X
         MINUS SIGN_OFF =                                     <b>:S(RETURN)</b>
         MINUS = &#39;-&#39; X                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
GT       XYZERO()
         INFFLOAT()                                             <b>:S(GT_3)</b>
         SMALL()                                                <b>:F(GT_1)</b>
GT_3     GT.(X,Y)                                   <b>:S(RETURN)F(FRETURN)</b>
GT_1     X SIGN_OFF =                                           <b>:F(GT_2)</b>
         Y SIGN_OFF =                                        <b>:F(FRETURN)</b>
         SWAP(.X, .Y)
GT_2     Y SIGN_OFF =                                         <b>:S(RETURN)</b>
         LGT(LPAD(X, SIZE(Y), &#39;0&#39;),
+            LPAD(Y, SIZE(X), &#39;0&#39;))                 <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
EQ       XYZERO()
         INFFLOAT()                                             <b>:S(EQ_2)</b>
         SMALL()                                                <b>:F(EQ_1)</b>
EQ_2     EQ.(X, Y)                                  <b>:S(RETURN)F(FRETURN)</b>
EQ_1     IDENT(X, Y)                                <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
GE       ~(~GT(X, Y) ~EQ(X, Y))                     <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
NE       EQ(X, Y)                                   <b>:S(FRETURN)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
LT       GE(X, Y)                                   <b>:S(FRETURN)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
LE       GT(X, Y)                                   <b>:S(FRETURN)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
DIFF     DIFF = X + -Y                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SUM      XYZERO()
         SUM = INFFLOAT() SUM.(X, Y)                          <b>:S(RETURN)</b>
         SUM = SMALL() SUM.(X, Y)                             <b>:S(RETURN)</b>
         SUM = LT(X,0) -(-X + -Y)                             <b>:S(RETURN)</b>
         Y SIGN_OFF =                                          <b>:S(SUM_1)</b>
         (LT(X, Y) SWAP(.X, .Y))
         K = SPLIT(.X)
         Y = Y + X2
         SPLIT(.Y, RTAB(K))
         SUM = (Y1 + X1) LPAD(Y2, K, &#39;0&#39;)                      <b>:(RETURN)</b>
SUM_1    SUM = GT(Y, X) -(Y - X)                              <b>:S(RETURN)</b>
         Y = LPAD(Y, SIZE(X), &#39;0&#39;)
<font color="#818181"><i>* ADD 10&#39;s COMPLEMENT OF Y</i></font>
         SUM = X + 1 + REPLACE(Y, &#39;0123456789&#39;, &#39;9876543210&#39;)
         SUM &#39;1&#39; LDG_ZEROS REM . SUM                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MULT     XYZERO()
         MULT = INFFLOAT() MULT.(X, Y)                        <b>:S(RETURN)</b>
         MULT = LE(SIZE(X) + SIZE(Y), NO_DIGITS)
+           MULT.(X, Y)                                       <b>:S(RETURN)</b>
         MULT = LT(X, 0) -X * -Y                              <b>:S(RETURN)</b>
         MULT = LT(Y, 0) -(X * -Y)                            <b>:S(RETURN)</b>
         (GT(Y, X)  SWAP(.X, .Y))
         MULT = EQ(Y, 0) 0                                    <b>:S(RETURN)</b>
         K = SPLIT(.X)
         MULT = (Y * X1) DUPL(&#39;0&#39;, K)
         MULT = MULT + X2 * Y                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
DIV      XYZERO()
         DIV = INFFLOAT() DIV.(X, Y)                          <b>:S(RETURN)</b>
         DIV = SMALL() DIV.(X, Y)                             <b>:S(RETURN)</b>
         DIV = LT(X, 0) -(-X / Y)                             <b>:S(RETURN)</b>
         DIV = LT(Y, 0) -(X / -Y)                             <b>:S(RETURN)</b>
         DIV = GT(Y, X) 0                                     <b>:S(RETURN)</b>
<font color="#818181"><i>* ORIGINAL STATEMENTS FROM BOOK:</i></font>
<font color="#818181"><i>*        KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)</i></font>
<font color="#818181"><i>*        KX = SPLIT(.X, LEN(NO_DIGITS))</i></font>
<font color="#818181"><i>* SUGGESTED REPLACEMENT TO AVOID GENERATING ERROR TERMS THAT ARE</i></font>
<font color="#818181"><i>* LARGER THAN THE INCOMING NUMERATOR. SUCH A SITUATION CAN PRODUCE</i></font>
<font color="#818181"><i>* CYCLES.</i></font>
         KY = SPLIT(.Y, LEN(NO_DIGITS / 2) | REM)
         KX = SPLIT(.X, LEN(NO_DIGITS / 2) | REM)
         KX = LT.(X1, Y1) SPLIT(.X, LEN(NO_DIGITS / 2 + 1) | REM)
<font color="#818181"><i>* END OF REPLACEMENT STATEMENTS.</i></font>
         T1 = X1 / Y1
         T2 = DUPL(&#39;0&#39;, KX - KY)
         T = X - ((T1 * Y)  T2)
         DIV = T1 T2
         T = LT(T, 0) T + 1 - Y
         DIV = DIV + (T / Y)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
REMDR    REMDR = X - (X / Y) * Y                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
INFINIP_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;INFINIP.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL INFINIP
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*            ###  #     #  #######  ###  #     #  ###  ######          *</i></font>
<font color="#818181"><i>*             #   ##    #  #         #   ##    #   #   #     #         *</i></font>
<font color="#818181"><i>*             #   # #   #  #         #   # #   #   #   #     #         *</i></font>
<font color="#818181"><i>*             #   #  #  #  #####     #   #  #  #   #   ######          *</i></font>
<font color="#818181"><i>*             #   #   # #  #         #   #   # #   #   #               *</i></font>
<font color="#818181"><i>*             #   #    ##  #         #   #    ##   #   #               *</i></font>
<font color="#818181"><i>*            ###  #     #  #        ###  #     #  ###  #               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* INFINIP          INFINITE PRECISION INTEGER MATH                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INFINIP.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;INFINIP&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:06 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'INFINIP.INC'
-LINE 182 "INFINIP.lss"
         &CODE = 1
         &CODE = 0
END
<h1>ITERDIR - Directory (file) iterator</h1>

Use bq to gather directory data matching pattern. crack to crack
the string into an array of lines. atol to produce a linked list,
and return that list as the directory iterator.

General note on iterators. The iter_() function returns an iterator
This iterator is passed to a value function v() which returns the
next thing being iterated. v() should fail if the end of iteration
is reached. The iterator is also passed to next() which returns a
new iterator which will return the next item in the iteration.
next_() may fail on the end of the iteration, but this is not
expected.

[[
An iterator should be used as:

    i = iter_type(args)
top   v = vali(i) :f(btm)
      do stuff with v
    i = next_type(i) :(top)
btm
]]

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="ATOL.html">ATOL</a><br>
<a href="CHARS.html">CHARS</a><br>

<<INCLUDES>>= 
-INCLUDE 'BQ.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'ATOL.INC'
-INCLUDE 'CHARS.INC'
@

<<ITERDIR>>=
-MODULE ITERDIR
-PUBLIC `VALUE_DIR(), ITER_DIR(), NEXT_DIR()
*
         DEFINE('ITER_DIR(W)')
         DEFINE('VALUE_DIR(D)')
         DEFINE('NEXT_DIR(D)')                           :(END_ITER_DIR)
*
VALUE_DIR
         VALUE_DIR = DIFFER(D) VALUE(D)             :S(RETURN)F(FRETURN)
*
ITER_DIR ITER_DIR = ATOL(CRACK(BQ('ls ' W, CHARS_NL), CHARS_NL))
+                                                   :S(RETURN)F(FRETURN)
*
NEXT_DIR NEXT_DIR = DIFFER(D) NEXT(D)               :S(RETURN)F(FRETURN)
*
END_ITER_DIR
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ITERDIR.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL ITERDIR
-EJECT
*
************************************************************************
*                                                                      *
*        ###  #######  #######  ######   ######   ###  ######          *
*         #      #     #        #     #  #     #   #   #     #         *
*         #      #     #        #     #  #     #   #   #     #         *
*         #      #     #####    ######   #     #   #   ######          *
*         #      #     #        #   #    #     #   #   #   #           *
*         #      #     #        #    #   #     #   #   #    #          *
*        ###     #     #######  #     #  ######   ###  #     #         *
*                                                                      *
* ITERDIR                   DIRECTORY ITERATOR                         *
*                                                                      *
************************************************************************
*
* ITERDIR.lss
*
<<ITERDIR>>
*
* CE: .MSNOBOL4;
@
-LINE 32 "ITERDIR.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'ATOL.INC'
-INCLUDE 'CHARS.INC'
-STITL ITERDIR
-EJECT
-LINE 70 "ITERDIR.lss"
*
************************************************************************
*                                                                      *
*        ###  #######  #######  ######   ######   ###  ######          *
*         #      #     #        #     #  #     #   #   #     #         *
*         #      #     #        #     #  #     #   #   #     #         *
*         #      #     #####    ######   #     #   #   ######          *
*         #      #     #        #   #    #     #   #   #   #           *
*         #      #     #        #    #   #     #   #   #    #          *
*        ###     #     #######  #     #  ######   ###  #     #         *
*                                                                      *
* ITERDIR                   DIRECTORY ITERATOR                         *
*                                                                      *
************************************************************************
*
* ITERDIR.lss
*
-LINE 39 "ITERDIR.lss"
-MODULE ITERDIR
-PUBLIC `VALUE_DIR(), ITER_DIR(), NEXT_DIR()
*
         DEFINE('ITER_DIR(W)')
         DEFINE('VALUE_DIR(D)')
         DEFINE('NEXT_DIR(D)')                           :(END_ITER_DIR)
*
VALUE_DIR
         VALUE_DIR = DIFFER(D) VALUE(D)             :S(RETURN)F(FRETURN)
*
ITER_DIR ITER_DIR = ATOL(CRACK(BQ('ls ' W, CHARS_NL), CHARS_NL))
+                                                   :S(RETURN)F(FRETURN)
*
NEXT_DIR NEXT_DIR = DIFFER(D) NEXT(D)               :S(RETURN)F(FRETURN)
*
END_ITER_DIR
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ITERDIR - Directory (file) iterator</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Use bq to gather directory data matching pattern. crack to crack
the string into an array of lines. atol to produce a linked list,
and return that list as the directory iterator.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
General note on iterators. The iter_() function returns an iterator
This iterator is passed to a value function v() which returns the
next thing being iterated. v() should fail if the end of iteration
is reached. The iterator is also passed to next() which returns a
new iterator which will return the next item in the iteration.
next_() may fail on the end of the iteration, but this is not
expected.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| An iterator should be used as:
| 
|     i = iter_type(args)
| top   v = vali(i) :f(btm)
|       do stuff with v
|     i = next_type(i) :(top)
| btm
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="ATOL.html">ATOL</a><br>
<a href="CHARS.html">CHARS</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;ATOL.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ITERDIR&raquo;&equiv;</b>
-MODULE ITERDIR
-PUBLIC `VALUE_DIR(), ITER_DIR(), NEXT_DIR()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;ITER_DIR(W)&#39;)
         DEFINE(&#39;VALUE_DIR(D)&#39;)
         DEFINE(&#39;NEXT_DIR(D)&#39;)                           <b>:(END_ITER_DIR)</b>
<font color="#818181"><i>*</i></font>
VALUE_DIR
         VALUE_DIR = DIFFER(D) VALUE(D)             <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
ITER_DIR ITER_DIR = ATOL(CRACK(BQ(&#39;ls &#39; W, CHARS_NL), CHARS_NL))
+                                                   <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
NEXT_DIR NEXT_DIR = DIFFER(D) NEXT(D)               <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
END_ITER_DIR
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ITERDIR.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL ITERDIR
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*        ###  #######  #######  ######   ######   ###  ######          *</i></font>
<font color="#818181"><i>*         #      #     #        #     #  #     #   #   #     #         *</i></font>
<font color="#818181"><i>*         #      #     #        #     #  #     #   #   #     #         *</i></font>
<font color="#818181"><i>*         #      #     #####    ######   #     #   #   ######          *</i></font>
<font color="#818181"><i>*         #      #     #        #   #    #     #   #   #   #           *</i></font>
<font color="#818181"><i>*         #      #     #        #    #   #     #   #   #    #          *</i></font>
<font color="#818181"><i>*        ###     #     #######  #     #  ######   ###  #     #         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ITERDIR                   DIRECTORY ITERATOR                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ITERDIR.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ITERDIR&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Sun Jun  8 20:28:11 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ITERDIR.INC'
-LINE 61 "ITERDIR.lss"
         &CODE = 1
         &CODE = 0
END
<h1>JIT - Just In Time Code Generation</h1>

{{
This is broken until all set_p() get_p() calls are replaced with
long/pointer code. The process will take several days.
}}

Interface to the GNU Lightning library to allow dynamic code production
at run-time for: ARM, HPPA, IA64, MIPS, PPC, S390, SPARC, Intel X86
(32 bit) and X86_64.

GNU Lightning does not have an ELF writer. It does appear to support
all of the platforms that I would want.

<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="P64.html">P64</a><br>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>=
-INCLUDE 'CRACK.INC'
-INCLUDE 'P64.INC'
-INCLUDE 'SEQ.INC'
@

<<JIT>>=
-CASE 1
-PLUSOPS 1
-SNOBOL TERMINAL = 'JIT (THU JUL  4 14:54:49 EDT 2013)'
-SNOBOL SLOAD('CRACK.INC')
-SNOBOL SLOAD('SEQ.INC')
-SNOBOL SLOAD('DYNAMIC.INC')
-SNOBOL SLOAD('WRAPPER.INC')
@

<<JIT>>=
-EMBED C 'jit'
@

<<JIT,TYPE=C>>=
-SNOBOL WRAPPER_STARTFILE(.EMBED)

#include <lightning.h>

/* Setup, state and misc */
-SNOBOL C_WRAPPER_PROTO('INIT_JIT(STRING)', .EMBED)
-SNOBOL C_WRAPPER_PROTO('FINISH_JIT()', .EMBED)

static jit_state_t *_jit;

static long get_state_jit(void) { return (long)_jit; }

-SNOBOL C_WRAPPER_PROTO('GET_STATE_JIT()LONG', .EMBED)

static void set_state_jit(long p) { _jit = (void *)p; }

-SNOBOL C_WRAPPER_PROTO('SET_STATE_JIT(LONG)', .EMBED)

static long new_state_jit(void) { return (long)jit_new_state(); }

-SNOBOL C_WRAPPER_PROTO('NEW_STATE_JIT()LONG', .EMBED)

static void destroy_state_jit(void) { jit_destroy_state(); }

-SNOBOL C_WRAPPER_PROTO('DESTROY_STATE_JIT()', .EMBED)

static void clear_state_jit(void) { jit_clear_state(); }

-SNOBOL C_WRAPPER_PROTO('CLEAR_STATE_JIT()', .EMBED)

static void prolog_jit(void) { jit_prolog(); }

-SNOBOL C_WRAPPER_PROTO('PROLOG_JIT()', .EMBED)

static void epilog_jit(void) { jit_epilog(); }

-SNOBOL C_WRAPPER_PROTO('EPILOG_JIT()', .EMBED)

static long note_jit(char *s, int n) { return (long)jit_note(s, n); }

-SNOBOL C_WRAPPER_PROTO('NOTE_JIT(STRING,INTEGER)LONG', .EMBED)

static long name_jit(char *s) { return (long)jit_name(s); }

-SNOBOL C_WRAPPER_PROTO('NAME_JIT(STRING)LONG', .EMBED)

static long address_jit(long p) { return (long)jit_address((void *)p); }

-SNOBOL C_WRAPPER_PROTO('ADDRESS_JIT(LONG)LONG', .EMBED)

static void disassemble_jit(void) { jit_disassemble(); }

-SNOBOL C_WRAPPER_PROTO('DISASSEMBLE_JIT()', .EMBED)

static long emit_jit(void) { (long)jit_emit(); }

-SNOBOL C_WRAPPER_PROTO('EMIT_JIT()LONG', .EMBED)

static void print_jit(void) { jit_print(); }

-SNOBOL C_WRAPPER_PROTO('PRINT_JIT()', .EMBED)

static long label_jit(void) { return (long)jit_label(); }

-SNOBOL C_WRAPPER_PROTO('LABEL_JIT()INTEGER', .EMBED)

static void ellipsis_jit(void) { jit_ellipsis(); }

-SNOBOL C_WRAPPER_PROTO('ELLIPSIS_JIT()', .EMBED)

//static int get_note_jit(void)
//{
//    int notei;
//    void *p, *p2;
//    jit_get_note(get_p_(), (char **)&p, (char **)&p2, &notei);
//    set_p_(p);
//    set_p2_(p2);
//    return notei;
//}

-CMNT -SNOBOL C_WRAPPER_PROTO('GET_NOTE_JIT()INTEGER', .EMBED)

static int pointer_p_jit(void) { return jit_pointer_p(get_p_()); }

-SNOBOL C_WRAPPER_PROTO('POINTER_P_JIT()PREDICATE', .EMBED)

static int callee_save_p(int r) { return jit_callee_save_p(r); }

-SNOBOL C_WRAPPER_PROTO('CALLEE_SAVE_P_JIT(INTEGER)PREDICATE', .EMBED)

static void patch_at_jit(void) { jit_patch_at(get_p_(), get_p2_()); }

-SNOBOL C_WRAPPER_PROTO('PATCH_AT_JIT()', .EMBED)

static void patch_abs_jit(void) { jit_patch_abs(get_p_(), get_p2_()); }

-SNOBOL C_WRAPPER_PROTO('PATCH_ABS_JIT()', .EMBED)

static void patch_jit(void) { jit_patch(get_p_()); }

-SNOBOL C_WRAPPER_PROTO('PATCH_JIT()', .EMBED)

static void prepare_jit(void) { jit_prepare(); }

-SNOBOL C_WRAPPER_PROTO('PREPARE_JIT()', .EMBED)

static int allocai_jit(int n) { return jit_allocai(n); }

-SNOBOL C_WRAPPER_PROTO('ALLOCAI_JIT(INTEGER)INTEGER', .EMBED)

/* DATA, LENGTH, ALIGNMENT (0..4). DATA/LENGTH HASHED */
static long data_jit(long p, int l, int a)
{
    return (long)jit_data((void *)p, l, a);
}

-SNOBOL C_WRAPPER_PROTO('DATA_JIT(LONG,INTEGER,INTEGER)LONG', .EMBED)

static long forward_jit(void) { return (long)jit_forward(); }

-SNOBOL C_WRAPPER_PROTO('FORWARD_JIT()LONG', .EMBED)

static void live_jit(int r) { jit_live(r); }

-SNOBOL C_WRAPPER_PROTO('LIVE_JIT(INTEGER)', .EMBED)

static void link_jit(void) { jit_link(get_p_()); }

-SNOBOL C_WRAPPER_PROTO('LINK_JIT()', .EMBED)

/* REGISTERS */
static int r_num_jit(void) { return jit_r_num(); }

-SNOBOL C_WRAPPER_PROTO('R_NUM_JIT()INTEGER', .EMBED)

static int v_num_jit(void) { return jit_v_num(); }

-SNOBOL C_WRAPPER_PROTO('V_NUM_JIT()INTEGER', .EMBED)

static int f_num_jit(void) { return jit_f_num(); }

-SNOBOL C_WRAPPER_PROTO('F_NUM_JIT()INTEGER', .EMBED)

-SNOBOL L = 'r0 r1 r2 r3 v0 v1 v2 v3 f0 f1 f2 f3 f4 f5 f6 f7 fp'
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static int get_' A<I> '_jit(void) { '; "        +
            " EMBED = '#ifdef JIT_' AU<I>; "                           +
            " EMBED = '    return JIT_' AU<I> ';'; "                   +
            " EMBED = DIFFER(A<I>) '#else'; "                          +
            " EMBED = DIFFER(A<I>) '    return -1;'; "                 +
            " EMBED = DIFFER(A<I>) '#endif'; "                         +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO('GET_' AU<I> '_JIT()INTEGER', .EMBED) "  +
            , .I)

/* REGISTER MATH */
-SNOBOL L = 'addr addcr addxr subr subcr subxr mulr divr divr_u '      +
            'remr remr_u andr orr xorr lshr rshr rshr_u '              +
            'ltr ltr_u ler ler_u ger ger_u gtr gtr_u eqr ner '         +
            'addr_f addr_d subr_f subr_d mulr_f mulr_d divr_f divr_d ' +
            'ltr_f ler_f eqr_f ger_f gtr_f ner_f unltr_f unler_f '     +
            'uneqr_f unger_f ungtr_f ltgtr_f ordr_f unordr_f '         +
            'ltr_d ler_d eqr_d ger_d gtr_d ner_d unltr_d unler_d '     +
            'uneqr_d unger_d ungtr_d ltgtr_d ordr_d unordr_d '         +
            'ldxr_c ldxr_uc ldxr_s ldxr_us ldxr_i ldxr_ui ldxr_l '     +
            'ldxr ldxr_f ldxr_d '                                      +
            'stxr_c stxr_s stxr_i stxr stxr_l stxr_f stxr_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' "                                 +
            " A<I> '_jit(int r1, int r2, int r3) { '; "                +
            " EMBED = '    jit_' A<I> '(r1, r2, r3);'; "               +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER,INTEGER)', " +
            " .EMBED) ", .I)

/* INTEGER IMMEDIATE MATH */
-SNOBOL L = 'addi addci addxi subi subci subxi muli divi divi_u '      +
            'remi remi_u andi ori xori lshi rshi rshi_u '              +
            'lti lti_u lei lei_u gei gei_u gti gti_u eqi nei '         +
            'ldxi_c ldxi_uc ldxi_s ldxi_us ldxi_i ldxi_ui ldxi_l '     +
            'ldxi ldxi_f ldxi_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r1, int r2) { '; " +
            " EMBED = '    jit_' A<I> '(r1, r2, (long)get_p_());'; "   +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER)', "         +
            " .EMBED) ", .I)

-SNOBOL L = 'stxi_c stxi_s stxi_i stxi_l stxi stxi_f stxi_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r1, int r2) { '; " +
            " EMBED = '    jit_' A<I> '(r1, (long)get_p_(), r2);'; "   +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER)', "         +
            " .EMBED) ", .I)

/* FLOAT IMMEDIATE MATH */
-SNOBOL L = 'addi_f subi_f muli_f divi_f '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r1, int r2) { '; " +
            " EMBED = '    jit_' A<I> '(r1, r2, get_f_());'; "         +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER)', "         +
            " .EMBED) ", .I)

/* DOUBLE IMMEDIATE MATH */
-SNOBOL L = 'addi_d subi_d muli_d divi_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r1, int r2) { '; " +
            " EMBED = '    jit_' A<I> '(r1, r2, get_d_());'; "         +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER)', "         +
            " .EMBED) ", .I)

/* BRANCH - REGISTER */
-SNOBOL L = 'bltr bltr_u bler bler_u bgtr bgtr_u bger bger_u '         +
            'beqr bner bmsr bmcr boaddr bxaddr bosubr bxsubr '         +
            'boaddr_u bxaddr_u bosubr_u bxsubr_u '                     +
            'bltr_f bler_f bgtr_f bger_f beqr_f bner_f '               +
            'bunltr_f bunler_f buneqr_f bunger_f bungtr_f '            +
            'bltgtr_f bordr_f bunordr_f '                              +
            'bltr_d bler_d bgtr_d bger_d beqr_d bner_d '               +
            'bunltr_d bunler_d buneqr_d bunger_d bungtr_d '            +
            'bltgtr_d bordr_d bunordr_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static long ' A<I> '_jit(int r1, int r2) { '; " +
            " EMBED = '    return (long)jit_' A<I> '(r1, r2);'; "      +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER)LONG', "     +
            " .EMBED) ", .I)

/* TWO REGISTER MOV, HTONR, NTOHR, COM, NEG, ABS, SQRT, EXT, TRUNC */
-SNOBOL L = 'movr movr_f movr_d movr_f_w movr_w_f movr_d_w movr_w_d '  +
            'htonr ntohr comr negr negr_f negr_d absr_f absr_d '       +
            'sqrtr_f sqrtr_d '                                         +
            'extr_c extr_uc extr_s extr_us extr_i extr_ui '            +
            'extr_f extr_d_f extr_d extr_f_d '                         +
            'truncr_f_i truncr_f truncr_f_l truncr_d_i truncr_d '      +
            'truncr_d_l '                                              +
            'ldr_c ldr_uc ldr_s ldr_us ldr_i ldr ldr_ui ldr_l '        +
            'ldr_f ldr_d '                                             +
            'str_c str_s str_i str str_l str_f str_d'
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r1, int r2) { '; " +
            " EMBED = '    jit_' A<I> '(r1, r2);'; "                   +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER)', "         +
            " .EMBED) ", .I)

/* THREE REGISTER MOV */
-SNOBOL L = 'movr_d_ww movr_ww_d'
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void '"                                  +
            " A<I> '_jit(int r,int s,int t) { '; "                     +
            " EMBED = '    jit_' A<I> '(r, s, t);'; "                  +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER,INTEGER,INTEGER)', " +
            " .EMBED) ", .I)

static long movi_jit(int r1)
{
    return (long)jit_movi(r1, (jit_word_t)get_p_());
}

-SNOBOL C_WRAPPER_PROTO('MOVI_JIT(INTEGER)LONG', .EMBED)

static void movi_f_jit(int r1)
{
    jit_movi_f(r1, get_f_());
}

-SNOBOL C_WRAPPER_PROTO('MOVI_F_JIT(INTEGER)', .EMBED)

static void movi_d_jit(int r1)
{
    jit_movi_d(r1, get_d_());
}

-SNOBOL C_WRAPPER_PROTO('MOVI_D_JIT(INTEGER)', .EMBED)

static void movi_f_w_jit(int r1)
{
    jit_movi_f_w(r1, get_f_());
}

-SNOBOL C_WRAPPER_PROTO('MOVI_F_W_JIT(INTEGER)', .EMBED)

static void movi_d_w_jit(int r1)
{
    jit_movi_d_w(r1, get_d_());
}

-SNOBOL C_WRAPPER_PROTO('MOVI_D_W_JIT(INTEGER)', .EMBED)

static void movi_d_ww_jit(int r1, int r2)
{
    jit_movi_d_ww(r1, r2, get_d_());
}

-SNOBOL C_WRAPPER_PROTO('MOVI_D_WW_JIT(INTEGER,INTEGER)', .EMBED)

/* ARG */
-SNOBOL L = 'arg arg_f arg_d'
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(void) { '; "           +
            " EMBED = '    set_p_(jit_' A<I> '());'; "                 +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT()', "                        +
            " .EMBED) ", .I)

-SNOBOL L = 'getarg getarg_c getarg_uc getarg_s getarg_us getarg_i '   +
            'getarg_ui getarg_l getarg_f getarg_d '                    +
            'ldi_c ldi_uc ldi_s ldi_us ldi_i ldi ldi_ui ldi_l ldi_f '  +
            'ldi_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r) { '; "          +
            " EMBED = '    jit_' A<I> '(r, get_p_());'; "              +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER)', "                 +
            " .EMBED) ", .I)

-SNOBOL L = 'blti blti_u blei blei_u beqi bgei bgei_u bgti bgti_u '    +
            'bnei bmsi bmci boaddi boaddi_u bxaddi bxaddi_u '          +
            'bosubi bosubi_u bxsubi bxsubi_u '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r) { '; "          +
        " EMBED = ' set_p_(jit_' A<I> '(r, (jit_word_t)get_p_()));'; " +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER)', "                 +
            " .EMBED) ", .I)

-SNOBOL L = 'sti_c sti_s sti_i sti sti_l sti_f sti_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r) { '; "          +
            " EMBED = '    jit_' A<I> '(get_p_(), r);'; "              +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER)', "                 +
            " .EMBED) ", .I)

-SNOBOL L = 'pushargr pushargr_f pushargr_d '                          +
            'retr retval_c retval_uc retval_s retval_us retval_i '     +
            'retval retval_ui retval_l retr_f retval_f '               +
            'retr_d retval_d '
-SNOBOL LU = REPLACE(L, &LCASE, &UCASE)
-SNOBOL A = CRACK(L, ' ')
-SNOBOL AU = CRACK(LU, ' ')
-SNOBOL SEQ(" EMBED = 'static void ' A<I> '_jit(int r) { '; "          +
            " EMBED = '    jit_' A<I> '(r);'; "                        +
            " EMBED = DIFFER(A<I>) '}'; "                              +
            " C_WRAPPER_PROTO(AU<I> '_JIT(INTEGER)', "                 +
            " .EMBED) ", .I)

static void pushargi_jit(void) { jit_pushargi((jit_word_t)get_p_()); }

-SNOBOL C_WRAPPER_PROTO('PUSHARGI_JIT()', .EMBED)

static void pushargi_f_jit(void) { jit_pushargi_f(get_f_()); }

-SNOBOL C_WRAPPER_PROTO('PUSHARGI_F_JIT()', .EMBED)

static void pushargi_d_jit(void) { jit_pushargi_d(get_d_()); }

-SNOBOL C_WRAPPER_PROTO('PUSHARGI_D_JIT()', .EMBED)

static void jmpr_jit(int r) { jit_jmpr(r); }

-SNOBOL C_WRAPPER_PROTO('JMPR_JIT(INTEGER)', .EMBED)

static long jmpi_jit(void) { return (long)jit_jmpi(); }

-SNOBOL C_WRAPPER_PROTO('JMPI_JIT()LONG', .EMBED)

static void callr_jit(int r) { jit_callr(r); }

-SNOBOL C_WRAPPER_PROTO('CALLR_JIT(INTEGER)', .EMBED)

static void calli_jit(void) { set_p_(jit_calli(get_p_())); }

-SNOBOL C_WRAPPER_PROTO('CAllI_JIT()', .EMBED)

static void finishr_jit(int r) { jit_finishr(r); }

-SNOBOL C_WRAPPER_PROTO('FINISHR_JIT(INTEGER)', .EMBED)

static void finishi_jit(void) { set_p_(jit_finishi(get_p_())); }

-SNOBOL C_WRAPPER_PROTO('FINISHI_JIT()', .EMBED)

static void ret_jit(void) { jit_ret(); }

-SNOBOL C_WRAPPER_PROTO('RET_JIT()', .EMBED)

static void reti_jit(void) { jit_reti((jit_word_t)get_p_()); }

-SNOBOL C_WRAPPER_PROTO('RETI_JIT()', .EMBED)

static void reti_f_jit(void) { jit_reti_f(get_f_()); }

-SNOBOL C_WRAPPER_PROTO('RETI_F_JIT()', .EMBED)

static void reti_d_jit(void) { jit_reti_d(get_d_()); }

-SNOBOL C_WRAPPER_PROTO('RETI_D_JIT()', .EMBED)

-END
@

<<JIT>>=
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(jit) :F(ERROR) ;
-SNOBOL LIBS = ' -L. -lp64 -llightning'
-SNOBOL OBJECTS = jit ; OBJECTS '.c' = '.o'
-SNOBOL LINK_DYNAMIC('./jit', OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS jit.so
-CMNT -SNOBOL  A = CRACK(jit ' ' OBJECTS, ' ')
-CMNT -SNOBOL  SEQ(' DELETE(A<K>) ', .K)
@

<<JIT>>=
         LOAD('INIT_JIT(STRING)', 'jit.so')
         LOAD('R_NUM_JIT()INTEGER', 'jit.so')
         LOAD('V_NUM_JIT()INTEGER', 'jit.so')
         LOAD('F_NUM_JIT()INTEGER', 'jit.so')
         LOAD('FINISH_JIT()', 'jit.so')
*
         LOAD('GET_STATE_JIT()INTEGER', 'jit.so')
         LOAD('SET_STATE_JIT(INTEGER)', 'jit.so')
         LOAD('NEW_STATE_JIT()INTEGER', 'jit.so')
         LOAD('DESTROY_STATE_JIT()', 'jit.so')
         LOAD('CLEAR_STATE_JIT()', 'jit.so')
*
         LOAD('PROLOG_JIT()', 'jit.so')
         LOAD('EPILOG_JIT()', 'jit.so')
         LOAD('NOTE_JIT(STRING,INTEGER)INTEGER', 'jit.so')
         LOAD('NAME_JIT(STRING)INTEGER', 'jit.so')
         LOAD('ADDRESS_JIT(INTEGER)INTEGER', 'jit.so')
         LOAD('DISASSEMBLE_JIT()', 'jit.so')
         LOAD('EMIT_JIT()INTEGER', 'jit.so')
         LOAD('PRINT_JIT()', 'jit.so')
         LOAD('LABEL_JIT()INTEGER', 'jit.so')
         LOAD('ELLIPSIS_JIT()', 'jit.so')
*        LOAD('GET_NOTE_JIT()INTEGER', 'jit.so')
         LOAD('POINTER_P_JIT()', 'jit.so')
         LOAD('CALLEE_SAVE_P_JIT(INTEGER)', 'jit.so')
         LOAD('PATCH_AT_JIT()', 'jit.so')
         LOAD('PATCH_ABS_JIT()', 'jit.so')
         LOAD('PATCH_JIT()', 'jit.so')
         LOAD('PREPARE_JIT()', 'jit.so')
         LOAD('ALLOCAI_JIT(INTEGER)INTEGER', 'jit.so')
         LOAD('DATA_JIT(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
         LOAD('FORWARD_JIT()INTEGER', 'jit.so')
         LOAD('LIVE_JIT(INTEGER)', 'jit.so')
         LOAD('LINK_JIT()', 'jit.so')
*
* WE DO R0..R3, V0..V3, F0..F7 AND FP, EVEN THOUGH NOT ALL OF THESE
* REGISTERS MAY EXIST. THE ONES THAT DON'T WILL BE -1. USE JIT_R_NUM(),
* JIT_V_NUM() AND JIT_F_NUM() TO DETERMINE THE ACTUAL NUMBER OF
* REGISTERS. NOTE THAT WORST CASE, R0..R2, V0..V2 AND F0..F5 ARE
* USABLE.
*
         L = 'R0 R1 R2 R3 V0 V1 V2 V3 F0 F1 F2 F3 F4 F5 F6 F7 FP'
         A = CRACK(L, ' ')
         SEQ(" LOAD('GET_' A<I> '_JIT()INTEGER', 'jit.so'); "
+            " $('JIT_' A<I>) = EVAL('GET_' A<I> '_JIT()') ", .I)
*
         L = 'ADDR ADDCR ADDXR SUBR SUBCR SUBXR MULR DIVR DIVR_U '
+            'REMR REMR_U ANDR ORR XORR LSHR RSHR RSHR_U '
+            'LTR LTR_U LER LER_U GER GER_U GTR GTR_U EQR NER '
+            'ADDR_F ADDR_D SUBR_F SUBR_D MULR_F MULR_D DIVR_F DIVR_D '
+            'LTR_F LER_F EQR_F GER_F GTR_F NER_F UNLTR_F UNLER_F '
+            'UNEQR_F UNGER_F UNGTR_F LTGTR_F ORDR_F UNORDR_F '
+            'LTR_D LER_D EQR_D GER_D GTR_D NER_D UNLTR_D UNLER_D '
+            'UNEQR_D UNGER_D UNGTR_D LTGTR_D ORDR_D UNORDR_D '
+            'LDXR_C LDXR_UC LDXR_S LDXR_US LDXR_I LDXR_UI LDXR_L '
+            'LDXR LDXR_F LDXR_D '
+            'STXR_C STXR_S STXR_I STXR STXR_L STXR_F STXR_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'ADDI ADDCI ADDXI SUBI SUBCI SUBXI MULI DIVI DIVI_U '
+            'REMI REMI_U ANDI ORI XORI LSHI RSHI RSHI_U '
+            'LTI LTI_U LEI LEI_U GEI GEI_U GTI GTI_U EQI NEI '
+            'ADDI_F SUBI_F MULI_F DIVI_F '
+            'ADDI_D SUBI_D MULI_D DIVI_D '
+            'LDXI_C LDXI_UC LDXI_S LDXI_US LDXI_I LDXI_UI LDXI_L LDXI '
+            'LDXI_F LDXI_D '
+            'STXI_C STXI_S STXI_I STXI_L STXI STXI_F STXI_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'BLTR BLTR_U BLER BLER_U BGTR BGTR_U BGER BGER_U '
+            'BEQR BNER BMSR BMCR BOADDR BXADDR BOSUBR BXSUBR' 
+            'BOADDR_U BXADDR_U BOSUBR_U BXSUBR_U '
+            'BLTR_F BLER_F BGTR_F BGER_F BEQR_F BNER_R '
+            'BUNLTR_F BUNLER_F BUNEQR_F BUNGER_F BUNGTR_F '
+            'BLTGTR_F BORDR_F BUNORDR_F ' 
+            'BLTR_D BLER_D BGTR_D BGER_D BEQR_D BNER_D '
+            'BUNLTR_D BUNLER_D BUNEQR_D BUNGER_D BUNGTR_D '
+            'BLTGTR_D BORDR_D BUNORDR_D ' 
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'MOVR MOVR_F MOVR_D MOVR_F_W MOVR_W_F MOVR_D_W MOVR_W_D '
+            'HTONR NTOHR COMR NEGR NEGR_F NEGR_D ABSR_F ABSR_D '
+            'SQRTR_F SQRTR_D '
+            'EXTR_C EXTR_UC EXTR_S EXTR_US EXTR_I EXTR_UI '
+            'EXTR_F EXTR_D_F EXTR_D EXTR_F_D '
+            'TRUNCR_F_I TRUNCR_F TRUNCR_F_L TRUNCR_D_I TRUNCR_D '
+            'TRUNCR_D_L '
+            'LDR_C LDR_UC LDR_S LDR_US LDR_I LDR LDR_UI LDR_L '
+            'LDR_F LDR_D '
+            'STR_C STR_S STR_I STR STR_L STR_F STR_D'
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'MOVR_D_WW MOVR_WW_D'
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         LOAD('MOVI_JIT(INTEGER)INTEGER', 'jit.so')
         LOAD('MOVI_F_JIT(INTEGER)', 'jit.so')
         LOAD('MOVI_D_JIT(INTEGER)', 'jit.so')
         LOAD('MOVI_F_W_JIT(INTEGER,INTEGER)', 'jit.so')
         LOAD('MOVI_D_W_JIT(INTEGER,INTEGER)', 'jit.so')
         LOAD('MOVI_D_WW_JIT(INTEGER,INTEGER)', 'jit.so')
*
         L = 'ARG ARG_F ARG_D'
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT()', 'jit.so') ", .I)
*
         L = 'GETARG GETARG_C GETARG_UC GETARG_S GETARG_US GETARG_I '
+            'GETARG_UI GETARG_L GETARG_F GETARG_D '
+            'LDI_C LDI_UC LDI_S LDI_US LDI_I LDI LDI_UI LDI_L LDI_F '
+            'LDI_D STI_C STI_S STI_I STI STI_L STI_F STI_D '
+            'BLTI BLTI_U BLEI BLEI_U BEQI BGEI BGEI_U BGTI BGTI_U '
+            'BNEI BMSI BMCI BOADDI BOADDI_U BXADDI BXADDI_U '
+            'BOSUBI BOSUBI_U BXSUBI BXSUBI_U '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER)', 'jit.so') ", .I)
*
         L = 'PUSHARGR PUSHARGR_F PUSHARGR_D '
+            'RETR RETVAL_C RETVAL_UC RETVAL_S RETVAL_US RETVAL_I '
+            'RETVAL RETVAL_UI RETVAL_L RETR_F RETVAL_F '
+            'RETR_D RETVAL_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER)', 'jit.so') ", .I)
         LOAD('PUSHARGI_JIT()', 'jit.so')
         LOAD('PUSHARGI_F_JIT()', 'jit.so')
         LOAD('PUSHARGI_D_JIT()', 'jit.so')
*
         LOAD('JMPR_JIT(INTEGER)', 'jit.so')
         LOAD('JMPI_JIT()INTEGER', 'jit.so')
*
         LOAD('CALLR_JIT(INTEGER)', 'jit.so')
         LOAD('CALLI_JIT()', 'jit.so')
*
         LOAD('FINISHR_JIT(INTEGER)', 'jit.so')
         LOAD('FINISHI_JIT()', 'jit.so')
*
         LOAD('RET_JIT()', 'jit.so')
         LOAD('RETI_JIT()', 'jit.so')
         LOAD('RETI_F_JIT()', 'jit.so')
         LOAD('RETI_D_JIT()', 'jit.so')
*
* PROXY FUNCTIONS TO HIDE SET_P()/GET_P(). THESE ARE SHORT FUNCTIONS (1
* OR 2 LINES). USE THESE FUNCTIONS TO USE JIT, RATHER THAN THE ..._JIT
* FUNCTIONS. THESE FUNCTIONS TAKE CARE OF ANY INT/POINTER ISSUES,
* WHEREAS USING THE UNDERLYING FUNCTIONS WILL NOT, AND THE CODE WILL BE
* NOT BE PORTABLE.
*
JIT_DEFINE
*
-PUBLIC JIT_R_NUM(), JIT_V_NUM(), JIT_FNUM()
         DEFINE('JIT_R_NUM()')
         DEFINE('JIT_V_NUM()')
         DEFINE('JIT_F_NUM()')
-PUBLIC JIT_ARG(), JIT_ARG_F(), JIT_ARG_D()
         DEFINE('JIT_ARG()')
         DEFINE('JIT_ARG_F()')
         DEFINE('JIT_ARG_D()')
-PUBLIC JIT_RET(), JIT_RETI(), JIT_RETI_F(), JIT_RETI_D()
         DEFINE('JIT_RET()')
         DEFINE('JIT_RETI(P)')
         DEFINE('JIT_RETI_F(F)')
         DEFINE('JIT_RETI_D(D)')
-PUBLIC JIT_FINISHR(), JIT_FINISHI(), JIT_INIT(), JIT_FINISH()
         DEFINE('JIT_FINISHR(R)')
         DEFINE('JIT_FINISHI(P)')
         DEFINE('JIT_INIT(S)')
         DEFINE('JIT_FINISH()')
-PUBLIC JIT_MOVI(), JIT_MOVI_F(), JIT_MOVI_D()
         DEFINE('JIT_MOVI(R,P)')
         DEFINE('JIT_MOVI_F(R,F)')
         DEFINE('JIT_MOVI_D(R,D)')
-PUBLIC JIT_GETARG(), JIT_GETARG_C(), JIT_GETARG_UC(), JIT_GETARG_S()
-PUBLIC JIT_GETARG_US(), JIT_GETARG_I(), JIT_GETARG_UI(), JIT_GETARG_L()
-PUBLIC JIT_GETARG_F(), JIT_GETARG_D()
         DEFINE('JIT_GETARG(R,A)')
         DEFINE('JIT_GETARG_C(R,A)')
         DEFINE('JIT_GETARG_UC(R,A)')
         DEFINE('JIT_GETARG_S(R,A)')
         DEFINE('JIT_GETARG_US(R,A)')
         DEFINE('JIT_GETARG_I(R,A)')
         DEFINE('JIT_GETARG_UI(R,A)')
         DEFINE('JIT_GETARG_L(R,A)')
         DEFINE('JIT_GETARG_F(R,A)')
         DEFINE('JIT_GETARG_D(R,A)')
-PUBLIC JIT_PROLOG(), JIT_EPILOG(), JIT_PRINT(), JIT_DISASSEMBLE()
-PUBLIC JIT_LABEL(), JIT_ELLIPSIS(), JIT_EMIT(), JIT_ADDRESS()
         DEFINE('JIT_PROLOG()')
         DEFINE('JIT_EPILOG()')
         DEFINE('JIT_PRINT()')
         DEFINE('JIT_DISASSEMBLE()')
         DEFINE('JIT_LABEL()')
         DEFINE('JIT_ELLIPSIS()')
         DEFINE('JIT_EMIT()')
         DEFINE('JIT_ADDRESS(P)')
-PUBLIC JIT_RETR(), JIT_RETR_F(), JIT_RETR_D()
         DEFINE('JIT_RETR(R)')
         DEFINE('JIT_RETR_F(R)')
         DEFINE('JIT_RETR_D(R)')
-PUBLIC JIT_GETSTATE(), JIT_SET_STATE(), JIT_NEW_STATE()
-PUBLIC JIT_DESTROY_STATE(), JIT_CLEAR_STATE()
         DEFINE('JIT_GET_STATE()')
         DEFINE('JIT_SET_STATE(JIT)')
         DEFINE('JIT_NEW_STATE()')
         DEFINE('JIT_DESTROY_STATE()')
         DEFINE('JIT_CLEAR_STATE()')
-PUBLIC JIT_JMPR(), JIT_JMPI()
         DEFINE('JIT_JMPR(R)')
         DEFINE('JIT_JMPI(P)')
-PUBLIC JIT_CALLR(), JIT_CALLI()
         DEFINE('JIT_CALLR(R)')
         DEFINE('JIT_CALLI(P)')
-PUBLIC JIT_NOTE(), JIT_NAME(), JIT_PREPARE(), JIT_ALLOCAI()
         DEFINE('JIT_NOTE(S,N)')
         DEFINE('JIT_NAME(S)')
         DEFINE('JIT_PREPARE()')
         DEFINE('JIT_ALLOCAI(N)')
-PUBLIC JIT_PATCH_AT, JIT_PATCH_ABS(), JIT_PATCH()
         DEFINE('JIT_PATCH_AT(P,P2)')
         DEFINE('JIT_PATCH_ABS(P,P2)')
         DEFINE('JIT_PATCH(P)')
-PUBLIC JIT_ADDR(), JIT_ADDCR(), JIT_ADDXR()
         DEFINE('JIT_ADDR(R1,R2,R3)')
         DEFINE('JIT_ADDCR(R1,R2,R3)')
         DEFINE('JIT_ADDXR(R1,R2,R3)')
-PUBLIC JIT_SUBR(), JIT_SUBCR(), JIT_SUBXR()
         DEFINE('JIT_SUBR(R1,R2,R3)')
         DEFINE('JIT_SUBCR(R1,R2,R3)')
         DEFINE('JIT_SUBXR(R1,R2,R3)')
-PUBLIC JIT_MULR(), JIT_DIVR(), JIT_DIVR_U(), JIT_REMR(), JIT_REMR_U()
         DEFINE('JIT_MULR(R1,R2,R3)')
         DEFINE('JIT_DIVR(R1,R2,R3)')
         DEFINE('JIT_DIVR_U(R1,R2,R3)')
         DEFINE('JIT_REMR(R1,R2,R3)')
         DEFINE('JIT_REMR_U(R1,R2,R3)')
-PUBLIC JIT_ANDR(), JIT_ORR(), JIT_XORR(), JIT_LSHR(), JIT_RSHR()
-PUBLIC JIT_RSHR_U()
         DEFINE('JIT_ANDR(R1,R2,R3)')
         DEFINE('JIT_ORR(R1,R2,R3)')
         DEFINE('JIT_XORR(R1,R2,R3)')
         DEFINE('JIT_LSHR(R1,R2,R3)')
         DEFINE('JIT_RSHR(R1,R2,R3)')
         DEFINE('JIT_RSHR_U(R1,R2,R3)')
-PUBLIC JIT_LTR(), JIT_LTR_U()
         DEFINE('JIT_LTR(R1,R2,R3)')
         DEFINE('JIT_LTR_U(R1,R2,R3)')
-PUBLIC JIT_LER(), JIT_LER_U()
         DEFINE('JIT_LER(R1,R2,R3)')
         DEFINE('JIT_LER_U(R1,R2,R3)')
-PUBLIC JIT_GER(), JIT_GER_U()
         DEFINE('JIT_GER(R1,R2,R3)')
         DEFINE('JIT_GER_U(R1,R2,R3)')
-PUBLIC JIT_GTR(), GTR_U()
         DEFINE('JIT_GTR(R1,R2,R3)')
         DEFINE('JIT_GTR_U(R1,R2,R3)')
-PUBLIC JIT_EQR(), JIT_NER()
         DEFINE('JIT_EQR(R1,R2,R3)')
         DEFINE('JIT_NER(R1,R2,R3)')
-PUBLIC JIT_ADDR_F(), JIT_ADDR_D()
         DEFINE('JIT_ADDR_F(R1,R2,R3)')
         DEFINE('JIT_ADDR_D(R1,R2,R3)')
-PUBLIC JIT_SUBR_F(), JIT_SUBR_D()
         DEFINE('JIT_SUBR_F(R1,R2,R3)')
         DEFINE('JIT_SUBR_D(R1,R2,R3)')
-PUBLIC JIT_MULR_F(), JIT_MULR_D()
         DEFINE('JIT_MULR_F(R1,R2,R3)')
         DEFINE('JIT_MULR_D(R1,R2,R3)')
-PUBLIC JIT_DIVR_F(), JIT_DIVR_D()
         DEFINE('JIT_DIVR_F(R1,R2,R3)')
         DEFINE('JIT_DIVR_D(R1,R2,R3)')
-PUBLIC JIT_LTR_F(), JIT_LER_F(), JIT_EQR_F(), JIT_GER_F(), JIT_GTR_F()
-PUBLIC JIT_NER_F()
         DEFINE('JIT_LTR_F(R1,R2,R3)')
         DEFINE('JIT_LER_F(R1,R2,R3)')
         DEFINE('JIT_EQR_F(R1,R2,R3)')
         DEFINE('JIT_GER_F(R1,R2,R3)')
         DEFINE('JIT_GTR_F(R1,R2,R3)')
         DEFINE('JIT_NER_F(R1,R2,R3)')
-PUBLIC JIT_UNLTR_F(), JIT_UNLER_F(), JIT_UNEQR_F(), JIT_UNGER_F()
-PUBLIC JIT_UNGTR_F(), JIT_LTGTR_F(), JIT_ORDR_F(), JIT_UNORDR_F()
         DEFINE('JIT_UNLTR_F(R1,R2,R3)')
         DEFINE('JIT_UNLER_F(R1,R2,R3)')
         DEFINE('JIT_UNEQR_F(R1,R2,R3)')
         DEFINE('JIT_UNGER_F(R1,R2,R3)')
         DEFINE('JIT_UNGTR_F(R1,R2,R3)')
         DEFINE('JIT_LTGTR_F(R1,R2,R3)')
         DEFINE('JIT_ORDR_F(R1,R2,R3)')
         DEFINE('JIT_UNORDR_F(R1,R2,R3)')
-PUBLIC JIT_LTR_D(), JIT_LER_D(), JIT_EQR_D(), JIT_GER_D(), JIT_GTR_D()
-PUBLIC JIT_NER_D()
-PUBLIC JIT_UNLTR_D(), JIT_UNLER_D(), JIT_UNEQR_D(), JIT_UNGER_D()
-PUBLIC JIT_UNGTR_D(), JIT_LTGTR_D(), JIT_ORDR_D(), JIT_UNORDR_D(),
         DEFINE('JIT_LTR_D(R1,R2,R3)')
         DEFINE('JIT_LER_D(R1,R2,R3)')
         DEFINE('JIT_EQR_D(R1,R2,R3)')
         DEFINE('JIT_GER_D(R1,R2,R3)')
         DEFINE('JIT_GTR_D(R1,R2,R3)')
         DEFINE('JIT_NER_D(R1,R2,R3)')
         DEFINE('JIT_UNLTR_D(R1,R2,R3)')
         DEFINE('JIT_UNLER_D(R1,R2,R3)')
         DEFINE('JIT_UNEQR_D(R1,R2,R3)')
         DEFINE('JIT_UNGER_D(R1,R2,R3)')
         DEFINE('JIT_UNGTR_D(R1,R2,R3)')
         DEFINE('JIT_LTGTR_D(R1,R2,R3)')
         DEFINE('JIT_ORDR_D(R1,R2,R3)')
         DEFINE('JIT_UNORDR_D(R1,R2,R3)')
-PUBLIC JIT_LDXR_C(), JIT_LDXR_UC(), JIT_LDXR_S(), JIT_LDXR_US()
-PUBLIC JIT_LDXR_I(), JIT_LDXR_UI(), JIT_LDXR_L(), JIT_LDXR()
-PUBLIC JIT_LDXR_F(), JIT_LDXR_D()
         DEFINE('JIT_LDXR_C(R1,R2,R3)')
         DEFINE('JIT_LDXR_UC(R1,R2,R3)')
         DEFINE('JIT_LDXR_S(R1,R2,R3)')
         DEFINE('JIT_LDXR_US(R1,R2,R3)')
         DEFINE('JIT_LDXR_I(R1,R2,R3)')
         DEFINE('JIT_LDXR_UI(R1,R2,R3)')
         DEFINE('JIT_LDXR_L(R1,R2,R3)')
         DEFINE('JIT_LDXR(R1,R2,R3)')
         DEFINE('JIT_LDXR_F(R1,R2,R3)')
         DEFINE('JIT_LDXR_D(R1,R2,R3)')
-PUBLIC JIT_STXR_C(), JIT_STXR_S(), JIT_STXR_I(), JIT_STXR()
-PUBLIC JIT_STXR_L(), JIT_STXR_F(), JIT_STXR_D()
         DEFINE('JIT_STXR_C(R1,R2,R3)')
         DEFINE('JIT_STXR_S(R1,R2,R3)')
         DEFINE('JIT_STXR_I(R1,R2,R3)')
         DEFINE('JIT_STXR(R1,R2,R3)')
         DEFINE('JIT_STXR_L(R1,R2,R3)')
         DEFINE('JIT_STXR_F(R1,R2,R3)')
         DEFINE('JIT_STXR_D(R1,R2,R3)')
-PUBLIC JIT_BLTR(), JIT_BLTR_U(), JIT_BLER(), JIT_BLER_U()
         DEFINE('JIT_BLTR(R1,R2)')
         DEFINE('JIT_BLTR_U(R1,R2)')
         DEFINE('JIT_BLER(R1,R2)')
         DEFINE('JIT_BLER_U(R1,R2)')
-PUBLIC JIT_BGTR(), JIT_BGTR_U(), JIT_BGER(), JIT_BGER_U()
         DEFINE('JIT_BGTR(R1,R2)')
         DEFINE('JIT_BGTR_U(R1,R2)')
         DEFINE('JIT_BGER(R1,R2)')
         DEFINE('JIT_BGER_U(R1,R2)')
-PUBLIC JIT_BEQR(), JIT_BNER(), JIT_BMSR(), JIT_BMCR()
         DEFINE('JIT_BEQR(R1,R2)')
         DEFINE('JIT_BNER(R1,R2)')
         DEFINE('JIT_BMSR(R1,R2)')
         DEFINE('JIT_BMCR(R1,R2)')
-PUBLIC JIT_BOADDR(), JIT_BXADDR(), JIT_BOSUBR(), JIT_BXSUBR()
         DEFINE('JIT_BOADDR(R1,R2)')
         DEFINE('JIT_BXADDR(R1,R2)')
         DEFINE('JIT_BOSUBR(R1,R2)')
         DEFINE('JIT_BXSUBR(R1,R2)')
-PUBLIC JIT_BOADDR_U(), JIT_BXADDR_U(), JIT_BOSUBR_U(), JIT_BXSUBR_U()
         DEFINE('JIT_BOADDR_U(R1,R2)')
         DEFINE('JIT_BXADDR_U(R1,R2)')
         DEFINE('JIT_BOSUBR_U(R1,R2)')
         DEFINE('JIT_BXSUBR_U(R1,R2)')
-PUBLIC JIT_BLTR_F(), JIT_BLER_F(), JIT_BGTR_F(), JIT_BGER_F()
-PUBLIC JIT_BEQR_F(), JIT_BNER_R()
         DEFINE('JIT_BLTR_F(R1,R2)')
         DEFINE('JIT_BLER_F(R1,R2)')
         DEFINE('JIT_BGTR_F(R1,R2)')
         DEFINE('JIT_BGER_F(R1,R2)')
         DEFINE('JIT_BEQR_F(R1,R2)')
         DEFINE('JIT_BNER_R(R1,R2)')
-PUBLIC JIT_BUNLTR_F(), JIT_BUNLER_F(), JIT_BUNEQR_F()
-PUBLIC JIT_BUNGER_F(), JIT_BUNGTR_F(), JIT_BLTGTR_F()
         DEFINE('JIT_BUNLTR_F(R1,R2)')
         DEFINE('JIT_BUNLER_F(R1,R2)')
         DEFINE('JIT_BUNEQR_F(R1,R2)')
         DEFINE('JIT_BUNGER_F(R1,R2)')
         DEFINE('JIT_BUNGTR_F(R1,R2)')
         DEFINE('JIT_BLTGTR_F(R1,R2)')
-PUBLIC JIT_BORDR_F(), JIT_BUNORDR_F()
         DEFINE('JIT_BORDR_F(R1,R2)')
         DEFINE('JIT_BUNORDR_F(R1,R2)')
-PUBLIC JIT_BLTR_D(), JIT_BLER_D(), JIT_BGTR_D(), JIT_BGER_D()
-PUBLIC JIT_BEQR_D(), JIT_BNER_D()
         DEFINE('JIT_BLTR_D(R1,R2)')
         DEFINE('JIT_BLER_D(R1,R2)')
         DEFINE('JIT_BGTR_D(R1,R2)')
         DEFINE('JIT_BGER_D(R1,R2)')
         DEFINE('JIT_BEQR_D(R1,R2)')
         DEFINE('JIT_BNER_D(R1,R2)')
-PUBLIC JIT_BUNLTR_D(), JIT_BUNLER_D(), JIT_BUNEQR_D()
         DEFINE('JIT_BUNLTR_D(R1,R2)')
         DEFINE('JIT_BUNLER_D(R1,R2)')
         DEFINE('JIT_BUNEQR_D(R1,R2)')
-PUBLIC JIT_BUNGER_D(), JIT_BUNGTR_D(), JIT_BLTGTR_D()
         DEFINE('JIT_BUNGER_D(R1,R2)')
         DEFINE('JIT_BUNGTR_D(R1,R2)')
         DEFINE('JIT_BLTGTR_D(R1,R2)')
-PUBLIC JIT_BORDR_D(), JIT_BUNORDR_D()
         DEFINE('JIT_BORDR_D(R1,R2)')
         DEFINE('JIT_BUNORDR_D(R1,R2)')
-PUBLIC JIT_ADDI(), JIT_ADDCI(), JIT_ADDXI()
         DEFINE('JIT_ADDI(R1,R2,P)')
         DEFINE('JIT_ADDCI(R1,R2,P)')
         DEFINE('JIT_ADDXI(R1,R2,P)')
-PUBLIC JIT_SUBI(), JIT_SUBCI(), JIT_SUBXI()
         DEFINE('JIT_SUBI(R1,R2,P)')
         DEFINE('JIT_SUBCI(R1,R2,P)')
         DEFINE('JIT_SUBXI(R1,R2,P)')
-PUBLIC JIT_MULI(), JIT_DIVI(), JIT_DIVI_U(), JIT_REMI(), JIT_REMI_U()
         DEFINE('JIT_MULI(R1,R2,P)')
         DEFINE('JIT_DIVI(R1,R2,P)')
         DEFINE('JIT_DIVI_U(R1,R2,P)')
         DEFINE('JIT_REMI(R1,R2,P)')
         DEFINE('JIT_REMI_U(R1,R2,P)')
-PUBLIC JIT_ANDI(), JIT_ORI(), JIT_XORI(), JIT_LSHI()
-PUBLIC JIT_RSHI(), JIT_RSHI_U(), 
         DEFINE('JIT_ANDI(R1,R2,P)')
         DEFINE('JIT_ORI(R1,R2,P)')
         DEFINE('JIT_XORI(R1,R2,P)')
         DEFINE('JIT_LSHI(R1,R2,P)')
         DEFINE('JIT_RSHI(R1,R2,P)')
         DEFINE('JIT_RSHI_U(R1,R2,P)')
-PUBLIC JIT_LTI(), JIT_LTI_U(), JIT_LEI(), JIT_LEI_U()
         DEFINE('JIT_LTI(R1,R2,P)')
         DEFINE('JIT_LTI_U(R1,R2,P)')
         DEFINE('JIT_LEI(R1,R2,P)')
         DEFINE('JIT_LEI_U(R1,R2,P)')
-PUBLIC JIT_GEI(), JIT_GEI_U(), JIT_GTI(), JIT_GTI_U()
         DEFINE('JIT_GEI(R1,R2,P)')
         DEFINE('JIT_GEI_U(R1,R2,P)')
         DEFINE('JIT_GTI(R1,R2,P)')
         DEFINE('JIT_GTI_U(R1,R2,P)')
-PUBLIC JIT_EQI(), JIT_NEI()
         DEFINE('JIT_EQI(R1,R2,P)')
         DEFINE('JIT_NEI(R1,R2,P)')
-PUBLIC JIT_LDXI_C(), JIT_LDXI_UC(), JIT_LDXI_S(), JIT_LDXI_US()
         DEFINE('JIT_LDXI_C(R1,R2,P)')
         DEFINE('JIT_LDXI_UC(R1,R2,P)')
         DEFINE('JIT_LDXI_S(R1,R2,P)')
         DEFINE('JIT_LDXI_US(R1,R2,P)')
-PUBLIC JIT_LDXI_I(), JIT_LDXI_UI(), JIT_LDXI_L()
         DEFINE('JIT_LDXI_I(R1,R2,P)')
         DEFINE('JIT_LDXI_UI(R1,R2,P)')
         DEFINE('JIT_LDXI_L(R1,R2,P)')
-PUBLIC JIT_LDXI(), JIT_LDXI_F(), JIT_LDXI_D()
         DEFINE('JIT_LDXI(R1,R2,P)')
         DEFINE('JIT_LDXI_F(R1,R2,P)')
         DEFINE('JIT_LDXI_D(R1,R2,P)')
-PUBLIC JIT_STXI_C(), JIT_STXI_S(), JIT_STXI_I()
         DEFINE('JIT_STXI_C(R1,P,R2)')
         DEFINE('JIT_STXI_S(R1,P,R2)')
         DEFINE('JIT_STXI_I(R1,P,R2)')
-PUBLIC JIT_STXI_L(), JIT_STXI(), JIT_STXI_F(), JIT_STXI_D()
         DEFINE('JIT_STXI_L(R1,P,R2)')
         DEFINE('JIT_STXI(R1,P,R2)')
         DEFINE('JIT_STXI_F(R1,P,R2)')
         DEFINE('JIT_STXI_D(R1,P,R2)')
-PUBLIC JIT_ADDI_F(), JIT_SUBI_F(), JIT_MULI_F(), JIT_DIVI_F()
         DEFINE('JIT_ADDI_F(R1,R2,F)')
         DEFINE('JIT_SUBI_F(R1,R2,F)')
         DEFINE('JIT_MULI_F(R1,R2,F)')
         DEFINE('JIT_DIVI_F(R1,R2,F)')
-PUBLIC JIT_ADDI_D(), JIT_SUBI_D(), JIT_MULI_D(), JIT_DIVI_D()
         DEFINE('JIT_ADDI_D(R1,R2,D)')
         DEFINE('JIT_SUBI_D(R1,R2,D)')
         DEFINE('JIT_MULI_D(R1,R2,D)')
         DEFINE('JIT_DIVI_D(R1,R2,D)')
-PUBLIC JIT_MOVR(), JIT_MOVR_F(), JIT_MOVR_D()
         DEFINE('JIT_MOVR(R1,R2)')
         DEFINE('JIT_MOVR_F(R1,R2)')
         DEFINE('JIT_MOVR_D(R1,R2)')
-PUBLIC JIT_HTONR(), JIT_NTOHR()
         DEFINE('JIT_HTONR(R1,R2)')
         DEFINE('JIT_NTOHR(R1,R2)')
-PUBLIC JIT_COMR()
         DEFINE('JIT_COMR(R1,R2)')
-PUBLIC JIT_NEGR(), JIT_NEGR_F(), JIT_NEGR_D()
         DEFINE('JIT_NEGR(R1,R2)')
         DEFINE('JIT_NEGR_F(R1,R2)')
         DEFINE('JIT_NEGR_D(R1,R2)')
-PUBLIC JIT_ABSR_F(), JIT_ABSR_D()
         DEFINE('JIT_ABSR_F(R1,R2)')
         DEFINE('JIT_ABSR_D(R1,R2)')
-PUBLIC JIT_SQRTR_F(), JIT_SQRTR_D()
         DEFINE('JIT_SQRTR_F(R1,R2)')
         DEFINE('JIT_SQRTR_D(R1,R2)')
-PUBLIC JIT_EXTR_C(), JIT_EXTR_UC(), JIT_EXTR_S(), JIT_EXTR_US()
         DEFINE('JIT_EXTR_C(R1,R2)')
         DEFINE('JIT_EXTR_UC(R1,R2)')
         DEFINE('JIT_EXTR_S(R1,R2)')
         DEFINE('JIT_EXTR_US(R1,R2)')
-PUBLIC JIT_EXTR_I(), JIT_EXTR_UI(), JIT_EXTR_F(), JIT_EXTR_D_F()
         DEFINE('JIT_EXTR_I(R1,R2)')
         DEFINE('JIT_EXTR_UI(R1,R2)')
         DEFINE('JIT_EXTR_F(R1,R2)')
         DEFINE('JIT_EXTR_D_F(R1,R2)')
-PUBLIC JIT_EXTR_D(), JIT_EXTR_F_D()
         DEFINE('JIT_EXTR_D(R1,R2)')
         DEFINE('JIT_EXTR_F_D(R1,R2)')
-PUBLIC JIT_TRUNCR_F_I(), JIT_TRUNCR_F(), JIT_TRUNCR_F_L()
-PUBLIC JIT_TRUNCR_D_I(), JIT_TRUNCR_D(), JIT_TRUNCR_D_L()
         DEFINE('JIT_TRUNCR_F_I(R1,R2)')
         DEFINE('JIT_TRUNCR_F(R1,R2)')
         DEFINE('JIT_TRUNCR_F_L(R1,R2)')
         DEFINE('JIT_TRUNCR_D_I(R1,R2)')
         DEFINE('JIT_TRUNCR_D(R1,R2)')
         DEFINE('JIT_TRUNCR_D_L(R1,R2)')
-PUBLIC JIT_LDR_C(), JIT_LDR_UC(), JIT_LDR_S(), JIT_LDR_US()
         DEFINE('JIT_LDR_C(R1,R2)')
         DEFINE('JIT_LDR_UC(R1,R2)')
         DEFINE('JIT_LDR_S(R1,R2)')
         DEFINE('JIT_LDR_US(R1,R2)')
-PUBLIC JIT_LDR_I(), JIT_LDR(), JIT_LDR_UI(), JIT_LDR_L() 
         DEFINE('JIT_LDR_I(R1,R2)')
         DEFINE('JIT_LDR(R1,R2)')
         DEFINE('JIT_LDR_UI(R1,R2)')
         DEFINE('JIT_LDR_L(R1,R2)')
-PUBLIC JIT_LDR_F(), JIT_LDR_D()
         DEFINE('JIT_LDR_F(R1,R2)')
         DEFINE('JIT_LDR_D(R1,R2)')
-PUBLIC JIT_STR_C(), JIT_STR_S(), JIT_STR_I(), JIT_STR()
         DEFINE('JIT_STR_C(R1,R2)')
         DEFINE('JIT_STR_S(R1,R2)')
         DEFINE('JIT_STR_I(R1,R2)')
         DEFINE('JIT_STR(R1,R2)')
-PUBLIC JIT_STR_L(), JIT_STR_F(), JIT_STR_D()
         DEFINE('JIT_STR_L(R1,R2)')
         DEFINE('JIT_STR_F(R1,R2)')
         DEFINE('JIT_STR_D(R1,R2)')
-PUBLIC JIT_LDI_C(), JIT_LDI_UC(), JIT_LDI_S(), JIT_LDI_US()
         DEFINE('JIT_LDI_C(R,P)')
         DEFINE('JIT_LDI_UC(R,P)')
         DEFINE('JIT_LDI_S(R,P)')
         DEFINE('JIT_LDI_US(R,P)')
-PUBLIC JIT_LDI_I(), JIT_LDI(), JIT_LDI_UI(), JIT_LDI_L()
         DEFINE('JIT_LDI_I(R,P)')
         DEFINE('JIT_LDI(R,P)')
         DEFINE('JIT_LDI_UI(R,P)')
         DEFINE('JIT_LDI_L(R,P)')
-PUBLIC JIT_LDI_F(), JIT_LDI_D()
         DEFINE('JIT_LDI_F(R,P)')
         DEFINE('JIT_LDI_D(R,P)')
-PUBLIC JIT_PUSHARGI(), JIT_PUSHARGI_F(), JIT_PUSHARGI_D()
         DEFINE('JIT_PUSHARGI(P)')
         DEFINE('JIT_PUSHARGI_F(F)')
         DEFINE('JIT_PUSHARGI_D(D)')
-PUBLIC JIT_BLTI(), JIT_BLTI_U(), JIT_BLEI(), JIT_BLEI_U()
         DEFINE('JIT_BLTI(R,P)')
         DEFINE('JIT_BLTI_U(R,P)')
         DEFINE('JIT_BLEI(R,P)')
         DEFINE('JIT_BLEI_U(R,P)')
-PUBLIC JIT_BEQI(), JIT_BGEI(), JIT_BGEI_U(), JIT_BGTI()
         DEFINE('JIT_BEQI(R,P)')
         DEFINE('JIT_BGEI(R,P)')
         DEFINE('JIT_BGEI_U(R,P)')
         DEFINE('JIT_BGTI(R,P)')
-PUBLIC JIT_BGTI_U(), JIT_BNEI(), JIT_BMSI(), JIT_BMCI()
         DEFINE('JIT_BGTI_U(R,P)')
         DEFINE('JIT_BNEI(R,P)')
         DEFINE('JIT_BMSI(R,P)')
         DEFINE('JIT_BMCI(R,P)')
-PUBLIC JIT_BOADDI(), JIT_BOADDI_U(), JIT_BXADDI()
         DEFINE('JIT_BOADDI(R,P)')
         DEFINE('JIT_BOADDI_U(R,P)')
         DEFINE('JIT_BXADDI(R,P)')
-PUBLIC JIT_BXADDI_U(), JIT_BOSUBI(), JIT_BOSUBI_U()
         DEFINE('JIT_BXADDI_U(R,P)')
         DEFINE('JIT_BOSUBI(R,P)')
         DEFINE('JIT_BOSUBI_U(R,P)')
-PUBLIC JIT_BXSUBI(), JIT_BXSUBI_U()
         DEFINE('JIT_BXSUBI(R,P)')
         DEFINE('JIT_BXSUBI_U(R,P)')
-PUBLIC JIT_STI_C(), JIT_STI_S(), JIT_STI_I(), JIT_STI(), JIT_STI_L()
-PUBLIC JIT_STI_F(), JIT_STI_D()
         DEFINE('JIT_STI_C(P,R)')
         DEFINE('JIT_STI_S(P,R)')
         DEFINE('JIT_STI_I(P,R)')
         DEFINE('JIT_STI(P,R)')
         DEFINE('JIT_STI_L(P,R)')
         DEFINE('JIT_STI_F(P,R)')
         DEFINE('JIT_STI_D(P,R)')
-PUBLIC JIT_PUSHARGR(), JIT_PUSHARGR_F(), JIT_PUSHARGR_D()
         DEFINE('JIT_PUSHARGR(R)')
         DEFINE('JIT_PUSHARGR_F(R)')
         DEFINE('JIT_PUSHARGR_D(R)')
-PUBLIC JIT_RETVAL_C(), JIT_RETVAL_UC(), JIT_RETVAL_S(), JIT_RETVAL_US()
-PUBLIC JIT_RETVAL_I(), JIT_RETVAL(), JIT_RETVAL_UI(), JIT_RETVAL_L()
-PUBLIC JIT_RETVAL_F(), JIT_RETVAL_D()
         DEFINE('JIT_RETVAL_C(R)')
         DEFINE('JIT_RETVAL_UC(R)')
         DEFINE('JIT_RETVAL_S(R)')
         DEFINE('JIT_RETVAL_US(R)')
         DEFINE('JIT_RETVAL_I(R)')
         DEFINE('JIT_RETVAL(R)')
         DEFINE('JIT_RETVAL_UI(R)')
         DEFINE('JIT_RETVAL_L(R)')
         DEFINE('JIT_RETVAL_F(R)')
         DEFINE('JIT_RETVAL_D(R)')                            :(JIT_END)
*
JIT_R_NUM
         JIT_R_NUM = R_NUM_JIT()                               :(RETURN)
*
JIT_V_NUM
         JIT_V_NUM = V_NUM_JIT()                               :(RETURN)
*
JIT_F_NUM
         JIT_F_NUM = F_NUM_JIT()                               :(RETURN)
*
JIT_ARG  ARG_JIT()
         JIT_ARG = GET_P()                                     :(RETURN)
*
JIT_ARG_F
         ARG_F_JIT()
         JIT_ARG_F = GET_P()                                   :(RETURN)
*
JIT_ARG_D
         ARG_D_JIT()
         JIT_ARG_D = GET_P()                                   :(RETURN)
*
JIT_RET  RET_JIT()                                             :(RETURN)
*
JIT_RETI SET_P(P)
         RETI_JIT()                                            :(RETURN)
*
JIT_RETI_F
         SET_F(F)
         RETI_F_JIT()                                          :(RETURN)
*
JIT_RETI_D
         SET_D(D)
         RETI_D_JIT()                                          :(RETURN)
*
JIT_FINISHR
         FINISHR_JIT(R)                                        :(RETURN)
*
JIT_FINISHI
         SET_P(P)
         FINISHI_JIT()                                         :(RETURN)
*
JIT_INIT INIT_JIT(S)                                           :(RETURN)
*
JIT_FINISH
         FINISH_JIT()                                          :(RETURN)
*
JIT_MOVI SET_P(P)
         JIT_MOVI = MOVI_JIT(R)                                :(RETURN)
*
JIT_MOVI_F
         SET_F(F)
         MOVI_F_JIT(R)                                         :(RETURN)
*
JIT_MOVI_D(R,D)
         SET_D(D)
         MOVI_D_JIT(R)                                         :(RETURN)
*
JIT_GETARG
         SET_P(A)
         GETARG_JIT(R)                                         :(RETURN)
*
JIT_GETARG_C
         SET_P(A)
         GETARG_C_JIT(R)                                       :(RETURN)
*
JIT_GETARG_UC
         SET_P(A)
         GETARG_UC_JIT(R)                                      :(RETURN)
*
JIT_GETARG_S
         SET_P(A)
         GETARG_S_JIT(R)                                       :(RETURN)
*
JIT_GETARG_US
         SET_P(A)
         GETARG_US_JIT(R)                                      :(RETURN)
*
JIT_GETARG_I
         SET_P(A)
         GETARG_I_JIT(R)                                       :(RETURN)
*
JIT_GETARG_UI
         SET_P(A)
         GETARG_UI_JIT(R)                                      :(RETURN)
*
JIT_GETARG_L
         SET_P(A)
         GETARG_L_JIT(R)                                       :(RETURN)
*
JIT_GETARG_F
         SET_P(A)
         GETARG_F_JIT(R)                                       :(RETURN)
*
JIT_GETARG_D
         SET_P(A)
         GETARG_D_JIT(R)                                       :(RETURN)
*
JIT_PROLOG
         PROLOG_JIT()                                          :(RETURN)
*
JIT_EPILOG
         EPILOG_JIT()                                          :(RETURN)
*
JIT_PRINT
         PRINT_JIT()                                           :(RETURN)
*
JIT_DISASSEMBLE
         DISASSEMBLE_JIT()                                     :(RETURN)
*
JIT_LABEL
         JIT_LABEL = LABEL_JIT()                               :(RETURN)
*
JIT_ELLIPSIS
         ELLIPSIS_JIT()                                        :(RETURN)
*
JIT_EMIT JIT_EMIT = EMIT_JIT()                                 :(RETURN)
*
JIT_ADDRESS
         JIT_ADDRESS = ADDRESS_JIT(P)                          :(RETURN)
*
JIT_RETR RETR_JIT(R)                                           :(RETURN)
*
JIT_RETR_F
         RETR_F_JIT(R)                                         :(RETURN)
*
JIT_RETR_D
         RETR_D_JIT(R)                                         :(RETURN)
*
JIT_GET_STATE
         JIT_GET_STATE = GET_STATE_JIT()                       :(RETURN)
*
JIT_SET_STATE
         SET_STATE_JIT(JIT)                                    :(RETURN)
*
JIT_NEW_STATE
         JIT_NEW_STATE = NEW_STATE_JIT()                       :(RETURN)
*
JIT_DESTROY_STATE
         DESTROY_STATE_JIT()                                   :(RETURN)
*
JIT_CLEAR_STATE
         CLEAR_STATE_JIT()                                     :(RETURN)
*
JIT_JMPR JMPR_JIT(R)                                           :(RETURN)
*
JIT_JMPI SET_P(P)
         JIT_JMPI = JMPI_JIT()                                 :(RETURN)
*
JIT_CALLR
         CALLR_JIT(R)                                          :(RETURN)
*
JIT_CALLI
         SET_P(P)
         CALLI_JIT()
         JIT_CALLI = GET_P()                                   :(RETURN)
*
JIT_NOTE JIT_NOTE = NOTE_JIT(S, N)                             :(RETURN)
*
JIT_NAME JIT_NAME = NAME_JIT(S)                                :(RETURN)
*
JIT_PREPARE
         PREPARE_JIT()                                         :(RETURN)
*
JIT_ALLOCAI
         JIT_ALLOCAI = ALLOCAI_JIT(N)                          :(RETURN)
*
JIT_PATCH_AT
         SET_P(P2)
         P_TO_P2()
         SET_P(P)
         PATCH_AT_JIT()                                        :(RETURN)
*
JIT_PATCH_ABS
         SET_P(P2)
         P_TO_P2()
         SET_P(P)
         PATCH_ABS_JIT()                                       :(RETURN)
*
JIT_PATCH
         SET_P(P)
         PATCH_JIT()                                           :(RETURN)
*
JIT_ADDR ADDR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_ADDCR
         ADDCR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_ADDXR
         ADDXR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_SUBR SUBR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_SUBCR
         SUBCR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_SUBXR
         SUBXR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_MULR MULR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_DIVR DIVR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_DIVR_U
         DIVR_U_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_REMR REMR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_REMR_U
         REMR_U_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_ANDR ANDR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_ORR  ORR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_XORR XORR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_LSHR LSHR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_RSHR RSHR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_RSHR_U
         RSHR_U_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LTR  LTR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_LTR_U
         LTR_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_LER  LER_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_LER_U
         LER_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GER  GER_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_GER_U
         GER_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GTR  GTR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_GTR_U
         GTR_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_EQR  EQR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_NER  NER_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_ADDR_F
         ADDR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_ADDR_D
         ADDR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_SUBR_F
         SUBR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_SUBR_D
         SUBR_D(R1, R2, R3)                                    :(RETURN)
*
JIT_MULR_F
         MULR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_MULR_D
         MULR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_DIVR_F
         DIVR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_DIVR_D
         DIVR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LTR_F
         LTR_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_LER_F
         LER_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_EQR_F
         EQR_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GER_F
         GER_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GTR_F
         GTR_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_NER_F
         NER_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_UNLTR_F
         UNLTR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNLER_F
         UNLER_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNEQR_F
         UNEQR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGER_F
         UNGER_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGTR_F
         UNGTR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LTGTR_F
         LTGTR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_ORDR_F
         ORDR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_UNORDR_F
         UNORDR_F_JIT(R1, R2, R3)                              :(RETURN)
*
JIT_LTR_D
         LTR_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_LER_D
         LER_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_EQR_D
         EQR_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GER_D
         GER_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GTR_D
         GTR_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_NER_D
         NER_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_UNLTR_D
         UNLTR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNLER_D
         UNLER_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNEQR_D
         UNEQR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGER_D
         UNGER_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGTR_D
         UNGTR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LTGTR_D
         LTGTR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_ORDR_D
         ORDR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_UNORDR_D
         UNORDR_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_C
         LDXR_C_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_UC
         LDXR_UC_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LDXR_S
         LDXR_S_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_US
         LDXR_US_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LDXR_I
         LDXR_I_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_UI
         LDXR_UI_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LDXR_L
         LDXR_L_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR LDXR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_LDXR_F
         LDXR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_D
         LDXR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_C
         STXR_C_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_S
         STRX_S_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_I
         STXR_I_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR STXR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_STXR_L
         STXR_L_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_F
         SRXR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_D
         STXR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_BLTR JIT_BLTR = BLTR_JIT(R1, R2)                           :(RETURN)
*
JIT_BLTR_U
         JIT_BLTR_U = BLTR_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BLER JIT_BLER = BLER_JIT(R1, R2)                           :(RETURN)
*
JIT_BLER_U
         BLER_U_JIT = BLER_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BGTR JIT_BGTR = BGTR_JIT(R1, R2)                           :(RETURN)
*
JIT_BGTR_U
         JIT_BGTR_U = BGTR_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BGER JIT_BGER = BGER_JIT(R1, R2)                           :(RETURN)
*
JIT_BGER_U
         JIT_BGER_U = BGER_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BEQR JIT_BEQR = BEQR_JIT(R1, R2)                           :(RETURN)
*
JIT_BNER JIT_BNER = BNER_JIT(R1, R2)                           :(RETURN)
*
JIT_BMSR JIT_BMSR = BMSR_JIT(R1, R2)                           :(RETURN)
*
JIT_BMCR JIT_BMCR = BMCR_JIT(R1, R2)                           :(RETURN)
*
JIT_BOADDR
         JIT_BOADDR = BOADDR_JIT(R1, R2)                       :(RETURN)
*
JIT_BXADDR
         JIT_BXADDR = BXADDR_JIT(R1, R2)                       :(RETURN)
*
JIT_BOSUBR
         JIT_BOSUBR = BOSUBR_JIT(R1, R2)                       :(RETURN)
*
JIT_BXSUBR
         JIT_BXSUBR = BXSUBR_JIT(R1, R2)                       :(RETURN)
*
JIT_BOADDR_U
         JIT_BOADDR_U = BOADDR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BXADDR_U
         JIT_BXADDR_U = BXADDR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BOSUBR_U
         JIT_BOSUBR_U = BOSUBR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BXSUBR_U
         JIT_BXSUBR_U = BXSUBR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BLTR_F
         JIT_BLTR_F = BLTR_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BLER_F
         JIT_BLER_F = BLER_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BGTR_F
         JIT_BGTR_F = BGTR_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BGER_F
         JIT_BGER_F = BGER_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BEQR_F
         JIT_BEQR_F = BEQR_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BNER_R
         JIT_BNER_R = BNER_R_JIT(R1, R2)                       :(RETURN)
*
JIT_BUNLTR_F
         JIT_BUNLTR_F = BUNLTR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNLER_F
         JIT_BUNLER_F = BUNLER_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNEQR_F
         JIT_BUNEQR_F = BUNEQR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGER_F
         JIT_BUNGER_F = BUNGER_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGTR_F
         JIT_BUNGTR_F = BUNGTR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BLTGTR_F
         JIT_BLTGTR_F = BLTGTR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BORDR_F
         JIT_BORDR_F = BORDR_F_JIT(R1, R2)                     :(RETURN)
*
JIT_BUNORDR_F
         JIT_BUNORDR_F = BUNORDR_F_JIT(R1, R2)                 :(RETURN)
*
JIT_BLTR_D
         JIT_BLTR_D = BLTR_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BLER_D
         JIT_BLER_D = BLER_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BGTR_D
         JIT_BGTR_D = BGTR_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BGER_D
         JIT_BGER_D = BGER_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BEQR_D
         JIT_BEQR_D = BEQR_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BNER_D
         JIT_BNER_D = BNER_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BUNLTR_D
         JIT_BUNLTR_D = BUNLTR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNLER_D
         JIT_BUNLER_D = BUNLER_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNEQR_D
         JIT_BUNEQR_D = BUNEQR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGER_D
         JIT_BUNGER_D = BUNGER_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGTR_D
         JIT_BUNGTR_D = BUNGTR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BLTGTR_D
         JIT_BLTGTR_D = BLTGTR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BORDR_D
         JIT_BORDR_D = BORDR_D_JIT(R1, R2)                     :(RETURN)
*
JIT_BUNORDR_D
         JIT_BUNORDR_D = BUNORDR_D_JIT(R1, R2)                 :(RETURN)
*
JIT_ADDI SET_P(P)
         ADDI_JIT(R1, R2)                                      :(RETURN)
*
JIT_ADDCI
         SET_P(P)
         ADDCI_JIT(R1, R2)                                     :(RETURN)
*
JIT_ADDXI
         SET_P(P)
         ADDXI_JIT(R1, R2)                                     :(RETURN)
*
JIT_SUBI SET_P(P)
         SUBI_JIT(R1, R2)                                      :(RETURN)
*
JIT_SUBCI
         SET_P(P)
         SUBCI_JIT(R1, R2)                                     :(RETURN)
*
JIT_SUBXI
         SET_P(P)
         SUBXI_JIT(R1, R2)                                     :(RETURN)
*
JIT_MULI SET_P(P)
         MULI_JIT(R1, R2)                                      :(RETURN)
*
JIT_DIVI SET_P(P)
         DIVI_JIT(R1, R2)                                      :(RETURN)
*
JIT_DIVI_U
         SET_P(P)
         DIVI_U_JIT(R1, R2)                                    :(RETURN)
*
JIT_REMI SET_P(P)
         REMI_JIT(R1, R2)                                      :(RETURN)
*
JIT_REMI_U
         SET_P(P)
         REMI_U_JIT(R1, R2)                                    :(RETURN)
*
JIT_ANDI SET_P(P)
         ANDI_JIT(R1, R2)                                      :(RETURN)
*
JIT_ORI  SET_P(P)
         ORI_JIT(R1, R2)                                       :(RETURN)
*
JIT_XORI SET_P(P)
         XORI_JIT(R1, R2)                                      :(RETURN)
*
JIT_LSHI SET_P(P)
         LSHI_JIT(R1, R2)                                      :(RETURN)
*
JIT_RSHI SET_P(P)
         RSHI_JIT(R1, R2)                                      :(RETURN)
*
JIT_RSHI_U
         SET_P(P)
         RSHI_U_JIT(R1, R2)                                    :(RETURN)
*
JIT_LTI  SET_P(P)
         LTI_JIT(R1, R2)                                       :(RETURN)
*
JIT_LTI_U
         SET_P(P)
         LTI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_LEI  SET_P(P)
         LEI_JIT(R1, R2)                                       :(RETURN)
*
JIT_LEI_U
         SET_P(P)
         LEI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_GEI  SET_P(P)
         GEI_JIT(R1, R2)                                       :(RETURN)
*
JIT_GEI_U
         SET_P(P)
         GEI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_GTI  SET_P(P)
         GTI_JIT(R1, R2)                                       :(RETURN)
*
JIT_GTI_U
         SET_P(P)
         GTI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_EQI  SET_P(P)
         EQI_JIT(R1, R2)                                       :(RETURN)
*
JIT_NEI  SET_P(P)
         NEI_JIT(R1, R2)                                       :(RETURN)
*
JIT_LDXI_C
         SET_P(P)
         LDXI_C_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_UC
         SET_P(P)
         LDXI_UC_JIT(R1, R2)                                   :(RETURN)
*
JIT_LDXI_S
         SET_P(P)
         LDXI_S_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_US
         SET_P(P)
         LDXI_US_JIT(R1, R2)                                   :(RETURN)
*
JIT_LDXI_I
         SET_P(P)
         LDXI_I_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_UI
         SET_P(P)
         LDXI_UI_JIT(R1, R2)                                   :(RETURN)
*
JIT_LDXI_L
         SET_P(P)
         LDXI_L_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI SET_P(P)
         LDXI_JIT(R1, R2)                                      :(RETURN)
*
JIT_LDXI_F
         SET_P(P)
         LDXI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_D
         SET_P(P)
         LDXI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_C
         SET_P(P)
         STXI_C_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_S
         SET_P(P)
         STXI_S_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_I
         SET_P(P)
         STXI_I_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_L
         SET_P(P)
         STXI_L_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI
         SET_P(P)
         STXI_JIT(R1, R2)                                      :(RETURN)
*
JIT_STXI_F
         SET_P(P)
         STXI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_D
         SET_P(P)
         STXI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_ADDI_F
         SET_F(F)
         ADDI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_SUBI_F
         SET_F(F)
         SUBI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_MULI_F
         SET_F(F)
         MULI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_DIVI_F
         SET_F(F)
         DIVI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_ADDI_D
         SET_D(D)
         ADDI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_SUBI_D
         SET_D(D)
         SUBI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_MULI_D
         SET_D(D)
         MULI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_DIVI_D
         SET_D(D)
         DIVI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_MOVR MOVR_JIT(R1, R2)                                      :(RETURN)
*
JIT_MOVR_F
         MOVR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_MOVR_D
         MOVR_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_HTONR
         HTONR_JIT(R1, R2)                                     :(RETURN)
*
JIT_NTOHR
         NTOHR_JIT(R1, R2)                                     :(RETURN)
*
JIT_COMR COMR_JIT(R1, R2)                                      :(RETURN)
*
JIT_NEGR NEGR_JIT(R1, R2)                                      :(RETURN)
*
JIT_NEGR_F
         NEGR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_NEGR_D
         NEGR_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_ABSR_F
         ABSR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_ABSR_D
         ABSR_D_JIT(R1, R2)                                    :(RETURN)
JIT_SQRTR_F
         SQRTR_F_JIT(R1, R2)                                   :(RETURN)
*
JIT_SQRTR_D
         SQRTR_D_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_C
         EXTR_C_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_UC
         EXTR_UC_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_S
         EXTR_S_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_US
         EXTR_US_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_I
         EXTR_I_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_UI
         EXTR_UI_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_F
         EXTR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_D_F
         EXTR_D_F_JIT(R1, R2)                                  :(RETURN)
*
JIT_EXTR_D
         EXTR_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_F_D
         EXTR_F_D_JIT(R1, R2)                                  :(RETURN)
*
JIT_TRUNCR_F_I
         TRUNCR_F_I_JIT(R1, R2)                                :(RETURN)
*
JIT_TRUNCR_F
         TRUNCR_F_JIT(R1, R2)                                  :(RETURN)
*
JIT_TRUNCR_F_L
         TRUNCR_F_L_JIT(R1, R2)                                :(RETURN)
*
JIT_TRUNCR_D_I
         TRUNCR_D_I_JIT(R1, R2)                                :(RETURN)
*
JIT_TRUNCR_D
         TRUNCR_D_JIT(R1, R2)                                  :(RETURN)
*
JIT_TRUNCR_D_L
         TRUNCR_D_L_JIT(R1, R2)                                :(RETURN)
*
JIT_LDR_C
         LDR_C_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_UC
         LDR_UC_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDR_S
         LDR_S_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_US
         LDR_US_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDR_I
         LDR_I_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR
         LDR_JIT(R1, R2)                                       :(RETURN)
*
JIT_LDR_UI
         LDR_UI_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDR_L
         LDR_L_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_F
         LDR_F_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_D
         LDR_D_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_C
         STR_C_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_S
         STR_S_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_I
         STR_I_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR  STR_JIT(R1, R2)                                       :(RETURN)
*
JIT_STR_L
         STR_L_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_F
         STR_F_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_D
         STR_D_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDI_C
         SET_P(P)
         LDI_C_JIT(R)                                          :(RETURN)
*
JIT_LDI_UC
         SET_P(P)
         LDI_UC_JIT(R)                                         :(RETURN)
*
JIT_LDI_S
         SET_P(P)
         LDI_S_JIT(R)                                          :(RETURN)
*
JIT_LDI_US
         SET_P(P)
         LDI_US_JIT(R)                                         :(RETURN)
*
JIT_LDI_I
         SET_P(P)
         LDI_I_JIT(R)                                          :(RETURN)
*
JIT_LDI  SET_P(P)
         LDI_JIT(R)                                            :(RETURN)
*
JIT_LDI_UI
         SET_P(P)
         LDI_UI_JIT(R)                                         :(RETURN)
*
JIT_LDI_L
         SET_P(P)
         LDI_L_JIT(R)                                          :(RETURN)
*
JIT_LDI_F
         SET_P(P)
         LDI_F_JIT(R)                                          :(RETURN)
*
JIT_LDI_D
         SET_P(P)
         LDI_D_JIT(R)                                          :(RETURN)
*
JIT_PUSHARGI
         SET_P(P)
         PUSHARGI_JIT()                                        :(RETURN)
*
JIT_PUSHARGI_F
         SET_F(F)
         PUSHARGI_F_JIT()                                      :(RETURN)
*
JIT_PUSHARGI_D
         SET_D(D)
         PUSHARGI_D_JIT()                                      :(RETURN)
*
JIT_BLTI SET_P(P)
         BLTI_JIT(R)                                           :(RETURN)
*
JIT_BLTI_U
         SET_P(P)
         BLTI_U_JIT(R)                                         :(RETURN)
*
JIT_BLEI SET_P(P)
         BLEI_JIT(R)                                           :(RETURN)
*
JIT_BLEI_U
         SET_P(P)
         BLEI_U_JIT(R)                                         :(RETURN)
*
JIT_BEQI SET_P(P)
         BEQI_JIT(R)                                           :(RETURN)
*
JIT_BGEI SET_P(P)
         BGEI_JIT(R)                                           :(RETURN)
*
JIT_BGEI_U
         SET_P(P)
         BGEI_U_JIT(R)                                         :(RETURN)
*
JIT_BGTI SET_P(P)
         BGTI_JIT(R)                                           :(RETURN)
*
JIT_BGTI_U
         SET_P(P)
         BGTI_U_JIT(R)                                         :(RETURN)
*
JIT_BNEI SET_P(P)
         BNEI_JIT(R)                                           :(RETURN)
*
JIT_BMSI SET_P(P)
         BMSI_JIT(R)                                           :(RETURN)
*
JIT_BMCI SET_P(P)
         BMCI_JIT(R)                                           :(RETURN)
*
JIT_BOADDI
         SET_P(P)
         BOADDI_JIT(R)                                         :(RETURN)
*
JIT_BOADDI_U
         SET_P(P)
         BOADDI_U_JIT(R)                                       :(RETURN)
*
JIT_BXADDI
         SET_P(P)
         BXADDI_JIT(R)                                         :(RETURN)
*
JIT_BXADDI_U
         SET_P(P)
         BXADDI_U_JIT(R)                                       :(RETURN)
*
JIT_BOSUBI
         SET_P(P)
         BOSUBI_JIT(R)                                         :(RETURN)
*
JIT_BOSUBI_U
         SET_P(P)
         BOSUBI_U_JIT(R)                                       :(RETURN)
*
JIT_BXSUBI
         SET_P(P)
         BXSUBI_JIT(R)                                         :(RETURN)
*
JIT_BXSUBI_U
         SET_P(P)
         BXSUBI_U_JIT(R)                                       :(RETURN)
*
JIT_STI_C
         SET_P(P)
         STI_C_JIT(R)                                          :(RETURN)
*
JIT_STI_S
         SET_P(P)
         STI_S_JIT(R)                                          :(RETURN)
*
JIT_STI_I
         SET_P(P)
         STI_I_JIT(R)                                          :(RETURN)
*
JIT_STI  SET_P(P)
         STI_JIT(R)                                            :(RETURN)
*
JIT_STI_L
         SET_P(P)
         STI_L_JIT(R)                                          :(RETURN)
*
JIT_STI_F
         SET_P(P)
         STI_F_JIT(R)                                          :(RETURN)
*
JIT_STI_D
         SET_P(P)
         STI_D_JIT(R)                                          :(RETURN)
*
JIT_PUSHARGR
         PUSHARGR_JIT(R)                                       :(RETURN)
*
JIT_PUSHARGR_F
         PUSHARGR_F_JIT(R)                                     :(RETURN)
*
JIT_PUSHARGR_D
         PUSHARGR_D_JIT(R)                                     :(RETURN)
*
JIT_RETVAL_C
         RETVAL_C_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_UC
         RETVAL_UC_JIT(R)                                      :(RETURN)
*
JIT_RETVAL_S
         RETVAL_S_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_US
         RETVAL_US_JIT(R)                                      :(RETURN)
*
JIT_RETVAL_I
         RETVAL_I_JIT(R)                                       :(RETURN)
*
JIT_RETVAL
         RETVAL_JIT(R)                                         :(RETURN)
*
JIT_RETVAL_UI
         RETVAL_UI_JIT(R)                                      :(RETURN)
*
JIT_RETVAL_L
         RETVAL_L_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_F
         RETVAL_F_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_D
         RETVAL_D_JIT(R)                                       :(RETURN)
*
JIT_END  CODE('JIT_DEFINE')
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'JIT.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE JIT
<<INCLUDES>>
-STITL JIT
-EJECT
*
************************************************************************
*                                                                      *
*                              #  ###  #######                         *
*                              #   #      #                            *
*                              #   #      #                            *
*                              #   #      #                            *
*                        #     #   #      #                            *
*                        #     #   #      #                            *
*                         #####   ###     #                            *
*                                                                      *
* JIT                JUST-IN-TIME CODE GENERATION                      *
*                                                                      *
************************************************************************
*
* QMUL/QDIV NOT YET SUPPORTED
*
* JIT.lss
*
<<JIT>>
*
* CE: .MSNOBOL4;
@
-MODULE JIT
-LINE 21 "JIT.lss"
-INCLUDE 'CRACK.INC'
-INCLUDE 'P64.INC'
-INCLUDE 'SEQ.INC'
-STITL JIT
-LINE 2154 "JIT.lss"
-EJECT
*
************************************************************************
*                                                                      *
*                              #  ###  #######                         *
*                              #   #      #                            *
*                              #   #      #                            *
*                              #   #      #                            *
*                        #     #   #      #                            *
*                        #     #   #      #                            *
*                         #####   ###     #                            *
*                                                                      *
* JIT                JUST-IN-TIME CODE GENERATION                      *
*                                                                      *
************************************************************************
*
* QMUL/QDIV NOT YET SUPPORTED
*
* JIT.lss
*
-LINE 27 "JIT.lss"
-CASE 1
-PLUSOPS 1
-LINE 30 "JIT.lss"
-LINE 31 "JIT.lss"
-LINE 32 "JIT.lss"
-LINE 33 "JIT.lss"
-LINE 34 "JIT.lss"
-LINE 37 "JIT.lss"
         jit = 'jit.c'
-LINE 475 "JIT.lss"
-LINE 476 "JIT.lss"
-LINE 477 "JIT.lss"
-LINE 478 "JIT.lss"
-LINE 479 "JIT.lss"
-LINE 480 "JIT.lss"
-LINE 488 "JIT.lss"
         LOAD('INIT_JIT(STRING)', 'jit.so')
         LOAD('R_NUM_JIT()INTEGER', 'jit.so')
         LOAD('V_NUM_JIT()INTEGER', 'jit.so')
         LOAD('F_NUM_JIT()INTEGER', 'jit.so')
         LOAD('FINISH_JIT()', 'jit.so')
*
         LOAD('GET_STATE_JIT()INTEGER', 'jit.so')
         LOAD('SET_STATE_JIT(INTEGER)', 'jit.so')
         LOAD('NEW_STATE_JIT()INTEGER', 'jit.so')
         LOAD('DESTROY_STATE_JIT()', 'jit.so')
         LOAD('CLEAR_STATE_JIT()', 'jit.so')
*
         LOAD('PROLOG_JIT()', 'jit.so')
         LOAD('EPILOG_JIT()', 'jit.so')
         LOAD('NOTE_JIT(STRING,INTEGER)INTEGER', 'jit.so')
         LOAD('NAME_JIT(STRING)INTEGER', 'jit.so')
         LOAD('ADDRESS_JIT(INTEGER)INTEGER', 'jit.so')
         LOAD('DISASSEMBLE_JIT()', 'jit.so')
         LOAD('EMIT_JIT()INTEGER', 'jit.so')
         LOAD('PRINT_JIT()', 'jit.so')
         LOAD('LABEL_JIT()INTEGER', 'jit.so')
         LOAD('ELLIPSIS_JIT()', 'jit.so')
*        LOAD('GET_NOTE_JIT()INTEGER', 'jit.so')
         LOAD('POINTER_P_JIT()', 'jit.so')
         LOAD('CALLEE_SAVE_P_JIT(INTEGER)', 'jit.so')
         LOAD('PATCH_AT_JIT()', 'jit.so')
         LOAD('PATCH_ABS_JIT()', 'jit.so')
         LOAD('PATCH_JIT()', 'jit.so')
         LOAD('PREPARE_JIT()', 'jit.so')
         LOAD('ALLOCAI_JIT(INTEGER)INTEGER', 'jit.so')
         LOAD('DATA_JIT(INTEGER,INTEGER,INTEGER)INTEGER', 'jit.so')
         LOAD('FORWARD_JIT()INTEGER', 'jit.so')
         LOAD('LIVE_JIT(INTEGER)', 'jit.so')
         LOAD('LINK_JIT()', 'jit.so')
*
* WE DO R0..R3, V0..V3, F0..F7 AND FP, EVEN THOUGH NOT ALL OF THESE
* REGISTERS MAY EXIST. THE ONES THAT DON'T WILL BE -1. USE JIT_R_NUM(),
* JIT_V_NUM() AND JIT_F_NUM() TO DETERMINE THE ACTUAL NUMBER OF
* REGISTERS. NOTE THAT WORST CASE, R0..R2, V0..V2 AND F0..F5 ARE
* USABLE.
*
         L = 'R0 R1 R2 R3 V0 V1 V2 V3 F0 F1 F2 F3 F4 F5 F6 F7 FP'
         A = CRACK(L, ' ')
         SEQ(" LOAD('GET_' A<I> '_JIT()INTEGER', 'jit.so'); "
+            " $('JIT_' A<I>) = EVAL('GET_' A<I> '_JIT()') ", .I)
*
         L = 'ADDR ADDCR ADDXR SUBR SUBCR SUBXR MULR DIVR DIVR_U '
+            'REMR REMR_U ANDR ORR XORR LSHR RSHR RSHR_U '
+            'LTR LTR_U LER LER_U GER GER_U GTR GTR_U EQR NER '
+            'ADDR_F ADDR_D SUBR_F SUBR_D MULR_F MULR_D DIVR_F DIVR_D '
+            'LTR_F LER_F EQR_F GER_F GTR_F NER_F UNLTR_F UNLER_F '
+            'UNEQR_F UNGER_F UNGTR_F LTGTR_F ORDR_F UNORDR_F '
+            'LTR_D LER_D EQR_D GER_D GTR_D NER_D UNLTR_D UNLER_D '
+            'UNEQR_D UNGER_D UNGTR_D LTGTR_D ORDR_D UNORDR_D '
+            'LDXR_C LDXR_UC LDXR_S LDXR_US LDXR_I LDXR_UI LDXR_L '
+            'LDXR LDXR_F LDXR_D '
+            'STXR_C STXR_S STXR_I STXR STXR_L STXR_F STXR_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'ADDI ADDCI ADDXI SUBI SUBCI SUBXI MULI DIVI DIVI_U '
+            'REMI REMI_U ANDI ORI XORI LSHI RSHI RSHI_U '
+            'LTI LTI_U LEI LEI_U GEI GEI_U GTI GTI_U EQI NEI '
+            'ADDI_F SUBI_F MULI_F DIVI_F '
+            'ADDI_D SUBI_D MULI_D DIVI_D '
+            'LDXI_C LDXI_UC LDXI_S LDXI_US LDXI_I LDXI_UI LDXI_L LDXI '
+            'LDXI_F LDXI_D '
+            'STXI_C STXI_S STXI_I STXI_L STXI STXI_F STXI_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'BLTR BLTR_U BLER BLER_U BGTR BGTR_U BGER BGER_U '
+            'BEQR BNER BMSR BMCR BOADDR BXADDR BOSUBR BXSUBR'
+            'BOADDR_U BXADDR_U BOSUBR_U BXSUBR_U '
+            'BLTR_F BLER_F BGTR_F BGER_F BEQR_F BNER_R '
+            'BUNLTR_F BUNLER_F BUNEQR_F BUNGER_F BUNGTR_F '
+            'BLTGTR_F BORDR_F BUNORDR_F '
+            'BLTR_D BLER_D BGTR_D BGER_D BEQR_D BNER_D '
+            'BUNLTR_D BUNLER_D BUNEQR_D BUNGER_D BUNGTR_D '
+            'BLTGTR_D BORDR_D BUNORDR_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'MOVR MOVR_F MOVR_D MOVR_F_W MOVR_W_F MOVR_D_W MOVR_W_D '
+            'HTONR NTOHR COMR NEGR NEGR_F NEGR_D ABSR_F ABSR_D '
+            'SQRTR_F SQRTR_D '
+            'EXTR_C EXTR_UC EXTR_S EXTR_US EXTR_I EXTR_UI '
+            'EXTR_F EXTR_D_F EXTR_D EXTR_F_D '
+            'TRUNCR_F_I TRUNCR_F TRUNCR_F_L TRUNCR_D_I TRUNCR_D '
+            'TRUNCR_D_L '
+            'LDR_C LDR_UC LDR_S LDR_US LDR_I LDR LDR_UI LDR_L '
+            'LDR_F LDR_D '
+            'STR_C STR_S STR_I STR STR_L STR_F STR_D'
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         L = 'MOVR_D_WW MOVR_WW_D'
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER,INTEGER,INTEGER)', 'jit.so') "
+            , .I)
*
         LOAD('MOVI_JIT(INTEGER)INTEGER', 'jit.so')
         LOAD('MOVI_F_JIT(INTEGER)', 'jit.so')
         LOAD('MOVI_D_JIT(INTEGER)', 'jit.so')
         LOAD('MOVI_F_W_JIT(INTEGER,INTEGER)', 'jit.so')
         LOAD('MOVI_D_W_JIT(INTEGER,INTEGER)', 'jit.so')
         LOAD('MOVI_D_WW_JIT(INTEGER,INTEGER)', 'jit.so')
*
         L = 'ARG ARG_F ARG_D'
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT()', 'jit.so') ", .I)
*
         L = 'GETARG GETARG_C GETARG_UC GETARG_S GETARG_US GETARG_I '
+            'GETARG_UI GETARG_L GETARG_F GETARG_D '
+            'LDI_C LDI_UC LDI_S LDI_US LDI_I LDI LDI_UI LDI_L LDI_F '
+            'LDI_D STI_C STI_S STI_I STI STI_L STI_F STI_D '
+            'BLTI BLTI_U BLEI BLEI_U BEQI BGEI BGEI_U BGTI BGTI_U '
+            'BNEI BMSI BMCI BOADDI BOADDI_U BXADDI BXADDI_U '
+            'BOSUBI BOSUBI_U BXSUBI BXSUBI_U '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER)', 'jit.so') ", .I)
*
         L = 'PUSHARGR PUSHARGR_F PUSHARGR_D '
+            'RETR RETVAL_C RETVAL_UC RETVAL_S RETVAL_US RETVAL_I '
+            'RETVAL RETVAL_UI RETVAL_L RETR_F RETVAL_F '
+            'RETR_D RETVAL_D '
         A = CRACK(L, ' ')
         SEQ(" LOAD(A<I> '_JIT(INTEGER)', 'jit.so') ", .I)
         LOAD('PUSHARGI_JIT()', 'jit.so')
         LOAD('PUSHARGI_F_JIT()', 'jit.so')
         LOAD('PUSHARGI_D_JIT()', 'jit.so')
*
         LOAD('JMPR_JIT(INTEGER)', 'jit.so')
         LOAD('JMPI_JIT()INTEGER', 'jit.so')
*
         LOAD('CALLR_JIT(INTEGER)', 'jit.so')
         LOAD('CALLI_JIT()', 'jit.so')
*
         LOAD('FINISHR_JIT(INTEGER)', 'jit.so')
         LOAD('FINISHI_JIT()', 'jit.so')
*
         LOAD('RET_JIT()', 'jit.so')
         LOAD('RETI_JIT()', 'jit.so')
         LOAD('RETI_F_JIT()', 'jit.so')
         LOAD('RETI_D_JIT()', 'jit.so')
*
* PROXY FUNCTIONS TO HIDE SET_P()/GET_P(). THESE ARE SHORT FUNCTIONS (1
* OR 2 LINES). USE THESE FUNCTIONS TO USE JIT, RATHER THAN THE ..._JIT
* FUNCTIONS. THESE FUNCTIONS TAKE CARE OF ANY INT/POINTER ISSUES,
* WHEREAS USING THE UNDERLYING FUNCTIONS WILL NOT, AND THE CODE WILL BE
* NOT BE PORTABLE.
*
JIT_DEFINE
*
-PUBLIC JIT_R_NUM(), JIT_V_NUM(), JIT_FNUM()
         DEFINE('JIT_R_NUM()')
         DEFINE('JIT_V_NUM()')
         DEFINE('JIT_F_NUM()')
-PUBLIC JIT_ARG(), JIT_ARG_F(), JIT_ARG_D()
         DEFINE('JIT_ARG()')
         DEFINE('JIT_ARG_F()')
         DEFINE('JIT_ARG_D()')
-PUBLIC JIT_RET(), JIT_RETI(), JIT_RETI_F(), JIT_RETI_D()
         DEFINE('JIT_RET()')
         DEFINE('JIT_RETI(P)')
         DEFINE('JIT_RETI_F(F)')
         DEFINE('JIT_RETI_D(D)')
-PUBLIC JIT_FINISHR(), JIT_FINISHI(), JIT_INIT(), JIT_FINISH()
         DEFINE('JIT_FINISHR(R)')
         DEFINE('JIT_FINISHI(P)')
         DEFINE('JIT_INIT(S)')
         DEFINE('JIT_FINISH()')
-PUBLIC JIT_MOVI(), JIT_MOVI_F(), JIT_MOVI_D()
         DEFINE('JIT_MOVI(R,P)')
         DEFINE('JIT_MOVI_F(R,F)')
         DEFINE('JIT_MOVI_D(R,D)')
-PUBLIC JIT_GETARG(), JIT_GETARG_C(), JIT_GETARG_UC(), JIT_GETARG_S()
-PUBLIC JIT_GETARG_US(), JIT_GETARG_I(), JIT_GETARG_UI(), JIT_GETARG_L()
-PUBLIC JIT_GETARG_F(), JIT_GETARG_D()
         DEFINE('JIT_GETARG(R,A)')
         DEFINE('JIT_GETARG_C(R,A)')
         DEFINE('JIT_GETARG_UC(R,A)')
         DEFINE('JIT_GETARG_S(R,A)')
         DEFINE('JIT_GETARG_US(R,A)')
         DEFINE('JIT_GETARG_I(R,A)')
         DEFINE('JIT_GETARG_UI(R,A)')
         DEFINE('JIT_GETARG_L(R,A)')
         DEFINE('JIT_GETARG_F(R,A)')
         DEFINE('JIT_GETARG_D(R,A)')
-PUBLIC JIT_PROLOG(), JIT_EPILOG(), JIT_PRINT(), JIT_DISASSEMBLE()
-PUBLIC JIT_LABEL(), JIT_ELLIPSIS(), JIT_EMIT(), JIT_ADDRESS()
         DEFINE('JIT_PROLOG()')
         DEFINE('JIT_EPILOG()')
         DEFINE('JIT_PRINT()')
         DEFINE('JIT_DISASSEMBLE()')
         DEFINE('JIT_LABEL()')
         DEFINE('JIT_ELLIPSIS()')
         DEFINE('JIT_EMIT()')
         DEFINE('JIT_ADDRESS(P)')
-PUBLIC JIT_RETR(), JIT_RETR_F(), JIT_RETR_D()
         DEFINE('JIT_RETR(R)')
         DEFINE('JIT_RETR_F(R)')
         DEFINE('JIT_RETR_D(R)')
-PUBLIC JIT_GETSTATE(), JIT_SET_STATE(), JIT_NEW_STATE()
-PUBLIC JIT_DESTROY_STATE(), JIT_CLEAR_STATE()
         DEFINE('JIT_GET_STATE()')
         DEFINE('JIT_SET_STATE(JIT)')
         DEFINE('JIT_NEW_STATE()')
         DEFINE('JIT_DESTROY_STATE()')
         DEFINE('JIT_CLEAR_STATE()')
-PUBLIC JIT_JMPR(), JIT_JMPI()
         DEFINE('JIT_JMPR(R)')
         DEFINE('JIT_JMPI(P)')
-PUBLIC JIT_CALLR(), JIT_CALLI()
         DEFINE('JIT_CALLR(R)')
         DEFINE('JIT_CALLI(P)')
-PUBLIC JIT_NOTE(), JIT_NAME(), JIT_PREPARE(), JIT_ALLOCAI()
         DEFINE('JIT_NOTE(S,N)')
         DEFINE('JIT_NAME(S)')
         DEFINE('JIT_PREPARE()')
         DEFINE('JIT_ALLOCAI(N)')
-PUBLIC JIT_PATCH_AT, JIT_PATCH_ABS(), JIT_PATCH()
         DEFINE('JIT_PATCH_AT(P,P2)')
         DEFINE('JIT_PATCH_ABS(P,P2)')
         DEFINE('JIT_PATCH(P)')
-PUBLIC JIT_ADDR(), JIT_ADDCR(), JIT_ADDXR()
         DEFINE('JIT_ADDR(R1,R2,R3)')
         DEFINE('JIT_ADDCR(R1,R2,R3)')
         DEFINE('JIT_ADDXR(R1,R2,R3)')
-PUBLIC JIT_SUBR(), JIT_SUBCR(), JIT_SUBXR()
         DEFINE('JIT_SUBR(R1,R2,R3)')
         DEFINE('JIT_SUBCR(R1,R2,R3)')
         DEFINE('JIT_SUBXR(R1,R2,R3)')
-PUBLIC JIT_MULR(), JIT_DIVR(), JIT_DIVR_U(), JIT_REMR(), JIT_REMR_U()
         DEFINE('JIT_MULR(R1,R2,R3)')
         DEFINE('JIT_DIVR(R1,R2,R3)')
         DEFINE('JIT_DIVR_U(R1,R2,R3)')
         DEFINE('JIT_REMR(R1,R2,R3)')
         DEFINE('JIT_REMR_U(R1,R2,R3)')
-PUBLIC JIT_ANDR(), JIT_ORR(), JIT_XORR(), JIT_LSHR(), JIT_RSHR()
-PUBLIC JIT_RSHR_U()
         DEFINE('JIT_ANDR(R1,R2,R3)')
         DEFINE('JIT_ORR(R1,R2,R3)')
         DEFINE('JIT_XORR(R1,R2,R3)')
         DEFINE('JIT_LSHR(R1,R2,R3)')
         DEFINE('JIT_RSHR(R1,R2,R3)')
         DEFINE('JIT_RSHR_U(R1,R2,R3)')
-PUBLIC JIT_LTR(), JIT_LTR_U()
         DEFINE('JIT_LTR(R1,R2,R3)')
         DEFINE('JIT_LTR_U(R1,R2,R3)')
-PUBLIC JIT_LER(), JIT_LER_U()
         DEFINE('JIT_LER(R1,R2,R3)')
         DEFINE('JIT_LER_U(R1,R2,R3)')
-PUBLIC JIT_GER(), JIT_GER_U()
         DEFINE('JIT_GER(R1,R2,R3)')
         DEFINE('JIT_GER_U(R1,R2,R3)')
-PUBLIC JIT_GTR(), GTR_U()
         DEFINE('JIT_GTR(R1,R2,R3)')
         DEFINE('JIT_GTR_U(R1,R2,R3)')
-PUBLIC JIT_EQR(), JIT_NER()
         DEFINE('JIT_EQR(R1,R2,R3)')
         DEFINE('JIT_NER(R1,R2,R3)')
-PUBLIC JIT_ADDR_F(), JIT_ADDR_D()
         DEFINE('JIT_ADDR_F(R1,R2,R3)')
         DEFINE('JIT_ADDR_D(R1,R2,R3)')
-PUBLIC JIT_SUBR_F(), JIT_SUBR_D()
         DEFINE('JIT_SUBR_F(R1,R2,R3)')
         DEFINE('JIT_SUBR_D(R1,R2,R3)')
-PUBLIC JIT_MULR_F(), JIT_MULR_D()
         DEFINE('JIT_MULR_F(R1,R2,R3)')
         DEFINE('JIT_MULR_D(R1,R2,R3)')
-PUBLIC JIT_DIVR_F(), JIT_DIVR_D()
         DEFINE('JIT_DIVR_F(R1,R2,R3)')
         DEFINE('JIT_DIVR_D(R1,R2,R3)')
-PUBLIC JIT_LTR_F(), JIT_LER_F(), JIT_EQR_F(), JIT_GER_F(), JIT_GTR_F()
-PUBLIC JIT_NER_F()
         DEFINE('JIT_LTR_F(R1,R2,R3)')
         DEFINE('JIT_LER_F(R1,R2,R3)')
         DEFINE('JIT_EQR_F(R1,R2,R3)')
         DEFINE('JIT_GER_F(R1,R2,R3)')
         DEFINE('JIT_GTR_F(R1,R2,R3)')
         DEFINE('JIT_NER_F(R1,R2,R3)')
-PUBLIC JIT_UNLTR_F(), JIT_UNLER_F(), JIT_UNEQR_F(), JIT_UNGER_F()
-PUBLIC JIT_UNGTR_F(), JIT_LTGTR_F(), JIT_ORDR_F(), JIT_UNORDR_F()
         DEFINE('JIT_UNLTR_F(R1,R2,R3)')
         DEFINE('JIT_UNLER_F(R1,R2,R3)')
         DEFINE('JIT_UNEQR_F(R1,R2,R3)')
         DEFINE('JIT_UNGER_F(R1,R2,R3)')
         DEFINE('JIT_UNGTR_F(R1,R2,R3)')
         DEFINE('JIT_LTGTR_F(R1,R2,R3)')
         DEFINE('JIT_ORDR_F(R1,R2,R3)')
         DEFINE('JIT_UNORDR_F(R1,R2,R3)')
-PUBLIC JIT_LTR_D(), JIT_LER_D(), JIT_EQR_D(), JIT_GER_D(), JIT_GTR_D()
-PUBLIC JIT_NER_D()
-PUBLIC JIT_UNLTR_D(), JIT_UNLER_D(), JIT_UNEQR_D(), JIT_UNGER_D()
-PUBLIC JIT_UNGTR_D(), JIT_LTGTR_D(), JIT_ORDR_D(), JIT_UNORDR_D(),
         DEFINE('JIT_LTR_D(R1,R2,R3)')
         DEFINE('JIT_LER_D(R1,R2,R3)')
         DEFINE('JIT_EQR_D(R1,R2,R3)')
         DEFINE('JIT_GER_D(R1,R2,R3)')
         DEFINE('JIT_GTR_D(R1,R2,R3)')
         DEFINE('JIT_NER_D(R1,R2,R3)')
         DEFINE('JIT_UNLTR_D(R1,R2,R3)')
         DEFINE('JIT_UNLER_D(R1,R2,R3)')
         DEFINE('JIT_UNEQR_D(R1,R2,R3)')
         DEFINE('JIT_UNGER_D(R1,R2,R3)')
         DEFINE('JIT_UNGTR_D(R1,R2,R3)')
         DEFINE('JIT_LTGTR_D(R1,R2,R3)')
         DEFINE('JIT_ORDR_D(R1,R2,R3)')
         DEFINE('JIT_UNORDR_D(R1,R2,R3)')
-PUBLIC JIT_LDXR_C(), JIT_LDXR_UC(), JIT_LDXR_S(), JIT_LDXR_US()
-PUBLIC JIT_LDXR_I(), JIT_LDXR_UI(), JIT_LDXR_L(), JIT_LDXR()
-PUBLIC JIT_LDXR_F(), JIT_LDXR_D()
         DEFINE('JIT_LDXR_C(R1,R2,R3)')
         DEFINE('JIT_LDXR_UC(R1,R2,R3)')
         DEFINE('JIT_LDXR_S(R1,R2,R3)')
         DEFINE('JIT_LDXR_US(R1,R2,R3)')
         DEFINE('JIT_LDXR_I(R1,R2,R3)')
         DEFINE('JIT_LDXR_UI(R1,R2,R3)')
         DEFINE('JIT_LDXR_L(R1,R2,R3)')
         DEFINE('JIT_LDXR(R1,R2,R3)')
         DEFINE('JIT_LDXR_F(R1,R2,R3)')
         DEFINE('JIT_LDXR_D(R1,R2,R3)')
-PUBLIC JIT_STXR_C(), JIT_STXR_S(), JIT_STXR_I(), JIT_STXR()
-PUBLIC JIT_STXR_L(), JIT_STXR_F(), JIT_STXR_D()
         DEFINE('JIT_STXR_C(R1,R2,R3)')
         DEFINE('JIT_STXR_S(R1,R2,R3)')
         DEFINE('JIT_STXR_I(R1,R2,R3)')
         DEFINE('JIT_STXR(R1,R2,R3)')
         DEFINE('JIT_STXR_L(R1,R2,R3)')
         DEFINE('JIT_STXR_F(R1,R2,R3)')
         DEFINE('JIT_STXR_D(R1,R2,R3)')
-PUBLIC JIT_BLTR(), JIT_BLTR_U(), JIT_BLER(), JIT_BLER_U()
         DEFINE('JIT_BLTR(R1,R2)')
         DEFINE('JIT_BLTR_U(R1,R2)')
         DEFINE('JIT_BLER(R1,R2)')
         DEFINE('JIT_BLER_U(R1,R2)')
-PUBLIC JIT_BGTR(), JIT_BGTR_U(), JIT_BGER(), JIT_BGER_U()
         DEFINE('JIT_BGTR(R1,R2)')
         DEFINE('JIT_BGTR_U(R1,R2)')
         DEFINE('JIT_BGER(R1,R2)')
         DEFINE('JIT_BGER_U(R1,R2)')
-PUBLIC JIT_BEQR(), JIT_BNER(), JIT_BMSR(), JIT_BMCR()
         DEFINE('JIT_BEQR(R1,R2)')
         DEFINE('JIT_BNER(R1,R2)')
         DEFINE('JIT_BMSR(R1,R2)')
         DEFINE('JIT_BMCR(R1,R2)')
-PUBLIC JIT_BOADDR(), JIT_BXADDR(), JIT_BOSUBR(), JIT_BXSUBR()
         DEFINE('JIT_BOADDR(R1,R2)')
         DEFINE('JIT_BXADDR(R1,R2)')
         DEFINE('JIT_BOSUBR(R1,R2)')
         DEFINE('JIT_BXSUBR(R1,R2)')
-PUBLIC JIT_BOADDR_U(), JIT_BXADDR_U(), JIT_BOSUBR_U(), JIT_BXSUBR_U()
         DEFINE('JIT_BOADDR_U(R1,R2)')
         DEFINE('JIT_BXADDR_U(R1,R2)')
         DEFINE('JIT_BOSUBR_U(R1,R2)')
         DEFINE('JIT_BXSUBR_U(R1,R2)')
-PUBLIC JIT_BLTR_F(), JIT_BLER_F(), JIT_BGTR_F(), JIT_BGER_F()
-PUBLIC JIT_BEQR_F(), JIT_BNER_R()
         DEFINE('JIT_BLTR_F(R1,R2)')
         DEFINE('JIT_BLER_F(R1,R2)')
         DEFINE('JIT_BGTR_F(R1,R2)')
         DEFINE('JIT_BGER_F(R1,R2)')
         DEFINE('JIT_BEQR_F(R1,R2)')
         DEFINE('JIT_BNER_R(R1,R2)')
-PUBLIC JIT_BUNLTR_F(), JIT_BUNLER_F(), JIT_BUNEQR_F()
-PUBLIC JIT_BUNGER_F(), JIT_BUNGTR_F(), JIT_BLTGTR_F()
         DEFINE('JIT_BUNLTR_F(R1,R2)')
         DEFINE('JIT_BUNLER_F(R1,R2)')
         DEFINE('JIT_BUNEQR_F(R1,R2)')
         DEFINE('JIT_BUNGER_F(R1,R2)')
         DEFINE('JIT_BUNGTR_F(R1,R2)')
         DEFINE('JIT_BLTGTR_F(R1,R2)')
-PUBLIC JIT_BORDR_F(), JIT_BUNORDR_F()
         DEFINE('JIT_BORDR_F(R1,R2)')
         DEFINE('JIT_BUNORDR_F(R1,R2)')
-PUBLIC JIT_BLTR_D(), JIT_BLER_D(), JIT_BGTR_D(), JIT_BGER_D()
-PUBLIC JIT_BEQR_D(), JIT_BNER_D()
         DEFINE('JIT_BLTR_D(R1,R2)')
         DEFINE('JIT_BLER_D(R1,R2)')
         DEFINE('JIT_BGTR_D(R1,R2)')
         DEFINE('JIT_BGER_D(R1,R2)')
         DEFINE('JIT_BEQR_D(R1,R2)')
         DEFINE('JIT_BNER_D(R1,R2)')
-PUBLIC JIT_BUNLTR_D(), JIT_BUNLER_D(), JIT_BUNEQR_D()
         DEFINE('JIT_BUNLTR_D(R1,R2)')
         DEFINE('JIT_BUNLER_D(R1,R2)')
         DEFINE('JIT_BUNEQR_D(R1,R2)')
-PUBLIC JIT_BUNGER_D(), JIT_BUNGTR_D(), JIT_BLTGTR_D()
         DEFINE('JIT_BUNGER_D(R1,R2)')
         DEFINE('JIT_BUNGTR_D(R1,R2)')
         DEFINE('JIT_BLTGTR_D(R1,R2)')
-PUBLIC JIT_BORDR_D(), JIT_BUNORDR_D()
         DEFINE('JIT_BORDR_D(R1,R2)')
         DEFINE('JIT_BUNORDR_D(R1,R2)')
-PUBLIC JIT_ADDI(), JIT_ADDCI(), JIT_ADDXI()
         DEFINE('JIT_ADDI(R1,R2,P)')
         DEFINE('JIT_ADDCI(R1,R2,P)')
         DEFINE('JIT_ADDXI(R1,R2,P)')
-PUBLIC JIT_SUBI(), JIT_SUBCI(), JIT_SUBXI()
         DEFINE('JIT_SUBI(R1,R2,P)')
         DEFINE('JIT_SUBCI(R1,R2,P)')
         DEFINE('JIT_SUBXI(R1,R2,P)')
-PUBLIC JIT_MULI(), JIT_DIVI(), JIT_DIVI_U(), JIT_REMI(), JIT_REMI_U()
         DEFINE('JIT_MULI(R1,R2,P)')
         DEFINE('JIT_DIVI(R1,R2,P)')
         DEFINE('JIT_DIVI_U(R1,R2,P)')
         DEFINE('JIT_REMI(R1,R2,P)')
         DEFINE('JIT_REMI_U(R1,R2,P)')
-PUBLIC JIT_ANDI(), JIT_ORI(), JIT_XORI(), JIT_LSHI()
-PUBLIC JIT_RSHI(), JIT_RSHI_U(),
         DEFINE('JIT_ANDI(R1,R2,P)')
         DEFINE('JIT_ORI(R1,R2,P)')
         DEFINE('JIT_XORI(R1,R2,P)')
         DEFINE('JIT_LSHI(R1,R2,P)')
         DEFINE('JIT_RSHI(R1,R2,P)')
         DEFINE('JIT_RSHI_U(R1,R2,P)')
-PUBLIC JIT_LTI(), JIT_LTI_U(), JIT_LEI(), JIT_LEI_U()
         DEFINE('JIT_LTI(R1,R2,P)')
         DEFINE('JIT_LTI_U(R1,R2,P)')
         DEFINE('JIT_LEI(R1,R2,P)')
         DEFINE('JIT_LEI_U(R1,R2,P)')
-PUBLIC JIT_GEI(), JIT_GEI_U(), JIT_GTI(), JIT_GTI_U()
         DEFINE('JIT_GEI(R1,R2,P)')
         DEFINE('JIT_GEI_U(R1,R2,P)')
         DEFINE('JIT_GTI(R1,R2,P)')
         DEFINE('JIT_GTI_U(R1,R2,P)')
-PUBLIC JIT_EQI(), JIT_NEI()
         DEFINE('JIT_EQI(R1,R2,P)')
         DEFINE('JIT_NEI(R1,R2,P)')
-PUBLIC JIT_LDXI_C(), JIT_LDXI_UC(), JIT_LDXI_S(), JIT_LDXI_US()
         DEFINE('JIT_LDXI_C(R1,R2,P)')
         DEFINE('JIT_LDXI_UC(R1,R2,P)')
         DEFINE('JIT_LDXI_S(R1,R2,P)')
         DEFINE('JIT_LDXI_US(R1,R2,P)')
-PUBLIC JIT_LDXI_I(), JIT_LDXI_UI(), JIT_LDXI_L()
         DEFINE('JIT_LDXI_I(R1,R2,P)')
         DEFINE('JIT_LDXI_UI(R1,R2,P)')
         DEFINE('JIT_LDXI_L(R1,R2,P)')
-PUBLIC JIT_LDXI(), JIT_LDXI_F(), JIT_LDXI_D()
         DEFINE('JIT_LDXI(R1,R2,P)')
         DEFINE('JIT_LDXI_F(R1,R2,P)')
         DEFINE('JIT_LDXI_D(R1,R2,P)')
-PUBLIC JIT_STXI_C(), JIT_STXI_S(), JIT_STXI_I()
         DEFINE('JIT_STXI_C(R1,P,R2)')
         DEFINE('JIT_STXI_S(R1,P,R2)')
         DEFINE('JIT_STXI_I(R1,P,R2)')
-PUBLIC JIT_STXI_L(), JIT_STXI(), JIT_STXI_F(), JIT_STXI_D()
         DEFINE('JIT_STXI_L(R1,P,R2)')
         DEFINE('JIT_STXI(R1,P,R2)')
         DEFINE('JIT_STXI_F(R1,P,R2)')
         DEFINE('JIT_STXI_D(R1,P,R2)')
-PUBLIC JIT_ADDI_F(), JIT_SUBI_F(), JIT_MULI_F(), JIT_DIVI_F()
         DEFINE('JIT_ADDI_F(R1,R2,F)')
         DEFINE('JIT_SUBI_F(R1,R2,F)')
         DEFINE('JIT_MULI_F(R1,R2,F)')
         DEFINE('JIT_DIVI_F(R1,R2,F)')
-PUBLIC JIT_ADDI_D(), JIT_SUBI_D(), JIT_MULI_D(), JIT_DIVI_D()
         DEFINE('JIT_ADDI_D(R1,R2,D)')
         DEFINE('JIT_SUBI_D(R1,R2,D)')
         DEFINE('JIT_MULI_D(R1,R2,D)')
         DEFINE('JIT_DIVI_D(R1,R2,D)')
-PUBLIC JIT_MOVR(), JIT_MOVR_F(), JIT_MOVR_D()
         DEFINE('JIT_MOVR(R1,R2)')
         DEFINE('JIT_MOVR_F(R1,R2)')
         DEFINE('JIT_MOVR_D(R1,R2)')
-PUBLIC JIT_HTONR(), JIT_NTOHR()
         DEFINE('JIT_HTONR(R1,R2)')
         DEFINE('JIT_NTOHR(R1,R2)')
-PUBLIC JIT_COMR()
         DEFINE('JIT_COMR(R1,R2)')
-PUBLIC JIT_NEGR(), JIT_NEGR_F(), JIT_NEGR_D()
         DEFINE('JIT_NEGR(R1,R2)')
         DEFINE('JIT_NEGR_F(R1,R2)')
         DEFINE('JIT_NEGR_D(R1,R2)')
-PUBLIC JIT_ABSR_F(), JIT_ABSR_D()
         DEFINE('JIT_ABSR_F(R1,R2)')
         DEFINE('JIT_ABSR_D(R1,R2)')
-PUBLIC JIT_SQRTR_F(), JIT_SQRTR_D()
         DEFINE('JIT_SQRTR_F(R1,R2)')
         DEFINE('JIT_SQRTR_D(R1,R2)')
-PUBLIC JIT_EXTR_C(), JIT_EXTR_UC(), JIT_EXTR_S(), JIT_EXTR_US()
         DEFINE('JIT_EXTR_C(R1,R2)')
         DEFINE('JIT_EXTR_UC(R1,R2)')
         DEFINE('JIT_EXTR_S(R1,R2)')
         DEFINE('JIT_EXTR_US(R1,R2)')
-PUBLIC JIT_EXTR_I(), JIT_EXTR_UI(), JIT_EXTR_F(), JIT_EXTR_D_F()
         DEFINE('JIT_EXTR_I(R1,R2)')
         DEFINE('JIT_EXTR_UI(R1,R2)')
         DEFINE('JIT_EXTR_F(R1,R2)')
         DEFINE('JIT_EXTR_D_F(R1,R2)')
-PUBLIC JIT_EXTR_D(), JIT_EXTR_F_D()
         DEFINE('JIT_EXTR_D(R1,R2)')
         DEFINE('JIT_EXTR_F_D(R1,R2)')
-PUBLIC JIT_TRUNCR_F_I(), JIT_TRUNCR_F(), JIT_TRUNCR_F_L()
-PUBLIC JIT_TRUNCR_D_I(), JIT_TRUNCR_D(), JIT_TRUNCR_D_L()
         DEFINE('JIT_TRUNCR_F_I(R1,R2)')
         DEFINE('JIT_TRUNCR_F(R1,R2)')
         DEFINE('JIT_TRUNCR_F_L(R1,R2)')
         DEFINE('JIT_TRUNCR_D_I(R1,R2)')
         DEFINE('JIT_TRUNCR_D(R1,R2)')
         DEFINE('JIT_TRUNCR_D_L(R1,R2)')
-PUBLIC JIT_LDR_C(), JIT_LDR_UC(), JIT_LDR_S(), JIT_LDR_US()
         DEFINE('JIT_LDR_C(R1,R2)')
         DEFINE('JIT_LDR_UC(R1,R2)')
         DEFINE('JIT_LDR_S(R1,R2)')
         DEFINE('JIT_LDR_US(R1,R2)')
-PUBLIC JIT_LDR_I(), JIT_LDR(), JIT_LDR_UI(), JIT_LDR_L()
         DEFINE('JIT_LDR_I(R1,R2)')
         DEFINE('JIT_LDR(R1,R2)')
         DEFINE('JIT_LDR_UI(R1,R2)')
         DEFINE('JIT_LDR_L(R1,R2)')
-PUBLIC JIT_LDR_F(), JIT_LDR_D()
         DEFINE('JIT_LDR_F(R1,R2)')
         DEFINE('JIT_LDR_D(R1,R2)')
-PUBLIC JIT_STR_C(), JIT_STR_S(), JIT_STR_I(), JIT_STR()
         DEFINE('JIT_STR_C(R1,R2)')
         DEFINE('JIT_STR_S(R1,R2)')
         DEFINE('JIT_STR_I(R1,R2)')
         DEFINE('JIT_STR(R1,R2)')
-PUBLIC JIT_STR_L(), JIT_STR_F(), JIT_STR_D()
         DEFINE('JIT_STR_L(R1,R2)')
         DEFINE('JIT_STR_F(R1,R2)')
         DEFINE('JIT_STR_D(R1,R2)')
-PUBLIC JIT_LDI_C(), JIT_LDI_UC(), JIT_LDI_S(), JIT_LDI_US()
         DEFINE('JIT_LDI_C(R,P)')
         DEFINE('JIT_LDI_UC(R,P)')
         DEFINE('JIT_LDI_S(R,P)')
         DEFINE('JIT_LDI_US(R,P)')
-PUBLIC JIT_LDI_I(), JIT_LDI(), JIT_LDI_UI(), JIT_LDI_L()
         DEFINE('JIT_LDI_I(R,P)')
         DEFINE('JIT_LDI(R,P)')
         DEFINE('JIT_LDI_UI(R,P)')
         DEFINE('JIT_LDI_L(R,P)')
-PUBLIC JIT_LDI_F(), JIT_LDI_D()
         DEFINE('JIT_LDI_F(R,P)')
         DEFINE('JIT_LDI_D(R,P)')
-PUBLIC JIT_PUSHARGI(), JIT_PUSHARGI_F(), JIT_PUSHARGI_D()
         DEFINE('JIT_PUSHARGI(P)')
         DEFINE('JIT_PUSHARGI_F(F)')
         DEFINE('JIT_PUSHARGI_D(D)')
-PUBLIC JIT_BLTI(), JIT_BLTI_U(), JIT_BLEI(), JIT_BLEI_U()
         DEFINE('JIT_BLTI(R,P)')
         DEFINE('JIT_BLTI_U(R,P)')
         DEFINE('JIT_BLEI(R,P)')
         DEFINE('JIT_BLEI_U(R,P)')
-PUBLIC JIT_BEQI(), JIT_BGEI(), JIT_BGEI_U(), JIT_BGTI()
         DEFINE('JIT_BEQI(R,P)')
         DEFINE('JIT_BGEI(R,P)')
         DEFINE('JIT_BGEI_U(R,P)')
         DEFINE('JIT_BGTI(R,P)')
-PUBLIC JIT_BGTI_U(), JIT_BNEI(), JIT_BMSI(), JIT_BMCI()
         DEFINE('JIT_BGTI_U(R,P)')
         DEFINE('JIT_BNEI(R,P)')
         DEFINE('JIT_BMSI(R,P)')
         DEFINE('JIT_BMCI(R,P)')
-PUBLIC JIT_BOADDI(), JIT_BOADDI_U(), JIT_BXADDI()
         DEFINE('JIT_BOADDI(R,P)')
         DEFINE('JIT_BOADDI_U(R,P)')
         DEFINE('JIT_BXADDI(R,P)')
-PUBLIC JIT_BXADDI_U(), JIT_BOSUBI(), JIT_BOSUBI_U()
         DEFINE('JIT_BXADDI_U(R,P)')
         DEFINE('JIT_BOSUBI(R,P)')
         DEFINE('JIT_BOSUBI_U(R,P)')
-PUBLIC JIT_BXSUBI(), JIT_BXSUBI_U()
         DEFINE('JIT_BXSUBI(R,P)')
         DEFINE('JIT_BXSUBI_U(R,P)')
-PUBLIC JIT_STI_C(), JIT_STI_S(), JIT_STI_I(), JIT_STI(), JIT_STI_L()
-PUBLIC JIT_STI_F(), JIT_STI_D()
         DEFINE('JIT_STI_C(P,R)')
         DEFINE('JIT_STI_S(P,R)')
         DEFINE('JIT_STI_I(P,R)')
         DEFINE('JIT_STI(P,R)')
         DEFINE('JIT_STI_L(P,R)')
         DEFINE('JIT_STI_F(P,R)')
         DEFINE('JIT_STI_D(P,R)')
-PUBLIC JIT_PUSHARGR(), JIT_PUSHARGR_F(), JIT_PUSHARGR_D()
         DEFINE('JIT_PUSHARGR(R)')
         DEFINE('JIT_PUSHARGR_F(R)')
         DEFINE('JIT_PUSHARGR_D(R)')
-PUBLIC JIT_RETVAL_C(), JIT_RETVAL_UC(), JIT_RETVAL_S(), JIT_RETVAL_US()
-PUBLIC JIT_RETVAL_I(), JIT_RETVAL(), JIT_RETVAL_UI(), JIT_RETVAL_L()
-PUBLIC JIT_RETVAL_F(), JIT_RETVAL_D()
         DEFINE('JIT_RETVAL_C(R)')
         DEFINE('JIT_RETVAL_UC(R)')
         DEFINE('JIT_RETVAL_S(R)')
         DEFINE('JIT_RETVAL_US(R)')
         DEFINE('JIT_RETVAL_I(R)')
         DEFINE('JIT_RETVAL(R)')
         DEFINE('JIT_RETVAL_UI(R)')
         DEFINE('JIT_RETVAL_L(R)')
         DEFINE('JIT_RETVAL_F(R)')
         DEFINE('JIT_RETVAL_D(R)')                            :(JIT_END)
*
JIT_R_NUM
         JIT_R_NUM = R_NUM_JIT()                               :(RETURN)
*
JIT_V_NUM
         JIT_V_NUM = V_NUM_JIT()                               :(RETURN)
*
JIT_F_NUM
         JIT_F_NUM = F_NUM_JIT()                               :(RETURN)
*
JIT_ARG  ARG_JIT()
         JIT_ARG = GET_P()                                     :(RETURN)
*
JIT_ARG_F
         ARG_F_JIT()
         JIT_ARG_F = GET_P()                                   :(RETURN)
*
JIT_ARG_D
         ARG_D_JIT()
         JIT_ARG_D = GET_P()                                   :(RETURN)
*
JIT_RET  RET_JIT()                                             :(RETURN)
*
JIT_RETI SET_P(P)
         RETI_JIT()                                            :(RETURN)
*
JIT_RETI_F
         SET_F(F)
         RETI_F_JIT()                                          :(RETURN)
*
JIT_RETI_D
         SET_D(D)
         RETI_D_JIT()                                          :(RETURN)
*
JIT_FINISHR
         FINISHR_JIT(R)                                        :(RETURN)
*
JIT_FINISHI
         SET_P(P)
         FINISHI_JIT()                                         :(RETURN)
*
JIT_INIT INIT_JIT(S)                                           :(RETURN)
*
JIT_FINISH
         FINISH_JIT()                                          :(RETURN)
*
JIT_MOVI SET_P(P)
         JIT_MOVI = MOVI_JIT(R)                                :(RETURN)
*
JIT_MOVI_F
         SET_F(F)
         MOVI_F_JIT(R)                                         :(RETURN)
*
JIT_MOVI_D(R,D)
         SET_D(D)
         MOVI_D_JIT(R)                                         :(RETURN)
*
JIT_GETARG
         SET_P(A)
         GETARG_JIT(R)                                         :(RETURN)
*
JIT_GETARG_C
         SET_P(A)
         GETARG_C_JIT(R)                                       :(RETURN)
*
JIT_GETARG_UC
         SET_P(A)
         GETARG_UC_JIT(R)                                      :(RETURN)
*
JIT_GETARG_S
         SET_P(A)
         GETARG_S_JIT(R)                                       :(RETURN)
*
JIT_GETARG_US
         SET_P(A)
         GETARG_US_JIT(R)                                      :(RETURN)
*
JIT_GETARG_I
         SET_P(A)
         GETARG_I_JIT(R)                                       :(RETURN)
*
JIT_GETARG_UI
         SET_P(A)
         GETARG_UI_JIT(R)                                      :(RETURN)
*
JIT_GETARG_L
         SET_P(A)
         GETARG_L_JIT(R)                                       :(RETURN)
*
JIT_GETARG_F
         SET_P(A)
         GETARG_F_JIT(R)                                       :(RETURN)
*
JIT_GETARG_D
         SET_P(A)
         GETARG_D_JIT(R)                                       :(RETURN)
*
JIT_PROLOG
         PROLOG_JIT()                                          :(RETURN)
*
JIT_EPILOG
         EPILOG_JIT()                                          :(RETURN)
*
JIT_PRINT
         PRINT_JIT()                                           :(RETURN)
*
JIT_DISASSEMBLE
         DISASSEMBLE_JIT()                                     :(RETURN)
*
JIT_LABEL
         JIT_LABEL = LABEL_JIT()                               :(RETURN)
*
JIT_ELLIPSIS
         ELLIPSIS_JIT()                                        :(RETURN)
*
JIT_EMIT JIT_EMIT = EMIT_JIT()                                 :(RETURN)
*
JIT_ADDRESS
         JIT_ADDRESS = ADDRESS_JIT(P)                          :(RETURN)
*
JIT_RETR RETR_JIT(R)                                           :(RETURN)
*
JIT_RETR_F
         RETR_F_JIT(R)                                         :(RETURN)
*
JIT_RETR_D
         RETR_D_JIT(R)                                         :(RETURN)
*
JIT_GET_STATE
         JIT_GET_STATE = GET_STATE_JIT()                       :(RETURN)
*
JIT_SET_STATE
         SET_STATE_JIT(JIT)                                    :(RETURN)
*
JIT_NEW_STATE
         JIT_NEW_STATE = NEW_STATE_JIT()                       :(RETURN)
*
JIT_DESTROY_STATE
         DESTROY_STATE_JIT()                                   :(RETURN)
*
JIT_CLEAR_STATE
         CLEAR_STATE_JIT()                                     :(RETURN)
*
JIT_JMPR JMPR_JIT(R)                                           :(RETURN)
*
JIT_JMPI SET_P(P)
         JIT_JMPI = JMPI_JIT()                                 :(RETURN)
*
JIT_CALLR
         CALLR_JIT(R)                                          :(RETURN)
*
JIT_CALLI
         SET_P(P)
         CALLI_JIT()
         JIT_CALLI = GET_P()                                   :(RETURN)
*
JIT_NOTE JIT_NOTE = NOTE_JIT(S, N)                             :(RETURN)
*
JIT_NAME JIT_NAME = NAME_JIT(S)                                :(RETURN)
*
JIT_PREPARE
         PREPARE_JIT()                                         :(RETURN)
*
JIT_ALLOCAI
         JIT_ALLOCAI = ALLOCAI_JIT(N)                          :(RETURN)
*
JIT_PATCH_AT
         SET_P(P2)
         P_TO_P2()
         SET_P(P)
         PATCH_AT_JIT()                                        :(RETURN)
*
JIT_PATCH_ABS
         SET_P(P2)
         P_TO_P2()
         SET_P(P)
         PATCH_ABS_JIT()                                       :(RETURN)
*
JIT_PATCH
         SET_P(P)
         PATCH_JIT()                                           :(RETURN)
*
JIT_ADDR ADDR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_ADDCR
         ADDCR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_ADDXR
         ADDXR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_SUBR SUBR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_SUBCR
         SUBCR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_SUBXR
         SUBXR_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_MULR MULR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_DIVR DIVR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_DIVR_U
         DIVR_U_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_REMR REMR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_REMR_U
         REMR_U_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_ANDR ANDR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_ORR  ORR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_XORR XORR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_LSHR LSHR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_RSHR RSHR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_RSHR_U
         RSHR_U_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LTR  LTR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_LTR_U
         LTR_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_LER  LER_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_LER_U
         LER_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GER  GER_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_GER_U
         GER_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GTR  GTR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_GTR_U
         GTR_U_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_EQR  EQR_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_NER  NER_JIT(R1, R2, R3)                                   :(RETURN)
*
JIT_ADDR_F
         ADDR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_ADDR_D
         ADDR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_SUBR_F
         SUBR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_SUBR_D
         SUBR_D(R1, R2, R3)                                    :(RETURN)
*
JIT_MULR_F
         MULR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_MULR_D
         MULR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_DIVR_F
         DIVR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_DIVR_D
         DIVR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LTR_F
         LTR_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_LER_F
         LER_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_EQR_F
         EQR_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GER_F
         GER_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GTR_F
         GTR_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_NER_F
         NER_F_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_UNLTR_F
         UNLTR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNLER_F
         UNLER_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNEQR_F
         UNEQR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGER_F
         UNGER_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGTR_F
         UNGTR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LTGTR_F
         LTGTR_F_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_ORDR_F
         ORDR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_UNORDR_F
         UNORDR_F_JIT(R1, R2, R3)                              :(RETURN)
*
JIT_LTR_D
         LTR_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_LER_D
         LER_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_EQR_D
         EQR_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GER_D
         GER_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_GTR_D
         GTR_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_NER_D
         NER_D_JIT(R1, R2, R3)                                 :(RETURN)
*
JIT_UNLTR_D
         UNLTR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNLER_D
         UNLER_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNEQR_D
         UNEQR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGER_D
         UNGER_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_UNGTR_D
         UNGTR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LTGTR_D
         LTGTR_D_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_ORDR_D
         ORDR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_UNORDR_D
         UNORDR_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_C
         LDXR_C_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_UC
         LDXR_UC_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LDXR_S
         LDXR_S_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_US
         LDXR_US_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LDXR_I
         LDXR_I_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_UI
         LDXR_UI_JIT(R1, R2, R3)                               :(RETURN)
*
JIT_LDXR_L
         LDXR_L_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR LDXR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_LDXR_F
         LDXR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_LDXR_D
         LDXR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_C
         STXR_C_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_S
         STRX_S_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_I
         STXR_I_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR STXR_JIT(R1, R2, R3)                                  :(RETURN)
*
JIT_STXR_L
         STXR_L_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_F
         SRXR_F_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_STXR_D
         STXR_D_JIT(R1, R2, R3)                                :(RETURN)
*
JIT_BLTR JIT_BLTR = BLTR_JIT(R1, R2)                           :(RETURN)
*
JIT_BLTR_U
         JIT_BLTR_U = BLTR_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BLER JIT_BLER = BLER_JIT(R1, R2)                           :(RETURN)
*
JIT_BLER_U
         BLER_U_JIT = BLER_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BGTR JIT_BGTR = BGTR_JIT(R1, R2)                           :(RETURN)
*
JIT_BGTR_U
         JIT_BGTR_U = BGTR_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BGER JIT_BGER = BGER_JIT(R1, R2)                           :(RETURN)
*
JIT_BGER_U
         JIT_BGER_U = BGER_U_JIT(R1, R2)                       :(RETURN)
*
JIT_BEQR JIT_BEQR = BEQR_JIT(R1, R2)                           :(RETURN)
*
JIT_BNER JIT_BNER = BNER_JIT(R1, R2)                           :(RETURN)
*
JIT_BMSR JIT_BMSR = BMSR_JIT(R1, R2)                           :(RETURN)
*
JIT_BMCR JIT_BMCR = BMCR_JIT(R1, R2)                           :(RETURN)
*
JIT_BOADDR
         JIT_BOADDR = BOADDR_JIT(R1, R2)                       :(RETURN)
*
JIT_BXADDR
         JIT_BXADDR = BXADDR_JIT(R1, R2)                       :(RETURN)
*
JIT_BOSUBR
         JIT_BOSUBR = BOSUBR_JIT(R1, R2)                       :(RETURN)
*
JIT_BXSUBR
         JIT_BXSUBR = BXSUBR_JIT(R1, R2)                       :(RETURN)
*
JIT_BOADDR_U
         JIT_BOADDR_U = BOADDR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BXADDR_U
         JIT_BXADDR_U = BXADDR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BOSUBR_U
         JIT_BOSUBR_U = BOSUBR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BXSUBR_U
         JIT_BXSUBR_U = BXSUBR_U_JIT(R1, R2)                   :(RETURN)
*
JIT_BLTR_F
         JIT_BLTR_F = BLTR_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BLER_F
         JIT_BLER_F = BLER_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BGTR_F
         JIT_BGTR_F = BGTR_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BGER_F
         JIT_BGER_F = BGER_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BEQR_F
         JIT_BEQR_F = BEQR_F_JIT(R1, R2)                       :(RETURN)
*
JIT_BNER_R
         JIT_BNER_R = BNER_R_JIT(R1, R2)                       :(RETURN)
*
JIT_BUNLTR_F
         JIT_BUNLTR_F = BUNLTR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNLER_F
         JIT_BUNLER_F = BUNLER_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNEQR_F
         JIT_BUNEQR_F = BUNEQR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGER_F
         JIT_BUNGER_F = BUNGER_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGTR_F
         JIT_BUNGTR_F = BUNGTR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BLTGTR_F
         JIT_BLTGTR_F = BLTGTR_F_JIT(R1, R2)                   :(RETURN)
*
JIT_BORDR_F
         JIT_BORDR_F = BORDR_F_JIT(R1, R2)                     :(RETURN)
*
JIT_BUNORDR_F
         JIT_BUNORDR_F = BUNORDR_F_JIT(R1, R2)                 :(RETURN)
*
JIT_BLTR_D
         JIT_BLTR_D = BLTR_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BLER_D
         JIT_BLER_D = BLER_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BGTR_D
         JIT_BGTR_D = BGTR_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BGER_D
         JIT_BGER_D = BGER_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BEQR_D
         JIT_BEQR_D = BEQR_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BNER_D
         JIT_BNER_D = BNER_D_JIT(R1, R2)                       :(RETURN)
*
JIT_BUNLTR_D
         JIT_BUNLTR_D = BUNLTR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNLER_D
         JIT_BUNLER_D = BUNLER_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNEQR_D
         JIT_BUNEQR_D = BUNEQR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGER_D
         JIT_BUNGER_D = BUNGER_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BUNGTR_D
         JIT_BUNGTR_D = BUNGTR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BLTGTR_D
         JIT_BLTGTR_D = BLTGTR_D_JIT(R1, R2)                   :(RETURN)
*
JIT_BORDR_D
         JIT_BORDR_D = BORDR_D_JIT(R1, R2)                     :(RETURN)
*
JIT_BUNORDR_D
         JIT_BUNORDR_D = BUNORDR_D_JIT(R1, R2)                 :(RETURN)
*
JIT_ADDI SET_P(P)
         ADDI_JIT(R1, R2)                                      :(RETURN)
*
JIT_ADDCI
         SET_P(P)
         ADDCI_JIT(R1, R2)                                     :(RETURN)
*
JIT_ADDXI
         SET_P(P)
         ADDXI_JIT(R1, R2)                                     :(RETURN)
*
JIT_SUBI SET_P(P)
         SUBI_JIT(R1, R2)                                      :(RETURN)
*
JIT_SUBCI
         SET_P(P)
         SUBCI_JIT(R1, R2)                                     :(RETURN)
*
JIT_SUBXI
         SET_P(P)
         SUBXI_JIT(R1, R2)                                     :(RETURN)
*
JIT_MULI SET_P(P)
         MULI_JIT(R1, R2)                                      :(RETURN)
*
JIT_DIVI SET_P(P)
         DIVI_JIT(R1, R2)                                      :(RETURN)
*
JIT_DIVI_U
         SET_P(P)
         DIVI_U_JIT(R1, R2)                                    :(RETURN)
*
JIT_REMI SET_P(P)
         REMI_JIT(R1, R2)                                      :(RETURN)
*
JIT_REMI_U
         SET_P(P)
         REMI_U_JIT(R1, R2)                                    :(RETURN)
*
JIT_ANDI SET_P(P)
         ANDI_JIT(R1, R2)                                      :(RETURN)
*
JIT_ORI  SET_P(P)
         ORI_JIT(R1, R2)                                       :(RETURN)
*
JIT_XORI SET_P(P)
         XORI_JIT(R1, R2)                                      :(RETURN)
*
JIT_LSHI SET_P(P)
         LSHI_JIT(R1, R2)                                      :(RETURN)
*
JIT_RSHI SET_P(P)
         RSHI_JIT(R1, R2)                                      :(RETURN)
*
JIT_RSHI_U
         SET_P(P)
         RSHI_U_JIT(R1, R2)                                    :(RETURN)
*
JIT_LTI  SET_P(P)
         LTI_JIT(R1, R2)                                       :(RETURN)
*
JIT_LTI_U
         SET_P(P)
         LTI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_LEI  SET_P(P)
         LEI_JIT(R1, R2)                                       :(RETURN)
*
JIT_LEI_U
         SET_P(P)
         LEI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_GEI  SET_P(P)
         GEI_JIT(R1, R2)                                       :(RETURN)
*
JIT_GEI_U
         SET_P(P)
         GEI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_GTI  SET_P(P)
         GTI_JIT(R1, R2)                                       :(RETURN)
*
JIT_GTI_U
         SET_P(P)
         GTI_U_JIT(R1, R2)                                     :(RETURN)
*
JIT_EQI  SET_P(P)
         EQI_JIT(R1, R2)                                       :(RETURN)
*
JIT_NEI  SET_P(P)
         NEI_JIT(R1, R2)                                       :(RETURN)
*
JIT_LDXI_C
         SET_P(P)
         LDXI_C_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_UC
         SET_P(P)
         LDXI_UC_JIT(R1, R2)                                   :(RETURN)
*
JIT_LDXI_S
         SET_P(P)
         LDXI_S_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_US
         SET_P(P)
         LDXI_US_JIT(R1, R2)                                   :(RETURN)
*
JIT_LDXI_I
         SET_P(P)
         LDXI_I_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_UI
         SET_P(P)
         LDXI_UI_JIT(R1, R2)                                   :(RETURN)
*
JIT_LDXI_L
         SET_P(P)
         LDXI_L_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI SET_P(P)
         LDXI_JIT(R1, R2)                                      :(RETURN)
*
JIT_LDXI_F
         SET_P(P)
         LDXI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDXI_D
         SET_P(P)
         LDXI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_C
         SET_P(P)
         STXI_C_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_S
         SET_P(P)
         STXI_S_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_I
         SET_P(P)
         STXI_I_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_L
         SET_P(P)
         STXI_L_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI
         SET_P(P)
         STXI_JIT(R1, R2)                                      :(RETURN)
*
JIT_STXI_F
         SET_P(P)
         STXI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_STXI_D
         SET_P(P)
         STXI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_ADDI_F
         SET_F(F)
         ADDI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_SUBI_F
         SET_F(F)
         SUBI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_MULI_F
         SET_F(F)
         MULI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_DIVI_F
         SET_F(F)
         DIVI_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_ADDI_D
         SET_D(D)
         ADDI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_SUBI_D
         SET_D(D)
         SUBI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_MULI_D
         SET_D(D)
         MULI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_DIVI_D
         SET_D(D)
         DIVI_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_MOVR MOVR_JIT(R1, R2)                                      :(RETURN)
*
JIT_MOVR_F
         MOVR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_MOVR_D
         MOVR_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_HTONR
         HTONR_JIT(R1, R2)                                     :(RETURN)
*
JIT_NTOHR
         NTOHR_JIT(R1, R2)                                     :(RETURN)
*
JIT_COMR COMR_JIT(R1, R2)                                      :(RETURN)
*
JIT_NEGR NEGR_JIT(R1, R2)                                      :(RETURN)
*
JIT_NEGR_F
         NEGR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_NEGR_D
         NEGR_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_ABSR_F
         ABSR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_ABSR_D
         ABSR_D_JIT(R1, R2)                                    :(RETURN)
JIT_SQRTR_F
         SQRTR_F_JIT(R1, R2)                                   :(RETURN)
*
JIT_SQRTR_D
         SQRTR_D_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_C
         EXTR_C_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_UC
         EXTR_UC_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_S
         EXTR_S_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_US
         EXTR_US_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_I
         EXTR_I_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_UI
         EXTR_UI_JIT(R1, R2)                                   :(RETURN)
*
JIT_EXTR_F
         EXTR_F_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_D_F
         EXTR_D_F_JIT(R1, R2)                                  :(RETURN)
*
JIT_EXTR_D
         EXTR_D_JIT(R1, R2)                                    :(RETURN)
*
JIT_EXTR_F_D
         EXTR_F_D_JIT(R1, R2)                                  :(RETURN)
*
JIT_TRUNCR_F_I
         TRUNCR_F_I_JIT(R1, R2)                                :(RETURN)
*
JIT_TRUNCR_F
         TRUNCR_F_JIT(R1, R2)                                  :(RETURN)
*
JIT_TRUNCR_F_L
         TRUNCR_F_L_JIT(R1, R2)                                :(RETURN)
*
JIT_TRUNCR_D_I
         TRUNCR_D_I_JIT(R1, R2)                                :(RETURN)
*
JIT_TRUNCR_D
         TRUNCR_D_JIT(R1, R2)                                  :(RETURN)
*
JIT_TRUNCR_D_L
         TRUNCR_D_L_JIT(R1, R2)                                :(RETURN)
*
JIT_LDR_C
         LDR_C_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_UC
         LDR_UC_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDR_S
         LDR_S_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_US
         LDR_US_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDR_I
         LDR_I_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR
         LDR_JIT(R1, R2)                                       :(RETURN)
*
JIT_LDR_UI
         LDR_UI_JIT(R1, R2)                                    :(RETURN)
*
JIT_LDR_L
         LDR_L_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_F
         LDR_F_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDR_D
         LDR_D_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_C
         STR_C_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_S
         STR_S_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_I
         STR_I_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR  STR_JIT(R1, R2)                                       :(RETURN)
*
JIT_STR_L
         STR_L_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_F
         STR_F_JIT(R1, R2)                                     :(RETURN)
*
JIT_STR_D
         STR_D_JIT(R1, R2)                                     :(RETURN)
*
JIT_LDI_C
         SET_P(P)
         LDI_C_JIT(R)                                          :(RETURN)
*
JIT_LDI_UC
         SET_P(P)
         LDI_UC_JIT(R)                                         :(RETURN)
*
JIT_LDI_S
         SET_P(P)
         LDI_S_JIT(R)                                          :(RETURN)
*
JIT_LDI_US
         SET_P(P)
         LDI_US_JIT(R)                                         :(RETURN)
*
JIT_LDI_I
         SET_P(P)
         LDI_I_JIT(R)                                          :(RETURN)
*
JIT_LDI  SET_P(P)
         LDI_JIT(R)                                            :(RETURN)
*
JIT_LDI_UI
         SET_P(P)
         LDI_UI_JIT(R)                                         :(RETURN)
*
JIT_LDI_L
         SET_P(P)
         LDI_L_JIT(R)                                          :(RETURN)
*
JIT_LDI_F
         SET_P(P)
         LDI_F_JIT(R)                                          :(RETURN)
*
JIT_LDI_D
         SET_P(P)
         LDI_D_JIT(R)                                          :(RETURN)
*
JIT_PUSHARGI
         SET_P(P)
         PUSHARGI_JIT()                                        :(RETURN)
*
JIT_PUSHARGI_F
         SET_F(F)
         PUSHARGI_F_JIT()                                      :(RETURN)
*
JIT_PUSHARGI_D
         SET_D(D)
         PUSHARGI_D_JIT()                                      :(RETURN)
*
JIT_BLTI SET_P(P)
         BLTI_JIT(R)                                           :(RETURN)
*
JIT_BLTI_U
         SET_P(P)
         BLTI_U_JIT(R)                                         :(RETURN)
*
JIT_BLEI SET_P(P)
         BLEI_JIT(R)                                           :(RETURN)
*
JIT_BLEI_U
         SET_P(P)
         BLEI_U_JIT(R)                                         :(RETURN)
*
JIT_BEQI SET_P(P)
         BEQI_JIT(R)                                           :(RETURN)
*
JIT_BGEI SET_P(P)
         BGEI_JIT(R)                                           :(RETURN)
*
JIT_BGEI_U
         SET_P(P)
         BGEI_U_JIT(R)                                         :(RETURN)
*
JIT_BGTI SET_P(P)
         BGTI_JIT(R)                                           :(RETURN)
*
JIT_BGTI_U
         SET_P(P)
         BGTI_U_JIT(R)                                         :(RETURN)
*
JIT_BNEI SET_P(P)
         BNEI_JIT(R)                                           :(RETURN)
*
JIT_BMSI SET_P(P)
         BMSI_JIT(R)                                           :(RETURN)
*
JIT_BMCI SET_P(P)
         BMCI_JIT(R)                                           :(RETURN)
*
JIT_BOADDI
         SET_P(P)
         BOADDI_JIT(R)                                         :(RETURN)
*
JIT_BOADDI_U
         SET_P(P)
         BOADDI_U_JIT(R)                                       :(RETURN)
*
JIT_BXADDI
         SET_P(P)
         BXADDI_JIT(R)                                         :(RETURN)
*
JIT_BXADDI_U
         SET_P(P)
         BXADDI_U_JIT(R)                                       :(RETURN)
*
JIT_BOSUBI
         SET_P(P)
         BOSUBI_JIT(R)                                         :(RETURN)
*
JIT_BOSUBI_U
         SET_P(P)
         BOSUBI_U_JIT(R)                                       :(RETURN)
*
JIT_BXSUBI
         SET_P(P)
         BXSUBI_JIT(R)                                         :(RETURN)
*
JIT_BXSUBI_U
         SET_P(P)
         BXSUBI_U_JIT(R)                                       :(RETURN)
*
JIT_STI_C
         SET_P(P)
         STI_C_JIT(R)                                          :(RETURN)
*
JIT_STI_S
         SET_P(P)
         STI_S_JIT(R)                                          :(RETURN)
*
JIT_STI_I
         SET_P(P)
         STI_I_JIT(R)                                          :(RETURN)
*
JIT_STI  SET_P(P)
         STI_JIT(R)                                            :(RETURN)
*
JIT_STI_L
         SET_P(P)
         STI_L_JIT(R)                                          :(RETURN)
*
JIT_STI_F
         SET_P(P)
         STI_F_JIT(R)                                          :(RETURN)
*
JIT_STI_D
         SET_P(P)
         STI_D_JIT(R)                                          :(RETURN)
*
JIT_PUSHARGR
         PUSHARGR_JIT(R)                                       :(RETURN)
*
JIT_PUSHARGR_F
         PUSHARGR_F_JIT(R)                                     :(RETURN)
*
JIT_PUSHARGR_D
         PUSHARGR_D_JIT(R)                                     :(RETURN)
*
JIT_RETVAL_C
         RETVAL_C_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_UC
         RETVAL_UC_JIT(R)                                      :(RETURN)
*
JIT_RETVAL_S
         RETVAL_S_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_US
         RETVAL_US_JIT(R)                                      :(RETURN)
*
JIT_RETVAL_I
         RETVAL_I_JIT(R)                                       :(RETURN)
*
JIT_RETVAL
         RETVAL_JIT(R)                                         :(RETURN)
*
JIT_RETVAL_UI
         RETVAL_UI_JIT(R)                                      :(RETURN)
*
JIT_RETVAL_L
         RETVAL_L_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_F
         RETVAL_F_JIT(R)                                       :(RETURN)
*
JIT_RETVAL_D
         RETVAL_D_JIT(R)                                       :(RETURN)
*
JIT_END  CODE('JIT_DEFINE')
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>JIT - Just In Time Code Generation</h1>
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
This is broken until all set_p() get_p() calls are replaced with
long/pointer code. The process will take several days.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
Interface to the GNU Lightning library to allow dynamic code production
at run-time for: ARM, HPPA, IA64, MIPS, PPC, S390, SPARC, Intel X86
(32 bit) and X86_64.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
GNU Lightning does not have an ELF writer. It does appear to support
all of the platforms that I would want.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="P64.html">P64</a><br>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;P64.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JIT&raquo;&equiv;</b>
-CASE 1
-PLUSOPS 1
-SNOBOL TERMINAL = &#39;JIT (THU JUL  4 14:54:49 EDT 2013)&#39;
-SNOBOL SLOAD(&#39;CRACK.INC&#39;)
-SNOBOL SLOAD(&#39;SEQ.INC&#39;)
-SNOBOL SLOAD(&#39;DYNAMIC.INC&#39;)
-SNOBOL SLOAD(&#39;WRAPPER.INC&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JIT&raquo;&equiv;</b>
-EMBED C &#39;jit&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JIT,TYPE=C&raquo;&equiv;</b>
-SNOBOL WRAPPER_STARTFILE(.EMBED)

<font color="#818181"><i>#include &lt;lightning.h&gt;</i></font>

/* Setup, state and misc */
-SNOBOL C_WRAPPER_PROTO(&#39;INIT_JIT(STRING)&#39;, .EMBED)
-SNOBOL C_WRAPPER_PROTO(&#39;FINISH_JIT()&#39;, .EMBED)

static jit_state_t *_jit;

static long get_state_jit(void) { return (long)_jit; }

-SNOBOL C_WRAPPER_PROTO(&#39;GET_STATE_JIT()LONG&#39;, .EMBED)

static void set_state_jit(long p) { _jit = (void *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;SET_STATE_JIT(LONG)&#39;, .EMBED)

static long new_state_jit(void) { return (long)jit_new_state(); }

-SNOBOL C_WRAPPER_PROTO(&#39;NEW_STATE_JIT()LONG&#39;, .EMBED)

static void destroy_state_jit(void) { jit_destroy_state(); }

-SNOBOL C_WRAPPER_PROTO(&#39;DESTROY_STATE_JIT()&#39;, .EMBED)

static void clear_state_jit(void) { jit_clear_state(); }

-SNOBOL C_WRAPPER_PROTO(&#39;CLEAR_STATE_JIT()&#39;, .EMBED)

static void prolog_jit(void) { jit_prolog(); }

-SNOBOL C_WRAPPER_PROTO(&#39;PROLOG_JIT()&#39;, .EMBED)

static void epilog_jit(void) { jit_epilog(); }

-SNOBOL C_WRAPPER_PROTO(&#39;EPILOG_JIT()&#39;, .EMBED)

static long note_jit(char *s, int n) { return (long)jit_note(s, n); }

-SNOBOL C_WRAPPER_PROTO(&#39;NOTE_JIT(STRING,INTEGER)LONG&#39;, .EMBED)

static long name_jit(char *s) { return (long)jit_name(s); }

-SNOBOL C_WRAPPER_PROTO(&#39;NAME_JIT(STRING)LONG&#39;, .EMBED)

static long address_jit(long p) { return (long)jit_address((void *)p); }

-SNOBOL C_WRAPPER_PROTO(&#39;ADDRESS_JIT(LONG)LONG&#39;, .EMBED)

static void disassemble_jit(void) { jit_disassemble(); }

-SNOBOL C_WRAPPER_PROTO(&#39;DISASSEMBLE_JIT()&#39;, .EMBED)

static long emit_jit(void) { (long)jit_emit(); }

-SNOBOL C_WRAPPER_PROTO(&#39;EMIT_JIT()LONG&#39;, .EMBED)

static void print_jit(void) { jit_print(); }

-SNOBOL C_WRAPPER_PROTO(&#39;PRINT_JIT()&#39;, .EMBED)

static long label_jit(void) { return (long)jit_label(); }

-SNOBOL C_WRAPPER_PROTO(&#39;LABEL_JIT()INTEGER&#39;, .EMBED)

static void ellipsis_jit(void) { jit_ellipsis(); }

-SNOBOL C_WRAPPER_PROTO(&#39;ELLIPSIS_JIT()&#39;, .EMBED)

//static int get_note_jit(void)
//{
//    int notei;
//    void *p, *p2;
//    jit_get_note(get_p_(), (char **)&amp;p, (char **)&amp;p2, &amp;notei);
//    set_p_(p);
//    set_p2_(p2);
//    return notei;
//}

-CMNT -SNOBOL C_WRAPPER_PROTO(&#39;GET_NOTE_JIT()INTEGER&#39;, .EMBED)

static int pointer_p_jit(void) { return jit_pointer_p(get_p_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;POINTER_P_JIT()PREDICATE&#39;, .EMBED)

static int callee_save_p(int r) { return jit_callee_save_p(r); }

-SNOBOL C_WRAPPER_PROTO(&#39;CALLEE_SAVE_P_JIT(INTEGER)PREDICATE&#39;, .EMBED)

static void patch_at_jit(void) { jit_patch_at(get_p_(), get_p2_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;PATCH_AT_JIT()&#39;, .EMBED)

static void patch_abs_jit(void) { jit_patch_abs(get_p_(), get_p2_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;PATCH_ABS_JIT()&#39;, .EMBED)

static void patch_jit(void) { jit_patch(get_p_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;PATCH_JIT()&#39;, .EMBED)

static void prepare_jit(void) { jit_prepare(); }

-SNOBOL C_WRAPPER_PROTO(&#39;PREPARE_JIT()&#39;, .EMBED)

static int allocai_jit(int n) { return jit_allocai(n); }

-SNOBOL C_WRAPPER_PROTO(&#39;ALLOCAI_JIT(INTEGER)INTEGER&#39;, .EMBED)

/* DATA, LENGTH, ALIGNMENT (0..4). DATA/LENGTH HASHED */
static long data_jit(long p, int l, int a)
{
    return (long)jit_data((void *)p, l, a);
}

-SNOBOL C_WRAPPER_PROTO(&#39;DATA_JIT(LONG,INTEGER,INTEGER)LONG&#39;, .EMBED)

static long forward_jit(void) { return (long)jit_forward(); }

-SNOBOL C_WRAPPER_PROTO(&#39;FORWARD_JIT()LONG&#39;, .EMBED)

static void live_jit(int r) { jit_live(r); }

-SNOBOL C_WRAPPER_PROTO(&#39;LIVE_JIT(INTEGER)&#39;, .EMBED)

static void link_jit(void) { jit_link(get_p_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;LINK_JIT()&#39;, .EMBED)

/* REGISTERS */
static int r_num_jit(void) { return jit_r_num(); }

-SNOBOL C_WRAPPER_PROTO(&#39;R_NUM_JIT()INTEGER&#39;, .EMBED)

static int v_num_jit(void) { return jit_v_num(); }

-SNOBOL C_WRAPPER_PROTO(&#39;V_NUM_JIT()INTEGER&#39;, .EMBED)

static int f_num_jit(void) { return jit_f_num(); }

-SNOBOL C_WRAPPER_PROTO(&#39;F_NUM_JIT()INTEGER&#39;, .EMBED)

-SNOBOL L = &#39;r0 r1 r2 r3 v0 v1 v2 v3 f0 f1 f2 f3 f4 f5 f6 f7 fp&#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static int get_&#39; A&lt;I&gt; &#39;_jit(void) { &#39;; &quot;        +
            &quot; EMBED = &#39;#ifdef JIT_&#39; AU&lt;I&gt;; &quot;                           +
            &quot; EMBED = &#39;    return JIT_&#39; AU&lt;I&gt; &#39;;&#39;; &quot;                   +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;#else&#39;; &quot;                          +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;    return -1;&#39;; &quot;                 +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;#endif&#39;; &quot;                         +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(&#39;GET_&#39; AU&lt;I&gt; &#39;_JIT()INTEGER&#39;, .EMBED) &quot;  +
            , .I)

/* REGISTER MATH */
-SNOBOL L = &#39;addr addcr addxr subr subcr subxr mulr divr divr_u &#39;      +
            &#39;remr remr_u andr orr xorr lshr rshr rshr_u &#39;              +
            &#39;ltr ltr_u ler ler_u ger ger_u gtr gtr_u eqr ner &#39;         +
            &#39;addr_f addr_d subr_f subr_d mulr_f mulr_d divr_f divr_d &#39; +
            &#39;ltr_f ler_f eqr_f ger_f gtr_f ner_f unltr_f unler_f &#39;     +
            &#39;uneqr_f unger_f ungtr_f ltgtr_f ordr_f unordr_f &#39;         +
            &#39;ltr_d ler_d eqr_d ger_d gtr_d ner_d unltr_d unler_d &#39;     +
            &#39;uneqr_d unger_d ungtr_d ltgtr_d ordr_d unordr_d &#39;         +
            &#39;ldxr_c ldxr_uc ldxr_s ldxr_us ldxr_i ldxr_ui ldxr_l &#39;     +
            &#39;ldxr ldxr_f ldxr_d &#39;                                      +
            &#39;stxr_c stxr_s stxr_i stxr stxr_l stxr_f stxr_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; &quot;                                 +
            &quot; A&lt;I&gt; &#39;_jit(int r1, int r2, int r3) { &#39;; &quot;                +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r1, r2, r3);&#39;; &quot;               +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER,INTEGER)&#39;, &quot; +
            &quot; .EMBED) &quot;, .I)

/* INTEGER IMMEDIATE MATH */
-SNOBOL L = &#39;addi addci addxi subi subci subxi muli divi divi_u &#39;      +
            &#39;remi remi_u andi ori xori lshi rshi rshi_u &#39;              +
            &#39;lti lti_u lei lei_u gei gei_u gti gti_u eqi nei &#39;         +
            &#39;ldxi_c ldxi_uc ldxi_s ldxi_us ldxi_i ldxi_ui ldxi_l &#39;     +
            &#39;ldxi ldxi_f ldxi_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r1, int r2) { &#39;; &quot; +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r1, r2, (long)get_p_());&#39;; &quot;   +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &quot;         +
            &quot; .EMBED) &quot;, .I)

-SNOBOL L = &#39;stxi_c stxi_s stxi_i stxi_l stxi stxi_f stxi_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r1, int r2) { &#39;; &quot; +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r1, (long)get_p_(), r2);&#39;; &quot;   +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &quot;         +
            &quot; .EMBED) &quot;, .I)

/* FLOAT IMMEDIATE MATH */
-SNOBOL L = &#39;addi_f subi_f muli_f divi_f &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r1, int r2) { &#39;; &quot; +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r1, r2, get_f_());&#39;; &quot;         +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &quot;         +
            &quot; .EMBED) &quot;, .I)

/* DOUBLE IMMEDIATE MATH */
-SNOBOL L = &#39;addi_d subi_d muli_d divi_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r1, int r2) { &#39;; &quot; +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r1, r2, get_d_());&#39;; &quot;         +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &quot;         +
            &quot; .EMBED) &quot;, .I)

/* BRANCH - REGISTER */
-SNOBOL L = &#39;bltr bltr_u bler bler_u bgtr bgtr_u bger bger_u &#39;         +
            &#39;beqr bner bmsr bmcr boaddr bxaddr bosubr bxsubr &#39;         +
            &#39;boaddr_u bxaddr_u bosubr_u bxsubr_u &#39;                     +
            &#39;bltr_f bler_f bgtr_f bger_f beqr_f bner_f &#39;               +
            &#39;bunltr_f bunler_f buneqr_f bunger_f bungtr_f &#39;            +
            &#39;bltgtr_f bordr_f bunordr_f &#39;                              +
            &#39;bltr_d bler_d bgtr_d bger_d beqr_d bner_d &#39;               +
            &#39;bunltr_d bunler_d buneqr_d bunger_d bungtr_d &#39;            +
            &#39;bltgtr_d bordr_d bunordr_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static long &#39; A&lt;I&gt; &#39;_jit(int r1, int r2) { &#39;; &quot; +
            &quot; EMBED = &#39;    return (long)jit_&#39; A&lt;I&gt; &#39;(r1, r2);&#39;; &quot;      +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)LONG&#39;, &quot;     +
            &quot; .EMBED) &quot;, .I)

/* TWO REGISTER MOV, HTONR, NTOHR, COM, NEG, ABS, SQRT, EXT, TRUNC */
-SNOBOL L = &#39;movr movr_f movr_d movr_f_w movr_w_f movr_d_w movr_w_d &#39;  +
            &#39;htonr ntohr comr negr negr_f negr_d absr_f absr_d &#39;       +
            &#39;sqrtr_f sqrtr_d &#39;                                         +
            &#39;extr_c extr_uc extr_s extr_us extr_i extr_ui &#39;            +
            &#39;extr_f extr_d_f extr_d extr_f_d &#39;                         +
            &#39;truncr_f_i truncr_f truncr_f_l truncr_d_i truncr_d &#39;      +
            &#39;truncr_d_l &#39;                                              +
            &#39;ldr_c ldr_uc ldr_s ldr_us ldr_i ldr ldr_ui ldr_l &#39;        +
            &#39;ldr_f ldr_d &#39;                                             +
            &#39;str_c str_s str_i str str_l str_f str_d&#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r1, int r2) { &#39;; &quot; +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r1, r2);&#39;; &quot;                   +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &quot;         +
            &quot; .EMBED) &quot;, .I)

/* THREE REGISTER MOV */
-SNOBOL L = &#39;movr_d_ww movr_ww_d&#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39;&quot;                                  +
            &quot; A&lt;I&gt; &#39;_jit(int r,int s,int t) { &#39;; &quot;                     +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r, s, t);&#39;; &quot;                  +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER,INTEGER,INTEGER)&#39;, &quot; +
            &quot; .EMBED) &quot;, .I)

static long movi_jit(int r1)
{
    return (long)jit_movi(r1, (jit_word_t)get_p_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;MOVI_JIT(INTEGER)LONG&#39;, .EMBED)

static void movi_f_jit(int r1)
{
    jit_movi_f(r1, get_f_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;MOVI_F_JIT(INTEGER)&#39;, .EMBED)

static void movi_d_jit(int r1)
{
    jit_movi_d(r1, get_d_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;MOVI_D_JIT(INTEGER)&#39;, .EMBED)

static void movi_f_w_jit(int r1)
{
    jit_movi_f_w(r1, get_f_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;MOVI_F_W_JIT(INTEGER)&#39;, .EMBED)

static void movi_d_w_jit(int r1)
{
    jit_movi_d_w(r1, get_d_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;MOVI_D_W_JIT(INTEGER)&#39;, .EMBED)

static void movi_d_ww_jit(int r1, int r2)
{
    jit_movi_d_ww(r1, r2, get_d_());
}

-SNOBOL C_WRAPPER_PROTO(&#39;MOVI_D_WW_JIT(INTEGER,INTEGER)&#39;, .EMBED)

/* ARG */
-SNOBOL L = &#39;arg arg_f arg_d&#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(void) { &#39;; &quot;           +
            &quot; EMBED = &#39;    set_p_(jit_&#39; A&lt;I&gt; &#39;());&#39;; &quot;                 +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT()&#39;, &quot;                        +
            &quot; .EMBED) &quot;, .I)

-SNOBOL L = &#39;getarg getarg_c getarg_uc getarg_s getarg_us getarg_i &#39;   +
            &#39;getarg_ui getarg_l getarg_f getarg_d &#39;                    +
            &#39;ldi_c ldi_uc ldi_s ldi_us ldi_i ldi ldi_ui ldi_l ldi_f &#39;  +
            &#39;ldi_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r) { &#39;; &quot;          +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r, get_p_());&#39;; &quot;              +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER)&#39;, &quot;                 +
            &quot; .EMBED) &quot;, .I)

-SNOBOL L = &#39;blti blti_u blei blei_u beqi bgei bgei_u bgti bgti_u &#39;    +
            &#39;bnei bmsi bmci boaddi boaddi_u bxaddi bxaddi_u &#39;          +
            &#39;bosubi bosubi_u bxsubi bxsubi_u &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r) { &#39;; &quot;          +
        &quot; EMBED = &#39; set_p_(jit_&#39; A&lt;I&gt; &#39;(r, (jit_word_t)get_p_()));&#39;; &quot; +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER)&#39;, &quot;                 +
            &quot; .EMBED) &quot;, .I)

-SNOBOL L = &#39;sti_c sti_s sti_i sti sti_l sti_f sti_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r) { &#39;; &quot;          +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(get_p_(), r);&#39;; &quot;              +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER)&#39;, &quot;                 +
            &quot; .EMBED) &quot;, .I)

-SNOBOL L = &#39;pushargr pushargr_f pushargr_d &#39;                          +
            &#39;retr retval_c retval_uc retval_s retval_us retval_i &#39;     +
            &#39;retval retval_ui retval_l retr_f retval_f &#39;               +
            &#39;retr_d retval_d &#39;
-SNOBOL LU = REPLACE(L, &amp;LCASE, &amp;UCASE)
-SNOBOL A = CRACK(L, &#39; &#39;)
-SNOBOL AU = CRACK(LU, &#39; &#39;)
-SNOBOL SEQ(&quot; EMBED = &#39;static void &#39; A&lt;I&gt; &#39;_jit(int r) { &#39;; &quot;          +
            &quot; EMBED = &#39;    jit_&#39; A&lt;I&gt; &#39;(r);&#39;; &quot;                        +
            &quot; EMBED = DIFFER(A&lt;I&gt;) &#39;}&#39;; &quot;                              +
            &quot; C_WRAPPER_PROTO(AU&lt;I&gt; &#39;_JIT(INTEGER)&#39;, &quot;                 +
            &quot; .EMBED) &quot;, .I)

static void pushargi_jit(void) { jit_pushargi((jit_word_t)get_p_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;PUSHARGI_JIT()&#39;, .EMBED)

static void pushargi_f_jit(void) { jit_pushargi_f(get_f_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;PUSHARGI_F_JIT()&#39;, .EMBED)

static void pushargi_d_jit(void) { jit_pushargi_d(get_d_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;PUSHARGI_D_JIT()&#39;, .EMBED)

static void jmpr_jit(int r) { jit_jmpr(r); }

-SNOBOL C_WRAPPER_PROTO(&#39;JMPR_JIT(INTEGER)&#39;, .EMBED)

static long jmpi_jit(void) { return (long)jit_jmpi(); }

-SNOBOL C_WRAPPER_PROTO(&#39;JMPI_JIT()LONG&#39;, .EMBED)

static void callr_jit(int r) { jit_callr(r); }

-SNOBOL C_WRAPPER_PROTO(&#39;CALLR_JIT(INTEGER)&#39;, .EMBED)

static void calli_jit(void) { set_p_(jit_calli(get_p_())); }

-SNOBOL C_WRAPPER_PROTO(&#39;CAllI_JIT()&#39;, .EMBED)

static void finishr_jit(int r) { jit_finishr(r); }

-SNOBOL C_WRAPPER_PROTO(&#39;FINISHR_JIT(INTEGER)&#39;, .EMBED)

static void finishi_jit(void) { set_p_(jit_finishi(get_p_())); }

-SNOBOL C_WRAPPER_PROTO(&#39;FINISHI_JIT()&#39;, .EMBED)

static void ret_jit(void) { jit_ret(); }

-SNOBOL C_WRAPPER_PROTO(&#39;RET_JIT()&#39;, .EMBED)

static void reti_jit(void) { jit_reti((jit_word_t)get_p_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;RETI_JIT()&#39;, .EMBED)

static void reti_f_jit(void) { jit_reti_f(get_f_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;RETI_F_JIT()&#39;, .EMBED)

static void reti_d_jit(void) { jit_reti_d(get_d_()); }

-SNOBOL C_WRAPPER_PROTO(&#39;RETI_D_JIT()&#39;, .EMBED)

-END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JIT&raquo;&equiv;</b>
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(jit) :F(ERROR) ;
-SNOBOL LIBS = &#39; -L. -lp64 -llightning&#39;
-SNOBOL OBJECTS = jit ; OBJECTS &#39;.c&#39; = &#39;.o&#39;
-SNOBOL LINK_DYNAMIC(&#39;./jit&#39;, OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON&#39;T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS jit.so
-CMNT -SNOBOL  A = CRACK(jit &#39; &#39; OBJECTS, &#39; &#39;)
-CMNT -SNOBOL  SEQ(&#39; DELETE(A&lt;K&gt;) &#39;, .K)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JIT&raquo;&equiv;</b>
         LOAD(&#39;INIT_JIT(STRING)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;R_NUM_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;V_NUM_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;F_NUM_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;FINISH_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;GET_STATE_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;SET_STATE_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;NEW_STATE_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;DESTROY_STATE_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;CLEAR_STATE_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;PROLOG_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;EPILOG_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;NOTE_JIT(STRING,INTEGER)INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;NAME_JIT(STRING)INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;ADDRESS_JIT(INTEGER)INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;DISASSEMBLE_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;EMIT_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PRINT_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;LABEL_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;ELLIPSIS_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*        LOAD(&#39;GET_NOTE_JIT()INTEGER&#39;, &#39;jit.so&#39;)</i></font>
         LOAD(&#39;POINTER_P_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;CALLEE_SAVE_P_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PATCH_AT_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PATCH_ABS_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PATCH_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PREPARE_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;ALLOCAI_JIT(INTEGER)INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;DATA_JIT(INTEGER,INTEGER,INTEGER)INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;FORWARD_JIT()INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;LIVE_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;LINK_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE DO R0..R3, V0..V3, F0..F7 AND FP, EVEN THOUGH NOT ALL OF THESE</i></font>
<font color="#818181"><i>* REGISTERS MAY EXIST. THE ONES THAT DON&#39;T WILL BE -1. USE JIT_R_NUM(),</i></font>
<font color="#818181"><i>* JIT_V_NUM() AND JIT_F_NUM() TO DETERMINE THE ACTUAL NUMBER OF</i></font>
<font color="#818181"><i>* REGISTERS. NOTE THAT WORST CASE, R0..R2, V0..V2 AND F0..F5 ARE</i></font>
<font color="#818181"><i>* USABLE.</i></font>
<font color="#818181"><i>*</i></font>
         L = &#39;R0 R1 R2 R3 V0 V1 V2 V3 F0 F1 F2 F3 F4 F5 F6 F7 FP&#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(&#39;GET_&#39; A&lt;I&gt; &#39;_JIT()INTEGER&#39;, &#39;jit.so&#39;); &quot;
+            &quot; $(&#39;JIT_&#39; A&lt;I&gt;) = EVAL(&#39;GET_&#39; A&lt;I&gt; &#39;_JIT()&#39;) &quot;, .I)
<font color="#818181"><i>*</i></font>
         L = &#39;ADDR ADDCR ADDXR SUBR SUBCR SUBXR MULR DIVR DIVR_U &#39;
+            &#39;REMR REMR_U ANDR ORR XORR LSHR RSHR RSHR_U &#39;
+            &#39;LTR LTR_U LER LER_U GER GER_U GTR GTR_U EQR NER &#39;
+            &#39;ADDR_F ADDR_D SUBR_F SUBR_D MULR_F MULR_D DIVR_F DIVR_D &#39;
+            &#39;LTR_F LER_F EQR_F GER_F GTR_F NER_F UNLTR_F UNLER_F &#39;
+            &#39;UNEQR_F UNGER_F UNGTR_F LTGTR_F ORDR_F UNORDR_F &#39;
+            &#39;LTR_D LER_D EQR_D GER_D GTR_D NER_D UNLTR_D UNLER_D &#39;
+            &#39;UNEQR_D UNGER_D UNGTR_D LTGTR_D ORDR_D UNORDR_D &#39;
+            &#39;LDXR_C LDXR_UC LDXR_S LDXR_US LDXR_I LDXR_UI LDXR_L &#39;
+            &#39;LDXR LDXR_F LDXR_D &#39;
+            &#39;STXR_C STXR_S STXR_I STXR STXR_L STXR_F STXR_D &#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER,INTEGER,INTEGER)&#39;, &#39;jit.so&#39;) &quot;
+            , .I)
<font color="#818181"><i>*</i></font>
         L = &#39;ADDI ADDCI ADDXI SUBI SUBCI SUBXI MULI DIVI DIVI_U &#39;
+            &#39;REMI REMI_U ANDI ORI XORI LSHI RSHI RSHI_U &#39;
+            &#39;LTI LTI_U LEI LEI_U GEI GEI_U GTI GTI_U EQI NEI &#39;
+            &#39;ADDI_F SUBI_F MULI_F DIVI_F &#39;
+            &#39;ADDI_D SUBI_D MULI_D DIVI_D &#39;
+            &#39;LDXI_C LDXI_UC LDXI_S LDXI_US LDXI_I LDXI_UI LDXI_L LDXI &#39;
+            &#39;LDXI_F LDXI_D &#39;
+            &#39;STXI_C STXI_S STXI_I STXI_L STXI STXI_F STXI_D &#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &#39;jit.so&#39;) &quot;
+            , .I)
<font color="#818181"><i>*</i></font>
         L = &#39;BLTR BLTR_U BLER BLER_U BGTR BGTR_U BGER BGER_U &#39;
+            &#39;BEQR BNER BMSR BMCR BOADDR BXADDR BOSUBR BXSUBR&#39;
+            &#39;BOADDR_U BXADDR_U BOSUBR_U BXSUBR_U &#39;
+            &#39;BLTR_F BLER_F BGTR_F BGER_F BEQR_F BNER_R &#39;
+            &#39;BUNLTR_F BUNLER_F BUNEQR_F BUNGER_F BUNGTR_F &#39;
+            &#39;BLTGTR_F BORDR_F BUNORDR_F &#39;
+            &#39;BLTR_D BLER_D BGTR_D BGER_D BEQR_D BNER_D &#39;
+            &#39;BUNLTR_D BUNLER_D BUNEQR_D BUNGER_D BUNGTR_D &#39;
+            &#39;BLTGTR_D BORDR_D BUNORDR_D &#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &#39;jit.so&#39;) &quot;
+            , .I)
<font color="#818181"><i>*</i></font>
         L = &#39;MOVR MOVR_F MOVR_D MOVR_F_W MOVR_W_F MOVR_D_W MOVR_W_D &#39;
+            &#39;HTONR NTOHR COMR NEGR NEGR_F NEGR_D ABSR_F ABSR_D &#39;
+            &#39;SQRTR_F SQRTR_D &#39;
+            &#39;EXTR_C EXTR_UC EXTR_S EXTR_US EXTR_I EXTR_UI &#39;
+            &#39;EXTR_F EXTR_D_F EXTR_D EXTR_F_D &#39;
+            &#39;TRUNCR_F_I TRUNCR_F TRUNCR_F_L TRUNCR_D_I TRUNCR_D &#39;
+            &#39;TRUNCR_D_L &#39;
+            &#39;LDR_C LDR_UC LDR_S LDR_US LDR_I LDR LDR_UI LDR_L &#39;
+            &#39;LDR_F LDR_D &#39;
+            &#39;STR_C STR_S STR_I STR STR_L STR_F STR_D&#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER,INTEGER)&#39;, &#39;jit.so&#39;) &quot;
+            , .I)
<font color="#818181"><i>*</i></font>
         L = &#39;MOVR_D_WW MOVR_WW_D&#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER,INTEGER,INTEGER)&#39;, &#39;jit.so&#39;) &quot;
+            , .I)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;MOVI_JIT(INTEGER)INTEGER&#39;, &#39;jit.so&#39;)
         LOAD(&#39;MOVI_F_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;MOVI_D_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;MOVI_F_W_JIT(INTEGER,INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;MOVI_D_W_JIT(INTEGER,INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;MOVI_D_WW_JIT(INTEGER,INTEGER)&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         L = &#39;ARG ARG_F ARG_D&#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT()&#39;, &#39;jit.so&#39;) &quot;, .I)
<font color="#818181"><i>*</i></font>
         L = &#39;GETARG GETARG_C GETARG_UC GETARG_S GETARG_US GETARG_I &#39;
+            &#39;GETARG_UI GETARG_L GETARG_F GETARG_D &#39;
+            &#39;LDI_C LDI_UC LDI_S LDI_US LDI_I LDI LDI_UI LDI_L LDI_F &#39;
+            &#39;LDI_D STI_C STI_S STI_I STI STI_L STI_F STI_D &#39;
+            &#39;BLTI BLTI_U BLEI BLEI_U BEQI BGEI BGEI_U BGTI BGTI_U &#39;
+            &#39;BNEI BMSI BMCI BOADDI BOADDI_U BXADDI BXADDI_U &#39;
+            &#39;BOSUBI BOSUBI_U BXSUBI BXSUBI_U &#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER)&#39;, &#39;jit.so&#39;) &quot;, .I)
<font color="#818181"><i>*</i></font>
         L = &#39;PUSHARGR PUSHARGR_F PUSHARGR_D &#39;
+            &#39;RETR RETVAL_C RETVAL_UC RETVAL_S RETVAL_US RETVAL_I &#39;
+            &#39;RETVAL RETVAL_UI RETVAL_L RETR_F RETVAL_F &#39;
+            &#39;RETR_D RETVAL_D &#39;
         A = CRACK(L, &#39; &#39;)
         SEQ(&quot; LOAD(A&lt;I&gt; &#39;_JIT(INTEGER)&#39;, &#39;jit.so&#39;) &quot;, .I)
         LOAD(&#39;PUSHARGI_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PUSHARGI_F_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;PUSHARGI_D_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;JMPR_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;JMPI_JIT()INTEGER&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;CALLR_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;CALLI_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;FINISHR_JIT(INTEGER)&#39;, &#39;jit.so&#39;)
         LOAD(&#39;FINISHI_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;RET_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;RETI_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;RETI_F_JIT()&#39;, &#39;jit.so&#39;)
         LOAD(&#39;RETI_D_JIT()&#39;, &#39;jit.so&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PROXY FUNCTIONS TO HIDE SET_P()/GET_P(). THESE ARE SHORT FUNCTIONS (1</i></font>
<font color="#818181"><i>* OR 2 LINES). USE THESE FUNCTIONS TO USE JIT, RATHER THAN THE ..._JIT</i></font>
<font color="#818181"><i>* FUNCTIONS. THESE FUNCTIONS TAKE CARE OF ANY INT/POINTER ISSUES,</i></font>
<font color="#818181"><i>* WHEREAS USING THE UNDERLYING FUNCTIONS WILL NOT, AND THE CODE WILL BE</i></font>
<font color="#818181"><i>* NOT BE PORTABLE.</i></font>
<font color="#818181"><i>*</i></font>
JIT_DEFINE
<font color="#818181"><i>*</i></font>
-PUBLIC JIT_R_NUM(), JIT_V_NUM(), JIT_FNUM()
         DEFINE(&#39;JIT_R_NUM()&#39;)
         DEFINE(&#39;JIT_V_NUM()&#39;)
         DEFINE(&#39;JIT_F_NUM()&#39;)
-PUBLIC JIT_ARG(), JIT_ARG_F(), JIT_ARG_D()
         DEFINE(&#39;JIT_ARG()&#39;)
         DEFINE(&#39;JIT_ARG_F()&#39;)
         DEFINE(&#39;JIT_ARG_D()&#39;)
-PUBLIC JIT_RET(), JIT_RETI(), JIT_RETI_F(), JIT_RETI_D()
         DEFINE(&#39;JIT_RET()&#39;)
         DEFINE(&#39;JIT_RETI(P)&#39;)
         DEFINE(&#39;JIT_RETI_F(F)&#39;)
         DEFINE(&#39;JIT_RETI_D(D)&#39;)
-PUBLIC JIT_FINISHR(), JIT_FINISHI(), JIT_INIT(), JIT_FINISH()
         DEFINE(&#39;JIT_FINISHR(R)&#39;)
         DEFINE(&#39;JIT_FINISHI(P)&#39;)
         DEFINE(&#39;JIT_INIT(S)&#39;)
         DEFINE(&#39;JIT_FINISH()&#39;)
-PUBLIC JIT_MOVI(), JIT_MOVI_F(), JIT_MOVI_D()
         DEFINE(&#39;JIT_MOVI(R,P)&#39;)
         DEFINE(&#39;JIT_MOVI_F(R,F)&#39;)
         DEFINE(&#39;JIT_MOVI_D(R,D)&#39;)
-PUBLIC JIT_GETARG(), JIT_GETARG_C(), JIT_GETARG_UC(), JIT_GETARG_S()
-PUBLIC JIT_GETARG_US(), JIT_GETARG_I(), JIT_GETARG_UI(), JIT_GETARG_L()
-PUBLIC JIT_GETARG_F(), JIT_GETARG_D()
         DEFINE(&#39;JIT_GETARG(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_C(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_UC(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_S(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_US(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_I(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_UI(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_L(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_F(R,A)&#39;)
         DEFINE(&#39;JIT_GETARG_D(R,A)&#39;)
-PUBLIC JIT_PROLOG(), JIT_EPILOG(), JIT_PRINT(), JIT_DISASSEMBLE()
-PUBLIC JIT_LABEL(), JIT_ELLIPSIS(), JIT_EMIT(), JIT_ADDRESS()
         DEFINE(&#39;JIT_PROLOG()&#39;)
         DEFINE(&#39;JIT_EPILOG()&#39;)
         DEFINE(&#39;JIT_PRINT()&#39;)
         DEFINE(&#39;JIT_DISASSEMBLE()&#39;)
         DEFINE(&#39;JIT_LABEL()&#39;)
         DEFINE(&#39;JIT_ELLIPSIS()&#39;)
         DEFINE(&#39;JIT_EMIT()&#39;)
         DEFINE(&#39;JIT_ADDRESS(P)&#39;)
-PUBLIC JIT_RETR(), JIT_RETR_F(), JIT_RETR_D()
         DEFINE(&#39;JIT_RETR(R)&#39;)
         DEFINE(&#39;JIT_RETR_F(R)&#39;)
         DEFINE(&#39;JIT_RETR_D(R)&#39;)
-PUBLIC JIT_GETSTATE(), JIT_SET_STATE(), JIT_NEW_STATE()
-PUBLIC JIT_DESTROY_STATE(), JIT_CLEAR_STATE()
         DEFINE(&#39;JIT_GET_STATE()&#39;)
         DEFINE(&#39;JIT_SET_STATE(JIT)&#39;)
         DEFINE(&#39;JIT_NEW_STATE()&#39;)
         DEFINE(&#39;JIT_DESTROY_STATE()&#39;)
         DEFINE(&#39;JIT_CLEAR_STATE()&#39;)
-PUBLIC JIT_JMPR(), JIT_JMPI()
         DEFINE(&#39;JIT_JMPR(R)&#39;)
         DEFINE(&#39;JIT_JMPI(P)&#39;)
-PUBLIC JIT_CALLR(), JIT_CALLI()
         DEFINE(&#39;JIT_CALLR(R)&#39;)
         DEFINE(&#39;JIT_CALLI(P)&#39;)
-PUBLIC JIT_NOTE(), JIT_NAME(), JIT_PREPARE(), JIT_ALLOCAI()
         DEFINE(&#39;JIT_NOTE(S,N)&#39;)
         DEFINE(&#39;JIT_NAME(S)&#39;)
         DEFINE(&#39;JIT_PREPARE()&#39;)
         DEFINE(&#39;JIT_ALLOCAI(N)&#39;)
-PUBLIC JIT_PATCH_AT, JIT_PATCH_ABS(), JIT_PATCH()
         DEFINE(&#39;JIT_PATCH_AT(P,P2)&#39;)
         DEFINE(&#39;JIT_PATCH_ABS(P,P2)&#39;)
         DEFINE(&#39;JIT_PATCH(P)&#39;)
-PUBLIC JIT_ADDR(), JIT_ADDCR(), JIT_ADDXR()
         DEFINE(&#39;JIT_ADDR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_ADDCR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_ADDXR(R1,R2,R3)&#39;)
-PUBLIC JIT_SUBR(), JIT_SUBCR(), JIT_SUBXR()
         DEFINE(&#39;JIT_SUBR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_SUBCR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_SUBXR(R1,R2,R3)&#39;)
-PUBLIC JIT_MULR(), JIT_DIVR(), JIT_DIVR_U(), JIT_REMR(), JIT_REMR_U()
         DEFINE(&#39;JIT_MULR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_DIVR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_DIVR_U(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_REMR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_REMR_U(R1,R2,R3)&#39;)
-PUBLIC JIT_ANDR(), JIT_ORR(), JIT_XORR(), JIT_LSHR(), JIT_RSHR()
-PUBLIC JIT_RSHR_U()
         DEFINE(&#39;JIT_ANDR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_ORR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_XORR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LSHR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_RSHR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_RSHR_U(R1,R2,R3)&#39;)
-PUBLIC JIT_LTR(), JIT_LTR_U()
         DEFINE(&#39;JIT_LTR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LTR_U(R1,R2,R3)&#39;)
-PUBLIC JIT_LER(), JIT_LER_U()
         DEFINE(&#39;JIT_LER(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LER_U(R1,R2,R3)&#39;)
-PUBLIC JIT_GER(), JIT_GER_U()
         DEFINE(&#39;JIT_GER(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_GER_U(R1,R2,R3)&#39;)
-PUBLIC JIT_GTR(), GTR_U()
         DEFINE(&#39;JIT_GTR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_GTR_U(R1,R2,R3)&#39;)
-PUBLIC JIT_EQR(), JIT_NER()
         DEFINE(&#39;JIT_EQR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_NER(R1,R2,R3)&#39;)
-PUBLIC JIT_ADDR_F(), JIT_ADDR_D()
         DEFINE(&#39;JIT_ADDR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_ADDR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_SUBR_F(), JIT_SUBR_D()
         DEFINE(&#39;JIT_SUBR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_SUBR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_MULR_F(), JIT_MULR_D()
         DEFINE(&#39;JIT_MULR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_MULR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_DIVR_F(), JIT_DIVR_D()
         DEFINE(&#39;JIT_DIVR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_DIVR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_LTR_F(), JIT_LER_F(), JIT_EQR_F(), JIT_GER_F(), JIT_GTR_F()
-PUBLIC JIT_NER_F()
         DEFINE(&#39;JIT_LTR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LER_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_EQR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_GER_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_GTR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_NER_F(R1,R2,R3)&#39;)
-PUBLIC JIT_UNLTR_F(), JIT_UNLER_F(), JIT_UNEQR_F(), JIT_UNGER_F()
-PUBLIC JIT_UNGTR_F(), JIT_LTGTR_F(), JIT_ORDR_F(), JIT_UNORDR_F()
         DEFINE(&#39;JIT_UNLTR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNLER_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNEQR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNGER_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNGTR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LTGTR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_ORDR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNORDR_F(R1,R2,R3)&#39;)
-PUBLIC JIT_LTR_D(), JIT_LER_D(), JIT_EQR_D(), JIT_GER_D(), JIT_GTR_D()
-PUBLIC JIT_NER_D()
-PUBLIC JIT_UNLTR_D(), JIT_UNLER_D(), JIT_UNEQR_D(), JIT_UNGER_D()
-PUBLIC JIT_UNGTR_D(), JIT_LTGTR_D(), JIT_ORDR_D(), JIT_UNORDR_D(),
         DEFINE(&#39;JIT_LTR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LER_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_EQR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_GER_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_GTR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_NER_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNLTR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNLER_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNEQR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNGER_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNGTR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LTGTR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_ORDR_D(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_UNORDR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_LDXR_C(), JIT_LDXR_UC(), JIT_LDXR_S(), JIT_LDXR_US()
-PUBLIC JIT_LDXR_I(), JIT_LDXR_UI(), JIT_LDXR_L(), JIT_LDXR()
-PUBLIC JIT_LDXR_F(), JIT_LDXR_D()
         DEFINE(&#39;JIT_LDXR_C(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_UC(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_S(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_US(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_I(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_UI(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_L(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_LDXR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_STXR_C(), JIT_STXR_S(), JIT_STXR_I(), JIT_STXR()
-PUBLIC JIT_STXR_L(), JIT_STXR_F(), JIT_STXR_D()
         DEFINE(&#39;JIT_STXR_C(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_STXR_S(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_STXR_I(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_STXR(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_STXR_L(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_STXR_F(R1,R2,R3)&#39;)
         DEFINE(&#39;JIT_STXR_D(R1,R2,R3)&#39;)
-PUBLIC JIT_BLTR(), JIT_BLTR_U(), JIT_BLER(), JIT_BLER_U()
         DEFINE(&#39;JIT_BLTR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLTR_U(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLER(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLER_U(R1,R2)&#39;)
-PUBLIC JIT_BGTR(), JIT_BGTR_U(), JIT_BGER(), JIT_BGER_U()
         DEFINE(&#39;JIT_BGTR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGTR_U(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGER(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGER_U(R1,R2)&#39;)
-PUBLIC JIT_BEQR(), JIT_BNER(), JIT_BMSR(), JIT_BMCR()
         DEFINE(&#39;JIT_BEQR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BNER(R1,R2)&#39;)
         DEFINE(&#39;JIT_BMSR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BMCR(R1,R2)&#39;)
-PUBLIC JIT_BOADDR(), JIT_BXADDR(), JIT_BOSUBR(), JIT_BXSUBR()
         DEFINE(&#39;JIT_BOADDR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BXADDR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BOSUBR(R1,R2)&#39;)
         DEFINE(&#39;JIT_BXSUBR(R1,R2)&#39;)
-PUBLIC JIT_BOADDR_U(), JIT_BXADDR_U(), JIT_BOSUBR_U(), JIT_BXSUBR_U()
         DEFINE(&#39;JIT_BOADDR_U(R1,R2)&#39;)
         DEFINE(&#39;JIT_BXADDR_U(R1,R2)&#39;)
         DEFINE(&#39;JIT_BOSUBR_U(R1,R2)&#39;)
         DEFINE(&#39;JIT_BXSUBR_U(R1,R2)&#39;)
-PUBLIC JIT_BLTR_F(), JIT_BLER_F(), JIT_BGTR_F(), JIT_BGER_F()
-PUBLIC JIT_BEQR_F(), JIT_BNER_R()
         DEFINE(&#39;JIT_BLTR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLER_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGTR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGER_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BEQR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BNER_R(R1,R2)&#39;)
-PUBLIC JIT_BUNLTR_F(), JIT_BUNLER_F(), JIT_BUNEQR_F()
-PUBLIC JIT_BUNGER_F(), JIT_BUNGTR_F(), JIT_BLTGTR_F()
         DEFINE(&#39;JIT_BUNLTR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNLER_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNEQR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNGER_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNGTR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLTGTR_F(R1,R2)&#39;)
-PUBLIC JIT_BORDR_F(), JIT_BUNORDR_F()
         DEFINE(&#39;JIT_BORDR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNORDR_F(R1,R2)&#39;)
-PUBLIC JIT_BLTR_D(), JIT_BLER_D(), JIT_BGTR_D(), JIT_BGER_D()
-PUBLIC JIT_BEQR_D(), JIT_BNER_D()
         DEFINE(&#39;JIT_BLTR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLER_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGTR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BGER_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BEQR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BNER_D(R1,R2)&#39;)
-PUBLIC JIT_BUNLTR_D(), JIT_BUNLER_D(), JIT_BUNEQR_D()
         DEFINE(&#39;JIT_BUNLTR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNLER_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNEQR_D(R1,R2)&#39;)
-PUBLIC JIT_BUNGER_D(), JIT_BUNGTR_D(), JIT_BLTGTR_D()
         DEFINE(&#39;JIT_BUNGER_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNGTR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BLTGTR_D(R1,R2)&#39;)
-PUBLIC JIT_BORDR_D(), JIT_BUNORDR_D()
         DEFINE(&#39;JIT_BORDR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_BUNORDR_D(R1,R2)&#39;)
-PUBLIC JIT_ADDI(), JIT_ADDCI(), JIT_ADDXI()
         DEFINE(&#39;JIT_ADDI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_ADDCI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_ADDXI(R1,R2,P)&#39;)
-PUBLIC JIT_SUBI(), JIT_SUBCI(), JIT_SUBXI()
         DEFINE(&#39;JIT_SUBI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_SUBCI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_SUBXI(R1,R2,P)&#39;)
-PUBLIC JIT_MULI(), JIT_DIVI(), JIT_DIVI_U(), JIT_REMI(), JIT_REMI_U()
         DEFINE(&#39;JIT_MULI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_DIVI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_DIVI_U(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_REMI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_REMI_U(R1,R2,P)&#39;)
-PUBLIC JIT_ANDI(), JIT_ORI(), JIT_XORI(), JIT_LSHI()
-PUBLIC JIT_RSHI(), JIT_RSHI_U(),
         DEFINE(&#39;JIT_ANDI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_ORI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_XORI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LSHI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_RSHI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_RSHI_U(R1,R2,P)&#39;)
-PUBLIC JIT_LTI(), JIT_LTI_U(), JIT_LEI(), JIT_LEI_U()
         DEFINE(&#39;JIT_LTI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LTI_U(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LEI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LEI_U(R1,R2,P)&#39;)
-PUBLIC JIT_GEI(), JIT_GEI_U(), JIT_GTI(), JIT_GTI_U()
         DEFINE(&#39;JIT_GEI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_GEI_U(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_GTI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_GTI_U(R1,R2,P)&#39;)
-PUBLIC JIT_EQI(), JIT_NEI()
         DEFINE(&#39;JIT_EQI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_NEI(R1,R2,P)&#39;)
-PUBLIC JIT_LDXI_C(), JIT_LDXI_UC(), JIT_LDXI_S(), JIT_LDXI_US()
         DEFINE(&#39;JIT_LDXI_C(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_UC(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_S(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_US(R1,R2,P)&#39;)
-PUBLIC JIT_LDXI_I(), JIT_LDXI_UI(), JIT_LDXI_L()
         DEFINE(&#39;JIT_LDXI_I(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_UI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_L(R1,R2,P)&#39;)
-PUBLIC JIT_LDXI(), JIT_LDXI_F(), JIT_LDXI_D()
         DEFINE(&#39;JIT_LDXI(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_F(R1,R2,P)&#39;)
         DEFINE(&#39;JIT_LDXI_D(R1,R2,P)&#39;)
-PUBLIC JIT_STXI_C(), JIT_STXI_S(), JIT_STXI_I()
         DEFINE(&#39;JIT_STXI_C(R1,P,R2)&#39;)
         DEFINE(&#39;JIT_STXI_S(R1,P,R2)&#39;)
         DEFINE(&#39;JIT_STXI_I(R1,P,R2)&#39;)
-PUBLIC JIT_STXI_L(), JIT_STXI(), JIT_STXI_F(), JIT_STXI_D()
         DEFINE(&#39;JIT_STXI_L(R1,P,R2)&#39;)
         DEFINE(&#39;JIT_STXI(R1,P,R2)&#39;)
         DEFINE(&#39;JIT_STXI_F(R1,P,R2)&#39;)
         DEFINE(&#39;JIT_STXI_D(R1,P,R2)&#39;)
-PUBLIC JIT_ADDI_F(), JIT_SUBI_F(), JIT_MULI_F(), JIT_DIVI_F()
         DEFINE(&#39;JIT_ADDI_F(R1,R2,F)&#39;)
         DEFINE(&#39;JIT_SUBI_F(R1,R2,F)&#39;)
         DEFINE(&#39;JIT_MULI_F(R1,R2,F)&#39;)
         DEFINE(&#39;JIT_DIVI_F(R1,R2,F)&#39;)
-PUBLIC JIT_ADDI_D(), JIT_SUBI_D(), JIT_MULI_D(), JIT_DIVI_D()
         DEFINE(&#39;JIT_ADDI_D(R1,R2,D)&#39;)
         DEFINE(&#39;JIT_SUBI_D(R1,R2,D)&#39;)
         DEFINE(&#39;JIT_MULI_D(R1,R2,D)&#39;)
         DEFINE(&#39;JIT_DIVI_D(R1,R2,D)&#39;)
-PUBLIC JIT_MOVR(), JIT_MOVR_F(), JIT_MOVR_D()
         DEFINE(&#39;JIT_MOVR(R1,R2)&#39;)
         DEFINE(&#39;JIT_MOVR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_MOVR_D(R1,R2)&#39;)
-PUBLIC JIT_HTONR(), JIT_NTOHR()
         DEFINE(&#39;JIT_HTONR(R1,R2)&#39;)
         DEFINE(&#39;JIT_NTOHR(R1,R2)&#39;)
-PUBLIC JIT_COMR()
         DEFINE(&#39;JIT_COMR(R1,R2)&#39;)
-PUBLIC JIT_NEGR(), JIT_NEGR_F(), JIT_NEGR_D()
         DEFINE(&#39;JIT_NEGR(R1,R2)&#39;)
         DEFINE(&#39;JIT_NEGR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_NEGR_D(R1,R2)&#39;)
-PUBLIC JIT_ABSR_F(), JIT_ABSR_D()
         DEFINE(&#39;JIT_ABSR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_ABSR_D(R1,R2)&#39;)
-PUBLIC JIT_SQRTR_F(), JIT_SQRTR_D()
         DEFINE(&#39;JIT_SQRTR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_SQRTR_D(R1,R2)&#39;)
-PUBLIC JIT_EXTR_C(), JIT_EXTR_UC(), JIT_EXTR_S(), JIT_EXTR_US()
         DEFINE(&#39;JIT_EXTR_C(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_UC(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_S(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_US(R1,R2)&#39;)
-PUBLIC JIT_EXTR_I(), JIT_EXTR_UI(), JIT_EXTR_F(), JIT_EXTR_D_F()
         DEFINE(&#39;JIT_EXTR_I(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_UI(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_D_F(R1,R2)&#39;)
-PUBLIC JIT_EXTR_D(), JIT_EXTR_F_D()
         DEFINE(&#39;JIT_EXTR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_EXTR_F_D(R1,R2)&#39;)
-PUBLIC JIT_TRUNCR_F_I(), JIT_TRUNCR_F(), JIT_TRUNCR_F_L()
-PUBLIC JIT_TRUNCR_D_I(), JIT_TRUNCR_D(), JIT_TRUNCR_D_L()
         DEFINE(&#39;JIT_TRUNCR_F_I(R1,R2)&#39;)
         DEFINE(&#39;JIT_TRUNCR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_TRUNCR_F_L(R1,R2)&#39;)
         DEFINE(&#39;JIT_TRUNCR_D_I(R1,R2)&#39;)
         DEFINE(&#39;JIT_TRUNCR_D(R1,R2)&#39;)
         DEFINE(&#39;JIT_TRUNCR_D_L(R1,R2)&#39;)
-PUBLIC JIT_LDR_C(), JIT_LDR_UC(), JIT_LDR_S(), JIT_LDR_US()
         DEFINE(&#39;JIT_LDR_C(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR_UC(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR_S(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR_US(R1,R2)&#39;)
-PUBLIC JIT_LDR_I(), JIT_LDR(), JIT_LDR_UI(), JIT_LDR_L()
         DEFINE(&#39;JIT_LDR_I(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR_UI(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR_L(R1,R2)&#39;)
-PUBLIC JIT_LDR_F(), JIT_LDR_D()
         DEFINE(&#39;JIT_LDR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_LDR_D(R1,R2)&#39;)
-PUBLIC JIT_STR_C(), JIT_STR_S(), JIT_STR_I(), JIT_STR()
         DEFINE(&#39;JIT_STR_C(R1,R2)&#39;)
         DEFINE(&#39;JIT_STR_S(R1,R2)&#39;)
         DEFINE(&#39;JIT_STR_I(R1,R2)&#39;)
         DEFINE(&#39;JIT_STR(R1,R2)&#39;)
-PUBLIC JIT_STR_L(), JIT_STR_F(), JIT_STR_D()
         DEFINE(&#39;JIT_STR_L(R1,R2)&#39;)
         DEFINE(&#39;JIT_STR_F(R1,R2)&#39;)
         DEFINE(&#39;JIT_STR_D(R1,R2)&#39;)
-PUBLIC JIT_LDI_C(), JIT_LDI_UC(), JIT_LDI_S(), JIT_LDI_US()
         DEFINE(&#39;JIT_LDI_C(R,P)&#39;)
         DEFINE(&#39;JIT_LDI_UC(R,P)&#39;)
         DEFINE(&#39;JIT_LDI_S(R,P)&#39;)
         DEFINE(&#39;JIT_LDI_US(R,P)&#39;)
-PUBLIC JIT_LDI_I(), JIT_LDI(), JIT_LDI_UI(), JIT_LDI_L()
         DEFINE(&#39;JIT_LDI_I(R,P)&#39;)
         DEFINE(&#39;JIT_LDI(R,P)&#39;)
         DEFINE(&#39;JIT_LDI_UI(R,P)&#39;)
         DEFINE(&#39;JIT_LDI_L(R,P)&#39;)
-PUBLIC JIT_LDI_F(), JIT_LDI_D()
         DEFINE(&#39;JIT_LDI_F(R,P)&#39;)
         DEFINE(&#39;JIT_LDI_D(R,P)&#39;)
-PUBLIC JIT_PUSHARGI(), JIT_PUSHARGI_F(), JIT_PUSHARGI_D()
         DEFINE(&#39;JIT_PUSHARGI(P)&#39;)
         DEFINE(&#39;JIT_PUSHARGI_F(F)&#39;)
         DEFINE(&#39;JIT_PUSHARGI_D(D)&#39;)
-PUBLIC JIT_BLTI(), JIT_BLTI_U(), JIT_BLEI(), JIT_BLEI_U()
         DEFINE(&#39;JIT_BLTI(R,P)&#39;)
         DEFINE(&#39;JIT_BLTI_U(R,P)&#39;)
         DEFINE(&#39;JIT_BLEI(R,P)&#39;)
         DEFINE(&#39;JIT_BLEI_U(R,P)&#39;)
-PUBLIC JIT_BEQI(), JIT_BGEI(), JIT_BGEI_U(), JIT_BGTI()
         DEFINE(&#39;JIT_BEQI(R,P)&#39;)
         DEFINE(&#39;JIT_BGEI(R,P)&#39;)
         DEFINE(&#39;JIT_BGEI_U(R,P)&#39;)
         DEFINE(&#39;JIT_BGTI(R,P)&#39;)
-PUBLIC JIT_BGTI_U(), JIT_BNEI(), JIT_BMSI(), JIT_BMCI()
         DEFINE(&#39;JIT_BGTI_U(R,P)&#39;)
         DEFINE(&#39;JIT_BNEI(R,P)&#39;)
         DEFINE(&#39;JIT_BMSI(R,P)&#39;)
         DEFINE(&#39;JIT_BMCI(R,P)&#39;)
-PUBLIC JIT_BOADDI(), JIT_BOADDI_U(), JIT_BXADDI()
         DEFINE(&#39;JIT_BOADDI(R,P)&#39;)
         DEFINE(&#39;JIT_BOADDI_U(R,P)&#39;)
         DEFINE(&#39;JIT_BXADDI(R,P)&#39;)
-PUBLIC JIT_BXADDI_U(), JIT_BOSUBI(), JIT_BOSUBI_U()
         DEFINE(&#39;JIT_BXADDI_U(R,P)&#39;)
         DEFINE(&#39;JIT_BOSUBI(R,P)&#39;)
         DEFINE(&#39;JIT_BOSUBI_U(R,P)&#39;)
-PUBLIC JIT_BXSUBI(), JIT_BXSUBI_U()
         DEFINE(&#39;JIT_BXSUBI(R,P)&#39;)
         DEFINE(&#39;JIT_BXSUBI_U(R,P)&#39;)
-PUBLIC JIT_STI_C(), JIT_STI_S(), JIT_STI_I(), JIT_STI(), JIT_STI_L()
-PUBLIC JIT_STI_F(), JIT_STI_D()
         DEFINE(&#39;JIT_STI_C(P,R)&#39;)
         DEFINE(&#39;JIT_STI_S(P,R)&#39;)
         DEFINE(&#39;JIT_STI_I(P,R)&#39;)
         DEFINE(&#39;JIT_STI(P,R)&#39;)
         DEFINE(&#39;JIT_STI_L(P,R)&#39;)
         DEFINE(&#39;JIT_STI_F(P,R)&#39;)
         DEFINE(&#39;JIT_STI_D(P,R)&#39;)
-PUBLIC JIT_PUSHARGR(), JIT_PUSHARGR_F(), JIT_PUSHARGR_D()
         DEFINE(&#39;JIT_PUSHARGR(R)&#39;)
         DEFINE(&#39;JIT_PUSHARGR_F(R)&#39;)
         DEFINE(&#39;JIT_PUSHARGR_D(R)&#39;)
-PUBLIC JIT_RETVAL_C(), JIT_RETVAL_UC(), JIT_RETVAL_S(), JIT_RETVAL_US()
-PUBLIC JIT_RETVAL_I(), JIT_RETVAL(), JIT_RETVAL_UI(), JIT_RETVAL_L()
-PUBLIC JIT_RETVAL_F(), JIT_RETVAL_D()
         DEFINE(&#39;JIT_RETVAL_C(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_UC(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_S(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_US(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_I(R)&#39;)
         DEFINE(&#39;JIT_RETVAL(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_UI(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_L(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_F(R)&#39;)
         DEFINE(&#39;JIT_RETVAL_D(R)&#39;)                            <b>:(JIT_END)</b>
<font color="#818181"><i>*</i></font>
JIT_R_NUM
         JIT_R_NUM = R_NUM_JIT()                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_V_NUM
         JIT_V_NUM = V_NUM_JIT()                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_F_NUM
         JIT_F_NUM = F_NUM_JIT()                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ARG  ARG_JIT()
         JIT_ARG = GET_P()                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ARG_F
         ARG_F_JIT()
         JIT_ARG_F = GET_P()                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ARG_D
         ARG_D_JIT()
         JIT_ARG_D = GET_P()                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RET  RET_JIT()                                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETI SET_P(P)
         RETI_JIT()                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETI_F
         SET_F(F)
         RETI_F_JIT()                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETI_D
         SET_D(D)
         RETI_D_JIT()                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_FINISHR
         FINISHR_JIT(R)                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_FINISHI
         SET_P(P)
         FINISHI_JIT()                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_INIT INIT_JIT(S)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_FINISH
         FINISH_JIT()                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MOVI SET_P(P)
         JIT_MOVI = MOVI_JIT(R)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MOVI_F
         SET_F(F)
         MOVI_F_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MOVI_D(R,D)
         SET_D(D)
         MOVI_D_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG
         SET_P(A)
         GETARG_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_C
         SET_P(A)
         GETARG_C_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_UC
         SET_P(A)
         GETARG_UC_JIT(R)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_S
         SET_P(A)
         GETARG_S_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_US
         SET_P(A)
         GETARG_US_JIT(R)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_I
         SET_P(A)
         GETARG_I_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_UI
         SET_P(A)
         GETARG_UI_JIT(R)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_L
         SET_P(A)
         GETARG_L_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_F
         SET_P(A)
         GETARG_F_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GETARG_D
         SET_P(A)
         GETARG_D_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PROLOG
         PROLOG_JIT()                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EPILOG
         EPILOG_JIT()                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PRINT
         PRINT_JIT()                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DISASSEMBLE
         DISASSEMBLE_JIT()                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LABEL
         JIT_LABEL = LABEL_JIT()                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ELLIPSIS
         ELLIPSIS_JIT()                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EMIT JIT_EMIT = EMIT_JIT()                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDRESS
         JIT_ADDRESS = ADDRESS_JIT(P)                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETR RETR_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETR_F
         RETR_F_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETR_D
         RETR_D_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GET_STATE
         JIT_GET_STATE = GET_STATE_JIT()                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SET_STATE
         SET_STATE_JIT(JIT)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NEW_STATE
         JIT_NEW_STATE = NEW_STATE_JIT()                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DESTROY_STATE
         DESTROY_STATE_JIT()                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_CLEAR_STATE
         CLEAR_STATE_JIT()                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_JMPR JMPR_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_JMPI SET_P(P)
         JIT_JMPI = JMPI_JIT()                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_CALLR
         CALLR_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_CALLI
         SET_P(P)
         CALLI_JIT()
         JIT_CALLI = GET_P()                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NOTE JIT_NOTE = NOTE_JIT(S, N)                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NAME JIT_NAME = NAME_JIT(S)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PREPARE
         PREPARE_JIT()                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ALLOCAI
         JIT_ALLOCAI = ALLOCAI_JIT(N)                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PATCH_AT
         SET_P(P2)
         P_TO_P2()
         SET_P(P)
         PATCH_AT_JIT()                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PATCH_ABS
         SET_P(P2)
         P_TO_P2()
         SET_P(P)
         PATCH_ABS_JIT()                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PATCH
         SET_P(P)
         PATCH_JIT()                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDR ADDR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDCR
         ADDCR_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDXR
         ADDXR_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBR SUBR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBCR
         SUBCR_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBXR
         SUBXR_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MULR MULR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVR DIVR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVR_U
         DIVR_U_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_REMR REMR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_REMR_U
         REMR_U_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ANDR ANDR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ORR  ORR_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_XORR XORR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LSHR LSHR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RSHR RSHR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RSHR_U
         RSHR_U_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTR  LTR_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTR_U
         LTR_U_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LER  LER_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LER_U
         LER_U_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GER  GER_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GER_U
         GER_U_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GTR  GTR_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GTR_U
         GTR_U_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EQR  EQR_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NER  NER_JIT(R1, R2, R3)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDR_F
         ADDR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDR_D
         ADDR_D_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBR_F
         SUBR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBR_D
         SUBR_D(R1, R2, R3)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MULR_F
         MULR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MULR_D
         MULR_D_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVR_F
         DIVR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVR_D
         DIVR_D_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTR_F
         LTR_F_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LER_F
         LER_F_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EQR_F
         EQR_F_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GER_F
         GER_F_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GTR_F
         GTR_F_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NER_F
         NER_F_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNLTR_F
         UNLTR_F_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNLER_F
         UNLER_F_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNEQR_F
         UNEQR_F_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNGER_F
         UNGER_F_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNGTR_F
         UNGTR_F_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTGTR_F
         LTGTR_F_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ORDR_F
         ORDR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNORDR_F
         UNORDR_F_JIT(R1, R2, R3)                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTR_D
         LTR_D_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LER_D
         LER_D_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EQR_D
         EQR_D_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GER_D
         GER_D_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GTR_D
         GTR_D_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NER_D
         NER_D_JIT(R1, R2, R3)                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNLTR_D
         UNLTR_D_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNLER_D
         UNLER_D_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNEQR_D
         UNEQR_D_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNGER_D
         UNGER_D_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNGTR_D
         UNGTR_D_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTGTR_D
         LTGTR_D_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ORDR_D
         ORDR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_UNORDR_D
         UNORDR_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_C
         LDXR_C_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_UC
         LDXR_UC_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_S
         LDXR_S_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_US
         LDXR_US_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_I
         LDXR_I_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_UI
         LDXR_UI_JIT(R1, R2, R3)                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_L
         LDXR_L_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR LDXR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_F
         LDXR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXR_D
         LDXR_D_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR_C
         STXR_C_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR_S
         STRX_S_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR_I
         STXR_I_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR STXR_JIT(R1, R2, R3)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR_L
         STXR_L_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR_F
         SRXR_F_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXR_D
         STXR_D_JIT(R1, R2, R3)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTR JIT_BLTR = BLTR_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTR_U
         JIT_BLTR_U = BLTR_U_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLER JIT_BLER = BLER_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLER_U
         BLER_U_JIT = BLER_U_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGTR JIT_BGTR = BGTR_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGTR_U
         JIT_BGTR_U = BGTR_U_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGER JIT_BGER = BGER_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGER_U
         JIT_BGER_U = BGER_U_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BEQR JIT_BEQR = BEQR_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BNER JIT_BNER = BNER_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BMSR JIT_BMSR = BMSR_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BMCR JIT_BMCR = BMCR_JIT(R1, R2)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOADDR
         JIT_BOADDR = BOADDR_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXADDR
         JIT_BXADDR = BXADDR_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOSUBR
         JIT_BOSUBR = BOSUBR_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXSUBR
         JIT_BXSUBR = BXSUBR_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOADDR_U
         JIT_BOADDR_U = BOADDR_U_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXADDR_U
         JIT_BXADDR_U = BXADDR_U_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOSUBR_U
         JIT_BOSUBR_U = BOSUBR_U_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXSUBR_U
         JIT_BXSUBR_U = BXSUBR_U_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTR_F
         JIT_BLTR_F = BLTR_F_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLER_F
         JIT_BLER_F = BLER_F_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGTR_F
         JIT_BGTR_F = BGTR_F_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGER_F
         JIT_BGER_F = BGER_F_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BEQR_F
         JIT_BEQR_F = BEQR_F_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BNER_R
         JIT_BNER_R = BNER_R_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNLTR_F
         JIT_BUNLTR_F = BUNLTR_F_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNLER_F
         JIT_BUNLER_F = BUNLER_F_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNEQR_F
         JIT_BUNEQR_F = BUNEQR_F_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNGER_F
         JIT_BUNGER_F = BUNGER_F_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNGTR_F
         JIT_BUNGTR_F = BUNGTR_F_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTGTR_F
         JIT_BLTGTR_F = BLTGTR_F_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BORDR_F
         JIT_BORDR_F = BORDR_F_JIT(R1, R2)                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNORDR_F
         JIT_BUNORDR_F = BUNORDR_F_JIT(R1, R2)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTR_D
         JIT_BLTR_D = BLTR_D_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLER_D
         JIT_BLER_D = BLER_D_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGTR_D
         JIT_BGTR_D = BGTR_D_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGER_D
         JIT_BGER_D = BGER_D_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BEQR_D
         JIT_BEQR_D = BEQR_D_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BNER_D
         JIT_BNER_D = BNER_D_JIT(R1, R2)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNLTR_D
         JIT_BUNLTR_D = BUNLTR_D_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNLER_D
         JIT_BUNLER_D = BUNLER_D_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNEQR_D
         JIT_BUNEQR_D = BUNEQR_D_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNGER_D
         JIT_BUNGER_D = BUNGER_D_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNGTR_D
         JIT_BUNGTR_D = BUNGTR_D_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTGTR_D
         JIT_BLTGTR_D = BLTGTR_D_JIT(R1, R2)                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BORDR_D
         JIT_BORDR_D = BORDR_D_JIT(R1, R2)                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BUNORDR_D
         JIT_BUNORDR_D = BUNORDR_D_JIT(R1, R2)                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDI SET_P(P)
         ADDI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDCI
         SET_P(P)
         ADDCI_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDXI
         SET_P(P)
         ADDXI_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBI SET_P(P)
         SUBI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBCI
         SET_P(P)
         SUBCI_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBXI
         SET_P(P)
         SUBXI_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MULI SET_P(P)
         MULI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVI SET_P(P)
         DIVI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVI_U
         SET_P(P)
         DIVI_U_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_REMI SET_P(P)
         REMI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_REMI_U
         SET_P(P)
         REMI_U_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ANDI SET_P(P)
         ANDI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ORI  SET_P(P)
         ORI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_XORI SET_P(P)
         XORI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LSHI SET_P(P)
         LSHI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RSHI SET_P(P)
         RSHI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RSHI_U
         SET_P(P)
         RSHI_U_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTI  SET_P(P)
         LTI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LTI_U
         SET_P(P)
         LTI_U_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LEI  SET_P(P)
         LEI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LEI_U
         SET_P(P)
         LEI_U_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GEI  SET_P(P)
         GEI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GEI_U
         SET_P(P)
         GEI_U_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GTI  SET_P(P)
         GTI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_GTI_U
         SET_P(P)
         GTI_U_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EQI  SET_P(P)
         EQI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NEI  SET_P(P)
         NEI_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_C
         SET_P(P)
         LDXI_C_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_UC
         SET_P(P)
         LDXI_UC_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_S
         SET_P(P)
         LDXI_S_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_US
         SET_P(P)
         LDXI_US_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_I
         SET_P(P)
         LDXI_I_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_UI
         SET_P(P)
         LDXI_UI_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_L
         SET_P(P)
         LDXI_L_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI SET_P(P)
         LDXI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_F
         SET_P(P)
         LDXI_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDXI_D
         SET_P(P)
         LDXI_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI_C
         SET_P(P)
         STXI_C_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI_S
         SET_P(P)
         STXI_S_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI_I
         SET_P(P)
         STXI_I_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI_L
         SET_P(P)
         STXI_L_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI
         SET_P(P)
         STXI_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI_F
         SET_P(P)
         STXI_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STXI_D
         SET_P(P)
         STXI_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDI_F
         SET_F(F)
         ADDI_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBI_F
         SET_F(F)
         SUBI_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MULI_F
         SET_F(F)
         MULI_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVI_F
         SET_F(F)
         DIVI_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ADDI_D
         SET_D(D)
         ADDI_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SUBI_D
         SET_D(D)
         SUBI_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MULI_D
         SET_D(D)
         MULI_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_DIVI_D
         SET_D(D)
         DIVI_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MOVR MOVR_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MOVR_F
         MOVR_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_MOVR_D
         MOVR_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_HTONR
         HTONR_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NTOHR
         NTOHR_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_COMR COMR_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NEGR NEGR_JIT(R1, R2)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NEGR_F
         NEGR_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_NEGR_D
         NEGR_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ABSR_F
         ABSR_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_ABSR_D
         ABSR_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
JIT_SQRTR_F
         SQRTR_F_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_SQRTR_D
         SQRTR_D_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_C
         EXTR_C_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_UC
         EXTR_UC_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_S
         EXTR_S_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_US
         EXTR_US_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_I
         EXTR_I_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_UI
         EXTR_UI_JIT(R1, R2)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_F
         EXTR_F_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_D_F
         EXTR_D_F_JIT(R1, R2)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_D
         EXTR_D_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_EXTR_F_D
         EXTR_F_D_JIT(R1, R2)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_TRUNCR_F_I
         TRUNCR_F_I_JIT(R1, R2)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_TRUNCR_F
         TRUNCR_F_JIT(R1, R2)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_TRUNCR_F_L
         TRUNCR_F_L_JIT(R1, R2)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_TRUNCR_D_I
         TRUNCR_D_I_JIT(R1, R2)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_TRUNCR_D
         TRUNCR_D_JIT(R1, R2)                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_TRUNCR_D_L
         TRUNCR_D_L_JIT(R1, R2)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_C
         LDR_C_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_UC
         LDR_UC_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_S
         LDR_S_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_US
         LDR_US_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_I
         LDR_I_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR
         LDR_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_UI
         LDR_UI_JIT(R1, R2)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_L
         LDR_L_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_F
         LDR_F_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDR_D
         LDR_D_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR_C
         STR_C_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR_S
         STR_S_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR_I
         STR_I_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR  STR_JIT(R1, R2)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR_L
         STR_L_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR_F
         STR_F_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STR_D
         STR_D_JIT(R1, R2)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_C
         SET_P(P)
         LDI_C_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_UC
         SET_P(P)
         LDI_UC_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_S
         SET_P(P)
         LDI_S_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_US
         SET_P(P)
         LDI_US_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_I
         SET_P(P)
         LDI_I_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI  SET_P(P)
         LDI_JIT(R)                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_UI
         SET_P(P)
         LDI_UI_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_L
         SET_P(P)
         LDI_L_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_F
         SET_P(P)
         LDI_F_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_LDI_D
         SET_P(P)
         LDI_D_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PUSHARGI
         SET_P(P)
         PUSHARGI_JIT()                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PUSHARGI_F
         SET_F(F)
         PUSHARGI_F_JIT()                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PUSHARGI_D
         SET_D(D)
         PUSHARGI_D_JIT()                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTI SET_P(P)
         BLTI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLTI_U
         SET_P(P)
         BLTI_U_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLEI SET_P(P)
         BLEI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BLEI_U
         SET_P(P)
         BLEI_U_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BEQI SET_P(P)
         BEQI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGEI SET_P(P)
         BGEI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGEI_U
         SET_P(P)
         BGEI_U_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGTI SET_P(P)
         BGTI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BGTI_U
         SET_P(P)
         BGTI_U_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BNEI SET_P(P)
         BNEI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BMSI SET_P(P)
         BMSI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BMCI SET_P(P)
         BMCI_JIT(R)                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOADDI
         SET_P(P)
         BOADDI_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOADDI_U
         SET_P(P)
         BOADDI_U_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXADDI
         SET_P(P)
         BXADDI_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXADDI_U
         SET_P(P)
         BXADDI_U_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOSUBI
         SET_P(P)
         BOSUBI_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BOSUBI_U
         SET_P(P)
         BOSUBI_U_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXSUBI
         SET_P(P)
         BXSUBI_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_BXSUBI_U
         SET_P(P)
         BXSUBI_U_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI_C
         SET_P(P)
         STI_C_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI_S
         SET_P(P)
         STI_S_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI_I
         SET_P(P)
         STI_I_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI  SET_P(P)
         STI_JIT(R)                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI_L
         SET_P(P)
         STI_L_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI_F
         SET_P(P)
         STI_F_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_STI_D
         SET_P(P)
         STI_D_JIT(R)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PUSHARGR
         PUSHARGR_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PUSHARGR_F
         PUSHARGR_F_JIT(R)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_PUSHARGR_D
         PUSHARGR_D_JIT(R)                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_C
         RETVAL_C_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_UC
         RETVAL_UC_JIT(R)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_S
         RETVAL_S_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_US
         RETVAL_US_JIT(R)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_I
         RETVAL_I_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL
         RETVAL_JIT(R)                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_UI
         RETVAL_UI_JIT(R)                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_L
         RETVAL_L_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_F
         RETVAL_F_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_RETVAL_D
         RETVAL_D_JIT(R)                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JIT_END  CODE(&#39;JIT_DEFINE&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;JIT.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE JIT
<b>&laquo;INCLUDES&raquo;</b>
-STITL JIT
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                              #  ###  #######                         *</i></font>
<font color="#818181"><i>*                              #   #      #                            *</i></font>
<font color="#818181"><i>*                              #   #      #                            *</i></font>
<font color="#818181"><i>*                              #   #      #                            *</i></font>
<font color="#818181"><i>*                        #     #   #      #                            *</i></font>
<font color="#818181"><i>*                        #     #   #      #                            *</i></font>
<font color="#818181"><i>*                         #####   ###     #                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* JIT                JUST-IN-TIME CODE GENERATION                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* QMUL/QDIV NOT YET SUPPORTED</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JIT.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;JIT&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Mon Jun  9 22:44:43 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'JIT.INC'
-LINE 2145 "JIT.lss"
         &CODE = 1
         &CODE = 0
END
<h1>JSON - JSON Support Functions</h1>

JSON is used to serialize/deserialize data structures to JSON form.
Tables, arrays, strings, integers, reals and data types are supported.

Arrays are restricted to a single dimension (1..n) and DATA() types
are not supported (yet). Serializing DATA() would allow for serializing
SCOOP objects, which would be useful. Being able to serialize any
array would also be useful.

Values JSON_NULL, JSON_TRUE and JSON_FALSE are converted to 'null',
'true' and 'false'. The empty array is converted to ARRAY0.

But, even with the current limitations, JSON is useful with WEB
applications, and allows some data to be serialized into data bases
(mostly NDBM). It can also be used for configuration files and other
(for example, snapshots of calculations).

JSON does not have comments. There are a few approaches to commenting.
This decoder supports comments # or // to end of line or /* */
are taken as comments and ignored. This decoder also doesn't need ,
between array elements: [ 1 2 3 ] is the same as [ 1,2,3 ].

JASON_NL and JASON_IN can be set to control the newline and indent
sequences generated by JSON_ENCODE(). SNOBOL4 does not have concepts
for null, true or false. These three constants are defined as
JSON_NULL, JSON_TRUE and JSON_FALSE.

<h2>Uses</h2>
<a href="CH.html">CH</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HASH.html">HASH</a><br>
<a href="HEX.html">HEX</a><br>
<a href="SDIFF.html">SDIFF</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="SIZEA.html">SIZEA</a><br>

<<INCLUDES>>=
-INCLUDE 'CH.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'HEX.INC'
-INCLUDE 'SDIFF.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SIZEA.INC'
@

<<JSON>>=
-PUBLIC JSON_ENCODE(), JSON_DECODE()
         DEFINE('JSON_ENCODE(X)L')
         DEFINE('JSON_DECODE(X)')
*
         DEFINE('JSON_DECODE_STRING()S')
         DEFINE('JSON_DECODE_VALUE()')
         DEFINE('JSON_DECODE_OBJECT()T,T2')
         DEFINE('JSON_DECODE_ARRAY()T,I')
         DEFINE('JSON_ESCAPE(C)')
         DEFINE('JSON_INDENT()')
         DEFINE('JSON_ENCODE_OBJECT(X)K,I')
         DEFINE('JSON_ENCODE_ARRAY(X)I')
         DEFINE('JSON_ENCODE_STRING(S)L,C')
         DEFINE('JSON_ENCODE_VALUE(X)')
*
* JSON WHITESPACE. THIS CAN BE BETWEEN TOKENS, AND WILL BE IGNORED
*
* ALSO EATS 'COMMENTS' DEFINED AS # TO END OF LINE, // TO END OF
* LINE AND /* TO */
*
         JSON_WS2 = SPAN(CHARS_TAB CHARS_SPACE CHARS_FF CHARS_LF
+                        CHARS_CR) |
+                   ('#' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   ('//' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   ('/*' BREAK('*') '*/')
         JSON_WS = (JSON_WS2 *JSON_WS) |
+                  NULL
*
* A JSON NUMBER. PATTERN JSON_NUMBER IS ONLY USED TO DECODE JSON.
* ENCODING USES THE NORMAL OUTPUT FORMATTING, WITH THE RULE THAT
* A TRAILING '0' IS ADDED IF THE NUMBER OUTPUT ENDS IN '.'
*
         JSON_DIGIT19 = ANY("123456789")
         JSON_DIGIT = ANY("0123456789")
         JSON_DIGITS = JSON_DIGIT (*JSON_DIGITS | NULL)
         JSON_E = 'e+' | 'e-' | 'E+' | 'E-' | 'e' | 'E'
         JSON_EXP = JSON_E JSON_DIGITS
         JSON_FRAC = "." JSON_DIGITS
         JSON_INT = ("-" | NULL)
+                   ((JSON_DIGIT19 JSON_DIGITS) | JSON_DIGIT)
         JSON_NUMBER = JSON_INT (JSON_FRAC | NULL) (JSON_EXP | NULL)
*
* JSON CONSTANTS. THESE ARE NOT IN THE SNOBOL4 LEXICON, SO WE
* CREATE A TYPE THAT REPRESENT THESE VALUES UNIQUELY.
*
-PUBLIC JSON_NULL, JSON_TRUE, JSON_FALSE
         DATA('JSON_CONSTANT(VALUE)')
         JSON_NULL = JSON_CONSTANT('null')
         JSON_TRUE = JSON_CONSTANT('true')
         JSON_FALSE = JSON_CONSTANT('false')
*
* JSON_NL AND JSON_IN ARE PRODUCED FOR NEWLINE AND INDENT SEPARATION.
* DEFAULT IS A NEWLINE AND TWO SPACES. TO PRODUCE COMPACT JSON, REPLACE
* WITH NULL.
*
-PUBLIC JSON_NL, JSON_IN
         JSON_NL = CHARS_NL
         JSON_IN = '  '
*
* JSON_REST IS THE REST OF THE INPUT AFTER PARSING A JSON DOCUMENT
* FROM THE FRONT. THIS IS MEANT TO ALLOW CONCATENATION OF JSON
* DOCUMENTS.
*
-PUBLIC JSON_REST
         JSON_REST =
*
* JSON_HEX IS A HEX DIGIT USED BY THE \u CHARACTER IS A JSON STRING.
* JSON_NSET IS THE SET OF CHARACTERS WHICH CAN BE SIMPLY ACCEPTED IN
* A STRING. ANY CHARACTER NOT IN JSON_NSET (NORMAL SET) IS ESCAPED.
*
         JSON_HEX = ANY('0123456789abcdefABCDEF')
         JSON_NSET = SDIFF(CHARS_PRINTABLE, '"\/')           :(JSON_END)
*
JSON_ESCAPE
         JSON_ESCAPE = IDENT(C, '"') '\"'                     :S(RETURN)
         JSON_ESCAPE = IDENT(C, '\') '\\'                     :S(RETURN)
         JSON_ESCAPE = IDENT(C, '/') '\/'                     :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_BS) '\b'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_FF) '\f'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_NL) '\n'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_HT) '\t'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_CR) '\r'                :S(RETURN)
*
* FIXME: NOT RIGHT. SHOULD PASS THROUGH UTF-8, AND ONLY CONVERT CONTROL
*        WE ARE CHEATING BY JUST USING THIS TO CONVERT BYTES.
*
         JSON_ESCAPE = '\u00' HEX(C)                           :(RETURN)
*
JSON_ENCODE_STRING
         L =
         S (SPAN(JSON_NSET) | NULL) . L REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING L
         IDENT(S)                               :S(JSON_ENCODE_STRING_2)
         S LEN(1) . C REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING JSON_ESCAPE(C)
+                                                  :(JSON_ENCODE_STRING)
JSON_ENCODE_STRING_2
         JSON_ENCODE_STRING = '"' JSON_ENCODE_STRING '"'       :(RETURN)
*
* CAREFUL WITH REAL VALUES. CSNOBOL4 WILL PRINT '4.' (FOR EXAMPLE).
* BY THE SYNTAX SPECIFIED, THIS IS NOT LEGAL. '4.0' IS THE LEGAL
* FORM. FIX THIS BY APPENDING A '0' IF THE FINAL CHARACTER OF A REAL
* CONVERSION IS '.'.
*
* BOTH TABLE AND ARRAY TYPES CAUSE A RECURSION. DATA() TYPES CANNOT
* BE SERIALIZED.
*
JSON_ENCODE_VALUE
         JSON_ENCODE_VALUE = IDENT(X, JSON_NULL) 'null'       :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(X, JSON_TRUE) 'true'       :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(X, JSON_FALSE) 'false'     :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(X) '""'                    :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'INTEGER') X  :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'REAL') X
+                                                :F(JSON_ENCODE_VALUE_2)
*
* THE FOLLOWING CONDITION WILL NOT HAPPEN WITH SPITBOL.EXE
*
         JSON_ENCODE_VALUE 'nan' | 'inf'         :S(JSON_ENCODE_VALUE_3)
         JSON_ENCODE_VALUE RTAB(1) '.'                        :F(RETURN)
         JSON_ENCODE_VALUE = JSON_ENCODE_VALUE '0'             :(RETURN)
JSON_ENCODE_VALUE_2
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'STRING')
+                            JSON_ENCODE_STRING(X)            :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'TABLE')
+                            JSON_ENCODE_OBJECT(X)            :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'ARRAY')
+                            JSON_ENCODE_ARRAY(X)             :S(RETURN)
JSON_ENCODE_VALUE_3
         TERMINAL = 'JSON_ENCODE_VALUE: CANNOT ENCODE: '
+                   DATATYPE(X) ' ' X
                                                                  :(END)
*
JSON_INDENT
         JSON_INDENT = DUPL(JSON_IN, L)                        :(RETURN)
*
JSON_ENCODE_ARRAY
         JSON_ENCODE_ARRAY = '['
         L = L + 1
         DIFFER(DATATYPE(X), 'ARRAY')            :S(JSON_ENCODE_ARRAY_2)
         I = 1
         X<I>                                    :F(JSON_ENCODE_ARRAY_2)
JSON_ENCODE_ARRAY_1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT()
+                            JSON_ENCODE_VALUE(X<I>)
         I = I + 1
         X<I>                                    :F(JSON_ENCODE_ARRAY_2)
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY ','
+                                                 :(JSON_ENCODE_ARRAY_1)
JSON_ENCODE_ARRAY_2
         L = L - 1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT() ']'                 :(RETURN)
*
JSON_ENCODE_OBJECT
         JSON_ENCODE_OBJECT = '{'
         L = L + 1
         DIFFER(DATATYPE(X), 'TABLE')           :S(JSON_ENCODE_OBJECT_2)
         K = KEYST(X)                           :F(JSON_ENCODE_OBJECT_2)
         I = 1
JSON_ENCODE_OBJECT_1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT()
+                             JSON_ENCODE_STRING(K<I>) ': '
+                             JSON_ENCODE_VALUE(X<K<I>>)
         I = I + 1
         K<I>                                   :F(JSON_ENCODE_OBJECT_2)
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT ','
+                                                :(JSON_ENCODE_OBJECT_1)
JSON_ENCODE_OBJECT_2
         L = L - 1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT() '}'                :(RETURN)
*
JSON_ENCODE
         L = 0
         JSON_ENCODE = JSON_ENCODE_VALUE(X)                    :(RETURN)
*
JSON_DECODE_STRING
         X BREAK('\"') . S =                                 :F(FRETURN)
         JSON_DECODE_STRING = JSON_DECODE_STRING S
         X POS(0) '"' =                                       :S(RETURN)
         JSON_DECODE_STRING = ?(X ? POS(0) '\b' =)
+                     JSON_DECODE_STRING CHARS_BS :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\f' =)
+                     JSON_DECODE_STRING CHARS_FF :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\n' =)
+                     JSON_DECODE_STRING CHARS_NL :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\t' =)
+                     JSON_DECODE_STRING CHARS_HT :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\r' =)
+                     JSON_DECODE_STRING CHARS_CR :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\"' =)
+                     JSON_DECODE_STRING '"'      :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\\' =)
+                     JSON_DECODE_STRING '\'      :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\/' =)
+                     JSON_DECODE_STRING '/'      :S(JSON_DECODE_STRING)
* FIXME: HANDLE UTF SEQUENCES PROPERLY
         X POS(0) '\u00' (JSON_HEX JSON_HEX) . C =
+                                               :F(JSON_DECODE_STRING_2)
         JSON_DECODE_STRING = JSON_DECODE_STRING CH(C)
+                                                  :(JSON_DECODE_STRING)
JSON_DECODE_STRING_2
         TERMINAL = 'JSON_DECODE_STRING: ' X                      :(END)
*
JSON_DECODE_VALUE
         X POS(0) JSON_WS =
         IDENT(X)                                            :S(FRETURN)
         JSON_DECODE_VALUE = ?(X ? POS(0) 'null' =) JSON_NULL
+                                                             :S(RETURN)
         JSON_DECODE_VALUE = ?(X ? POS(0) 'true' =) JSON_TRUE
+                                                             :S(RETURN)
         JSON_DECODE_VALUE = ?(X ? POS(0) 'false' =) JSON_FALSE
+                                                             :S(RETURN)
         X POS(0) '"' =                          :F(JSON_DECODE_VALUE_2)
         JSON_DECODE_VALUE =  JSON_DECODE_STRING()  :S(RETURN)F(FRETURN)
JSON_DECODE_VALUE_2
         X POS(0) '{' =                          :F(JSON_DECODE_VALUE_3)
         JSON_DECODE_VALUE = JSON_DECODE_OBJECT()   :S(RETURN)F(FRETURN)
JSON_DECODE_VALUE_3
         X POS(0) '[' =                          :F(JSON_DECODE_VALUE_4)
         JSON_DECODE_VALUE = JSON_DECODE_ARRAY()    :S(RETURN)F(FRETURN)
JSON_DECODE_VALUE_4
         X JSON_NUMBER . JSON_DECODE_VALUE =                 :F(FRETURN)
         JSON_DECODE_VALUE = +JSON_DECODE_VALUE                :(RETURN)
*
JSON_DECODE_ARRAY
         T = TABLE()
         I = 0
JSON_DECODE_ARRAY_1
         X POS(0) JSON_WS =
         IDENT(X)                                            :S(FRETURN)
         X POS(0) ']' =                          :S(JSON_DECODE_ARRAY_2)
         I = I + 1
         T<I> = JSON_DECODE_VALUE()                          :F(FRETURN)
         X POS(0) JSON_WS ',' =                   :(JSON_DECODE_ARRAY_1)
JSON_DECODE_ARRAY_2
         JSON_DECODE_ARRAY = EQ(I) ARRAY0                     :S(RETURN)
         JSON_DECODE_ARRAY = ARRAY(I)
         SEQ(' JSON_DECODE_ARRAY<I> = T<I> ', .I)              :(RETURN)
*
JSON_DECODE_OBJECT
         JSON_DECODE_OBJECT = TABLE()
JSON_DECODE_OBJECT_1
         X POS(0) JSON_WS =
         IDENT(X)                                            :S(FRETURN)
         X POS(0) '}' =                                       :S(RETURN)
         X POS(0) '"' =                                      :F(FRETURN)
         T = JSON_DECODE_STRING()                            :F(FRETURN)
         X POS(0) JSON_WS ':' =                              :F(FRETURN)
         T2 = JSON_DECODE_VALUE()                            :F(FRETURN)
         JSON_DECODE_OBJECT<T> = T2
         X POS(0) JSON_WS ',' =                  :(JSON_DECODE_OBJECT_1)
*
JSON_DECODE
         X = X CHARS_NL
         JSON_DECODE = JSON_DECODE_VALUE()                   :F(FRETURN)
         JSON_REST = X                                         :(RETURN)
*
JSON_END
*
@

<<unit_test>>=
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'DDT.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'CRACK.INC'
*
         &CODE = 1
         OUTPUT = JSON_ENCODE()
         OUTPUT = JSON_ENCODE(TABLE())
         OUTPUT = JSON_ENCODE(#'A=1,B=2')
         T = #'A=1,B=2.'
         T2 = TABLE()
         T2<'C'> = 'HELLO'
         T2<'D'> = T
         OUTPUT = JSON_ENCODE(T2)
         T2 = TABLE()
         T2<'INTEGER'> = 42
         T2<'REAL'> = &PI
         T2<'REAL2'> = 1.23456789E23
         T2<'STRING'> = 'Hello world'
         T2<'STRING2'> = '"Hello world' CHARS_BS CHAR(255)
         T2<'STRING3'> = CHARS_PRINTABLE
         T2<'STRING4'> = CHARS_HIGH
         T2<'STRING5'> = CHARS_CONTROL
         T2<'ARRAY EMPTY'> = ARRAY0
         T2<'ARRAY'> = %'1,2,3'
         T2<'NULL'> = ''
         OUTPUT = JSON_ENCODE(T2)
         OUTPUT = JSON_ENCODE('A String')
         OUTPUT = JSON_ENCODE(JSON_NULL)
         OUTPUT = JSON_ENCODE(JSON_TRUE)
         OUTPUT = JSON_ENCODE(JSON_FALSE)
         OUTPUT = JSON_ENCODE(%'1,2,3')
         X = 'hello, world\"\\\/"'
         OUTPUT = JSON_DECODE_STRING()
         X = '0\b\u00FF1"'
         OUTPUT = HEX(JSON_DECODE_STRING())
         X = JSON_DECODE('{ "A": 1, "B": "hello" }')
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE('[ 1, 2, 3 ]')
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE('[[] {}]')
         OUTPUT = JSON_ENCODE(X)
         JSON_DECODE('[')                                        :S(END)
         JSON_DECODE('{')                                        :S(END)
         S = '1 2 3'
         JSON_DECODE(S)                                          :F(END)
         JSON_DECODE(JSON_REST)                                  :F(END)
         JSON_DECODE(JSON_REST)                                  :F(END)
         JSON_DECODE(JSON_REST)                                  :S(END)
*
* FIXME: USE SETEXIT() HERE TO CATCH BRANCH TO END, AND MAKE TEST
* SUCCESSFUL. GENERALLY, WE SHOULD HAVE A HARNESS THAT PERMITS, AND
* CHECKS AND LOGS OUTPUTS. A LIGHTWEIGHT TEST HARNESS FOR UNIT TESTING.
*
         &CODE = 0
         JSON_ENCODE(1E309)                                      :S(END)
         &CODE = 1
END
@

<<>>=
-MODULE JSON
-IN72
<<INCLUDES>>
-STITL JSON
-EJECT
*
************************************************************************
*                                                                      *
*                        #   #####   #######  #     #                  *
*                        #  #     #  #     #  ##    #                  *
*                        #  #        #     #  # #   #                  *
*                        #   #####   #     #  #  #  #                  *
*                  #     #        #  #     #  #   # #                  *
*                  #     #  #     #  #     #  #    ##                  *
*                   #####    #####   #######  #     #                  *
*                                                                      *
* JSON                  CONVERT TO AND FROM JSON                       *
*                                                                      *
************************************************************************
*
* JSON.lss
*
<<JSON>>
*
* CE: .F.MSNOBOL4;
@
-MODULE JSON
-IN72
-LINE 39 "JSON.lss"
-INCLUDE 'CH.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'HEX.INC'
-INCLUDE 'SDIFF.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SIZEA.INC'
-LINE 380 "JSON.lss"
-STITL JSON
-EJECT
*
************************************************************************
*                                                                      *
*                        #   #####   #######  #     #                  *
*                        #  #     #  #     #  ##    #                  *
*                        #  #        #     #  # #   #                  *
*                        #   #####   #     #  #  #  #                  *
*                  #     #        #  #     #  #   # #                  *
*                  #     #  #     #  #     #  #    ##                  *
*                   #####    #####   #######  #     #                  *
*                                                                      *
* JSON                  CONVERT TO AND FROM JSON                       *
*                                                                      *
************************************************************************
*
* JSON.lss
*
-LINE 49 "JSON.lss"
-PUBLIC JSON_ENCODE(), JSON_DECODE()
         DEFINE('JSON_ENCODE(X)L')
         DEFINE('JSON_DECODE(X)')
*
         DEFINE('JSON_DECODE_STRING()S')
         DEFINE('JSON_DECODE_VALUE()')
         DEFINE('JSON_DECODE_OBJECT()T,T2')
         DEFINE('JSON_DECODE_ARRAY()T,I')
         DEFINE('JSON_ESCAPE(C)')
         DEFINE('JSON_INDENT()')
         DEFINE('JSON_ENCODE_OBJECT(X)K,I')
         DEFINE('JSON_ENCODE_ARRAY(X)I')
         DEFINE('JSON_ENCODE_STRING(S)L,C')
         DEFINE('JSON_ENCODE_VALUE(X)')
*
* JSON WHITESPACE. THIS CAN BE BETWEEN TOKENS, AND WILL BE IGNORED
*
* ALSO EATS 'COMMENTS' DEFINED AS # TO END OF LINE, // TO END OF
* LINE AND /* TO */
*
         JSON_WS2 = SPAN(CHARS_TAB CHARS_SPACE CHARS_FF CHARS_LF
+                        CHARS_CR) |
+                   ('#' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   ('//' BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   ('/*' BREAK('*') '*/')
         JSON_WS = (JSON_WS2 *JSON_WS) |
+                  NULL
*
* A JSON NUMBER. PATTERN JSON_NUMBER IS ONLY USED TO DECODE JSON.
* ENCODING USES THE NORMAL OUTPUT FORMATTING, WITH THE RULE THAT
* A TRAILING '0' IS ADDED IF THE NUMBER OUTPUT ENDS IN '.'
*
         JSON_DIGIT19 = ANY("123456789")
         JSON_DIGIT = ANY("0123456789")
         JSON_DIGITS = JSON_DIGIT (*JSON_DIGITS | NULL)
         JSON_E = 'e+' | 'e-' | 'E+' | 'E-' | 'e' | 'E'
         JSON_EXP = JSON_E JSON_DIGITS
         JSON_FRAC = "." JSON_DIGITS
         JSON_INT = ("-" | NULL)
+                   ((JSON_DIGIT19 JSON_DIGITS) | JSON_DIGIT)
         JSON_NUMBER = JSON_INT (JSON_FRAC | NULL) (JSON_EXP | NULL)
*
* JSON CONSTANTS. THESE ARE NOT IN THE SNOBOL4 LEXICON, SO WE
* CREATE A TYPE THAT REPRESENT THESE VALUES UNIQUELY.
*
-PUBLIC JSON_NULL, JSON_TRUE, JSON_FALSE
         DATA('JSON_CONSTANT(VALUE)')
         JSON_NULL = JSON_CONSTANT('null')
         JSON_TRUE = JSON_CONSTANT('true')
         JSON_FALSE = JSON_CONSTANT('false')
*
* JSON_NL AND JSON_IN ARE PRODUCED FOR NEWLINE AND INDENT SEPARATION.
* DEFAULT IS A NEWLINE AND TWO SPACES. TO PRODUCE COMPACT JSON, REPLACE
* WITH NULL.
*
-PUBLIC JSON_NL, JSON_IN
         JSON_NL = CHARS_NL
         JSON_IN = '  '
*
* JSON_REST IS THE REST OF THE INPUT AFTER PARSING A JSON DOCUMENT
* FROM THE FRONT. THIS IS MEANT TO ALLOW CONCATENATION OF JSON
* DOCUMENTS.
*
-PUBLIC JSON_REST
         JSON_REST =
*
* JSON_HEX IS A HEX DIGIT USED BY THE \u CHARACTER IS A JSON STRING.
* JSON_NSET IS THE SET OF CHARACTERS WHICH CAN BE SIMPLY ACCEPTED IN
* A STRING. ANY CHARACTER NOT IN JSON_NSET (NORMAL SET) IS ESCAPED.
*
         JSON_HEX = ANY('0123456789abcdefABCDEF')
         JSON_NSET = SDIFF(CHARS_PRINTABLE, '"\/')           :(JSON_END)
*
JSON_ESCAPE
         JSON_ESCAPE = IDENT(C, '"') '\"'                     :S(RETURN)
         JSON_ESCAPE = IDENT(C, '\') '\\'                     :S(RETURN)
         JSON_ESCAPE = IDENT(C, '/') '\/'                     :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_BS) '\b'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_FF) '\f'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_NL) '\n'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_HT) '\t'                :S(RETURN)
         JSON_ESCAPE = IDENT(C, CHARS_CR) '\r'                :S(RETURN)
*
* FIXME: NOT RIGHT. SHOULD PASS THROUGH UTF-8, AND ONLY CONVERT CONTROL
*        WE ARE CHEATING BY JUST USING THIS TO CONVERT BYTES.
*
         JSON_ESCAPE = '\u00' HEX(C)                           :(RETURN)
*
JSON_ENCODE_STRING
         L =
         S (SPAN(JSON_NSET) | NULL) . L REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING L
         IDENT(S)                               :S(JSON_ENCODE_STRING_2)
         S LEN(1) . C REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING JSON_ESCAPE(C)
+                                                  :(JSON_ENCODE_STRING)
JSON_ENCODE_STRING_2
         JSON_ENCODE_STRING = '"' JSON_ENCODE_STRING '"'       :(RETURN)
*
* CAREFUL WITH REAL VALUES. CSNOBOL4 WILL PRINT '4.' (FOR EXAMPLE).
* BY THE SYNTAX SPECIFIED, THIS IS NOT LEGAL. '4.0' IS THE LEGAL
* FORM. FIX THIS BY APPENDING A '0' IF THE FINAL CHARACTER OF A REAL
* CONVERSION IS '.'.
*
* BOTH TABLE AND ARRAY TYPES CAUSE A RECURSION. DATA() TYPES CANNOT
* BE SERIALIZED.
*
JSON_ENCODE_VALUE
         JSON_ENCODE_VALUE = IDENT(X, JSON_NULL) 'null'       :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(X, JSON_TRUE) 'true'       :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(X, JSON_FALSE) 'false'     :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(X) '""'                    :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'INTEGER') X  :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'REAL') X
+                                                :F(JSON_ENCODE_VALUE_2)
*
* THE FOLLOWING CONDITION WILL NOT HAPPEN WITH SPITBOL.EXE
*
         JSON_ENCODE_VALUE 'nan' | 'inf'         :S(JSON_ENCODE_VALUE_3)
         JSON_ENCODE_VALUE RTAB(1) '.'                        :F(RETURN)
         JSON_ENCODE_VALUE = JSON_ENCODE_VALUE '0'             :(RETURN)
JSON_ENCODE_VALUE_2
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'STRING')
+                            JSON_ENCODE_STRING(X)            :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'TABLE')
+                            JSON_ENCODE_OBJECT(X)            :S(RETURN)
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), 'ARRAY')
+                            JSON_ENCODE_ARRAY(X)             :S(RETURN)
JSON_ENCODE_VALUE_3
         TERMINAL = 'JSON_ENCODE_VALUE: CANNOT ENCODE: '
+                   DATATYPE(X) ' ' X
                                                                  :(END)
*
JSON_INDENT
         JSON_INDENT = DUPL(JSON_IN, L)                        :(RETURN)
*
JSON_ENCODE_ARRAY
         JSON_ENCODE_ARRAY = '['
         L = L + 1
         DIFFER(DATATYPE(X), 'ARRAY')            :S(JSON_ENCODE_ARRAY_2)
         I = 1
         X<I>                                    :F(JSON_ENCODE_ARRAY_2)
JSON_ENCODE_ARRAY_1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT()
+                            JSON_ENCODE_VALUE(X<I>)
         I = I + 1
         X<I>                                    :F(JSON_ENCODE_ARRAY_2)
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY ','
+                                                 :(JSON_ENCODE_ARRAY_1)
JSON_ENCODE_ARRAY_2
         L = L - 1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT() ']'                 :(RETURN)
*
JSON_ENCODE_OBJECT
         JSON_ENCODE_OBJECT = '{'
         L = L + 1
         DIFFER(DATATYPE(X), 'TABLE')           :S(JSON_ENCODE_OBJECT_2)
         K = KEYST(X)                           :F(JSON_ENCODE_OBJECT_2)
         I = 1
JSON_ENCODE_OBJECT_1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT()
+                             JSON_ENCODE_STRING(K<I>) ': '
+                             JSON_ENCODE_VALUE(X<K<I>>)
         I = I + 1
         K<I>                                   :F(JSON_ENCODE_OBJECT_2)
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT ','
+                                                :(JSON_ENCODE_OBJECT_1)
JSON_ENCODE_OBJECT_2
         L = L - 1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT() '}'                :(RETURN)
*
JSON_ENCODE
         L = 0
         JSON_ENCODE = JSON_ENCODE_VALUE(X)                    :(RETURN)
*
JSON_DECODE_STRING
         X BREAK('\"') . S =                                 :F(FRETURN)
         JSON_DECODE_STRING = JSON_DECODE_STRING S
         X POS(0) '"' =                                       :S(RETURN)
         JSON_DECODE_STRING = ?(X ? POS(0) '\b' =)
+                     JSON_DECODE_STRING CHARS_BS :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\f' =)
+                     JSON_DECODE_STRING CHARS_FF :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\n' =)
+                     JSON_DECODE_STRING CHARS_NL :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\t' =)
+                     JSON_DECODE_STRING CHARS_HT :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\r' =)
+                     JSON_DECODE_STRING CHARS_CR :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\"' =)
+                     JSON_DECODE_STRING '"'      :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\\' =)
+                     JSON_DECODE_STRING '\'      :S(JSON_DECODE_STRING)
         JSON_DECODE_STRING = ?(X ? POS(0) '\/' =)
+                     JSON_DECODE_STRING '/'      :S(JSON_DECODE_STRING)
* FIXME: HANDLE UTF SEQUENCES PROPERLY
         X POS(0) '\u00' (JSON_HEX JSON_HEX) . C =
+                                               :F(JSON_DECODE_STRING_2)
         JSON_DECODE_STRING = JSON_DECODE_STRING CH(C)
+                                                  :(JSON_DECODE_STRING)
JSON_DECODE_STRING_2
         TERMINAL = 'JSON_DECODE_STRING: ' X                      :(END)
*
JSON_DECODE_VALUE
         X POS(0) JSON_WS =
         IDENT(X)                                            :S(FRETURN)
         JSON_DECODE_VALUE = ?(X ? POS(0) 'null' =) JSON_NULL
+                                                             :S(RETURN)
         JSON_DECODE_VALUE = ?(X ? POS(0) 'true' =) JSON_TRUE
+                                                             :S(RETURN)
         JSON_DECODE_VALUE = ?(X ? POS(0) 'false' =) JSON_FALSE
+                                                             :S(RETURN)
         X POS(0) '"' =                          :F(JSON_DECODE_VALUE_2)
         JSON_DECODE_VALUE =  JSON_DECODE_STRING()  :S(RETURN)F(FRETURN)
JSON_DECODE_VALUE_2
         X POS(0) '{' =                          :F(JSON_DECODE_VALUE_3)
         JSON_DECODE_VALUE = JSON_DECODE_OBJECT()   :S(RETURN)F(FRETURN)
JSON_DECODE_VALUE_3
         X POS(0) '[' =                          :F(JSON_DECODE_VALUE_4)
         JSON_DECODE_VALUE = JSON_DECODE_ARRAY()    :S(RETURN)F(FRETURN)
JSON_DECODE_VALUE_4
         X JSON_NUMBER . JSON_DECODE_VALUE =                 :F(FRETURN)
         JSON_DECODE_VALUE = +JSON_DECODE_VALUE                :(RETURN)
*
JSON_DECODE_ARRAY
         T = TABLE()
         I = 0
JSON_DECODE_ARRAY_1
         X POS(0) JSON_WS =
         IDENT(X)                                            :S(FRETURN)
         X POS(0) ']' =                          :S(JSON_DECODE_ARRAY_2)
         I = I + 1
         T<I> = JSON_DECODE_VALUE()                          :F(FRETURN)
         X POS(0) JSON_WS ',' =                   :(JSON_DECODE_ARRAY_1)
JSON_DECODE_ARRAY_2
         JSON_DECODE_ARRAY = EQ(I) ARRAY0                     :S(RETURN)
         JSON_DECODE_ARRAY = ARRAY(I)
         SEQ(' JSON_DECODE_ARRAY<I> = T<I> ', .I)              :(RETURN)
*
JSON_DECODE_OBJECT
         JSON_DECODE_OBJECT = TABLE()
JSON_DECODE_OBJECT_1
         X POS(0) JSON_WS =
         IDENT(X)                                            :S(FRETURN)
         X POS(0) '}' =                                       :S(RETURN)
         X POS(0) '"' =                                      :F(FRETURN)
         T = JSON_DECODE_STRING()                            :F(FRETURN)
         X POS(0) JSON_WS ':' =                              :F(FRETURN)
         T2 = JSON_DECODE_VALUE()                            :F(FRETURN)
         JSON_DECODE_OBJECT<T> = T2
         X POS(0) JSON_WS ',' =                  :(JSON_DECODE_OBJECT_1)
*
JSON_DECODE
         X = X CHARS_NL
         JSON_DECODE = JSON_DECODE_VALUE()                   :F(FRETURN)
         JSON_REST = X                                         :(RETURN)
*
JSON_END
*
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>JSON - JSON Support Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
JSON is used to serialize/deserialize data structures to JSON form.
Tables, arrays, strings, integers, reals and data types are supported.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Arrays are restricted to a single dimension (1..n) and DATA() types
are not supported (yet). Serializing DATA() would allow for serializing
SCOOP objects, which would be useful. Being able to serialize any
array would also be useful.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Values JSON_NULL, JSON_TRUE and JSON_FALSE are converted to 'null',
'true' and 'false'. The empty array is converted to ARRAY0.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
But, even with the current limitations, JSON is useful with WEB
applications, and allows some data to be serialized into data bases
(mostly NDBM). It can also be used for configuration files and other
(for example, snapshots of calculations).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
JSON does not have comments. There are a few approaches to commenting.
This decoder supports comments # or // to end of line or /* */
are taken as comments and ignored. This decoder also doesn't need ,
between array elements: [ 1 2 3 ] is the same as [ 1,2,3 ].
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
JASON_NL and JASON_IN can be set to control the newline and indent
sequences generated by JSON_ENCODE(). SNOBOL4 does not have concepts
for null, true or false. These three constants are defined as
JSON_NULL, JSON_TRUE and JSON_FALSE.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CH.html">CH</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="HASH.html">HASH</a><br>
<a href="HEX.html">HEX</a><br>
<a href="SDIFF.html">SDIFF</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="SIZEA.html">SIZEA</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CH.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;HEX.INC&#39;
-INCLUDE &#39;SDIFF.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;SIZEA.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;JSON&raquo;&equiv;</b>
-PUBLIC JSON_ENCODE(), JSON_DECODE()
         DEFINE(&#39;JSON_ENCODE(X)L&#39;)
         DEFINE(&#39;JSON_DECODE(X)&#39;)
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;JSON_DECODE_STRING()S&#39;)
         DEFINE(&#39;JSON_DECODE_VALUE()&#39;)
         DEFINE(&#39;JSON_DECODE_OBJECT()T,T2&#39;)
         DEFINE(&#39;JSON_DECODE_ARRAY()T,I&#39;)
         DEFINE(&#39;JSON_ESCAPE(C)&#39;)
         DEFINE(&#39;JSON_INDENT()&#39;)
         DEFINE(&#39;JSON_ENCODE_OBJECT(X)K,I&#39;)
         DEFINE(&#39;JSON_ENCODE_ARRAY(X)I&#39;)
         DEFINE(&#39;JSON_ENCODE_STRING(S)L,C&#39;)
         DEFINE(&#39;JSON_ENCODE_VALUE(X)&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON WHITESPACE. THIS CAN BE BETWEEN TOKENS, AND WILL BE IGNORED</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ALSO EATS &#39;COMMENTS&#39; DEFINED AS # TO END OF LINE, // TO END OF</i></font>
<font color="#818181"><i>* LINE AND /* TO */</i></font>
<font color="#818181"><i>*</i></font>
         JSON_WS2 = SPAN(CHARS_TAB CHARS_SPACE CHARS_FF CHARS_LF
+                        CHARS_CR) |
+                   (&#39;#&#39; BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   (&#39;//&#39; BREAK(CHARS_LF CHARS_CR) LEN(1)) |
+                   (&#39;/*&#39; BREAK(&#39;*&#39;) &#39;*/&#39;)
         JSON_WS = (JSON_WS2 *JSON_WS) |
+                  NULL
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A JSON NUMBER. PATTERN JSON_NUMBER IS ONLY USED TO DECODE JSON.</i></font>
<font color="#818181"><i>* ENCODING USES THE NORMAL OUTPUT FORMATTING, WITH THE RULE THAT</i></font>
<font color="#818181"><i>* A TRAILING &#39;0&#39; IS ADDED IF THE NUMBER OUTPUT ENDS IN &#39;.&#39;</i></font>
<font color="#818181"><i>*</i></font>
         JSON_DIGIT19 = ANY(&quot;123456789&quot;)
         JSON_DIGIT = ANY(&quot;0123456789&quot;)
         JSON_DIGITS = JSON_DIGIT (*JSON_DIGITS | NULL)
         JSON_E = &#39;e+&#39; | &#39;e-&#39; | &#39;E+&#39; | &#39;E-&#39; | &#39;e&#39; | &#39;E&#39;
         JSON_EXP = JSON_E JSON_DIGITS
         JSON_FRAC = &quot;.&quot; JSON_DIGITS
         JSON_INT = (&quot;-&quot; | NULL)
+                   ((JSON_DIGIT19 JSON_DIGITS) | JSON_DIGIT)
         JSON_NUMBER = JSON_INT (JSON_FRAC | NULL) (JSON_EXP | NULL)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON CONSTANTS. THESE ARE NOT IN THE SNOBOL4 LEXICON, SO WE</i></font>
<font color="#818181"><i>* CREATE A TYPE THAT REPRESENT THESE VALUES UNIQUELY.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC JSON_NULL, JSON_TRUE, JSON_FALSE
         DATA(&#39;JSON_CONSTANT(VALUE)&#39;)
         JSON_NULL = JSON_CONSTANT(&#39;null&#39;)
         JSON_TRUE = JSON_CONSTANT(&#39;true&#39;)
         JSON_FALSE = JSON_CONSTANT(&#39;false&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON_NL AND JSON_IN ARE PRODUCED FOR NEWLINE AND INDENT SEPARATION.</i></font>
<font color="#818181"><i>* DEFAULT IS A NEWLINE AND TWO SPACES. TO PRODUCE COMPACT JSON, REPLACE</i></font>
<font color="#818181"><i>* WITH NULL.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC JSON_NL, JSON_IN
         JSON_NL = CHARS_NL
         JSON_IN = &#39;  &#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON_REST IS THE REST OF THE INPUT AFTER PARSING A JSON DOCUMENT</i></font>
<font color="#818181"><i>* FROM THE FRONT. THIS IS MEANT TO ALLOW CONCATENATION OF JSON</i></font>
<font color="#818181"><i>* DOCUMENTS.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC JSON_REST
         JSON_REST =
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON_HEX IS A HEX DIGIT USED BY THE \u CHARACTER IS A JSON STRING.</i></font>
<font color="#818181"><i>* JSON_NSET IS THE SET OF CHARACTERS WHICH CAN BE SIMPLY ACCEPTED IN</i></font>
<font color="#818181"><i>* A STRING. ANY CHARACTER NOT IN JSON_NSET (NORMAL SET) IS ESCAPED.</i></font>
<font color="#818181"><i>*</i></font>
         JSON_HEX = ANY(&#39;0123456789abcdefABCDEF&#39;)
         JSON_NSET = SDIFF(CHARS_PRINTABLE, &#39;&quot;\/&#39;)           <b>:(JSON_END)</b>
<font color="#818181"><i>*</i></font>
JSON_ESCAPE
         JSON_ESCAPE = IDENT(C, &#39;&quot;&#39;) &#39;\&quot;&#39;                     <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, &#39;\&#39;) &#39;\\&#39;                     <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, &#39;/&#39;) &#39;\/&#39;                     <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_BS) &#39;\b&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_FF) &#39;\f&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_NL) &#39;\n&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_HT) &#39;\t&#39;                <b>:S(RETURN)</b>
         JSON_ESCAPE = IDENT(C, CHARS_CR) &#39;\r&#39;                <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME: NOT RIGHT. SHOULD PASS THROUGH UTF-8, AND ONLY CONVERT CONTROL</i></font>
<font color="#818181"><i>*        WE ARE CHEATING BY JUST USING THIS TO CONVERT BYTES.</i></font>
<font color="#818181"><i>*</i></font>
         JSON_ESCAPE = &#39;\u00&#39; HEX(C)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_STRING
         L =
         S (SPAN(JSON_NSET) | NULL) . L REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING L
         IDENT(S)                               <b>:S(JSON_ENCODE_STRING_2)</b>
         S LEN(1) . C REM . S
         JSON_ENCODE_STRING = JSON_ENCODE_STRING JSON_ESCAPE(C)
+                                                  <b>:(JSON_ENCODE_STRING)</b>
JSON_ENCODE_STRING_2
         JSON_ENCODE_STRING = &#39;&quot;&#39; JSON_ENCODE_STRING &#39;&quot;&#39;       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CAREFUL WITH REAL VALUES. CSNOBOL4 WILL PRINT &#39;4.&#39; (FOR EXAMPLE).</i></font>
<font color="#818181"><i>* BY THE SYNTAX SPECIFIED, THIS IS NOT LEGAL. &#39;4.0&#39; IS THE LEGAL</i></font>
<font color="#818181"><i>* FORM. FIX THIS BY APPENDING A &#39;0&#39; IF THE FINAL CHARACTER OF A REAL</i></font>
<font color="#818181"><i>* CONVERSION IS &#39;.&#39;.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BOTH TABLE AND ARRAY TYPES CAUSE A RECURSION. DATA() TYPES CANNOT</i></font>
<font color="#818181"><i>* BE SERIALIZED.</i></font>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_VALUE
         JSON_ENCODE_VALUE = IDENT(X, JSON_NULL) &#39;null&#39;       <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(X, JSON_TRUE) &#39;true&#39;       <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(X, JSON_FALSE) &#39;false&#39;     <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(X) &#39;&quot;&quot;&#39;                    <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;INTEGER&#39;) X  <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;REAL&#39;) X
+                                                <b>:F(JSON_ENCODE_VALUE_2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THE FOLLOWING CONDITION WILL NOT HAPPEN WITH SPITBOL.EXE</i></font>
<font color="#818181"><i>*</i></font>
         JSON_ENCODE_VALUE &#39;nan&#39; | &#39;inf&#39;         <b>:S(JSON_ENCODE_VALUE_3)</b>
         JSON_ENCODE_VALUE RTAB(1) &#39;.&#39;                        <b>:F(RETURN)</b>
         JSON_ENCODE_VALUE = JSON_ENCODE_VALUE &#39;0&#39;             <b>:(RETURN)</b>
JSON_ENCODE_VALUE_2
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;STRING&#39;)
+                            JSON_ENCODE_STRING(X)            <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;TABLE&#39;)
+                            JSON_ENCODE_OBJECT(X)            <b>:S(RETURN)</b>
         JSON_ENCODE_VALUE = IDENT(DATATYPE(X), &#39;ARRAY&#39;)
+                            JSON_ENCODE_ARRAY(X)             <b>:S(RETURN)</b>
JSON_ENCODE_VALUE_3
         TERMINAL = &#39;JSON_ENCODE_VALUE: CANNOT ENCODE: &#39;
+                   DATATYPE(X) &#39; &#39; X
                                                                  <b>:(END)</b>
<font color="#818181"><i>*</i></font>
JSON_INDENT
         JSON_INDENT = DUPL(JSON_IN, L)                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_ARRAY
         JSON_ENCODE_ARRAY = &#39;[&#39;
         L = L + 1
         DIFFER(DATATYPE(X), &#39;ARRAY&#39;)            <b>:S(JSON_ENCODE_ARRAY_2)</b>
         I = 1
         X&lt;I&gt;                                    <b>:F(JSON_ENCODE_ARRAY_2)</b>
JSON_ENCODE_ARRAY_1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT()
+                            JSON_ENCODE_VALUE(X&lt;I&gt;)
         I = I + 1
         X&lt;I&gt;                                    <b>:F(JSON_ENCODE_ARRAY_2)</b>
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY &#39;,&#39;
+                                                 <b>:(JSON_ENCODE_ARRAY_1)</b>
JSON_ENCODE_ARRAY_2
         L = L - 1
         JSON_ENCODE_ARRAY = JSON_ENCODE_ARRAY JSON_NL
+                            JSON_INDENT() &#39;]&#39;                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE_OBJECT
         JSON_ENCODE_OBJECT = &#39;{&#39;
         L = L + 1
         DIFFER(DATATYPE(X), &#39;TABLE&#39;)           <b>:S(JSON_ENCODE_OBJECT_2)</b>
         K = KEYST(X)                           <b>:F(JSON_ENCODE_OBJECT_2)</b>
         I = 1
JSON_ENCODE_OBJECT_1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT()
+                             JSON_ENCODE_STRING(K&lt;I&gt;) &#39;: &#39;
+                             JSON_ENCODE_VALUE(X&lt;K&lt;I&gt;&gt;)
         I = I + 1
         K&lt;I&gt;                                   <b>:F(JSON_ENCODE_OBJECT_2)</b>
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT &#39;,&#39;
+                                                <b>:(JSON_ENCODE_OBJECT_1)</b>
JSON_ENCODE_OBJECT_2
         L = L - 1
         JSON_ENCODE_OBJECT = JSON_ENCODE_OBJECT JSON_NL
+                             JSON_INDENT() &#39;}&#39;                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_ENCODE
         L = 0
         JSON_ENCODE = JSON_ENCODE_VALUE(X)                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_STRING
         X BREAK(&#39;\&quot;&#39;) . S =                                 <b>:F(FRETURN)</b>
         JSON_DECODE_STRING = JSON_DECODE_STRING S
         X POS(0) &#39;&quot;&#39; =                                       <b>:S(RETURN)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\b&#39; =)
+                     JSON_DECODE_STRING CHARS_BS <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\f&#39; =)
+                     JSON_DECODE_STRING CHARS_FF <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\n&#39; =)
+                     JSON_DECODE_STRING CHARS_NL <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\t&#39; =)
+                     JSON_DECODE_STRING CHARS_HT <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\r&#39; =)
+                     JSON_DECODE_STRING CHARS_CR <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\&quot;&#39; =)
+                     JSON_DECODE_STRING &#39;&quot;&#39;      <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\\&#39; =)
+                     JSON_DECODE_STRING &#39;\&#39;      <b>:S(JSON_DECODE_STRING)</b>
         JSON_DECODE_STRING = ?(X ? POS(0) &#39;\/&#39; =)
+                     JSON_DECODE_STRING &#39;/&#39;      <b>:S(JSON_DECODE_STRING)</b>
<font color="#818181"><i>* FIXME: HANDLE UTF SEQUENCES PROPERLY</i></font>
         X POS(0) &#39;\u00&#39; (JSON_HEX JSON_HEX) . C =
+                                               <b>:F(JSON_DECODE_STRING_2)</b>
         JSON_DECODE_STRING = JSON_DECODE_STRING CH(C)
+                                                  <b>:(JSON_DECODE_STRING)</b>
JSON_DECODE_STRING_2
         TERMINAL = &#39;JSON_DECODE_STRING: &#39; X                      <b>:(END)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_VALUE
         X POS(0) JSON_WS =
         IDENT(X)                                            <b>:S(FRETURN)</b>
         JSON_DECODE_VALUE = ?(X ? POS(0) &#39;null&#39; =) JSON_NULL
+                                                             <b>:S(RETURN)</b>
         JSON_DECODE_VALUE = ?(X ? POS(0) &#39;true&#39; =) JSON_TRUE
+                                                             <b>:S(RETURN)</b>
         JSON_DECODE_VALUE = ?(X ? POS(0) &#39;false&#39; =) JSON_FALSE
+                                                             <b>:S(RETURN)</b>
         X POS(0) &#39;&quot;&#39; =                          <b>:F(JSON_DECODE_VALUE_2)</b>
         JSON_DECODE_VALUE =  JSON_DECODE_STRING()  <b>:S(RETURN)F(FRETURN)</b>
JSON_DECODE_VALUE_2
         X POS(0) &#39;{&#39; =                          <b>:F(JSON_DECODE_VALUE_3)</b>
         JSON_DECODE_VALUE = JSON_DECODE_OBJECT()   <b>:S(RETURN)F(FRETURN)</b>
JSON_DECODE_VALUE_3
         X POS(0) &#39;[&#39; =                          <b>:F(JSON_DECODE_VALUE_4)</b>
         JSON_DECODE_VALUE = JSON_DECODE_ARRAY()    <b>:S(RETURN)F(FRETURN)</b>
JSON_DECODE_VALUE_4
         X JSON_NUMBER . JSON_DECODE_VALUE =                 <b>:F(FRETURN)</b>
         JSON_DECODE_VALUE = +JSON_DECODE_VALUE                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_ARRAY
         T = TABLE()
         I = 0
JSON_DECODE_ARRAY_1
         X POS(0) JSON_WS =
         IDENT(X)                                            <b>:S(FRETURN)</b>
         X POS(0) &#39;]&#39; =                          <b>:S(JSON_DECODE_ARRAY_2)</b>
         I = I + 1
         T&lt;I&gt; = JSON_DECODE_VALUE()                          <b>:F(FRETURN)</b>
         X POS(0) JSON_WS &#39;,&#39; =                   <b>:(JSON_DECODE_ARRAY_1)</b>
JSON_DECODE_ARRAY_2
         JSON_DECODE_ARRAY = EQ(I) ARRAY0                     <b>:S(RETURN)</b>
         JSON_DECODE_ARRAY = ARRAY(I)
         SEQ(&#39; JSON_DECODE_ARRAY&lt;I&gt; = T&lt;I&gt; &#39;, .I)              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE_OBJECT
         JSON_DECODE_OBJECT = TABLE()
JSON_DECODE_OBJECT_1
         X POS(0) JSON_WS =
         IDENT(X)                                            <b>:S(FRETURN)</b>
         X POS(0) &#39;}&#39; =                                       <b>:S(RETURN)</b>
         X POS(0) &#39;&quot;&#39; =                                      <b>:F(FRETURN)</b>
         T = JSON_DECODE_STRING()                            <b>:F(FRETURN)</b>
         X POS(0) JSON_WS &#39;:&#39; =                              <b>:F(FRETURN)</b>
         T2 = JSON_DECODE_VALUE()                            <b>:F(FRETURN)</b>
         JSON_DECODE_OBJECT&lt;T&gt; = T2
         X POS(0) JSON_WS &#39;,&#39; =                  <b>:(JSON_DECODE_OBJECT_1)</b>
<font color="#818181"><i>*</i></font>
JSON_DECODE
         X = X CHARS_NL
         JSON_DECODE = JSON_DECODE_VALUE()                   <b>:F(FRETURN)</b>
         JSON_REST = X                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
JSON_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;DDT.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         OUTPUT = JSON_ENCODE()
         OUTPUT = JSON_ENCODE(TABLE())
         OUTPUT = JSON_ENCODE(#&#39;A=1,B=2&#39;)
         T = #&#39;A=1,B=2.&#39;
         T2 = TABLE()
         T2&lt;&#39;C&#39;&gt; = &#39;HELLO&#39;
         T2&lt;&#39;D&#39;&gt; = T
         OUTPUT = JSON_ENCODE(T2)
         T2 = TABLE()
         T2&lt;&#39;INTEGER&#39;&gt; = 42
         T2&lt;&#39;REAL&#39;&gt; = &amp;PI
         T2&lt;&#39;REAL2&#39;&gt; = 1.23456789E23
         T2&lt;&#39;STRING&#39;&gt; = &#39;Hello world&#39;
         T2&lt;&#39;STRING2&#39;&gt; = &#39;&quot;Hello world&#39; CHARS_BS CHAR(255)
         T2&lt;&#39;STRING3&#39;&gt; = CHARS_PRINTABLE
         T2&lt;&#39;STRING4&#39;&gt; = CHARS_HIGH
         T2&lt;&#39;STRING5&#39;&gt; = CHARS_CONTROL
         T2&lt;&#39;ARRAY EMPTY&#39;&gt; = ARRAY0
         T2&lt;&#39;ARRAY&#39;&gt; = %&#39;1,2,3&#39;
         T2&lt;&#39;NULL&#39;&gt; = &#39;&#39;
         OUTPUT = JSON_ENCODE(T2)
         OUTPUT = JSON_ENCODE(&#39;A String&#39;)
         OUTPUT = JSON_ENCODE(JSON_NULL)
         OUTPUT = JSON_ENCODE(JSON_TRUE)
         OUTPUT = JSON_ENCODE(JSON_FALSE)
         OUTPUT = JSON_ENCODE(%&#39;1,2,3&#39;)
         X = &#39;hello, world\&quot;\\\/&quot;&#39;
         OUTPUT = JSON_DECODE_STRING()
         X = &#39;0\b\u00FF1&quot;&#39;
         OUTPUT = HEX(JSON_DECODE_STRING())
         X = JSON_DECODE(&#39;{ &quot;A&quot;: 1, &quot;B&quot;: &quot;hello&quot; }&#39;)
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE(&#39;[ 1, 2, 3 ]&#39;)
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE(&#39;[[] {}]&#39;)
         OUTPUT = JSON_ENCODE(X)
         JSON_DECODE(&#39;[&#39;)                                        <b>:S(END)</b>
         JSON_DECODE(&#39;{&#39;)                                        <b>:S(END)</b>
         S = &#39;1 2 3&#39;
         JSON_DECODE(S)                                          <b>:F(END)</b>
         JSON_DECODE(JSON_REST)                                  <b>:F(END)</b>
         JSON_DECODE(JSON_REST)                                  <b>:F(END)</b>
         JSON_DECODE(JSON_REST)                                  <b>:S(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIXME: USE SETEXIT() HERE TO CATCH BRANCH TO END, AND MAKE TEST</i></font>
<font color="#818181"><i>* SUCCESSFUL. GENERALLY, WE SHOULD HAVE A HARNESS THAT PERMITS, AND</i></font>
<font color="#818181"><i>* CHECKS AND LOGS OUTPUTS. A LIGHTWEIGHT TEST HARNESS FOR UNIT TESTING.</i></font>
<font color="#818181"><i>*</i></font>
         &amp;CODE = 0
         JSON_ENCODE(1E309)                                      <b>:S(END)</b>
         &amp;CODE = 1
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE JSON
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL JSON
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                        #   #####   #######  #     #                  *</i></font>
<font color="#818181"><i>*                        #  #     #  #     #  ##    #                  *</i></font>
<font color="#818181"><i>*                        #  #        #     #  # #   #                  *</i></font>
<font color="#818181"><i>*                        #   #####   #     #  #  #  #                  *</i></font>
<font color="#818181"><i>*                  #     #        #  #     #  #   # #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #     #  #    ##                  *</i></font>
<font color="#818181"><i>*                   #####    #####   #######  #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* JSON                  CONVERT TO AND FROM JSON                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* JSON.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;JSON&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:01:52 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'DDT.INC'
-LINE 318 "JSON.lss"
-INCLUDE 'JSON.INC'
-INCLUDE 'CRACK.INC'
*
         &CODE = 1
         OUTPUT = JSON_ENCODE()
         OUTPUT = JSON_ENCODE(TABLE())
         OUTPUT = JSON_ENCODE(#'A=1,B=2')
         T = #'A=1,B=2.'
         T2 = TABLE()
         T2<'C'> = 'HELLO'
         T2<'D'> = T
         OUTPUT = JSON_ENCODE(T2)
         T2 = TABLE()
         T2<'INTEGER'> = 42
         T2<'REAL'> = &PI
         T2<'REAL2'> = 1.23456789E23
         T2<'STRING'> = 'Hello world'
         T2<'STRING2'> = '"Hello world' CHARS_BS CHAR(255)
         T2<'STRING3'> = CHARS_PRINTABLE
         T2<'STRING4'> = CHARS_HIGH
         T2<'STRING5'> = CHARS_CONTROL
         T2<'ARRAY EMPTY'> = ARRAY0
         T2<'ARRAY'> = %'1,2,3'
         T2<'NULL'> = ''
         OUTPUT = JSON_ENCODE(T2)
         OUTPUT = JSON_ENCODE('A String')
         OUTPUT = JSON_ENCODE(JSON_NULL)
         OUTPUT = JSON_ENCODE(JSON_TRUE)
         OUTPUT = JSON_ENCODE(JSON_FALSE)
         OUTPUT = JSON_ENCODE(%'1,2,3')
         X = 'hello, world\"\\\/"'
         OUTPUT = JSON_DECODE_STRING()
         X = '0\b\u00FF1"'
         OUTPUT = HEX(JSON_DECODE_STRING())
         X = JSON_DECODE('{ "A": 1, "B": "hello" }')
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE('[ 1, 2, 3 ]')
         OUTPUT = JSON_ENCODE(X)
         X = JSON_DECODE('[[] {}]')
         OUTPUT = JSON_ENCODE(X)
         JSON_DECODE('[')                                        :S(END)
         JSON_DECODE('{')                                        :S(END)
         S = '1 2 3'
         JSON_DECODE(S)                                          :F(END)
         JSON_DECODE(JSON_REST)                                  :F(END)
         JSON_DECODE(JSON_REST)                                  :F(END)
         JSON_DECODE(JSON_REST)                                  :S(END)
*
* FIXME: USE SETEXIT() HERE TO CATCH BRANCH TO END, AND MAKE TEST
* SUCCESSFUL. GENERALLY, WE SHOULD HAVE A HARNESS THAT PERMITS, AND
* CHECKS AND LOGS OUTPUTS. A LIGHTWEIGHT TEST HARNESS FOR UNIT TESTING.
*
         &CODE = 0
         JSON_ENCODE(1E309)                                      :S(END)
         &CODE = 1
END
<h1>LAST - Return last list element</h1>

[[LAST(L)]] will return (by name) the name of the last [[NEXT]] field
of a list. Thus, if [[L1]] and [[L2]] are lists, [[LAST(L1) = L2]] will
concatenate the two lists. [[LAST(L) = L]] creates a circular list.

<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>

<<INCLUDES>>=
-INCLUDE 'LINK.INC'
@

<<LAST>>=
-MODULE LAST
-PUBLIC LAST()
         DEFINE('LAST(L)')                                   :(LAST_END)
*
LAST     IDENT(L)                                            :S(FRETURN)
LAST_1   L = DIFFER(NEXT(L)) NEXT(L)                          :S(LAST_1)
         LAST = .NEXT(L)                                      :(NRETURN)
*
LAST_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LAST.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL LAST
-EJECT
*
************************************************************************
*                                                                      *
*                  #           #      #####   #######                  *
*                  #          # #    #     #     #                     *
*                  #         #   #   #           #                     *
*                  #        #     #   #####      #                     *
*                  #        #######        #     #                     *
*                  #        #     #  #     #     #                     *
*                  #######  #     #   #####      #                     *
*                                                                      *
* LAST                 RETURN LAST LIST ELEMENT                        *
*                                                                      *
************************************************************************
*
* LAST.lss
*
<<LAST>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "LAST.lss"
-INCLUDE 'LINK.INC'
-STITL LAST
-EJECT
-LINE 39 "LAST.lss"
*
************************************************************************
*                                                                      *
*                  #           #      #####   #######                  *
*                  #          # #    #     #     #                     *
*                  #         #   #   #           #                     *
*                  #        #     #   #####      #                     *
*                  #        #######        #     #                     *
*                  #        #     #  #     #     #                     *
*                  #######  #     #   #####      #                     *
*                                                                      *
* LAST                 RETURN LAST LIST ELEMENT                        *
*                                                                      *
************************************************************************
*
* LAST.lss
*
-LINE 15 "LAST.lss"
-MODULE LAST
-PUBLIC LAST()
         DEFINE('LAST(L)')                                   :(LAST_END)
*
LAST     IDENT(L)                                            :S(FRETURN)
LAST_1   L = DIFFER(NEXT(L)) NEXT(L)                          :S(LAST_1)
         LAST = .NEXT(L)                                      :(NRETURN)
*
LAST_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>LAST - Return last list element</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">LAST(L)</font> will return (by name) the name of the last <font face="Source Code Pro">NEXT</font> field
of a list. Thus, if <font face="Source Code Pro">L1</font> and <font face="Source Code Pro">L2</font> are lists, <font face="Source Code Pro">LAST(L1) = L2</font> will
concatenate the two lists. <font face="Source Code Pro">LAST(L) = L</font> creates a circular list.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LINK.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LAST&raquo;&equiv;</b>
-MODULE LAST
-PUBLIC LAST()
         DEFINE(&#39;LAST(L)&#39;)                                   <b>:(LAST_END)</b>
<font color="#818181"><i>*</i></font>
LAST     IDENT(L)                                            <b>:S(FRETURN)</b>
LAST_1   L = DIFFER(NEXT(L)) NEXT(L)                          <b>:S(LAST_1)</b>
         LAST = .NEXT(L)                                      <b>:(NRETURN)</b>
<font color="#818181"><i>*</i></font>
LAST_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;LAST.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL LAST
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #           #      #####   #######                  *</i></font>
<font color="#818181"><i>*                  #          # #    #     #     #                     *</i></font>
<font color="#818181"><i>*                  #         #   #   #           #                     *</i></font>
<font color="#818181"><i>*                  #        #     #   #####      #                     *</i></font>
<font color="#818181"><i>*                  #        #######        #     #                     *</i></font>
<font color="#818181"><i>*                  #        #     #  #     #     #                     *</i></font>
<font color="#818181"><i>*                  #######  #     #   #####      #                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LAST                 RETURN LAST LIST ELEMENT                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LAST.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;LAST&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:08 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LAST.INC'
-LINE 30 "LAST.lss"
         &CODE = 1
         &CODE = 0
END
<h1>LIKE - Pattern to match like string</h1>

[[LIKE(S)]] returns a pattern that will match a string like the one
passed as argument. A like string is defined as one differing from
the argument by

<ol>
<li>a rearrangement of two characters,</li>
<li>the deletion of a character, or</li>
<li>the insertion of a character.</li>
</ol>

<h2>Uses</h2>

<<INCLUDES>>=
@

<<LIKE>>=
-MODULE LIKE
-PUBLIC LIKE()
         DEFINE('LIKE(S)C,T1,T2,N')                          :(LIKE_END)
*
LIKE     LIKE = S
LIKE_1   S TAB(N) . T1 REM . T2                               :F(RETURN)
         N = N + 1
* INSERTION OF CHARACTER AT POSITION N
         LIKE = LIKE | (T1 LEN(1) T2)
* DELETION OF CHARACTER AT POSITION N
         T2 LEN(1) . C  =                                     :F(RETURN)
         LIKE = LIKE | (T1 T2)
* TRANSPOSITION OF TWO CHARACTERS
         T2 POS(1) = C                                        :F(LIKE_1)
         LIKE = LIKE | (T1 T2)                                 :(LIKE_1)
*
LIKE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LIKE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL LIKE
-EJECT
*
************************************************************************
*                                                                      *
*                     #        ###  #    #  #######                    *
*                     #         #   #   #   #                          *
*                     #         #   #  #    #                          *
*                     #         #   ###     #####                      *
*                     #         #   #  #    #                          *
*                     #         #   #   #   #                          *
*                     #######  ###  #    #  #######                    *
*                                                                      *
* LIKE                PATTERN TO MATCH LIKE STRING                     *
*                                                                      *
************************************************************************
*
* LIKE.lss
*
<<LIKE>>
*
* CE: .MSNOBOL4;
@
-STITL LIKE
-EJECT
*
-LINE 51 "LIKE.lss"
************************************************************************
*                                                                      *
*                     #        ###  #    #  #######                    *
*                     #         #   #   #   #                          *
*                     #         #   #  #    #                          *
*                     #         #   ###     #####                      *
*                     #         #   #  #    #                          *
*                     #         #   #   #   #                          *
*                     #######  ###  #    #  #######                    *
*                                                                      *
* LIKE                PATTERN TO MATCH LIKE STRING                     *
*                                                                      *
************************************************************************
*
* LIKE.lss
*
-LINE 19 "LIKE.lss"
-MODULE LIKE
-PUBLIC LIKE()
         DEFINE('LIKE(S)C,T1,T2,N')                          :(LIKE_END)
*
LIKE     LIKE = S
LIKE_1   S TAB(N) . T1 REM . T2                               :F(RETURN)
         N = N + 1
* INSERTION OF CHARACTER AT POSITION N
         LIKE = LIKE | (T1 LEN(1) T2)
* DELETION OF CHARACTER AT POSITION N
         T2 LEN(1) . C  =                                     :F(RETURN)
         LIKE = LIKE | (T1 T2)
* TRANSPOSITION OF TWO CHARACTERS
         T2 POS(1) = C                                        :F(LIKE_1)
         LIKE = LIKE | (T1 T2)                                 :(LIKE_1)
*
LIKE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>LIKE - Pattern to match like string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">LIKE(S)</font> returns a pattern that will match a string like the one
passed as argument. A like string is defined as one differing from
the argument by
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<ol>
<li>a rearrangement of two characters,</li>
<li>the deletion of a character, or</li>
<li>the insertion of a character.</li>
</ol>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LIKE&raquo;&equiv;</b>
-MODULE LIKE
-PUBLIC LIKE()
         DEFINE(&#39;LIKE(S)C,T1,T2,N&#39;)                          <b>:(LIKE_END)</b>
<font color="#818181"><i>*</i></font>
LIKE     LIKE = S
LIKE_1   S TAB(N) . T1 REM . T2                               <b>:F(RETURN)</b>
         N = N + 1
<font color="#818181"><i>* INSERTION OF CHARACTER AT POSITION N</i></font>
         LIKE = LIKE | (T1 LEN(1) T2)
<font color="#818181"><i>* DELETION OF CHARACTER AT POSITION N</i></font>
         T2 LEN(1) . C  =                                     <b>:F(RETURN)</b>
         LIKE = LIKE | (T1 T2)
<font color="#818181"><i>* TRANSPOSITION OF TWO CHARACTERS</i></font>
         T2 POS(1) = C                                        <b>:F(LIKE_1)</b>
         LIKE = LIKE | (T1 T2)                                 <b>:(LIKE_1)</b>
<font color="#818181"><i>*</i></font>
LIKE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;LIKE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL LIKE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                     #        ###  #    #  #######                    *</i></font>
<font color="#818181"><i>*                     #         #   #   #   #                          *</i></font>
<font color="#818181"><i>*                     #         #   #  #    #                          *</i></font>
<font color="#818181"><i>*                     #         #   ###     #####                      *</i></font>
<font color="#818181"><i>*                     #         #   #  #    #                          *</i></font>
<font color="#818181"><i>*                     #         #   #   #   #                          *</i></font>
<font color="#818181"><i>*                     #######  ###  #    #  #######                    *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LIKE                PATTERN TO MATCH LIKE STRING                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LIKE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;LIKE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:09 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LIKE.INC'
-LINE 42 "LIKE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>LINK - Define [[LINK]] type</h1>

[[LINK()]] has two members: [[VALUE()]] and [[NEXT()]] and is used
to represent lists. [[CONS()]], [[CAR()]] and [[CDR()]] are defined
as synonyms. [[CAAR()]] through [[CDDDR()]] are also defined.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<LINK>>=
-MODULE LINK
-PUBLIC LINK(), NEXT()
         DATA('LINK(VALUE,NEXT)')
-PUBLIC CONS(), CAR(), CDR()
         OPSYN('CONS', 'LINK')
         OPSYN('CAR', 'VALUE')
         OPSYN('CDR', 'NEXT')
-PUBLIC CAAR(), CDAR(), CADR(), CDDR()
         DEFINE('CAAR(L)')
         DEFINE('CDAR(l)')
         DEFINE('CADR(L)')
         DEFINE('CDDR(L)')
-PUBLIC CAAAR(), CAADR(), CADAR(), CADDR()
-PUBLIC CDAAR(), CDADR(), CDDAR(), CDDDR()
         DEFINE('CAAAR(L)')
         DEFINE('CAADR(L)')
         DEFINE('CADAR(L)')
         DEFINE('CADDR(L)')
         DEFINE('CDAAR(L)')
         DEFINE('CDADR(L)')
         DEFINE('CDDAR(L)')
         DEFINE('CDDDR(L)')
                                                             :(LINK_END)
*
CAAAR    CAAAR = CAR(CAAR(L))                                  :(RETURN)
CAADR    CAADR = CAR(CADR(L))                                  :(RETURN)
CADAR    CADAR = CAR(CDAR(L))                                  :(RETURN)
CADDR    CADDR = CAR(CDDR(L))                                  :(RETURN)
CDAAR    CDAAR = CDR(CAAR(L))                                  :(RETURN)
CDADR    CDADR = CDR(CADR(L))                                  :(RETURN)
CDDAR    CDDAR = CDR(CDAR(L))                                  :(RETURN)
CDDDR    CDDDR = CDR(CDDR(L))                                  :(RETURN)
*
CAAR     CAAR = CAR(CAR(L))                                    :(RETURN)
CDAR     CDAR = CDR(CAR(L))                                    :(RETURN)
CADR     CADR = CAR(CDR(L))                                    :(RETURN)
CDDR     CDDR = CDR(CDR(L))                                    :(RETURN)
*
LINK_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LINK.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL LINK
-EJECT
*
************************************************************************
*                                                                      *
*                    #        ###  #     #  #    #                     *
*                    #         #   ##    #  #   #                      *
*                    #         #   # #   #  #  #                       *
*                    #         #   #  #  #  ###                        *
*                    #         #   #   # #  #  #                       *
*                    #         #   #    ##  #   #                      *
*                    #######  ###  #     #  #    #                     *
*                                                                      *
* LINK                        LINK TYPE                                *
*                                                                      *
************************************************************************
*
* LINK.lss
*
<<LINK>>
*
* CE: .MSNOBOL4;
@
-STITL LINK
-EJECT
*
-LINE 67 "LINK.lss"
************************************************************************
*                                                                      *
*                    #        ###  #     #  #    #                     *
*                    #         #   ##    #  #   #                      *
*                    #         #   # #   #  #  #                       *
*                    #         #   #  #  #  ###                        *
*                    #         #   #   # #  #  #                       *
*                    #         #   #    ##  #   #                      *
*                    #######  ###  #     #  #    #                     *
*                                                                      *
* LINK                        LINK TYPE                                *
*                                                                      *
************************************************************************
*
* LINK.lss
*
-LINE 13 "LINK.lss"
-MODULE LINK
-PUBLIC LINK(), NEXT()
         DATA('LINK(VALUE,NEXT)')
-PUBLIC CONS(), CAR(), CDR()
         OPSYN('CONS', 'LINK')
         OPSYN('CAR', 'VALUE')
         OPSYN('CDR', 'NEXT')
-PUBLIC CAAR(), CDAR(), CADR(), CDDR()
         DEFINE('CAAR(L)')
         DEFINE('CDAR(l)')
         DEFINE('CADR(L)')
         DEFINE('CDDR(L)')
-PUBLIC CAAAR(), CAADR(), CADAR(), CADDR()
-PUBLIC CDAAR(), CDADR(), CDDAR(), CDDDR()
         DEFINE('CAAAR(L)')
         DEFINE('CAADR(L)')
         DEFINE('CADAR(L)')
         DEFINE('CADDR(L)')
         DEFINE('CDAAR(L)')
         DEFINE('CDADR(L)')
         DEFINE('CDDAR(L)')
         DEFINE('CDDDR(L)')
                                                             :(LINK_END)
*
CAAAR    CAAAR = CAR(CAAR(L))                                  :(RETURN)
CAADR    CAADR = CAR(CADR(L))                                  :(RETURN)
CADAR    CADAR = CAR(CDAR(L))                                  :(RETURN)
CADDR    CADDR = CAR(CDDR(L))                                  :(RETURN)
CDAAR    CDAAR = CDR(CAAR(L))                                  :(RETURN)
CDADR    CDADR = CDR(CADR(L))                                  :(RETURN)
CDDAR    CDDAR = CDR(CDAR(L))                                  :(RETURN)
CDDDR    CDDDR = CDR(CDDR(L))                                  :(RETURN)
*
CAAR     CAAR = CAR(CAR(L))                                    :(RETURN)
CDAR     CDAR = CDR(CAR(L))                                    :(RETURN)
CADR     CADR = CAR(CDR(L))                                    :(RETURN)
CDDR     CDDR = CDR(CDR(L))                                    :(RETURN)
*
LINK_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>LINK - Define <font face="Source Code Pro">LINK</font> type</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">LINK()</font> has two members: <font face="Source Code Pro">VALUE()</font> and <font face="Source Code Pro">NEXT()</font> and is used
to represent lists. <font face="Source Code Pro">CONS()</font>, <font face="Source Code Pro">CAR()</font> and <font face="Source Code Pro">CDR()</font> are defined
as synonyms. <font face="Source Code Pro">CAAR()</font> through <font face="Source Code Pro">CDDDR()</font> are also defined.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LINK&raquo;&equiv;</b>
-MODULE LINK
-PUBLIC LINK(), NEXT()
         DATA(&#39;LINK(VALUE,NEXT)&#39;)
-PUBLIC CONS(), CAR(), CDR()
         OPSYN(&#39;CONS&#39;, &#39;LINK&#39;)
         OPSYN(&#39;CAR&#39;, &#39;VALUE&#39;)
         OPSYN(&#39;CDR&#39;, &#39;NEXT&#39;)
-PUBLIC CAAR(), CDAR(), CADR(), CDDR()
         DEFINE(&#39;CAAR(L)&#39;)
         DEFINE(&#39;CDAR(l)&#39;)
         DEFINE(&#39;CADR(L)&#39;)
         DEFINE(&#39;CDDR(L)&#39;)
-PUBLIC CAAAR(), CAADR(), CADAR(), CADDR()
-PUBLIC CDAAR(), CDADR(), CDDAR(), CDDDR()
         DEFINE(&#39;CAAAR(L)&#39;)
         DEFINE(&#39;CAADR(L)&#39;)
         DEFINE(&#39;CADAR(L)&#39;)
         DEFINE(&#39;CADDR(L)&#39;)
         DEFINE(&#39;CDAAR(L)&#39;)
         DEFINE(&#39;CDADR(L)&#39;)
         DEFINE(&#39;CDDAR(L)&#39;)
         DEFINE(&#39;CDDDR(L)&#39;)
                                                             <b>:(LINK_END)</b>
<font color="#818181"><i>*</i></font>
CAAAR    CAAAR = CAR(CAAR(L))                                  <b>:(RETURN)</b>
CAADR    CAADR = CAR(CADR(L))                                  <b>:(RETURN)</b>
CADAR    CADAR = CAR(CDAR(L))                                  <b>:(RETURN)</b>
CADDR    CADDR = CAR(CDDR(L))                                  <b>:(RETURN)</b>
CDAAR    CDAAR = CDR(CAAR(L))                                  <b>:(RETURN)</b>
CDADR    CDADR = CDR(CADR(L))                                  <b>:(RETURN)</b>
CDDAR    CDDAR = CDR(CDAR(L))                                  <b>:(RETURN)</b>
CDDDR    CDDDR = CDR(CDDR(L))                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CAAR     CAAR = CAR(CAR(L))                                    <b>:(RETURN)</b>
CDAR     CDAR = CDR(CAR(L))                                    <b>:(RETURN)</b>
CADR     CADR = CAR(CDR(L))                                    <b>:(RETURN)</b>
CDDR     CDDR = CDR(CDR(L))                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
LINK_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;LINK.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL LINK
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #        ###  #     #  #    #                     *</i></font>
<font color="#818181"><i>*                    #         #   ##    #  #   #                      *</i></font>
<font color="#818181"><i>*                    #         #   # #   #  #  #                       *</i></font>
<font color="#818181"><i>*                    #         #   #  #  #  ###                        *</i></font>
<font color="#818181"><i>*                    #         #   #   # #  #  #                       *</i></font>
<font color="#818181"><i>*                    #         #   #    ##  #   #                      *</i></font>
<font color="#818181"><i>*                    #######  ###  #     #  #    #                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LINK                        LINK TYPE                                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LINK.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;LINK&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:34 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LINK.INC'
-LINE 58 "LINK.lss"
         &CODE = 1
         &CODE = 0
END
<h1>list - A simple file viewer</h1>

list is a simple file viewer. It displays a file, and allows navigation
using arrow keys. list provides a find function, and allows lines to
be numbered. list is UTF-8 aware. Scrolling is reasonably efficient -
list knows to use terminal hardware scrolling if available.

<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="DISPLAY.html">DISPLAY</a><br>
<a href="GETKEY.html">GETKEY</a><br>
<a href="HOST.html">HOST</a><br>
<a href="LOGIC.html">LOGIC</a><br>
<a href="READLINE.html">READLINE</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>=
-INCLUDE 'CHARS.INC'
-INCLUDE 'DISPLAY.INC'
-INCLUDE 'GETKEY.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'LOGIC.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SEQ.INC'
@

<<LIST>>=
         TERMINAL = 'LIST (MON DEC 16 18:48:12 EST 2013)'
         RLAPPNAME('LIST')
         READ_HISTORY('.LIST')
         STIFLE_HISTORY(50)
         ACTIONS = TABLE()
         ACTIONS<KEY_UP>     = 'UP'
         ACTIONS<KEY_DOWN>   = 'DOWN'
         ACTIONS<KEY_PAGEDN> = 'PGDN'
         ACTIONS<KEY_PAGEUP> = 'PGUP'
         ACTIONS<'N'>        = 'TGLN'
         ACTIONS<'n'>        = 'TGLN'
         ACTIONS<'R'>        = 'PAGE'
         ACTIONS<'r'>        = 'PAGE'
         ACTIONS<KEY_HOME>   = 'HOME'
         ACTIONS<KEY_END>    = 'BTM'
         ACTIONS<'?'>        = 'HELP'
         ACTIONS<'H'>        = 'HELP'
         ACTIONS<'h'>        = 'HELP'
         ACTIONS<'E'>        = 'EDIT'
         ACTIONS<'e'>        = 'EDIT'
         ACTIONS<'Q'>        = 'QUIT'
         ACTIONS<'q'>        = 'QUIT'
         ACTIONS<'F'>        = 'FIND'
         ACTIONS<'f'>        = 'FIND'
         FN = '/dev/stdin'
         FN = HOST(HOST_ARGN, HOST(HOST_FIRSTARG))
         T = 1
         UNIT = IO_FINDUNIT()
READ     INPUT(.INFILE, UNIT,, FN)                               :S(FN1)
         TERMINAL = "CAN'T OPEN " FN
         TERMINAL = 'LIST FILENAME, THEN H FOR HELP'              :(END)
*
* READ FILE
*
FN1      LINES = TABLE()
         SEQ(' LINES<L> = TRIM(INFILE) ', .L)
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr -echo raw')
         UNIT2 = IO_FINDUNIT()
         OUTPUT(.T_OUT, UNIT2, 'T', '/dev/stderr')
         UNIT3 = IO_FINDUNIT()
         INPUT(.T_IN, UNIT3, 'CQ', '/dev/stderr')
         NUMBER =
         SS =
         SH =
*
         HC0 = HI('C0')
         H80 = HI('80')
         DEFINE('SHOWLINE(N)S,T,B,LS,C')                       :(SL_END)
*
SHOWLINE S = LINES<N>
*
* IF TERMINAL TAB IS 8, MAKE LINE NUMBERING 8 CHARACTERS TO NOT
* DISTURB TABBING WHEN 'N' IS USED
*
         S = LE(N, L) DIFFER(NUMBER) LPAD(N, 6) ': ' S
         LT(SIZE(S), DS_COLS)                                    :S(SL2)
*
* SKIP PRUNING LENGTH. NOTE THAT THE NEXT LINE WILL BE POSITIONED
* (BUT WON'T BE QUITE RIGHT). ESC SEQUENCES NEED TO BE ACCOMODATED.
*
         T = S
         S =
         LS =
* UTF8.INC IS BORKED. BUT, (BYTES & 0XCC) == 0X80 ARE MIDDLE BYTES, AND
* DON'T ADD TO LENGTH
SL3      IDENT(T)                                                :S(SL8)
         T LEN(1) . C REM . T
         S = S C
         LS = NE(AND(ORD(C), HC0), H80) LS + 1
         LT(LS, DS_COLS)                                         :S(SL3)
* REMOVE THE LAST CHARACTER IF IT IS A UTF-8 START CHARACTER
SL8      S LEN(1) . C RPOS(0)
         LT(ORD(C), 128)                                         :S(SL2)
         EQ(AND(ORD(C), HC0), H80)                               :S(SL2)
         S TAB(SIZE(S) - 1) . S
* THIS COULD INCREASE SIZE PAST DS_COLS. TO FIX, WE REDUCE THE COLUMN
* WIDTH BY ONE IF CHARS_FF APPEARS IN THE STRING (FIXME)
SL2      S = REPL(S, CHARS_FF, DS_REV '^L' DS_SGR0)
         IDENT(SH)                                               :S(SL7)
         S = REPL(S, SH, DS_REV SH DS_SGR0)
SL7      T_OUT = S DS_EL                                       :(RETURN)
*
SL_END
*
         T_OUT = DS_CIVIS
PAGE     T_OUT = DS_CLEAR
         I =
PLOOP    T_OUT = DS_GOTO(+I, 0)
         SHOWLINE(T + I)
         T_OUT = CHARS_CR CHARS_NL
         I = LT(I, DS_LINES - 2) I + 1                         :S(PLOOP)
         SHOWLINE(T + I + 1)
*         
TOP      A = ACTIONS<KEY = GETKEY(.T_IN)>
         DIFFER(A)                                                :S($A)
         T_OUT = CHARS_BEL                                        :(TOP)
*
DOWN     GE(T, L - 1)                                            :S(TOP)
         T_OUT = DS_IND
         T = T + 1
         T_OUT = DS_GOTO(DS_LINES - 1, 0) 
+                SHOWLINE(T + DS_LINES - 1)                       :(TOP)
*
UP       LE(T, 1)                                                :S(TOP)
         T_OUT = DS_RI
         T = T - 1
         T_OUT = DS_HOME SHOWLINE(T)                              :(TOP)
*
PGDN     T = T + DS_LINES
         T = GT(T, L - 1) L - 1                                  :(PAGE)
*
PGUP     T = T - DS_LINES
         T = LE(T) 1                                             :(PAGE)
*
TGLN     NUMBER = IDENT(NUMBER) 1                               :S(PAGE)
         NUMBER =                                                :(PAGE)
*
FIND     T_OUT = DS_GOTO(DS_LINES - 1, 0) DS_EL DS_CNORM
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr echo cooked')
         SS = TRIM(READLINE('FIND: '))
         (DIFFER(SS) ADD_HISTORY(SS))
         SH =
         IDENT(SS)                                               :S(SS2)
SLOOP    GE(T, L - 1)                                            :S(SS2)
         T = T + 1
         LINES<T> SS                                           :F(SLOOP)
         SH = SS
SS2      HOST(HOST_SYSCMD, 'stty -F /dev/stderr -echo raw')
         T_OUT = DS_CIVIS                                        :(PAGE)
*
HOME     T = 1                                                   :(PAGE)
*
BTM      T = L - 1                                               :(PAGE)
*
HELP     T_OUT = DS_CLEAR 'LIST (WED JAN  8 09:54:34 EST 2014)'
         T_OUT = CHARS_CR CHARS_NL CHARS_NL
         T_OUT = 'UP    - SCROLL UP LINE' CHARS_CR CHARS_NL
         T_OUT = 'DOWN  - SCROLL DOWN LINE' CHARS_CR CHARS_NL
         T_OUT = 'PGUP  - SCROLL UP PAGE' CHARS_CR CHARS_NL
         T_OUT = 'PGDN  - SCROLL DOWN PAGE' CHARS_CR CHARS_NL
         T_OUT = 'Q     - QUIT' CHARS_CR CHARS_NL
         T_OUT = 'H     - HELP' CHARS_CR CHARS_NL
         T_OUT = 'HOME  - TOP' CHARS_CR CHARS_NL
         T_OUT = 'END   - BOTTOM' CHARS_CR CHARS_NL
         T_OUT = 'F     - FIND' CHARS_CR CHARS_NL
         T_OUT = 'R     - REFRESH' CHARS_CR CHARS_NL
         T_OUT = 'N     - TOGGLE LINE NUMBERS' CHARS_CR CHARS_NL
         T_OUT = 'E     - EDIT' CHARS_CR CHARS_NL
         GETKEY(.T_IN)                                           :(PAGE)
*
EDIT     T_OUT = IDENT(FN) CHARS_BEL                             :S(TOP)
         T_OUT = DS_CNORM DS_GOTO(DS_LINES - 1, 0)
         T_OUT = CHARS_CR CHARS_NL CHARS_NL
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr echo cooked')
         WRITE_HISTORY('.LIST')
         HOST(HOST_SYSCMD, HOST(HOST_GETENV, 'EDITOR') ' ' FN)   :(READ)
*
QUIT     T_OUT = DS_CNORM DS_GOTO(DS_LINES - 1, 0)
+                CHARS_CR CHARS_NL CHARS_NL
*
         ENDFILE(UNIT2)
         DETACH(.T_OUT)
         ENDFILE(UNIT3)
         DETACH(.T_IN)
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr echo cooked')
         WRITE_HISTORY('.LIST')
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM LIST
-TITLE LIST
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                    #        ###   #####   #######                    *
*                    #         #   #     #     #                       *
*                    #         #   #           #                       *
*                    #         #    #####      #                       *
*                    #         #         #     #                       *
*                    #         #   #     #     #                       *
*                    #######  ###   #####      #                       *
*                                                                      *
* LIST                       FILE VIEWER                               *
*                                                                      *
************************************************************************
*
* list.lss
*
<<LIST>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM LIST
-LINE 204 "list.lss"
-TITLE LIST
START
-LINE 19 "list.lss"
-INCLUDE 'CHARS.INC'
-INCLUDE 'DISPLAY.INC'
-INCLUDE 'GETKEY.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'LOGIC.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SEQ.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                    #        ###   #####   #######                    *
*                    #         #   #     #     #                       *
*                    #         #   #           #                       *
*                    #         #    #####      #                       *
*                    #         #         #     #                       *
*                    #         #   #     #     #                       *
*                    #######  ###   #####      #                       *
*                                                                      *
* LIST                       FILE VIEWER                               *
*                                                                      *
************************************************************************
*
* list.lss
*
-LINE 30 "list.lss"
         TERMINAL = 'LIST (MON DEC 16 18:48:12 EST 2013)'
         RLAPPNAME('LIST')
         READ_HISTORY('.LIST')
         STIFLE_HISTORY(50)
         ACTIONS = TABLE()
         ACTIONS<KEY_UP>     = 'UP'
         ACTIONS<KEY_DOWN>   = 'DOWN'
         ACTIONS<KEY_PAGEDN> = 'PGDN'
         ACTIONS<KEY_PAGEUP> = 'PGUP'
         ACTIONS<'N'>        = 'TGLN'
         ACTIONS<'n'>        = 'TGLN'
         ACTIONS<'R'>        = 'PAGE'
         ACTIONS<'r'>        = 'PAGE'
         ACTIONS<KEY_HOME>   = 'HOME'
         ACTIONS<KEY_END>    = 'BTM'
         ACTIONS<'?'>        = 'HELP'
         ACTIONS<'H'>        = 'HELP'
         ACTIONS<'h'>        = 'HELP'
         ACTIONS<'E'>        = 'EDIT'
         ACTIONS<'e'>        = 'EDIT'
         ACTIONS<'Q'>        = 'QUIT'
         ACTIONS<'q'>        = 'QUIT'
         ACTIONS<'F'>        = 'FIND'
         ACTIONS<'f'>        = 'FIND'
         FN = '/dev/stdin'
         FN = HOST(HOST_ARGN, HOST(HOST_FIRSTARG))
         T = 1
         UNIT = IO_FINDUNIT()
READ     INPUT(.INFILE, UNIT,, FN)                               :S(FN1)
         TERMINAL = "CAN'T OPEN " FN
         TERMINAL = 'LIST FILENAME, THEN H FOR HELP'              :(END)
*
* READ FILE
*
FN1      LINES = TABLE()
         SEQ(' LINES<L> = TRIM(INFILE) ', .L)
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr -echo raw')
         UNIT2 = IO_FINDUNIT()
         OUTPUT(.T_OUT, UNIT2, 'T', '/dev/stderr')
         UNIT3 = IO_FINDUNIT()
         INPUT(.T_IN, UNIT3, 'CQ', '/dev/stderr')
         NUMBER =
         SS =
         SH =
*
         HC0 = HI('C0')
         H80 = HI('80')
         DEFINE('SHOWLINE(N)S,T,B,LS,C')                       :(SL_END)
*
SHOWLINE S = LINES<N>
*
* IF TERMINAL TAB IS 8, MAKE LINE NUMBERING 8 CHARACTERS TO NOT
* DISTURB TABBING WHEN 'N' IS USED
*
         S = LE(N, L) DIFFER(NUMBER) LPAD(N, 6) ': ' S
         LT(SIZE(S), DS_COLS)                                    :S(SL2)
*
* SKIP PRUNING LENGTH. NOTE THAT THE NEXT LINE WILL BE POSITIONED
* (BUT WON'T BE QUITE RIGHT). ESC SEQUENCES NEED TO BE ACCOMODATED.
*
         T = S
         S =
         LS =
* UTF8.INC IS BORKED. BUT, (BYTES & 0XCC) == 0X80 ARE MIDDLE BYTES, AND
* DON'T ADD TO LENGTH
SL3      IDENT(T)                                                :S(SL8)
         T LEN(1) . C REM . T
         S = S C
         LS = NE(AND(ORD(C), HC0), H80) LS + 1
         LT(LS, DS_COLS)                                         :S(SL3)
* REMOVE THE LAST CHARACTER IF IT IS A UTF-8 START CHARACTER
SL8      S LEN(1) . C RPOS(0)
         LT(ORD(C), 128)                                         :S(SL2)
         EQ(AND(ORD(C), HC0), H80)                               :S(SL2)
         S TAB(SIZE(S) - 1) . S
* THIS COULD INCREASE SIZE PAST DS_COLS. TO FIX, WE REDUCE THE COLUMN
* WIDTH BY ONE IF CHARS_FF APPEARS IN THE STRING (FIXME)
SL2      S = REPL(S, CHARS_FF, DS_REV '^L' DS_SGR0)
         IDENT(SH)                                               :S(SL7)
         S = REPL(S, SH, DS_REV SH DS_SGR0)
SL7      T_OUT = S DS_EL                                       :(RETURN)
*
SL_END
*
         T_OUT = DS_CIVIS
PAGE     T_OUT = DS_CLEAR
         I =
PLOOP    T_OUT = DS_GOTO(+I, 0)
         SHOWLINE(T + I)
         T_OUT = CHARS_CR CHARS_NL
         I = LT(I, DS_LINES - 2) I + 1                         :S(PLOOP)
         SHOWLINE(T + I + 1)
*
TOP      A = ACTIONS<KEY = GETKEY(.T_IN)>
         DIFFER(A)                                                :S($A)
         T_OUT = CHARS_BEL                                        :(TOP)
*
DOWN     GE(T, L - 1)                                            :S(TOP)
         T_OUT = DS_IND
         T = T + 1
         T_OUT = DS_GOTO(DS_LINES - 1, 0)
+                SHOWLINE(T + DS_LINES - 1)                       :(TOP)
*
UP       LE(T, 1)                                                :S(TOP)
         T_OUT = DS_RI
         T = T - 1
         T_OUT = DS_HOME SHOWLINE(T)                              :(TOP)
*
PGDN     T = T + DS_LINES
         T = GT(T, L - 1) L - 1                                  :(PAGE)
*
PGUP     T = T - DS_LINES
         T = LE(T) 1                                             :(PAGE)
*
TGLN     NUMBER = IDENT(NUMBER) 1                               :S(PAGE)
         NUMBER =                                                :(PAGE)
*
FIND     T_OUT = DS_GOTO(DS_LINES - 1, 0) DS_EL DS_CNORM
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr echo cooked')
         SS = TRIM(READLINE('FIND: '))
         (DIFFER(SS) ADD_HISTORY(SS))
         SH =
         IDENT(SS)                                               :S(SS2)
SLOOP    GE(T, L - 1)                                            :S(SS2)
         T = T + 1
         LINES<T> SS                                           :F(SLOOP)
         SH = SS
SS2      HOST(HOST_SYSCMD, 'stty -F /dev/stderr -echo raw')
         T_OUT = DS_CIVIS                                        :(PAGE)
*
HOME     T = 1                                                   :(PAGE)
*
BTM      T = L - 1                                               :(PAGE)
*
HELP     T_OUT = DS_CLEAR 'LIST (WED JAN  8 09:54:34 EST 2014)'
         T_OUT = CHARS_CR CHARS_NL CHARS_NL
         T_OUT = 'UP    - SCROLL UP LINE' CHARS_CR CHARS_NL
         T_OUT = 'DOWN  - SCROLL DOWN LINE' CHARS_CR CHARS_NL
         T_OUT = 'PGUP  - SCROLL UP PAGE' CHARS_CR CHARS_NL
         T_OUT = 'PGDN  - SCROLL DOWN PAGE' CHARS_CR CHARS_NL
         T_OUT = 'Q     - QUIT' CHARS_CR CHARS_NL
         T_OUT = 'H     - HELP' CHARS_CR CHARS_NL
         T_OUT = 'HOME  - TOP' CHARS_CR CHARS_NL
         T_OUT = 'END   - BOTTOM' CHARS_CR CHARS_NL
         T_OUT = 'F     - FIND' CHARS_CR CHARS_NL
         T_OUT = 'R     - REFRESH' CHARS_CR CHARS_NL
         T_OUT = 'N     - TOGGLE LINE NUMBERS' CHARS_CR CHARS_NL
         T_OUT = 'E     - EDIT' CHARS_CR CHARS_NL
         GETKEY(.T_IN)                                           :(PAGE)
*
EDIT     T_OUT = IDENT(FN) CHARS_BEL                             :S(TOP)
         T_OUT = DS_CNORM DS_GOTO(DS_LINES - 1, 0)
         T_OUT = CHARS_CR CHARS_NL CHARS_NL
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr echo cooked')
         WRITE_HISTORY('.LIST')
         HOST(HOST_SYSCMD, HOST(HOST_GETENV, 'EDITOR') ' ' FN)   :(READ)
*
QUIT     T_OUT = DS_CNORM DS_GOTO(DS_LINES - 1, 0)
+                CHARS_CR CHARS_NL CHARS_NL
*
         ENDFILE(UNIT2)
         DETACH(.T_OUT)
         ENDFILE(UNIT3)
         DETACH(.T_IN)
         HOST(HOST_SYSCMD, 'stty -F /dev/stderr echo cooked')
         WRITE_HISTORY('.LIST')
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>list - A simple file viewer</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
list is a simple file viewer. It displays a file, and allows navigation
using arrow keys. list provides a find function, and allows lines to
be numbered. list is UTF-8 aware. Scrolling is reasonably efficient -
list knows to use terminal hardware scrolling if available.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CHARS.html">CHARS</a><br>
<a href="DISPLAY.html">DISPLAY</a><br>
<a href="GETKEY.html">GETKEY</a><br>
<a href="HOST.html">HOST</a><br>
<a href="LOGIC.html">LOGIC</a><br>
<a href="READLINE.html">READLINE</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;DISPLAY.INC&#39;
-INCLUDE &#39;GETKEY.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;LOGIC.INC&#39;
-INCLUDE &#39;READLINE.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LIST&raquo;&equiv;</b>
         TERMINAL = &#39;LIST (MON DEC 16 18:48:12 EST 2013)&#39;
         RLAPPNAME(&#39;LIST&#39;)
         READ_HISTORY(&#39;.LIST&#39;)
         STIFLE_HISTORY(50)
         ACTIONS = TABLE()
         ACTIONS&lt;KEY_UP&gt;     = &#39;UP&#39;
         ACTIONS&lt;KEY_DOWN&gt;   = &#39;DOWN&#39;
         ACTIONS&lt;KEY_PAGEDN&gt; = &#39;PGDN&#39;
         ACTIONS&lt;KEY_PAGEUP&gt; = &#39;PGUP&#39;
         ACTIONS&lt;&#39;N&#39;&gt;        = &#39;TGLN&#39;
         ACTIONS&lt;&#39;n&#39;&gt;        = &#39;TGLN&#39;
         ACTIONS&lt;&#39;R&#39;&gt;        = &#39;PAGE&#39;
         ACTIONS&lt;&#39;r&#39;&gt;        = &#39;PAGE&#39;
         ACTIONS&lt;KEY_HOME&gt;   = &#39;HOME&#39;
         ACTIONS&lt;KEY_END&gt;    = &#39;BTM&#39;
         ACTIONS&lt;&#39;?&#39;&gt;        = &#39;HELP&#39;
         ACTIONS&lt;&#39;H&#39;&gt;        = &#39;HELP&#39;
         ACTIONS&lt;&#39;h&#39;&gt;        = &#39;HELP&#39;
         ACTIONS&lt;&#39;E&#39;&gt;        = &#39;EDIT&#39;
         ACTIONS&lt;&#39;e&#39;&gt;        = &#39;EDIT&#39;
         ACTIONS&lt;&#39;Q&#39;&gt;        = &#39;QUIT&#39;
         ACTIONS&lt;&#39;q&#39;&gt;        = &#39;QUIT&#39;
         ACTIONS&lt;&#39;F&#39;&gt;        = &#39;FIND&#39;
         ACTIONS&lt;&#39;f&#39;&gt;        = &#39;FIND&#39;
         FN = &#39;/dev/stdin&#39;
         FN = HOST(HOST_ARGN, HOST(HOST_FIRSTARG))
         T = 1
         UNIT = IO_FINDUNIT()
READ     INPUT(.INFILE, UNIT,, FN)                               <b>:S(FN1)</b>
         TERMINAL = &quot;CAN&#39;T OPEN &quot; FN
         TERMINAL = &#39;LIST FILENAME, THEN H FOR HELP&#39;              <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READ FILE</i></font>
<font color="#818181"><i>*</i></font>
FN1      LINES = TABLE()
         SEQ(&#39; LINES&lt;L&gt; = TRIM(INFILE) &#39;, .L)
         HOST(HOST_SYSCMD, &#39;stty -F /dev/stderr -echo raw&#39;)
         UNIT2 = IO_FINDUNIT()
         OUTPUT(.T_OUT, UNIT2, &#39;T&#39;, &#39;/dev/stderr&#39;)
         UNIT3 = IO_FINDUNIT()
         INPUT(.T_IN, UNIT3, &#39;CQ&#39;, &#39;/dev/stderr&#39;)
         NUMBER =
         SS =
         SH =
<font color="#818181"><i>*</i></font>
         HC0 = HI(&#39;C0&#39;)
         H80 = HI(&#39;80&#39;)
         DEFINE(&#39;SHOWLINE(N)S,T,B,LS,C&#39;)                       <b>:(SL_END)</b>
<font color="#818181"><i>*</i></font>
SHOWLINE S = LINES&lt;N&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF TERMINAL TAB IS 8, MAKE LINE NUMBERING 8 CHARACTERS TO NOT</i></font>
<font color="#818181"><i>* DISTURB TABBING WHEN &#39;N&#39; IS USED</i></font>
<font color="#818181"><i>*</i></font>
         S = LE(N, L) DIFFER(NUMBER) LPAD(N, 6) &#39;: &#39; S
         LT(SIZE(S), DS_COLS)                                    <b>:S(SL2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SKIP PRUNING LENGTH. NOTE THAT THE NEXT LINE WILL BE POSITIONED</i></font>
<font color="#818181"><i>* (BUT WON&#39;T BE QUITE RIGHT). ESC SEQUENCES NEED TO BE ACCOMODATED.</i></font>
<font color="#818181"><i>*</i></font>
         T = S
         S =
         LS =
<font color="#818181"><i>* UTF8.INC IS BORKED. BUT, (BYTES &amp; 0XCC) == 0X80 ARE MIDDLE BYTES, AND</i></font>
<font color="#818181"><i>* DON&#39;T ADD TO LENGTH</i></font>
SL3      IDENT(T)                                                <b>:S(SL8)</b>
         T LEN(1) . C REM . T
         S = S C
         LS = NE(AND(ORD(C), HC0), H80) LS + 1
         LT(LS, DS_COLS)                                         <b>:S(SL3)</b>
<font color="#818181"><i>* REMOVE THE LAST CHARACTER IF IT IS A UTF-8 START CHARACTER</i></font>
SL8      S LEN(1) . C RPOS(0)
         LT(ORD(C), 128)                                         <b>:S(SL2)</b>
         EQ(AND(ORD(C), HC0), H80)                               <b>:S(SL2)</b>
         S TAB(SIZE(S) - 1) . S
<font color="#818181"><i>* THIS COULD INCREASE SIZE PAST DS_COLS. TO FIX, WE REDUCE THE COLUMN</i></font>
<font color="#818181"><i>* WIDTH BY ONE IF CHARS_FF APPEARS IN THE STRING (FIXME)</i></font>
SL2      S = REPL(S, CHARS_FF, DS_REV &#39;^L&#39; DS_SGR0)
         IDENT(SH)                                               <b>:S(SL7)</b>
         S = REPL(S, SH, DS_REV SH DS_SGR0)
SL7      T_OUT = S DS_EL                                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SL_END
<font color="#818181"><i>*</i></font>
         T_OUT = DS_CIVIS
PAGE     T_OUT = DS_CLEAR
         I =
PLOOP    T_OUT = DS_GOTO(+I, 0)
         SHOWLINE(T + I)
         T_OUT = CHARS_CR CHARS_NL
         I = LT(I, DS_LINES - 2) I + 1                         <b>:S(PLOOP)</b>
         SHOWLINE(T + I + 1)
<font color="#818181"><i>*</i></font>
TOP      A = ACTIONS&lt;KEY = GETKEY(.T_IN)&gt;
         DIFFER(A)                                                <b>:S($A)</b>
         T_OUT = CHARS_BEL                                        <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
DOWN     GE(T, L - 1)                                            <b>:S(TOP)</b>
         T_OUT = DS_IND
         T = T + 1
         T_OUT = DS_GOTO(DS_LINES - 1, 0)
+                SHOWLINE(T + DS_LINES - 1)                       <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
UP       LE(T, 1)                                                <b>:S(TOP)</b>
         T_OUT = DS_RI
         T = T - 1
         T_OUT = DS_HOME SHOWLINE(T)                              <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
PGDN     T = T + DS_LINES
         T = GT(T, L - 1) L - 1                                  <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
PGUP     T = T - DS_LINES
         T = LE(T) 1                                             <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
TGLN     NUMBER = IDENT(NUMBER) 1                               <b>:S(PAGE)</b>
         NUMBER =                                                <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
FIND     T_OUT = DS_GOTO(DS_LINES - 1, 0) DS_EL DS_CNORM
         HOST(HOST_SYSCMD, &#39;stty -F /dev/stderr echo cooked&#39;)
         SS = TRIM(READLINE(&#39;FIND: &#39;))
         (DIFFER(SS) ADD_HISTORY(SS))
         SH =
         IDENT(SS)                                               <b>:S(SS2)</b>
SLOOP    GE(T, L - 1)                                            <b>:S(SS2)</b>
         T = T + 1
         LINES&lt;T&gt; SS                                           <b>:F(SLOOP)</b>
         SH = SS
SS2      HOST(HOST_SYSCMD, &#39;stty -F /dev/stderr -echo raw&#39;)
         T_OUT = DS_CIVIS                                        <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
HOME     T = 1                                                   <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
BTM      T = L - 1                                               <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
HELP     T_OUT = DS_CLEAR &#39;LIST (WED JAN  8 09:54:34 EST 2014)&#39;
         T_OUT = CHARS_CR CHARS_NL CHARS_NL
         T_OUT = &#39;UP    - SCROLL UP LINE&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;DOWN  - SCROLL DOWN LINE&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;PGUP  - SCROLL UP PAGE&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;PGDN  - SCROLL DOWN PAGE&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;Q     - QUIT&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;H     - HELP&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;HOME  - TOP&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;END   - BOTTOM&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;F     - FIND&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;R     - REFRESH&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;N     - TOGGLE LINE NUMBERS&#39; CHARS_CR CHARS_NL
         T_OUT = &#39;E     - EDIT&#39; CHARS_CR CHARS_NL
         GETKEY(.T_IN)                                           <b>:(PAGE)</b>
<font color="#818181"><i>*</i></font>
EDIT     T_OUT = IDENT(FN) CHARS_BEL                             <b>:S(TOP)</b>
         T_OUT = DS_CNORM DS_GOTO(DS_LINES - 1, 0)
         T_OUT = CHARS_CR CHARS_NL CHARS_NL
         HOST(HOST_SYSCMD, &#39;stty -F /dev/stderr echo cooked&#39;)
         WRITE_HISTORY(&#39;.LIST&#39;)
         HOST(HOST_SYSCMD, HOST(HOST_GETENV, &#39;EDITOR&#39;) &#39; &#39; FN)   <b>:(READ)</b>
<font color="#818181"><i>*</i></font>
QUIT     T_OUT = DS_CNORM DS_GOTO(DS_LINES - 1, 0)
+                CHARS_CR CHARS_NL CHARS_NL
<font color="#818181"><i>*</i></font>
         ENDFILE(UNIT2)
         DETACH(.T_OUT)
         ENDFILE(UNIT3)
         DETACH(.T_IN)
         HOST(HOST_SYSCMD, &#39;stty -F /dev/stderr echo cooked&#39;)
         WRITE_HISTORY(&#39;.LIST&#39;)
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM LIST
-TITLE LIST
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #        ###   #####   #######                    *</i></font>
<font color="#818181"><i>*                    #         #   #     #     #                       *</i></font>
<font color="#818181"><i>*                    #         #   #           #                       *</i></font>
<font color="#818181"><i>*                    #         #    #####      #                       *</i></font>
<font color="#818181"><i>*                    #         #         #     #                       *</i></font>
<font color="#818181"><i>*                    #         #   #     #     #                       *</i></font>
<font color="#818181"><i>*                    #######  ###   #####      #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LIST                       FILE VIEWER                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* list.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;LIST&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Fri Jun  6 14:26:49 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>LOGIC - CATSPAW SPITBOL compatible LOGIC() functions</h1>

[[LOGIC()]] works on integers or buffers (strings).

<h2>Uses</h2>

<<INCLUDES>>=
@

<<LOGIC>>=
-MODULE LOGIC
*
* NOTE! BASE ARGUMENT MUST BE PASSED A EXPLICIT NULL STRING FOR DEFAULT
*
* INTEGER/INTEGER, STRING/INTEGER, STRING/STRING
*
-PUBLIC LOGIC()
         LOAD('LOGIC(INTEGER,,)')
*
-PUBLIC NOT(), AND(), OR(), XOR(), NAND(), NOR(), UPLUS(), UMINUS()
-PUBLIC  UMUL(), UDIV(), SHL(), SHR(), SAR(), ROL(), ROR()
-PUBLIC HI(), IH(), DIB(), IDB()
         DEFINE('NOT(ARG)')
         DEFINE('AND(ARG1,ARG2)')
         DEFINE('OR(ARG1,ARG2)')
         DEFINE('XOR(ARG1,ARG2)')
         DEFINE('NAND(ARG1,ARG2)')
         DEFINE('NOR(ARG1,ARG2)')
         DEFINE('UPLUS(ARG1,ARG2)')
         DEFINE('UMINUS(ARG1,ARG2)')
         DEFINE('UMUL(ARG1,ARG2)')
         DEFINE('UDIV(ARG1,ARG2)')
         DEFINE('SHL(ARG1,ARG2)')
         DEFINE('SHR(ARG1,ARG2)')
         DEFINE('SAR(ARG1,ARG2)')
         DEFINE('ROL(ARG1,ARG2)')
         DEFINE('ROR(ARG1,ARG2)')
         DEFINE('HI(ARG)')
         DEFINE('IH(ARG)')
         DEFINE('DIB(ARG,BASE)')
         DEFINE('IDB(ARG,BASE)')                            :(LOGIC_END)
*
NOT      NOT    = LOGIC( 1, ARG)                    :S(RETURN)F(FRETURN)
AND      AND    = LOGIC( 2, ARG1, ARG2)             :S(RETURN)F(FRETURN)
OR       OR     = LOGIC( 3, ARG1, ARG2)             :S(RETURN)F(FRETURN)
XOR      XOR    = LOGIC( 4, ARG1, ARG2)             :S(RETURN)F(FRETURN)
NAND     NAND   = LOGIC( 5, ARG1, ARG2)             :S(RETURN)F(FRETURN)
NOR      NOR    = LOGIC( 6, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UPLUS    UPLUS  = LOGIC( 7, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UMINUS   UMINUS = LOGIC( 8, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UMUL     UMUL   = LOGIC( 9, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UDIV     UDIV   = LOGIC(10, ARG1, ARG2)             :S(RETURN)F(FRETURN)
SHL      SHL    = LOGIC(11, ARG1, ARG2)             :S(RETURN)F(FRETURN)
SHR      SHR    = LOGIC(12, ARG1, ARG2)             :S(RETURN)F(FRETURN)
SAR      SAR    = LOGIC(13, ARG1, ARG2)             :S(RETURN)F(FRETURN)
ROL      ROL    = LOGIC(14, ARG1, ARG2)             :S(RETURN)F(FRETURN)
ROR      ROR    = LOGIC(15, ARG1, ARG2)             :S(RETURN)F(FRETURN)
HI       HI     = LOGIC(16, CONVERT(ARG, 'STRING'), '')
+                                                   :S(RETURN)F(FRETURN)
IH       IH     = LOGIC(17, CONVERT(ARG, 'INTEGER'), '')
+                                                   :S(RETURN)F(FRETURN)
DIB      DIB    = LOGIC(16, CONVERT(ARG, 'STRING'), BASE)
+                                                   :S(RETURN)F(FRETURN)
IDB      IDB    = LOGIC(17, CONVERT(ARG, 'INTEGER'), BASE)
+                                                   :S(RETURN)F(FRETURN)
*
LOGIC_END
         CODE('LOGIC')
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LOGIC.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL LOGIC
-EJECT
*
************************************************************************
*                                                                      *
*             #        #######   #####   ###   #####                   *
*             #        #     #  #     #   #   #     #                  *
*             #        #     #  #         #   #                        *
*             #        #     #  #  ####   #   #                        *
*             #        #     #  #     #   #   #                        *
*             #        #     #  #     #   #   #     #                  *
*             #######  #######   #####   ###   #####                   *
*                                                                      *
* LOGIC       CATSPAW SPITBOL COMPATIBLE LOGIC() FUNCTIONS             *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 21, 2002                                                     *
*                                                                      *
************************************************************************
*
* LOGIC.lss
*
<<LOGIC>>
*
* CE: .MSNOBOL4;
@
-STITL LOGIC
-EJECT
*
-LINE 84 "LOGIC.lss"
************************************************************************
*                                                                      *
*             #        #######   #####   ###   #####                   *
*             #        #     #  #     #   #   #     #                  *
*             #        #     #  #         #   #                        *
*             #        #     #  #  ####   #   #                        *
*             #        #     #  #     #   #   #                        *
*             #        #     #  #     #   #   #     #                  *
*             #######  #######   #####   ###   #####                   *
*                                                                      *
* LOGIC       CATSPAW SPITBOL COMPATIBLE LOGIC() FUNCTIONS             *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 21, 2002                                                     *
*                                                                      *
************************************************************************
*
* LOGIC.lss
*
-LINE 11 "LOGIC.lss"
-MODULE LOGIC
*
* NOTE! BASE ARGUMENT MUST BE PASSED A EXPLICIT NULL STRING FOR DEFAULT
*
* INTEGER/INTEGER, STRING/INTEGER, STRING/STRING
*
-PUBLIC LOGIC()
         LOAD('LOGIC(INTEGER,,)')
*
-PUBLIC NOT(), AND(), OR(), XOR(), NAND(), NOR(), UPLUS(), UMINUS()
-PUBLIC  UMUL(), UDIV(), SHL(), SHR(), SAR(), ROL(), ROR()
-PUBLIC HI(), IH(), DIB(), IDB()
         DEFINE('NOT(ARG)')
         DEFINE('AND(ARG1,ARG2)')
         DEFINE('OR(ARG1,ARG2)')
         DEFINE('XOR(ARG1,ARG2)')
         DEFINE('NAND(ARG1,ARG2)')
         DEFINE('NOR(ARG1,ARG2)')
         DEFINE('UPLUS(ARG1,ARG2)')
         DEFINE('UMINUS(ARG1,ARG2)')
         DEFINE('UMUL(ARG1,ARG2)')
         DEFINE('UDIV(ARG1,ARG2)')
         DEFINE('SHL(ARG1,ARG2)')
         DEFINE('SHR(ARG1,ARG2)')
         DEFINE('SAR(ARG1,ARG2)')
         DEFINE('ROL(ARG1,ARG2)')
         DEFINE('ROR(ARG1,ARG2)')
         DEFINE('HI(ARG)')
         DEFINE('IH(ARG)')
         DEFINE('DIB(ARG,BASE)')
         DEFINE('IDB(ARG,BASE)')                            :(LOGIC_END)
*
NOT      NOT    = LOGIC( 1, ARG)                    :S(RETURN)F(FRETURN)
AND      AND    = LOGIC( 2, ARG1, ARG2)             :S(RETURN)F(FRETURN)
OR       OR     = LOGIC( 3, ARG1, ARG2)             :S(RETURN)F(FRETURN)
XOR      XOR    = LOGIC( 4, ARG1, ARG2)             :S(RETURN)F(FRETURN)
NAND     NAND   = LOGIC( 5, ARG1, ARG2)             :S(RETURN)F(FRETURN)
NOR      NOR    = LOGIC( 6, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UPLUS    UPLUS  = LOGIC( 7, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UMINUS   UMINUS = LOGIC( 8, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UMUL     UMUL   = LOGIC( 9, ARG1, ARG2)             :S(RETURN)F(FRETURN)
UDIV     UDIV   = LOGIC(10, ARG1, ARG2)             :S(RETURN)F(FRETURN)
SHL      SHL    = LOGIC(11, ARG1, ARG2)             :S(RETURN)F(FRETURN)
SHR      SHR    = LOGIC(12, ARG1, ARG2)             :S(RETURN)F(FRETURN)
SAR      SAR    = LOGIC(13, ARG1, ARG2)             :S(RETURN)F(FRETURN)
ROL      ROL    = LOGIC(14, ARG1, ARG2)             :S(RETURN)F(FRETURN)
ROR      ROR    = LOGIC(15, ARG1, ARG2)             :S(RETURN)F(FRETURN)
HI       HI     = LOGIC(16, CONVERT(ARG, 'STRING'), '')
+                                                   :S(RETURN)F(FRETURN)
IH       IH     = LOGIC(17, CONVERT(ARG, 'INTEGER'), '')
+                                                   :S(RETURN)F(FRETURN)
DIB      DIB    = LOGIC(16, CONVERT(ARG, 'STRING'), BASE)
+                                                   :S(RETURN)F(FRETURN)
IDB      IDB    = LOGIC(17, CONVERT(ARG, 'INTEGER'), BASE)
+                                                   :S(RETURN)F(FRETURN)
*
LOGIC_END
         CODE('LOGIC')
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>LOGIC - CATSPAW SPITBOL compatible LOGIC() functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">LOGIC()</font> works on integers or buffers (strings).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LOGIC&raquo;&equiv;</b>
-MODULE LOGIC
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NOTE! BASE ARGUMENT MUST BE PASSED A EXPLICIT NULL STRING FOR DEFAULT</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INTEGER/INTEGER, STRING/INTEGER, STRING/STRING</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC LOGIC()
         LOAD(&#39;LOGIC(INTEGER,,)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC NOT(), AND(), OR(), XOR(), NAND(), NOR(), UPLUS(), UMINUS()
-PUBLIC  UMUL(), UDIV(), SHL(), SHR(), SAR(), ROL(), ROR()
-PUBLIC HI(), IH(), DIB(), IDB()
         DEFINE(&#39;NOT(ARG)&#39;)
         DEFINE(&#39;AND(ARG1,ARG2)&#39;)
         DEFINE(&#39;OR(ARG1,ARG2)&#39;)
         DEFINE(&#39;XOR(ARG1,ARG2)&#39;)
         DEFINE(&#39;NAND(ARG1,ARG2)&#39;)
         DEFINE(&#39;NOR(ARG1,ARG2)&#39;)
         DEFINE(&#39;UPLUS(ARG1,ARG2)&#39;)
         DEFINE(&#39;UMINUS(ARG1,ARG2)&#39;)
         DEFINE(&#39;UMUL(ARG1,ARG2)&#39;)
         DEFINE(&#39;UDIV(ARG1,ARG2)&#39;)
         DEFINE(&#39;SHL(ARG1,ARG2)&#39;)
         DEFINE(&#39;SHR(ARG1,ARG2)&#39;)
         DEFINE(&#39;SAR(ARG1,ARG2)&#39;)
         DEFINE(&#39;ROL(ARG1,ARG2)&#39;)
         DEFINE(&#39;ROR(ARG1,ARG2)&#39;)
         DEFINE(&#39;HI(ARG)&#39;)
         DEFINE(&#39;IH(ARG)&#39;)
         DEFINE(&#39;DIB(ARG,BASE)&#39;)
         DEFINE(&#39;IDB(ARG,BASE)&#39;)                            <b>:(LOGIC_END)</b>
<font color="#818181"><i>*</i></font>
NOT      NOT    = LOGIC( 1, ARG)                    <b>:S(RETURN)F(FRETURN)</b>
AND      AND    = LOGIC( 2, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
OR       OR     = LOGIC( 3, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
XOR      XOR    = LOGIC( 4, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
NAND     NAND   = LOGIC( 5, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
NOR      NOR    = LOGIC( 6, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
UPLUS    UPLUS  = LOGIC( 7, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
UMINUS   UMINUS = LOGIC( 8, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
UMUL     UMUL   = LOGIC( 9, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
UDIV     UDIV   = LOGIC(10, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
SHL      SHL    = LOGIC(11, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
SHR      SHR    = LOGIC(12, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
SAR      SAR    = LOGIC(13, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
ROL      ROL    = LOGIC(14, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
ROR      ROR    = LOGIC(15, ARG1, ARG2)             <b>:S(RETURN)F(FRETURN)</b>
HI       HI     = LOGIC(16, CONVERT(ARG, &#39;STRING&#39;), &#39;&#39;)
+                                                   <b>:S(RETURN)F(FRETURN)</b>
IH       IH     = LOGIC(17, CONVERT(ARG, &#39;INTEGER&#39;), &#39;&#39;)
+                                                   <b>:S(RETURN)F(FRETURN)</b>
DIB      DIB    = LOGIC(16, CONVERT(ARG, &#39;STRING&#39;), BASE)
+                                                   <b>:S(RETURN)F(FRETURN)</b>
IDB      IDB    = LOGIC(17, CONVERT(ARG, &#39;INTEGER&#39;), BASE)
+                                                   <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
LOGIC_END
         CODE(&#39;LOGIC&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;LOGIC.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL LOGIC
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             #        #######   #####   ###   #####                   *</i></font>
<font color="#818181"><i>*             #        #     #  #     #   #   #     #                  *</i></font>
<font color="#818181"><i>*             #        #     #  #         #   #                        *</i></font>
<font color="#818181"><i>*             #        #     #  #  ####   #   #                        *</i></font>
<font color="#818181"><i>*             #        #     #  #     #   #   #                        *</i></font>
<font color="#818181"><i>*             #        #     #  #     #   #   #     #                  *</i></font>
<font color="#818181"><i>*             #######  #######   #####   ###   #####                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LOGIC       CATSPAW SPITBOL COMPATIBLE LOGIC() FUNCTIONS             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                       *</i></font>
<font color="#818181"><i>* JANUARY 21, 2002                                                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOGIC.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;LOGIC&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:09 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LOGIC.INC'
-LINE 75 "LOGIC.lss"
         &CODE = 1
         &CODE = 0
END
<h1>LOG - LOG Functions</h1>

[[CLOG(X)]] will return the common log (base 10) of [[X]].<br>
[[LOGB(X,B)]] will return the logarithm of [[X]] to the base [[B]].<br>
[[LOGB(X)]] will return the natural logarithm of [[X]] (same as
[[LN(X)]]). Note that CSNOBOL4 also has [[LOG(X)]] for natural log.

<h2>Uses</h2>
<a href="DEXP.html">DEXP</a><br>

<<INCLUDES>>=
-INCLUDE 'DEXP.INC'
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LOG.INC'
-INCLUDE 'FLOOR.INC'
         &CODE = 1
         EQ(CEIL(CLOG(1000)), 3)                                 :F(END)
         X = CLOG(EULERS_NUMBER) * LN(10)
         EQ(CEIL(X * 10000), 10000)                              :F(END)
         &CODE = 0
END
@

<<>>=
-MODULE LOG
<<INCLUDES>>
-STITL LOG
-EJECT
*
************************************************************************
*                                                                      *
*                      #        #######   #####                        *
*                      #        #     #  #     #                       *
*                      #        #     #  #                             *
*                      #        #     #  #  ####                       *
*                      #        #     #  #     #                       *
*                      #        #     #  #     #                       *
*                      #######  #######   #####                        *
*                                                                      *
* LOG                       LOG FUNCTIONS                              *
*                                                                      *
************************************************************************
*
* LOG.lss
*
* CONSTANTS TO 50 PLACES
*
* SEE
* http://numbers.computation.free.fr/Constants/Miscellaneous/digits.html
*
-PUBLIC LN_10, EULERS_NUMBER, PI
         LN_10    =
+                   2.30258509299404568401799145468436420760110148862877
         EULERS_NUMBER =
+                   2.71828182845904523536028747135266249775724709369995
         PI =
+                   3.14159265358979323846264338327950288419716939937510
*
-PUBLIC CLOG(), LOGB()
         DEXP('CLOG(X) = LN(X) / LN_10')
         DEXP('LOGB(X,B) = NE(B, 0) LN(X) / LN(B) ;'
+             'LOGB      = EQ(B, 0) LN(X)         ;')
*
LOG_END
*
* CE: .MSNOBOL4;
@
-MODULE LOG
-LINE 12 "LOG.lss"
-INCLUDE 'DEXP.INC'
-STITL LOG
-LINE 32 "LOG.lss"
-EJECT
*
************************************************************************
*                                                                      *
*                      #        #######   #####                        *
*                      #        #     #  #     #                       *
*                      #        #     #  #                             *
*                      #        #     #  #  ####                       *
*                      #        #     #  #     #                       *
*                      #        #     #  #     #                       *
*                      #######  #######   #####                        *
*                                                                      *
* LOG                       LOG FUNCTIONS                              *
*                                                                      *
************************************************************************
*
* LOG.lss
*
* CONSTANTS TO 50 PLACES
*
* SEE
* http://numbers.computation.free.fr/Constants/Miscellaneous/digits.html
*
-PUBLIC LN_10, EULERS_NUMBER, PI
         LN_10    =
+                   2.30258509299404568401799145468436420760110148862877
         EULERS_NUMBER =
+                   2.71828182845904523536028747135266249775724709369995
         PI =
+                   3.14159265358979323846264338327950288419716939937510
*
-PUBLIC CLOG(), LOGB()
         DEXP('CLOG(X) = LN(X) / LN_10')
         DEXP('LOGB(X,B) = NE(B, 0) LN(X) / LN(B) ;'
+             'LOGB      = EQ(B, 0) LN(X)         ;')
*
LOG_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>LOG - LOG Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CLOG(X)</font> will return the common log (base 10) of <font face="Source Code Pro">X</font>.<br>
<font face="Source Code Pro">LOGB(X,B)</font> will return the logarithm of <font face="Source Code Pro">X</font> to the base <font face="Source Code Pro">B</font>.<br>
<font face="Source Code Pro">LOGB(X)</font> will return the natural logarithm of <font face="Source Code Pro">X</font> (same as
<font face="Source Code Pro">LN(X)</font>). Note that CSNOBOL4 also has <font face="Source Code Pro">LOG(X)</font> for natural log.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="DEXP.html">DEXP</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;DEXP.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;LOG.INC&#39;
-INCLUDE &#39;FLOOR.INC&#39;
         &amp;CODE = 1
         EQ(CEIL(CLOG(1000)), 3)                                 <b>:F(END)</b>
         X = CLOG(EULERS_NUMBER) * LN(10)
         EQ(CEIL(X * 10000), 10000)                              <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE LOG
<b>&laquo;INCLUDES&raquo;</b>
-STITL LOG
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      #        #######   #####                        *</i></font>
<font color="#818181"><i>*                      #        #     #  #     #                       *</i></font>
<font color="#818181"><i>*                      #        #     #  #                             *</i></font>
<font color="#818181"><i>*                      #        #     #  #  ####                       *</i></font>
<font color="#818181"><i>*                      #        #     #  #     #                       *</i></font>
<font color="#818181"><i>*                      #        #     #  #     #                       *</i></font>
<font color="#818181"><i>*                      #######  #######   #####                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LOG                       LOG FUNCTIONS                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOG.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONSTANTS TO 50 PLACES</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SEE</i></font>
<font color="#818181"><i>* http://numbers.computation.free.fr/Constants/Miscellaneous/digits.html</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC LN_10, EULERS_NUMBER, PI
         LN_10    =
+                   2.30258509299404568401799145468436420760110148862877
         EULERS_NUMBER =
+                   2.71828182845904523536028747135266249775724709369995
         PI =
+                   3.14159265358979323846264338327950288419716939937510
<font color="#818181"><i>*</i></font>
-PUBLIC CLOG(), LOGB()
         DEXP(&#39;CLOG(X) = LN(X) / LN_10&#39;)
         DEXP(&#39;LOGB(X,B) = NE(B, 0) LN(X) / LN(B) ;&#39;
+             &#39;LOGB      = EQ(B, 0) LN(X)         ;&#39;)
<font color="#818181"><i>*</i></font>
LOG_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:10 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LOG.INC'
-LINE 19 "LOG.lss"
-INCLUDE 'FLOOR.INC'
         &CODE = 1
         EQ(CEIL(CLOG(1000)), 3)                                 :F(END)
         X = CLOG(EULERS_NUMBER) * LN(10)
         EQ(CEIL(X * 10000), 10000)                              :F(END)
         &CODE = 0
END
<h1>LPROG - Length of program</h1>

Profiling and other tasks need to know the number of statements in
the program. The [[LPROG()]] function supplies this information.
Each statement compiled is given a new statement number. This is
exploited by returning the statement number of a new statement.

[[LPROG()]] will return the length (i.e., the number of statements)
in the SNOBOL4 program in which it is called. Every use of [[CODE()]]
will increase this number, so call this early during execution.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<LPROG>>=
-MODULE LPROG
-PUBLIC LPROG()
         DEFINE('LPROG()')                                  :(LPROG_END)
*
LPROG                                :<CODE(' LPROG = &STNO :(RETURN)')>
*
LPROG_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LPROG.INC'
         &CODE = 1
         EQ(LPROG(), 9)                                          :F(END)
         &CODE = 0
END
@

<<>>=
-STITL LPROG
-EJECT
*
************************************************************************
*                                                                      *
*               #        ######   ######   #######   #####             *
*               #        #     #  #     #  #     #  #     #            *
*               #        #     #  #     #  #     #  #                  *
*               #        ######   ######   #     #  #  ####            *
*               #        #        #   #    #     #  #     #            *
*               #        #        #    #   #     #  #     #            *
*               #######  #        #     #  #######   #####             *
*                                                                      *
* LPROG                    LENGTH OF PROGRAM                           *
*                                                                      *
************************************************************************
*
* LPROG.lss
*
<<LPROG>>
*
* CE: .MSNOBOL4;
@
-STITL LPROG
-EJECT
*
-LINE 41 "LPROG.lss"
************************************************************************
*                                                                      *
*               #        ######   ######   #######   #####             *
*               #        #     #  #     #  #     #  #     #            *
*               #        #     #  #     #  #     #  #                  *
*               #        ######   ######   #     #  #  ####            *
*               #        #        #   #    #     #  #     #            *
*               #        #        #    #   #     #  #     #            *
*               #######  #        #     #  #######   #####             *
*                                                                      *
* LPROG                    LENGTH OF PROGRAM                           *
*                                                                      *
************************************************************************
*
* LPROG.lss
*
-LINE 18 "LPROG.lss"
-MODULE LPROG
-PUBLIC LPROG()
         DEFINE('LPROG()')                                  :(LPROG_END)
*
LPROG                                :<CODE(' LPROG = &STNO :(RETURN)')>
*
LPROG_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>LPROG - Length of program</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Profiling and other tasks need to know the number of statements in
the program. The <font face="Source Code Pro">LPROG()</font> function supplies this information.
Each statement compiled is given a new statement number. This is
exploited by returning the statement number of a new statement.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">LPROG()</font> will return the length (i.e., the number of statements)
in the SNOBOL4 program in which it is called. Every use of <font face="Source Code Pro">CODE()</font>
will increase this number, so call this early during execution.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;LPROG&raquo;&equiv;</b>
-MODULE LPROG
-PUBLIC LPROG()
         DEFINE(&#39;LPROG()&#39;)                                  <b>:(LPROG_END)</b>
<font color="#818181"><i>*</i></font>
LPROG                                <b>:&lt;CODE(&#39; LPROG = &amp;STNO :(RETURN)&#39;)&gt;</b>
<font color="#818181"><i>*</i></font>
LPROG_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;LPROG.INC&#39;
         &amp;CODE = 1
         EQ(LPROG(), 9)                                          <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL LPROG
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #        ######   ######   #######   #####             *</i></font>
<font color="#818181"><i>*               #        #     #  #     #  #     #  #     #            *</i></font>
<font color="#818181"><i>*               #        #     #  #     #  #     #  #                  *</i></font>
<font color="#818181"><i>*               #        ######   ######   #     #  #  ####            *</i></font>
<font color="#818181"><i>*               #        #        #   #    #     #  #     #            *</i></font>
<font color="#818181"><i>*               #        #        #    #   #     #  #     #            *</i></font>
<font color="#818181"><i>*               #######  #        #     #  #######   #####             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LPROG                    LENGTH OF PROGRAM                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LPROG.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;LPROG&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:10 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'LPROG.INC'
-LINE 31 "LPROG.lss"
         &CODE = 1
         EQ(LPROG(), 9)                                          :F(END)
         &CODE = 0
END
<H1>lseq</H1>

<h2>Uses</h2>

<<INCLUDES>>=
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM LSEQ
-TITLE LSEQ
START
*
************************************************************************
*                                                                      *
*                  #         #####   #######   #####                   *
*                  #        #     #  #        #     #                  *
*                  #        #        #        #     #                  *
*                  #         #####   #####    #     #                  *
*                  #              #  #        #   # #                  *
*                  #        #     #  #        #    #                   *
*                  #######   #####   #######   #### #                  *
*                                                                      *
* LSEQ          LEFT SEQUENCE NUMBER A SOURCE DECK (1-6)               *
*                                                                      *
************************************************************************
*
* lseq.lss
*
* USED FOR COBOL AND BASIC
*
         TERMINAL = 'LSEQ (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 6)
         Z = DUPL('0', 6)
         N = 10
*
TOP      (INPUT S) LEN(6) REM . R                                :F(END)
         (Z N) LEN(6) . L RPOS(0)
         N = N + 10
         R = RPAD(R, 12, ' ')
         (L R) ARB . L LEN(6) RPOS(0) 
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM LSEQ
-LINE 12 "lseq.lss"
-TITLE LSEQ
START
*
************************************************************************
*                                                                      *
*                  #         #####   #######   #####                   *
*                  #        #     #  #        #     #                  *
*                  #        #        #        #     #                  *
*                  #         #####   #####    #     #                  *
*                  #              #  #        #   # #                  *
*                  #        #     #  #        #    #                   *
*                  #######   #####   #######   #### #                  *
*                                                                      *
* LSEQ          LEFT SEQUENCE NUMBER A SOURCE DECK (1-6)               *
*                                                                      *
************************************************************************
*
* lseq.lss
*
* USED FOR COBOL AND BASIC
*
         TERMINAL = 'LSEQ (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 6)
         Z = DUPL('0', 6)
         N = 10
*
TOP      (INPUT S) LEN(6) REM . R                                :F(END)
         (Z N) LEN(6) . L RPOS(0)
         N = N + 10
         R = RPAD(R, 12, ' ')
         (L R) ARB . L LEN(6) RPOS(0)
         OUTPUT = TRIM(L)                                         :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>lseq</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM LSEQ
-TITLE LSEQ
START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #         #####   #######   #####                   *</i></font>
<font color="#818181"><i>*                  #        #     #  #        #     #                  *</i></font>
<font color="#818181"><i>*                  #        #        #        #     #                  *</i></font>
<font color="#818181"><i>*                  #         #####   #####    #     #                  *</i></font>
<font color="#818181"><i>*                  #              #  #        #   # #                  *</i></font>
<font color="#818181"><i>*                  #        #     #  #        #    #                   *</i></font>
<font color="#818181"><i>*                  #######   #####   #######   #### #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LSEQ          LEFT SEQUENCE NUMBER A SOURCE DECK (1-6)               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* lseq.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* USED FOR COBOL AND BASIC</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;LSEQ (SUN JUN 16 14:13:20 EDT 2013)&#39;
<font color="#818181"><i>*</i></font>
         S = DUPL(&#39; &#39;, 6)
         Z = DUPL(&#39;0&#39;, 6)
         N = 10
<font color="#818181"><i>*</i></font>
TOP      (INPUT S) LEN(6) REM . R                                <b>:F(END)</b>
         (Z N) LEN(6) . L RPOS(0)
         N = N + 10
         R = RPAD(R, 12, &#39; &#39;)
         (L R) ARB . L LEN(6) RPOS(0)
         OUTPUT = TRIM(L)                                         <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:11 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<H1>lsinc</H1>

List includes.

<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="HOST.html">HOST</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="TRIMB.html">TRIMB</a><br>

<<INCLUDES>>=
-INCLUDE 'CRACK.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'TRIMB.INC'
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM LSINC
-TITLE LSINC
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*               #         #####   ###  #     #   #####                 *
*               #        #     #   #   ##    #  #     #                *
*               #        #         #   # #   #  #                      *
*               #         #####    #   #  #  #  #                      *
*               #              #   #   #   # #  #                      *
*               #        #     #   #   #    ##  #     #                *
*               #######   #####   ###  #     #   #####                 *
*                                                                      *
* LSINC                 LIST INCLUDES NEEDED                           *
*                                                                      *
************************************************************************
*
* lsinc.lss
*
         TERMINAL = 'LSINC (TUE NOV 26 20:14:36 EST 2013)'
*
         QQ = '"'
         Q = "'"
         INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                           (ANY('Cc') ('OPY' | 'opy')))
+                BREAK(QQ Q) LEN(1) BREAK(QQ Q) . X
         &TRIM =  1
         LOADED = TABLE()
         DEFINE('INCLUDE(FILENAME)PATH,POSITION,UNIT,LIB')
         INCLUDE('/dev/stdin')
         A = CONVERT(LOADED, 'ARRAY')
         A = SORT(A)
         SEQ(' OUTPUT = A<I,1> ', .I)                             :(END)
*
INCLUDE  PATH = FILENAME
         UNIT = IO_FINDUNIT()
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, 'SNOPATH')                    :S(DOINC_8)
         X = HOST(HOST_GETENV, 'SNOLIB')                     :S(DOINC_8)
         X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
DOINC_8  A = CRACK(X, PS)
         I = 1
DOINC_10 P = TRIMB(A<I>)                                     :F(FRETURN)
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         I = I + 1                                           :(DOINC_10)
*
TOP      L = LIB                                             :F(DOINC_2)
         L INPAT                                                 :F(TOP)
*
         DIFFER(LOADED<X>)                                       :S(TOP)
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
*
         INCLUDE(X)                                          :F(FRETURN)
*
         INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
         LOADED<X> = 1
         FILENAME FENCE '/dev/'                                  :S(TOP)
         EQ(SET(UNIT, POSITION, 0), POSITION)          :S(TOP)F(FRETURN)
*
DOINC_2  ENDFILE(UNIT)
         DETACH(.LIB)                                          :(RETURN)
*
END START
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM LSINC
-LINE 22 "lsinc.lss"
-TITLE LSINC
START
-LINE 12 "lsinc.lss"
-INCLUDE 'CRACK.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'TRIMB.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*               #         #####   ###  #     #   #####                 *
*               #        #     #   #   ##    #  #     #                *
*               #        #         #   # #   #  #                      *
*               #         #####    #   #  #  #  #                      *
*               #              #   #   #   # #  #                      *
*               #        #     #   #   #    ##  #     #                *
*               #######   #####   ###  #     #   #####                 *
*                                                                      *
* LSINC                 LIST INCLUDES NEEDED                           *
*                                                                      *
************************************************************************
*
* lsinc.lss
*
         TERMINAL = 'LSINC (TUE NOV 26 20:14:36 EST 2013)'
*
         QQ = '"'
         Q = "'"
         INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                           (ANY('Cc') ('OPY' | 'opy')))
+                BREAK(QQ Q) LEN(1) BREAK(QQ Q) . X
         &TRIM =  1
         LOADED = TABLE()
         DEFINE('INCLUDE(FILENAME)PATH,POSITION,UNIT,LIB')
         INCLUDE('/dev/stdin')
         A = CONVERT(LOADED, 'ARRAY')
         A = SORT(A)
         SEQ(' OUTPUT = A<I,1> ', .I)                             :(END)
*
INCLUDE  PATH = FILENAME
         UNIT = IO_FINDUNIT()
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, 'SNOPATH')                    :S(DOINC_8)
         X = HOST(HOST_GETENV, 'SNOLIB')                     :S(DOINC_8)
         X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
DOINC_8  A = CRACK(X, PS)
         I = 1
DOINC_10 P = TRIMB(A<I>)                                     :F(FRETURN)
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                                :S(TOP)
         I = I + 1                                           :(DOINC_10)
*
TOP      L = LIB                                             :F(DOINC_2)
         L INPAT                                                 :F(TOP)
*
         DIFFER(LOADED<X>)                                       :S(TOP)
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
*
         INCLUDE(X)                                          :F(FRETURN)
*
         INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
         LOADED<X> = 1
         FILENAME FENCE '/dev/'                                  :S(TOP)
         EQ(SET(UNIT, POSITION, 0), POSITION)          :S(TOP)F(FRETURN)
*
DOINC_2  ENDFILE(UNIT)
         DETACH(.LIB)                                          :(RETURN)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>lsinc</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
List includes.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="HOST.html">HOST</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="TRIMB.html">TRIMB</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM LSINC
-TITLE LSINC
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #         #####   ###  #     #   #####                 *</i></font>
<font color="#818181"><i>*               #        #     #   #   ##    #  #     #                *</i></font>
<font color="#818181"><i>*               #        #         #   # #   #  #                      *</i></font>
<font color="#818181"><i>*               #         #####    #   #  #  #  #                      *</i></font>
<font color="#818181"><i>*               #              #   #   #   # #  #                      *</i></font>
<font color="#818181"><i>*               #        #     #   #   #    ##  #     #                *</i></font>
<font color="#818181"><i>*               #######   #####   ###  #     #   #####                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* LSINC                 LIST INCLUDES NEEDED                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* lsinc.lss</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;LSINC (TUE NOV 26 20:14:36 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         QQ = &#39;&quot;&#39;
         Q = &quot;&#39;&quot;
         INPAT = FENCE &#39;-&#39; ((ANY(&#39;Ii&#39;) (&#39;NCLUDE&#39; | &#39;nclude&#39;)) |
+                           (ANY(&#39;Cc&#39;) (&#39;OPY&#39; | &#39;opy&#39;)))
+                BREAK(QQ Q) LEN(1) BREAK(QQ Q) . X
         &amp;TRIM =  1
         LOADED = TABLE()
         DEFINE(&#39;INCLUDE(FILENAME)PATH,POSITION,UNIT,LIB&#39;)
         INCLUDE(&#39;/dev/stdin&#39;)
         A = CONVERT(LOADED, &#39;ARRAY&#39;)
         A = SORT(A)
         SEQ(&#39; OUTPUT = A&lt;I,1&gt; &#39;, .I)                             <b>:(END)</b>
<font color="#818181"><i>*</i></font>
INCLUDE  PATH = FILENAME
         UNIT = IO_FINDUNIT()
         INPUT(.LIB, UNIT,, PATH)                                <b>:S(TOP)</b>
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, &#39;SNOPATH&#39;)                    <b>:S(DOINC_8)</b>
         X = HOST(HOST_GETENV, &#39;SNOLIB&#39;)                     <b>:S(DOINC_8)</b>
         X = HOST(HOST_SNOLIB_DIR)                           <b>:F(FRETURN)</b>
DOINC_8  A = CRACK(X, PS)
         I = 1
DOINC_10 P = TRIMB(A&lt;I&gt;)                                     <b>:F(FRETURN)</b>
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                                <b>:S(TOP)</b>
         I = I + 1                                           <b>:(DOINC_10)</b>
<font color="#818181"><i>*</i></font>
TOP      L = LIB                                             <b>:F(DOINC_2)</b>
         L INPAT                                                 <b>:F(TOP)</b>
<font color="#818181"><i>*</i></font>
         DIFFER(LOADED&lt;X&gt;)                                       <b>:S(TOP)</b>
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
<font color="#818181"><i>*</i></font>
         INCLUDE(X)                                          <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         INPUT(.LIB, UNIT,, PATH)                            <b>:F(FRETURN)</b>
         LOADED&lt;X&gt; = 1
         FILENAME FENCE &#39;/dev/&#39;                                  <b>:S(TOP)</b>
         EQ(SET(UNIT, POSITION, 0), POSITION)          <b>:S(TOP)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
DOINC_2  ENDFILE(UNIT)
         DETACH(.LIB)                                          <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:12 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>MAX - MAX and MIN Functions</h1>

[[MAX(X,Y)]] will return the maximum of [[X]] and [[Y]]. [[MIN(X,Y)]]
returns the minimum of [[X]] and [[Y]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'MAX.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE MAX
<<INCLUDES>>
-STITL MAX
-EJECT
*
************************************************************************
*                                                                      *
*                      #     #     #     #     #                       *
*                      ##   ##    # #     #   #                        *
*                      # # # #   #   #     # #                         *
*                      #  #  #  #     #     #                          *
*                      #     #  #######    # #                         *
*                      #     #  #     #   #   #                        *
*                      #     #  #     #  #     #                       *
*                                                                      *
* MAX                      MAX/MIN FUNCTIONS                           *
*                                                                      *
************************************************************************
*
* MAX.lss
*
-PUBLIC MAX(), MIN()
         DEFINE('MAX(X,Y)')
         DEFINE('MIN(X,Y)')                                   :(MAX_END)
*
MAX      MAX = GT(X, Y) X                                     :S(RETURN)
         MAX = Y                                               :(RETURN)
*
MIN      MIN = LT(X, Y) X                                     :S(RETURN)
         MIN = Y                                               :(RETURN)
*
MAX_END
*
* CE: .MSNOBOL4;
@
-MODULE MAX
-LINE 9 "MAX.lss"
-STITL MAX
-LINE 24 "MAX.lss"
-EJECT
*
************************************************************************
*                                                                      *
*                      #     #     #     #     #                       *
*                      ##   ##    # #     #   #                        *
*                      # # # #   #   #     # #                         *
*                      #  #  #  #     #     #                          *
*                      #     #  #######    # #                         *
*                      #     #  #     #   #   #                        *
*                      #     #  #     #  #     #                       *
*                                                                      *
* MAX                      MAX/MIN FUNCTIONS                           *
*                                                                      *
************************************************************************
*
* MAX.lss
*
-PUBLIC MAX(), MIN()
         DEFINE('MAX(X,Y)')
         DEFINE('MIN(X,Y)')                                   :(MAX_END)
*
MAX      MAX = GT(X, Y) X                                     :S(RETURN)
         MAX = Y                                               :(RETURN)
*
MIN      MIN = LT(X, Y) X                                     :S(RETURN)
         MIN = Y                                               :(RETURN)
*
MAX_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>MAX - MAX and MIN Functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">MAX(X,Y)</font> will return the maximum of <font face="Source Code Pro">X</font> and <font face="Source Code Pro">Y</font>. <font face="Source Code Pro">MIN(X,Y)</font>
returns the minimum of <font face="Source Code Pro">X</font> and <font face="Source Code Pro">Y</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;MAX.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE MAX
<b>&laquo;INCLUDES&raquo;</b>
-STITL MAX
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      #     #     #     #     #                       *</i></font>
<font color="#818181"><i>*                      ##   ##    # #     #   #                        *</i></font>
<font color="#818181"><i>*                      # # # #   #   #     # #                         *</i></font>
<font color="#818181"><i>*                      #  #  #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #######    # #                         *</i></font>
<font color="#818181"><i>*                      #     #  #     #   #   #                        *</i></font>
<font color="#818181"><i>*                      #     #  #     #  #     #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* MAX                      MAX/MIN FUNCTIONS                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAX.lss</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC MAX(), MIN()
         DEFINE(&#39;MAX(X,Y)&#39;)
         DEFINE(&#39;MIN(X,Y)&#39;)                                   <b>:(MAX_END)</b>
<font color="#818181"><i>*</i></font>
MAX      MAX = GT(X, Y) X                                     <b>:S(RETURN)</b>
         MAX = Y                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MIN      MIN = LT(X, Y) X                                     <b>:S(RETURN)</b>
         MIN = Y                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MAX_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:37 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'MAX.INC'
-LINE 15 "MAX.lss"
         &CODE = 1
         &CODE = 0
END
<h1>MDY - M/D/Y from Y/D</h1>

[[MDY(Y,DY)]] will convert a year,day date into a month/day/year date.
For example [[MDY(71,83)]] will return '3/24/71'. The global variables
M and D are set to equal to the month and day respectively.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<MDY>>=
-MODULE MDY
-PUBLIC MDY()
         DEFINE('MDY(Y,DY)X,T')
         DAY_MONTH = '(334,12)(304,11)(273,10)(243,9)'
+           '(212,8)(181,7)(151,6)(120,5)(90,4)(59,3)(31,2)(0,1)'
         LY_DAY_MONTH = '(335,12)(305,11)(274,10)(244,9)'
+           '(213,8)(182,7)(152,6)(121,5)(91,4)(60,3)(31,2)(0,1)'
         I = SPAN('0123456789')
         SEARCH.X.M = '(' I $ X *GT(DY, X) ',' I $ M          :(MDY_END)
*
MDY      T = EQ(REMDR(Y, 400), 0) LY_DAY_MONTH                 :S(MDY_1)
         T = EQ(REMDR(Y, 100), 0) DAY_MONTH                    :S(MDY_1)
         T = EQ(REMDR(Y,   4), 0) LY_DAY_MONTH                 :S(MDY_1)
         T = DAY_MONTH
MDY_1    T SEARCH.X.M                                        :F(FRETURN)
         D = DY - X
         GT(D, 31)                                           :S(FRETURN)
         MDY = M '/' D '/' Y                                   :(RETURN)
*
MDY_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'MDY.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL MDY
-EJECT
*
************************************************************************
*                                                                      *
*                      #     #  ######   #     #                       *
*                      ##   ##  #     #   #   #                        *
*                      # # # #  #     #    # #                         *
*                      #  #  #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  ######      #                          *
*                                                                      *
* MDY                       M/D/Y FROM Y/D                             *
*                                                                      *
************************************************************************
*
* MDY.lss
*
<<MDY>>
*
* CE: .MSNOBOL4;
@
-STITL MDY
-EJECT
*
-LINE 48 "MDY.lss"
************************************************************************
*                                                                      *
*                      #     #  ######   #     #                       *
*                      ##   ##  #     #   #   #                        *
*                      # # # #  #     #    # #                         *
*                      #  #  #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  #     #     #                          *
*                      #     #  ######      #                          *
*                                                                      *
* MDY                       M/D/Y FROM Y/D                             *
*                                                                      *
************************************************************************
*
* MDY.lss
*
-LINE 13 "MDY.lss"
-MODULE MDY
-PUBLIC MDY()
         DEFINE('MDY(Y,DY)X,T')
         DAY_MONTH = '(334,12)(304,11)(273,10)(243,9)'
+           '(212,8)(181,7)(151,6)(120,5)(90,4)(59,3)(31,2)(0,1)'
         LY_DAY_MONTH = '(335,12)(305,11)(274,10)(244,9)'
+           '(213,8)(182,7)(152,6)(121,5)(91,4)(60,3)(31,2)(0,1)'
         I = SPAN('0123456789')
         SEARCH.X.M = '(' I $ X *GT(DY, X) ',' I $ M          :(MDY_END)
*
MDY      T = EQ(REMDR(Y, 400), 0) LY_DAY_MONTH                 :S(MDY_1)
         T = EQ(REMDR(Y, 100), 0) DAY_MONTH                    :S(MDY_1)
         T = EQ(REMDR(Y,   4), 0) LY_DAY_MONTH                 :S(MDY_1)
         T = DAY_MONTH
MDY_1    T SEARCH.X.M                                        :F(FRETURN)
         D = DY - X
         GT(D, 31)                                           :S(FRETURN)
         MDY = M '/' D '/' Y                                   :(RETURN)
*
MDY_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>MDY - M/D/Y from Y/D</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">MDY(Y,DY)</font> will convert a year,day date into a month/day/year date.
For example <font face="Source Code Pro">MDY(71,83)</font> will return '3/24/71'. The global variables
M and D are set to equal to the month and day respectively.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;MDY&raquo;&equiv;</b>
-MODULE MDY
-PUBLIC MDY()
         DEFINE(&#39;MDY(Y,DY)X,T&#39;)
         DAY_MONTH = &#39;(334,12)(304,11)(273,10)(243,9)&#39;
+           &#39;(212,8)(181,7)(151,6)(120,5)(90,4)(59,3)(31,2)(0,1)&#39;
         LY_DAY_MONTH = &#39;(335,12)(305,11)(274,10)(244,9)&#39;
+           &#39;(213,8)(182,7)(152,6)(121,5)(91,4)(60,3)(31,2)(0,1)&#39;
         I = SPAN(&#39;0123456789&#39;)
         SEARCH.X.M = &#39;(&#39; I $ X *GT(DY, X) &#39;,&#39; I $ M          <b>:(MDY_END)</b>
<font color="#818181"><i>*</i></font>
MDY      T = EQ(REMDR(Y, 400), 0) LY_DAY_MONTH                 <b>:S(MDY_1)</b>
         T = EQ(REMDR(Y, 100), 0) DAY_MONTH                    <b>:S(MDY_1)</b>
         T = EQ(REMDR(Y,   4), 0) LY_DAY_MONTH                 <b>:S(MDY_1)</b>
         T = DAY_MONTH
MDY_1    T SEARCH.X.M                                        <b>:F(FRETURN)</b>
         D = DY - X
         GT(D, 31)                                           <b>:S(FRETURN)</b>
         MDY = M &#39;/&#39; D &#39;/&#39; Y                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
MDY_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;MDY.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL MDY
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                      #     #  ######   #     #                       *</i></font>
<font color="#818181"><i>*                      ##   ##  #     #   #   #                        *</i></font>
<font color="#818181"><i>*                      # # # #  #     #    # #                         *</i></font>
<font color="#818181"><i>*                      #  #  #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  #     #     #                          *</i></font>
<font color="#818181"><i>*                      #     #  ######      #                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* MDY                       M/D/Y FROM Y/D                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MDY.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;MDY&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:12 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'MDY.INC'
-LINE 39 "MDY.lss"
         &CODE = 1
         &CODE = 0
END
<h1>NDBM - NDBM interface for CSNOBOL4</h1>

Interface to NDBM from CSNOBOL4. Allows permanent keyed storage
on disk.  Hashed, so performance may be better than TABLE usage
(for very large TABLEs).

<h2>Uses</h2>

<<INCLUDES>>=
@

<<NDBM>>=
-MODULE NDBM
NDBM_LOAD
*
-PUBLIC DBM_INSERT, DBM_REPLACE
         DBM_INSERT = 0
         DBM_REPLACE = 1
*
-PUBLIC DBM_OPEN(), DBM_CLOSE()
         LOAD('DBM_OPEN(STRING,STRING,STRING)INTEGER')
         LOAD('DBM_CLOSE(INTEGER)STRING')
*
-PUBLIC DBM_STORE(), DBM_FETCH(), DBM_DELETE()
         LOAD('DBM_STORE(INTEGER,STRING,STRING,INTEGER)INTEGER')
         LOAD('DBM_FETCH(INTEGER,STRING)STRING')
         LOAD('DBM_DELETE(INTEGER,STRING)INTEGER')
*
-PUBLIC DBM_FIRSTKEY(), DBM_NEXTKEY()
         LOAD('DBM_FIRSTKEY(INTEGER)STRING')
         LOAD('DBM_NEXTKEY(INTEGER)STRING')
*
-PUBLIC DBM_ERROR(), DBM_CLEARERR()
         LOAD('DBM_ERROR(INTEGER)STRING')
         LOAD('DBM_CLEARERR(INTEGER)STRING')
*
         CODE('NDBM_LOAD')
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'NDBM.INC'
         &CODE = 1
         HANDLE = DBM_OPEN('db', 'CW', '0660')                   :F(END)
         OUTPUT = HANDLE
         DBM_CLOSE(HANDLE)                                       :F(END)
         HANDLE = DBM_OPEN('db', 'W')                            :F(END)
         DDD = '++' DUPL(' ', 1100) '++'
         DBM_STORE(HANDLE, 'KEY1', DDD, DBM_REPLACE)             :F(END)
         DBM_STORE(HANDLE, 'KEY2', 'DATA2', DBM_INSERT)          :F(END)
         OUTPUT = DBM_FETCH(HANDLE, 'KEY1')                      :F(END)
         OUTPUT = DBM_FETCH(HANDLE, 'KEY2')                      :F(END)
         OUTPUT = DBM_FIRSTKEY(HANDLE)                           :F(END)
NXTK     OUTPUT = DBM_NEXTKEY(HANDLE)                           :S(NXTK)
         DBM_CLOSE(HANDLE)                                       :F(END)
         DELETE('db.db')
         &CODE = 0
END
@

<<>>=
-STITL NDBM
-EJECT
*
************************************************************************
*                                                                      *
*                 #     #  ######   ######   #     #                   *
*                 ##    #  #     #  #     #  ##   ##                   *
*                 # #   #  #     #  #     #  # # # #                   *
*                 #  #  #  #     #  ######   #  #  #                   *
*                 #   # #  #     #  #     #  #     #                   *
*                 #    ##  #     #  #     #  #     #                   *
*                 #     #  ######   ######   #     #                   *
*                                                                      *
* NDBM               NDBM INTERFACE FOR CSNOBOL4                       *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* DECEMBER 3, 2005                                                     *
*                                                                      *
************************************************************************
*
* NDBM.lss
*
<<NDBM>>
*
* CE: .MSNOBOL4;
@
-STITL NDBM
-EJECT
*
-LINE 66 "NDBM.lss"
************************************************************************
*                                                                      *
*                 #     #  ######   ######   #     #                   *
*                 ##    #  #     #  #     #  ##   ##                   *
*                 # #   #  #     #  #     #  # # # #                   *
*                 #  #  #  #     #  ######   #  #  #                   *
*                 #   # #  #     #  #     #  #     #                   *
*                 #    ##  #     #  #     #  #     #                   *
*                 #     #  ######   ######   #     #                   *
*                                                                      *
* NDBM               NDBM INTERFACE FOR CSNOBOL4                       *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* DECEMBER 3, 2005                                                     *
*                                                                      *
************************************************************************
*
* NDBM.lss
*
-LINE 13 "NDBM.lss"
-MODULE NDBM
NDBM_LOAD
*
-PUBLIC DBM_INSERT, DBM_REPLACE
         DBM_INSERT = 0
         DBM_REPLACE = 1
*
-PUBLIC DBM_OPEN(), DBM_CLOSE()
         LOAD('DBM_OPEN(STRING,STRING,STRING)INTEGER')
         LOAD('DBM_CLOSE(INTEGER)STRING')
*
-PUBLIC DBM_STORE(), DBM_FETCH(), DBM_DELETE()
         LOAD('DBM_STORE(INTEGER,STRING,STRING,INTEGER)INTEGER')
         LOAD('DBM_FETCH(INTEGER,STRING)STRING')
         LOAD('DBM_DELETE(INTEGER,STRING)INTEGER')
*
-PUBLIC DBM_FIRSTKEY(), DBM_NEXTKEY()
         LOAD('DBM_FIRSTKEY(INTEGER)STRING')
         LOAD('DBM_NEXTKEY(INTEGER)STRING')
*
-PUBLIC DBM_ERROR(), DBM_CLEARERR()
         LOAD('DBM_ERROR(INTEGER)STRING')
         LOAD('DBM_CLEARERR(INTEGER)STRING')
*
         CODE('NDBM_LOAD')
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>NDBM - NDBM interface for CSNOBOL4</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Interface to NDBM from CSNOBOL4. Allows permanent keyed storage
on disk.  Hashed, so performance may be better than TABLE usage
(for very large TABLEs).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;NDBM&raquo;&equiv;</b>
-MODULE NDBM
NDBM_LOAD
<font color="#818181"><i>*</i></font>
-PUBLIC DBM_INSERT, DBM_REPLACE
         DBM_INSERT = 0
         DBM_REPLACE = 1
<font color="#818181"><i>*</i></font>
-PUBLIC DBM_OPEN(), DBM_CLOSE()
         LOAD(&#39;DBM_OPEN(STRING,STRING,STRING)INTEGER&#39;)
         LOAD(&#39;DBM_CLOSE(INTEGER)STRING&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC DBM_STORE(), DBM_FETCH(), DBM_DELETE()
         LOAD(&#39;DBM_STORE(INTEGER,STRING,STRING,INTEGER)INTEGER&#39;)
         LOAD(&#39;DBM_FETCH(INTEGER,STRING)STRING&#39;)
         LOAD(&#39;DBM_DELETE(INTEGER,STRING)INTEGER&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC DBM_FIRSTKEY(), DBM_NEXTKEY()
         LOAD(&#39;DBM_FIRSTKEY(INTEGER)STRING&#39;)
         LOAD(&#39;DBM_NEXTKEY(INTEGER)STRING&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC DBM_ERROR(), DBM_CLEARERR()
         LOAD(&#39;DBM_ERROR(INTEGER)STRING&#39;)
         LOAD(&#39;DBM_CLEARERR(INTEGER)STRING&#39;)
<font color="#818181"><i>*</i></font>
         CODE(&#39;NDBM_LOAD&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;NDBM.INC&#39;
         &amp;CODE = 1
         HANDLE = DBM_OPEN(&#39;db&#39;, &#39;CW&#39;, &#39;0660&#39;)                   <b>:F(END)</b>
         OUTPUT = HANDLE
         DBM_CLOSE(HANDLE)                                       <b>:F(END)</b>
         HANDLE = DBM_OPEN(&#39;db&#39;, &#39;W&#39;)                            <b>:F(END)</b>
         DDD = &#39;++&#39; DUPL(&#39; &#39;, 1100) &#39;++&#39;
         DBM_STORE(HANDLE, &#39;KEY1&#39;, DDD, DBM_REPLACE)             <b>:F(END)</b>
         DBM_STORE(HANDLE, &#39;KEY2&#39;, &#39;DATA2&#39;, DBM_INSERT)          <b>:F(END)</b>
         OUTPUT = DBM_FETCH(HANDLE, &#39;KEY1&#39;)                      <b>:F(END)</b>
         OUTPUT = DBM_FETCH(HANDLE, &#39;KEY2&#39;)                      <b>:F(END)</b>
         OUTPUT = DBM_FIRSTKEY(HANDLE)                           <b>:F(END)</b>
NXTK     OUTPUT = DBM_NEXTKEY(HANDLE)                           <b>:S(NXTK)</b>
         DBM_CLOSE(HANDLE)                                       <b>:F(END)</b>
         DELETE(&#39;db.db&#39;)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL NDBM
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 #     #  ######   ######   #     #                   *</i></font>
<font color="#818181"><i>*                 ##    #  #     #  #     #  ##   ##                   *</i></font>
<font color="#818181"><i>*                 # #   #  #     #  #     #  # # # #                   *</i></font>
<font color="#818181"><i>*                 #  #  #  #     #  ######   #  #  #                   *</i></font>
<font color="#818181"><i>*                 #   # #  #     #  #     #  #     #                   *</i></font>
<font color="#818181"><i>*                 #    ##  #     #  #     #  #     #                   *</i></font>
<font color="#818181"><i>*                 #     #  ######   ######   #     #                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* NDBM               NDBM INTERFACE FOR CSNOBOL4                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                       *</i></font>
<font color="#818181"><i>* DECEMBER 3, 2005                                                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NDBM.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;NDBM&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:13 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'NDBM.INC'
-LINE 44 "NDBM.lss"
         &CODE = 1
         HANDLE = DBM_OPEN('db', 'CW', '0660')                   :F(END)
         OUTPUT = HANDLE
         DBM_CLOSE(HANDLE)                                       :F(END)
         HANDLE = DBM_OPEN('db', 'W')                            :F(END)
         DDD = '++' DUPL(' ', 1100) '++'
         DBM_STORE(HANDLE, 'KEY1', DDD, DBM_REPLACE)             :F(END)
         DBM_STORE(HANDLE, 'KEY2', 'DATA2', DBM_INSERT)          :F(END)
         OUTPUT = DBM_FETCH(HANDLE, 'KEY1')                      :F(END)
         OUTPUT = DBM_FETCH(HANDLE, 'KEY2')                      :F(END)
         OUTPUT = DBM_FIRSTKEY(HANDLE)                           :F(END)
NXTK     OUTPUT = DBM_NEXTKEY(HANDLE)                           :S(NXTK)
         DBM_CLOSE(HANDLE)                                       :F(END)
         DELETE('db.db')
         &CODE = 0
END
<h1>NOTP - Invert Pattern</h1>

[[NOTP(P)]] will return a pattern which will match the NULL string if
[[P]] fails and fail if [[P]] matches. If [[P]] aborts, [[NOTP(P)]]
will also abort.

<h2>Uses</h2>
<a href="STACK.html">STACK</a><br>

<<INCLUDES>>=
-INCLUDE 'STACK.INC'
@

<<NOTP>>=
-MODULE NOTP
-PUBLIC NOTP()
         DEFINE('NOTP(P)')                                   :(NOTP_END)
*
@

Gimpel's version uses [[*PUSH()]] instead of [[PUSH()]]. I think
that is wrong.  If pattern [[P]] fails, backtracking will go further
"left". That would cause extra [[NULL]]s to be pushed which would
not be [[POP]]ed. Using [[PUSH()]] instead helps.

<<NOTP>>=
NOTP     NOTP = PUSH() P *?(POP() PUSH(1)) FAIL |
+               *IDENT(POP())                                  :(RETURN)
*
NOTP_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'NOTP.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL NOTP
-EJECT
*
************************************************************************
*                                                                      *
*                   #     #  #######  #######  ######                  *
*                   ##    #  #     #     #     #     #                 *
*                   # #   #  #     #     #     #     #                 *
*                   #  #  #  #     #     #     ######                  *
*                   #   # #  #     #     #     #                       *
*                   #    ##  #     #     #     #                       *
*                   #     #  #######     #     #                       *
*                                                                      *
* NOTP                       INVERT PATTERN                            *
*                                                                      *
************************************************************************
*
* NOTP.lss
*
<<NOTP>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "NOTP.lss"
-INCLUDE 'STACK.INC'
-STITL NOTP
-EJECT
-LINE 46 "NOTP.lss"
*
************************************************************************
*                                                                      *
*                   #     #  #######  #######  ######                  *
*                   ##    #  #     #     #     #     #                 *
*                   # #   #  #     #     #     #     #                 *
*                   #  #  #  #     #     #     ######                  *
*                   #   # #  #     #     #     #                       *
*                   #    ##  #     #     #     #                       *
*                   #     #  #######     #     #                       *
*                                                                      *
* NOTP                       INVERT PATTERN                            *
*                                                                      *
************************************************************************
*
* NOTP.lss
*
-LINE 15 "NOTP.lss"
-MODULE NOTP
-PUBLIC NOTP()
         DEFINE('NOTP(P)')                                   :(NOTP_END)
*
-LINE 27 "NOTP.lss"
NOTP     NOTP = PUSH() P *?(POP() PUSH(1)) FAIL |
+               *IDENT(POP())                                  :(RETURN)
*
NOTP_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>NOTP - Invert Pattern</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">NOTP(P)</font> will return a pattern which will match the NULL string if
<font face="Source Code Pro">P</font> fails and fail if <font face="Source Code Pro">P</font> matches. If <font face="Source Code Pro">P</font> aborts, <font face="Source Code Pro">NOTP(P)</font>
will also abort.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="STACK.html">STACK</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;STACK.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;NOTP&raquo;&equiv;</b>
-MODULE NOTP
-PUBLIC NOTP()
         DEFINE(&#39;NOTP(P)&#39;)                                   <b>:(NOTP_END)</b>
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Gimpel's version uses <font face="Source Code Pro">*PUSH()</font> instead of <font face="Source Code Pro">PUSH()</font>. I think
that is wrong.  If pattern <font face="Source Code Pro">P</font> fails, backtracking will go further
"left". That would cause extra <font face="Source Code Pro">NULL</font>s to be pushed which would
not be <font face="Source Code Pro">POP</font>ed. Using <font face="Source Code Pro">PUSH()</font> instead helps.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;NOTP&raquo;&equiv;</b>
NOTP     NOTP = PUSH() P *?(POP() PUSH(1)) FAIL |
+               *IDENT(POP())                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
NOTP_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;NOTP.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL NOTP
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   #     #  #######  #######  ######                  *</i></font>
<font color="#818181"><i>*                   ##    #  #     #     #     #     #                 *</i></font>
<font color="#818181"><i>*                   # #   #  #     #     #     #     #                 *</i></font>
<font color="#818181"><i>*                   #  #  #  #     #     #     ######                  *</i></font>
<font color="#818181"><i>*                   #   # #  #     #     #     #                       *</i></font>
<font color="#818181"><i>*                   #    ##  #     #     #     #                       *</i></font>
<font color="#818181"><i>*                   #     #  #######     #     #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* NOTP                       INVERT PATTERN                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* NOTP.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;NOTP&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:13 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'NOTP.INC'
-LINE 37 "NOTP.lss"
         &CODE = 1
         &CODE = 0
END
<h1>ONCE - Pattern that succeeds once</h1>

[[ONCE()]] returns a pattern that will succeed just once and only
once and thereafter fail forever. [[ONCE()]] is similar to [[FENCE]]
in that it matches the null string initially. Unlike [[FENCE]],
however, failure in subsequent tries is like [[FAIL]], (as opposed to
[[ABORT]]) which permits other alternates to be taken.

<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>

<<INCLUDES>>=
-INCLUDE 'UNIQUE.INC'
@

<<ONCE>>=
-MODULE ONCE
-PUBLIC ONCE()
         DEFINE('ONCE(ID)NAME')                              :(ONCE_END)
ONCE     ONCE = IDENT(ID, NULL)
+               CONVERT('ONCE(' 1 ')', 'EXPRESSION')          :S(RETURN)
         NAME = UNIQUE()
         ONCE = $NAME
         $NAME = FAIL                                          :(RETURN)
ONCE_END
*
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ONCE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL ONCE
-EJECT
*
************************************************************************
*                                                                      *
*                  #######  #     #   #####   #######                  *
*                  #     #  ##    #  #     #  #                        *
*                  #     #  # #   #  #        #                        *
*                  #     #  #  #  #  #        #####                    *
*                  #     #  #   # #  #        #                        *
*                  #     #  #    ##  #     #  #                        *
*                  #######  #     #   #####   #######                  *
*                                                                      *
* ONCE                                                                 *
*                                                                      *
************************************************************************
*
* ONCE.lss
*
<<ONCE>>
*
* CE: .MSNOBOL4;
@
-LINE 13 "ONCE.lss"
-INCLUDE 'UNIQUE.INC'
-STITL ONCE
-EJECT
-LINE 42 "ONCE.lss"
*
************************************************************************
*                                                                      *
*                  #######  #     #   #####   #######                  *
*                  #     #  ##    #  #     #  #                        *
*                  #     #  # #   #  #        #                        *
*                  #     #  #  #  #  #        #####                    *
*                  #     #  #   # #  #        #                        *
*                  #     #  #    ##  #     #  #                        *
*                  #######  #     #   #####   #######                  *
*                                                                      *
* ONCE                                                                 *
*                                                                      *
************************************************************************
*
* ONCE.lss
*
-LINE 17 "ONCE.lss"
-MODULE ONCE
-PUBLIC ONCE()
         DEFINE('ONCE(ID)NAME')                              :(ONCE_END)
ONCE     ONCE = IDENT(ID, NULL)
+               CONVERT('ONCE(' 1 ')', 'EXPRESSION')          :S(RETURN)
         NAME = UNIQUE()
         ONCE = $NAME
         $NAME = FAIL                                          :(RETURN)
ONCE_END
*
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ONCE - Pattern that succeeds once</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ONCE()</font> returns a pattern that will succeed just once and only
once and thereafter fail forever. <font face="Source Code Pro">ONCE()</font> is similar to <font face="Source Code Pro">FENCE</font>
in that it matches the null string initially. Unlike <font face="Source Code Pro">FENCE</font>,
however, failure in subsequent tries is like <font face="Source Code Pro">FAIL</font>, (as opposed to
<font face="Source Code Pro">ABORT</font>) which permits other alternates to be taken.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ONCE&raquo;&equiv;</b>
-MODULE ONCE
-PUBLIC ONCE()
         DEFINE(&#39;ONCE(ID)NAME&#39;)                              <b>:(ONCE_END)</b>
ONCE     ONCE = IDENT(ID, NULL)
+               CONVERT(&#39;ONCE(&#39; 1 &#39;)&#39;, &#39;EXPRESSION&#39;)          <b>:S(RETURN)</b>
         NAME = UNIQUE()
         ONCE = $NAME
         $NAME = FAIL                                          <b>:(RETURN)</b>
ONCE_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ONCE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL ONCE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #######  #     #   #####   #######                  *</i></font>
<font color="#818181"><i>*                  #     #  ##    #  #     #  #                        *</i></font>
<font color="#818181"><i>*                  #     #  # #   #  #        #                        *</i></font>
<font color="#818181"><i>*                  #     #  #  #  #  #        #####                    *</i></font>
<font color="#818181"><i>*                  #     #  #   # #  #        #                        *</i></font>
<font color="#818181"><i>*                  #     #  #    ##  #     #  #                        *</i></font>
<font color="#818181"><i>*                  #######  #     #   #####   #######                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ONCE                                                                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ONCE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ONCE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:14 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ONCE.INC'
-LINE 33 "ONCE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>ORDER - Order characters in string</h1>

[[ORDER(S)]] will put the characters of its argument into alphabetic
order. [[ORDER('DCBA')]] returns [['ABCD']].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<ORDER>>=
-MODULE ORDER
-PUBLIC ORDER()
         DEFINE('ORDER(S)T,HIGHS,S1')                       :(ORDER_END)
*
ORDER    S LEN(1) . T =                                       :F(RETURN)
         &ALPHABET BREAK(T) REM . HIGHS
         ORDER (BREAK(HIGHS) | REM) . S1 = S1 T                 :(ORDER)
*
ORDER_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ORDER.INC'
         &CODE = 1
         IDENT(ORDER('DCBA'), 'ABCD')                            :F(END)
         &CODE = 0
END
@

<<>>=
-STITL ORDER
-EJECT
*
************************************************************************
*                                                                      *
*                #######  ######   ######   #######  ######            *
*                #     #  #     #  #     #  #        #     #           *
*                #     #  #     #  #     #  #        #     #           *
*                #     #  ######   #     #  #####    ######            *
*                #     #  #   #    #     #  #        #   #             *
*                #     #  #    #   #     #  #        #    #            *
*                #######  #     #  ######   #######  #     #           *
*                                                                      *
* ORDER                   ORDER CHARACTERS IN STRING                   *
*                                                                      *
************************************************************************
*
* ORDER.lss
*
<<ORDER>>
*
* CE: .MSNOBOL4;
@
-STITL ORDER
-EJECT
*
-LINE 37 "ORDER.lss"
************************************************************************
*                                                                      *
*                #######  ######   ######   #######  ######            *
*                #     #  #     #  #     #  #        #     #           *
*                #     #  #     #  #     #  #        #     #           *
*                #     #  ######   #     #  #####    ######            *
*                #     #  #   #    #     #  #        #   #             *
*                #     #  #    #   #     #  #        #    #            *
*                #######  #     #  ######   #######  #     #           *
*                                                                      *
* ORDER                   ORDER CHARACTERS IN STRING                   *
*                                                                      *
************************************************************************
*
* ORDER.lss
*
-LINE 12 "ORDER.lss"
-MODULE ORDER
-PUBLIC ORDER()
         DEFINE('ORDER(S)T,HIGHS,S1')                       :(ORDER_END)
*
ORDER    S LEN(1) . T =                                       :F(RETURN)
         &ALPHABET BREAK(T) REM . HIGHS
         ORDER (BREAK(HIGHS) | REM) . S1 = S1 T                 :(ORDER)
*
ORDER_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ORDER - Order characters in string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ORDER(S)</font> will put the characters of its argument into alphabetic
order. <font face="Source Code Pro">ORDER('DCBA')</font> returns <font face="Source Code Pro">'ABCD'</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ORDER&raquo;&equiv;</b>
-MODULE ORDER
-PUBLIC ORDER()
         DEFINE(&#39;ORDER(S)T,HIGHS,S1&#39;)                       <b>:(ORDER_END)</b>
<font color="#818181"><i>*</i></font>
ORDER    S LEN(1) . T =                                       <b>:F(RETURN)</b>
         &amp;ALPHABET BREAK(T) REM . HIGHS
         ORDER (BREAK(HIGHS) | REM) . S1 = S1 T                 <b>:(ORDER)</b>
<font color="#818181"><i>*</i></font>
ORDER_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ORDER.INC&#39;
         &amp;CODE = 1
         IDENT(ORDER(&#39;DCBA&#39;), &#39;ABCD&#39;)                            <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL ORDER
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                #######  ######   ######   #######  ######            *</i></font>
<font color="#818181"><i>*                #     #  #     #  #     #  #        #     #           *</i></font>
<font color="#818181"><i>*                #     #  #     #  #     #  #        #     #           *</i></font>
<font color="#818181"><i>*                #     #  ######   #     #  #####    ######            *</i></font>
<font color="#818181"><i>*                #     #  #   #    #     #  #        #   #             *</i></font>
<font color="#818181"><i>*                #     #  #    #   #     #  #        #    #            *</i></font>
<font color="#818181"><i>*                #######  #     #  ######   #######  #     #           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ORDER                   ORDER CHARACTERS IN STRING                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ORDER.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ORDER&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:14 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ORDER.INC'
-LINE 27 "ORDER.lss"
         &CODE = 1
         IDENT(ORDER('DCBA'), 'ABCD')                            :F(END)
         &CODE = 0
END
<h1>P64 - Pointer Utilities</h1>

Pointer utilities Includes peek and poke of various types (_p = pointer,
_c = char, _s = short, _i = int, _f = float, _d = double, _ld = long
double). Note that long long is excluded.

Defines interface to malloc(), free(), strdup() and strlen().

[[INCLUDE]]s used while building p64.so are:

<a href="CRACK.html">CRACK</a><br>
<a href="DYNAMIC.html">DYNAMIC</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="WRAPPER.html">WRAPPER</a>

<h2>Uses</h2>

<<INCLUDES>>=
@

<<P64>>=
-MODULE P64
-CASE 1
@

<<P64>>=
-SNOBOL TERMINAL = 'P64 (SUN NOV 10 03:57:08 EST 2013)'
-SNOBOL SLOAD('CRACK.INC')
-SNOBOL SLOAD('DYNAMIC.INC')
-SNOBOL SLOAD('SEQ.INC')
-SNOBOL SLOAD('WRAPPER.INC')
@

Build [[p64.c]] so we can produce our shared library.

<<P64>>=
-EMBED C 'p64'
@

<<P64,TYPE=C>>=
-SNOBOL WRAPPER_STARTFILE(.EMBED)

#include <stdlib.h>
#include <string.h>

static long peek_p(long p) { return (long)*(void **)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_P(LONG)LONG', .EMBED)

static long peek_c(long p) { return *(char *)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_C(LONG)INTEGER', .EMBED)

static long peek_s(long p) { return *(short *)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_S(LONG)INTEGER', .EMBED)

static long peek_i(long p) { return *(int *)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_I(LONG)INTEGER', .EMBED)

static double peek_d(long p) { return *(double *)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_D(LONG)REAL', .EMBED)

static double peek_f(long p) { return *(float *)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_F(LONG)REAL', .EMBED)

static double peek_ld(long p) { return *(long double *)p; }

-SNOBOL C_WRAPPER_PROTO('PEEK_LD(LONG)REAL', .EMBED)

static void poke_p(long p, long v) { *(void **)p = (void *)v; }

-SNOBOL C_WRAPPER_PROTO('POKE_P(LONG,LONG)', .EMBED)

static void poke_c(long p, int c) { *(char *)p = (char)c; }

-SNOBOL C_WRAPPER_PROTO('POKE_C(LONG,INTEGER)', .EMBED)

static void poke_s(long p, int s) { *(short *)p = (short)s; }

-SNOBOL C_WRAPPER_PROTO('POKE_S(LONG,INTEGER)', .EMBED)

static void poke_i(long p, int i) { *(int *)p = (int)i; }

-SNOBOL C_WRAPPER_PROTO('POKE_I(LONG,INTEGER)', .EMBED)

static void poke_d(long p, double v) { *(double *)p = v; }

-SNOBOL C_WRAPPER_PROTO('POKE_D(LONG,REAL)', .EMBED)

static void poke_f(long p, double v) { *(float *)p = v; }

-SNOBOL C_WRAPPER_PROTO('POKE_F(LONG,REAL)', .EMBED)

static void poke_ld(long p, double v) { *(long double *)p = v; }

-SNOBOL C_WRAPPER_PROTO('POKE_LD(LONG,REAL)', .EMBED)

static long malloc_(int n) { return (long)malloc(n); }

-SNOBOL C_WRAPPER_PROTO('MALLOC_(INTEGER)LONG', .EMBED)

static void free_(long p) { free((void *)p); }

-SNOBOL C_WRAPPER_PROTO('FREE_(LONG)', .EMBED)

static long strdup_(char *s) { return (long)strdup(s); }

-SNOBOL C_WRAPPER_PROTO('STRDUP_(STRING)LONG', .EMBED)

static long strlen_(long p) { return strlen((char *)p); }

-SNOBOL C_WRAPPER_PROTO('STRLEN_(LONG)INTEGER', .EMBED)

-END
@

Build [[p64.so]] shared library.

<<P64>>=
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(p64) :F(ERROR) ;
-SNOBOL OBJECTS = p64; OBJECTS '.c' = '.o'
-SNOBOL LINK_DYNAMIC('./p64', OBJECTS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS p64.so
-CMNT -SNOBOL A = CRACK(p64 ' ' OBJECTS, ' ')
-CMNT -SNOBOL SEQ(' DELETE(A<K>) ', .K)
@

<<P64>>=
-PUBLIC PEEK_P(), PEEK_C(), PEEK_S(), PEEK_I(), PEEK_D(), PEEK_F()
-PUBLIC PEEK_LD()
-PUBLIC POKE_P(), POKE_C(), POKE_S(), POKE_I(), POKE_D(), POKE_F()
-PUBLIC POKE_LD() 
*
         LOAD('PEEK_P(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_C(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_S(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_I(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_D(INTEGER)REAL', 'p64.so')
         LOAD('PEEK_F(INTEGER)REAL', 'p64.so')
         LOAD('PEEK_LD(INTEGER)REAL', 'p64.so')
         LOAD('POKE_P(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_C(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_S(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_I(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_D(INTEGER,REAL)', 'p64.so')
         LOAD('POKE_F(INTEGER,REAL)', 'p64.so')
         LOAD('POKE_LD(INTEGER,REAL)', 'p64.so')
         LOAD('MALLOC_(INTEGER)INTEGER', 'p64.so')
         LOAD('FREE_(INTEGER)', 'p64.so')
         LOAD('STRDUP_(STRING)INTEGER', 'p64.so')
         LOAD('STRLEN_(INTEGER)INTEGER', 'p64.so')
*
@

Define the actual API for the P64 module.

<<P64>>=
-PUBLIC MALLOC(), FREE(), STRDUP(), STRLEN()
         DEFINE('MALLOC(N)')
         DEFINE('FREE(P)')
         DEFINE('STRDUP(S)')
         DEFINE('STRLEN(P)')                                  :(P64_END)
*
MALLOC   MALLOC = MALLOC_(N)                                   :(RETURN)
*
FREE     FREE_(P)                                              :(RETURN)
*
STRDUP   STRDUP = STRDUP_(S)                                   :(RETURN)
*
STRLEN   STRLEN = STRLEN_(P)                                   :(RETURN)
*
P64_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'P64.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL P64
-EJECT
*
************************************************************************
*                                                                      *
*                       ######    ###   #   #                          *
*                       #     #  #   #  #   #                          *
*                       #     #  #      #   #                          *
*                       ######   ####   #####                          *
*                       #        #   #      #                          *
*                       #        #   #      #                          *
*                       #         ###       #                          *
*                                                                      *
* P64                    POINTER UTILITIES                             *
*                                                                      *
************************************************************************
*
* P64.lss
*
<<P64>>
*
* CE: .F.MSNOBOL4;
@
-STITL P64
-EJECT
*
-LINE 195 "P64.lss"
************************************************************************
*                                                                      *
*                       ######    ###   #   #                          *
*                       #     #  #   #  #   #                          *
*                       #     #  #      #   #                          *
*                       ######   ####   #####                          *
*                       #        #   #      #                          *
*                       #        #   #      #                          *
*                       #         ###       #                          *
*                                                                      *
* P64                    POINTER UTILITIES                             *
*                                                                      *
************************************************************************
*
* P64.lss
*
-LINE 22 "P64.lss"
-MODULE P64
-CASE 1
-LINE 27 "P64.lss"
-LINE 28 "P64.lss"
-LINE 29 "P64.lss"
-LINE 30 "P64.lss"
-LINE 31 "P64.lss"
-LINE 32 "P64.lss"
-LINE 37 "P64.lss"
         p64 = 'p64.c'
-LINE 124 "P64.lss"
-LINE 125 "P64.lss"
-LINE 126 "P64.lss"
-LINE 127 "P64.lss"
-LINE 128 "P64.lss"
-LINE 136 "P64.lss"
-PUBLIC PEEK_P(), PEEK_C(), PEEK_S(), PEEK_I(), PEEK_D(), PEEK_F()
-PUBLIC PEEK_LD()
-PUBLIC POKE_P(), POKE_C(), POKE_S(), POKE_I(), POKE_D(), POKE_F()
-PUBLIC POKE_LD()
*
         LOAD('PEEK_P(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_C(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_S(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_I(INTEGER)INTEGER', 'p64.so')
         LOAD('PEEK_D(INTEGER)REAL', 'p64.so')
         LOAD('PEEK_F(INTEGER)REAL', 'p64.so')
         LOAD('PEEK_LD(INTEGER)REAL', 'p64.so')
         LOAD('POKE_P(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_C(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_S(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_I(INTEGER,INTEGER)', 'p64.so')
         LOAD('POKE_D(INTEGER,REAL)', 'p64.so')
         LOAD('POKE_F(INTEGER,REAL)', 'p64.so')
         LOAD('POKE_LD(INTEGER,REAL)', 'p64.so')
         LOAD('MALLOC_(INTEGER)INTEGER', 'p64.so')
         LOAD('FREE_(INTEGER)', 'p64.so')
         LOAD('STRDUP_(STRING)INTEGER', 'p64.so')
         LOAD('STRLEN_(INTEGER)INTEGER', 'p64.so')
*
-LINE 165 "P64.lss"
-PUBLIC MALLOC(), FREE(), STRDUP(), STRLEN()
         DEFINE('MALLOC(N)')
         DEFINE('FREE(P)')
         DEFINE('STRDUP(S)')
         DEFINE('STRLEN(P)')                                  :(P64_END)
*
MALLOC   MALLOC = MALLOC_(N)                                   :(RETURN)
*
FREE     FREE_(P)                                              :(RETURN)
*
STRDUP   STRDUP = STRDUP_(S)                                   :(RETURN)
*
STRLEN   STRLEN = STRLEN_(P)                                   :(RETURN)
*
P64_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>P64 - Pointer Utilities</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Pointer utilities Includes peek and poke of various types (_p = pointer,
_c = char, _s = short, _i = int, _f = float, _d = double, _ld = long
double). Note that long long is excluded.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Defines interface to malloc(), free(), strdup() and strlen().
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">INCLUDE</font>s used while building p64.so are:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<a href="CRACK.html">CRACK</a><br>
<a href="DYNAMIC.html">DYNAMIC</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="WRAPPER.html">WRAPPER</a>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64&raquo;&equiv;</b>
-MODULE P64
-CASE 1
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64&raquo;&equiv;</b>
-SNOBOL TERMINAL = &#39;P64 (SUN NOV 10 03:57:08 EST 2013)&#39;
-SNOBOL SLOAD(&#39;CRACK.INC&#39;)
-SNOBOL SLOAD(&#39;DYNAMIC.INC&#39;)
-SNOBOL SLOAD(&#39;SEQ.INC&#39;)
-SNOBOL SLOAD(&#39;WRAPPER.INC&#39;)
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Build <font face="Source Code Pro">p64.c</font> so we can produce our shared library.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64&raquo;&equiv;</b>
-EMBED C &#39;p64&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64,TYPE=C&raquo;&equiv;</b>
-SNOBOL WRAPPER_STARTFILE(.EMBED)

<font color="#818181"><i>#include &lt;stdlib.h&gt;</i></font>
<font color="#818181"><i>#include &lt;string.h&gt;</i></font>

static long peek_p(long p) { return (long)*(void **)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_P(LONG)LONG&#39;, .EMBED)

static long peek_c(long p) { return *(char *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_C(LONG)INTEGER&#39;, .EMBED)

static long peek_s(long p) { return *(short *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_S(LONG)INTEGER&#39;, .EMBED)

static long peek_i(long p) { return *(int *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_I(LONG)INTEGER&#39;, .EMBED)

static double peek_d(long p) { return *(double *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_D(LONG)REAL&#39;, .EMBED)

static double peek_f(long p) { return *(float *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_F(LONG)REAL&#39;, .EMBED)

static double peek_ld(long p) { return *(long double *)p; }

-SNOBOL C_WRAPPER_PROTO(&#39;PEEK_LD(LONG)REAL&#39;, .EMBED)

static void poke_p(long p, long v) { *(void **)p = (void *)v; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_P(LONG,LONG)&#39;, .EMBED)

static void poke_c(long p, int c) { *(char *)p = (char)c; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_C(LONG,INTEGER)&#39;, .EMBED)

static void poke_s(long p, int s) { *(short *)p = (short)s; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_S(LONG,INTEGER)&#39;, .EMBED)

static void poke_i(long p, int i) { *(int *)p = (int)i; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_I(LONG,INTEGER)&#39;, .EMBED)

static void poke_d(long p, double v) { *(double *)p = v; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_D(LONG,REAL)&#39;, .EMBED)

static void poke_f(long p, double v) { *(float *)p = v; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_F(LONG,REAL)&#39;, .EMBED)

static void poke_ld(long p, double v) { *(long double *)p = v; }

-SNOBOL C_WRAPPER_PROTO(&#39;POKE_LD(LONG,REAL)&#39;, .EMBED)

static long malloc_(int n) { return (long)malloc(n); }

-SNOBOL C_WRAPPER_PROTO(&#39;MALLOC_(INTEGER)LONG&#39;, .EMBED)

static void free_(long p) { free((void *)p); }

-SNOBOL C_WRAPPER_PROTO(&#39;FREE_(LONG)&#39;, .EMBED)

static long strdup_(char *s) { return (long)strdup(s); }

-SNOBOL C_WRAPPER_PROTO(&#39;STRDUP_(STRING)LONG&#39;, .EMBED)

static long strlen_(long p) { return strlen((char *)p); }

-SNOBOL C_WRAPPER_PROTO(&#39;STRLEN_(LONG)INTEGER&#39;, .EMBED)

-END
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Build <font face="Source Code Pro">p64.so</font> shared library.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64&raquo;&equiv;</b>
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(p64) :F(ERROR) ;
-SNOBOL OBJECTS = p64; OBJECTS &#39;.c&#39; = &#39;.o&#39;
-SNOBOL LINK_DYNAMIC(&#39;./p64&#39;, OBJECTS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON&#39;T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS p64.so
-CMNT -SNOBOL A = CRACK(p64 &#39; &#39; OBJECTS, &#39; &#39;)
-CMNT -SNOBOL SEQ(&#39; DELETE(A&lt;K&gt;) &#39;, .K)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64&raquo;&equiv;</b>
-PUBLIC PEEK_P(), PEEK_C(), PEEK_S(), PEEK_I(), PEEK_D(), PEEK_F()
-PUBLIC PEEK_LD()
-PUBLIC POKE_P(), POKE_C(), POKE_S(), POKE_I(), POKE_D(), POKE_F()
-PUBLIC POKE_LD()
<font color="#818181"><i>*</i></font>
         LOAD(&#39;PEEK_P(INTEGER)INTEGER&#39;, &#39;p64.so&#39;)
         LOAD(&#39;PEEK_C(INTEGER)INTEGER&#39;, &#39;p64.so&#39;)
         LOAD(&#39;PEEK_S(INTEGER)INTEGER&#39;, &#39;p64.so&#39;)
         LOAD(&#39;PEEK_I(INTEGER)INTEGER&#39;, &#39;p64.so&#39;)
         LOAD(&#39;PEEK_D(INTEGER)REAL&#39;, &#39;p64.so&#39;)
         LOAD(&#39;PEEK_F(INTEGER)REAL&#39;, &#39;p64.so&#39;)
         LOAD(&#39;PEEK_LD(INTEGER)REAL&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_P(INTEGER,INTEGER)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_C(INTEGER,INTEGER)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_S(INTEGER,INTEGER)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_I(INTEGER,INTEGER)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_D(INTEGER,REAL)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_F(INTEGER,REAL)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;POKE_LD(INTEGER,REAL)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;MALLOC_(INTEGER)INTEGER&#39;, &#39;p64.so&#39;)
         LOAD(&#39;FREE_(INTEGER)&#39;, &#39;p64.so&#39;)
         LOAD(&#39;STRDUP_(STRING)INTEGER&#39;, &#39;p64.so&#39;)
         LOAD(&#39;STRLEN_(INTEGER)INTEGER&#39;, &#39;p64.so&#39;)
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
Define the actual API for the P64 module.
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;P64&raquo;&equiv;</b>
-PUBLIC MALLOC(), FREE(), STRDUP(), STRLEN()
         DEFINE(&#39;MALLOC(N)&#39;)
         DEFINE(&#39;FREE(P)&#39;)
         DEFINE(&#39;STRDUP(S)&#39;)
         DEFINE(&#39;STRLEN(P)&#39;)                                  <b>:(P64_END)</b>
<font color="#818181"><i>*</i></font>
MALLOC   MALLOC = MALLOC_(N)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FREE     FREE_(P)                                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
STRDUP   STRDUP = STRDUP_(S)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
STRLEN   STRLEN = STRLEN_(P)                                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
P64_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;P64.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL P64
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                       ######    ###   #   #                          *</i></font>
<font color="#818181"><i>*                       #     #  #   #  #   #                          *</i></font>
<font color="#818181"><i>*                       #     #  #      #   #                          *</i></font>
<font color="#818181"><i>*                       ######   ####   #####                          *</i></font>
<font color="#818181"><i>*                       #        #   #      #                          *</i></font>
<font color="#818181"><i>*                       #        #   #      #                          *</i></font>
<font color="#818181"><i>*                       #         ###       #                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* P64                    POINTER UTILITIES                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* P64.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;P64&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Sun Jun  8 17:21:50 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'P64.INC'
-LINE 186 "P64.lss"
         &CODE = 1
         &CODE = 0
END
<h1>PSQL - Interface to PostgreSQL</h1>

Interface to PostgreSQL. Uses <i>psql</i>. This is a crude
implementation because we want to be able to quickly modify the
API. [[SELECT]] results should be directly compatible with HTML
templating.  This is a thin layer on top of <i>psql</i>.

[[PSQL = SEND(PSQL_CLASS,'NEW')]] creates a new PSQL object.

[[SEND(PSQL,'OPEN')]] opens the connection to PSQL.  [[PIPE =
SEND(PSQL,'GET_PIPE')]] returns a pipe that can be written to with
[[$PIPE = 'sql statement;']].  After a command is written to the
pipe, [[SEND(PSQL,'OUTPUT')]] gathers the results and removes the
command echo. Results can be processed by function [[PSQL_RESULT()]]
which returns an [[ARRAY]] of [[TABLE]]s or [[NULL]] if no results
are available.  If there are no result rows, message 'OUTPUT' will
return [[NULL]].

If command output is not needed, [[SEND(PSQL,'DISCARD')]] can be
used. Either message 'OUTPUT' or 'DISCARD' must be used after a
command is issued, because data from <i>psql</i> must be read, and
we have to wait for the next prompt. Multiple line commands can be
issued. The command will be executed on receiving the [[;]]
command delimiter, or at the end of the line for [[\]] commands
(for example, to establish a different database or user).

A [[TABLE]] can be passed to [[PSQL_INSERT()]] which will convert it
to [[(NAME,...) VALUES (VALUE,...)]] ready to be combined into an SQL
[[INSERT]] statement.

Function [[PSQL_INSERT()]] uses [[PSQL_ESCAPE()]] to escape and
quote SQL strings.  [[PSQL_INSERT()]] can also be used to display
the contents of a [[PSQL TABLE]].

[[SEND(PSQL,'CLOSE')]] closes the connection to <i>psql</i>.

{{
It would be useful to catch the error, so we should probably use
[[PSQL_OUTPUT()]] from [[PSQL_OPEN()]]. Not being done now, and
will probably never be done because this should use a socket level
interface.
}}

[[&ERRLIMIT]] is used to prevent error code 11 if (for example), the
PostgreSQL server is not running. If the server is not running, output
is sent back from the first result of reading [[PSQL_PIPE]] with the
error message (in [[PSQL_DISCARD]]). We throw the error message away.
After the error message, the next read causes an error because the
psql process is no longer running. Setting [[&ERRLIMIT]] converts
the error into a failure, which is propagated back to [[PSQL_OPEN()]]
and the calling program.

<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="COUNT.html">COUNT</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SCOOP.html">SCOOP</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>

<h2>See Also</h2>
<a href="HASH.html">HASH</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="BQ.html">BQ</a>

<<INCLUDES>>=
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'COUNT.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'UNIQUE.INC'
@

We use a [[PTY]] to communicate with <i>psql</i>. This shouldn't be
necessary, a simple bi-directional pipe should be sufficient. The
protocol is to allow the caller to write to the pipe. The final
thing written should activate the command. If a pipe is used for
communication, when the 'DISCARD' or 'OUTPUT' message is sent, an
echo command is used to generate a marker for the end of input.

If a [[PTY]] is used, the marker is generated by modifying the
<i>psql</i> prompts ([[PROMPT1]] and [[PROMPT2]]). Command echo has
to be stripped in the [[PSQL_OUTPUT()]] function as well.

{{
If pipes are used, this PSQL implementation fails with [[errno = 29]]
([[ESPIPE]], seek on pipe).  The interpreter was modified to display
errno in these cases. I suspect that this has to do with process
timing. Using the [[PTY]] appears reliable.
}}

For performance reasons using [[PTY]] may not be a desirable
solution. CSNOBOL4 now uses [[FFI]] to allow access to [[io_getfp()]]
which returns the [[FILE *]] (C library file pointer) associated with
a unit. Also [[fileno()]] is published which returns the underlying
[[fd]] (file descriptor) for a [[FILE *]]. These can be used to
generate alternate I/O routines later.

Pipes work, but the best solution would be to use a socket level
interface to PostgreSQL.

Performance is 500 to 1,000 SQL statements per second on my netbook
(1.6Ghz Atom) and 1,000 to 3,000 statements per second (1.4Ghz Intel
i3).  This is far from stellar. SQL commands are always parsed since
the interface is via the <i>psql</i> utility. A direct socket interface
would be helpful, but this current interface should be sufficient
for the near term. The <i>psql</i> process is started and can be left
open for a long duration (for the entire application execution).

<<PSQL>>=
-MODULE PSQL
%SET (USE_PTY,1)
*
* THESE THREE ARE FUNCTIONS -- SIMPLY EASIER THAT WAY.
*
-PUBLIC PSQL_INSERT(), PSQL_RESULT(), PSQL_ESCAPE()
         DEFINE('PSQL_INSERT(T)N,V,I')
         DEFINE('PSQL_RESULT(S)I,N,R,T,KEY,DAT')
         DEFINE('PSQL_ESCAPE(S)')
*
* CREATE CLASS PSQL_CLASS AND POPULATE ITS METHODS
*
-PUBLIC CLASS:PSQL_CLASS
         PSQL_CLASS = SEND(CLASS, 'NEW_CLASS', 'PSQL_CLASS')
         DEFINE('PSQL_OPEN()L')
-PUBLIC PSQL_CLASS:'OPEN'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'OPEN', 'PSQL_OPEN')
         DEFINE('PSQL_CLOSE()PID')
-PUBLIC PSQL_CLASS:'CLOSE'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'CLOSE', 'PSQL_CLOSE')
-PUBLIC PSQL_CLASS:'GET_PIPE'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'GET_PIPE', CODE(
+           ' SEND = |.PIPE :(RETURN)'))
         DEFINE('PSQL_DISCARD()L')
-PUBLIC PSQL_CLASS:'DISCARD'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'DISCARD', 'PSQL_DISCARD')
         DEFINE('PSQL_OUTPUT()L')
-PUBLIC PSQL_CLASS:'OUTPUT'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'OUTPUT', 'PSQL_OUTPUT')
*
                                                             :(PSQL_END)
*
* CONVERT TABLE TO "(NAME, ...) VALUES (DATA, ...)" READY FOR SQL
* INSERT. USES PSQL_ESCAPE() TO ENSURE THAT VALUES ARE QUOTED CORRECTLY.
*
PSQL_INSERT
         T = CONVERT(T, 'ARRAY')
         SEQ(' N = N T<I, 1> ", "; '
+            ' V = V PSQL_ESCAPE(T<I, 2>) ", " ', .I)
         IDENT(N)                                            :S(FRETURN)
         N ', ' RPOS(0) =
         V ', ' RPOS(0) =
         PSQL_INSERT = '(' N ') VALUES (' V ')'                :(RETURN)
*
* CONVERT PSQL_OUTPUT() INTO ARRAY OF TABLES
*
PSQL_RESULT
         IDENT(S)                                            :S(FRETURN)
         S = S CHARS_NL
         N = COUNT(S, CHARS_NL CHARS_NL)
         EQ(N)                                               :S(FRETURN)
         PSQL_RESULT = ARRAY(N)
PSQL5    S POS(0) ARB . T CHARS_NL CHARS_NL REM . S           :F(RETURN)
         R = TABLE()
PSQL6    T POS(0) BREAK('|') . KEY '|'
+          BRKREM(CHARS_NL) . DAT (CHARS_NL | RPOS(0)) =       :F(PSQL7)
         R<KEY> = DAT                                           :(PSQL6)
PSQL7    I = I + 1
         PSQL_RESULT<I> = R                                     :(PSQL5)
*
* ESCAPE AND QUOTE AN SQL STRING
*
PSQL_ESCAPE
         PSQL_ESCAPE = "'" REPL(S, "'", "''") "'"              :(RETURN)
*
* DISCARD OUTPUT FROM LAST SQL COMMAND.
*
PSQL_DISCARD
%IF (USE_PTY)
         L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                  :S(RETURN)F(PSQL_DISCARD)
%ELSE
         $|.PIPE = '\echo *'                                 :F(FRETURN)
PSQL_D2  L = $|.PIPE
         L POS(0) '*' RPOS(0)                       :S(RETURN)F(PSQL_D2)
%ENDIF
*
* GATHER AND RETURN OUTPUT FROM SQL COMMAND. DISCARD COMMAND ECHO,
* RETURNING ONLY RESULTS.
*
PSQL_OUTPUT
%IF (USE_PTY)
PSQL2    L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                                  :S(PSQL3)
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
PSQL3    PSQL_OUTPUT CHARS_NL CHARS_NL RPOS(0) = CHARS_NL      :S(PSQL3)
PSQL4    PSQL_OUTPUT BREAK(CHARS_NL) CHARS_NL REM . PSQL_OUTPUT
+                                                            :F(FRETURN)
         PSQL_OUTPUT POS(0) '# '                      :S(PSQL4)F(RETURN)
%ELSE
         $|.PIPE = '\echo *'                                 :F(FRETURN)
PSQL2    L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                                 :S(RETURN)
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
%ENDIF
*
* OPEN PSQL COMMAND. SEND COMMANDS TO MAKE PSQL_OUTPUT() EASIER,
* PSQL_RESULT() FOR PARSING SELECT RESULTS AND BUILDING RESULT ARRAYS.
*
PSQL_OPEN
         |.UNIT = IO_FINDUNIT()                              :F(FRETURN)
         |.PIPE = UNIQUE()
%IF (USE_PTY)
         INPUT(|.PIPE, |.UNIT, 'U', '||/usr/bin/psql -q')    :F(FRETURN)
%ELSE
         INPUT(|.PIPE, |.UNIT, 'U', '|/usr/bin/psql -q')     :F(FRETURN)
%ENDIF
         OUTPUT(|.PIPE, |.UNIT)                              :F(FRETURN)
%IF (USE_PTY)
         $|.PIPE = "\set PROMPT1 '\n*\n'"                    :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\set PROMPT2 '# '"                       :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
%ENDIF
         $|.PIPE = "\pset pager off"                         :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\a"                                      :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\x on"                                   :F(FRETURN)
         SELF('DISCARD')                            :F(FRETURN)S(RETURN)
*
* CLOSE PSQL
*
PSQL_CLOSE
         $|.PIPE = '\q'                                      :F(FRETURN)
         ENDFILE(|.UNIT)                                     :F(FRETURN)
         DETACH(|.PIPE)                                      :F(FRETURN)
*
* ENDFILE() CLOSES PSQL. INDEED, WE SEND A QUIT COMMAND (\q) FIRST!
* BUT... THE CLOSE CODE IN THE INTERPRETER DOES NOT REAP THE ZOMBIE.
* WAIT() IS DEFINED IN CSNOBOL4, USE WAIT() TO REAP. THIS IS WRONG,
* WE MAY REAP THE WRONG PROCESS! SHOULD FIX THIS IN IO.C - THE CODE
* IS IN IO.C, BUT ISN'T WORKING (?)
*
         PID = WAIT()                               :S(RETURN)F(FRETURN)
*
PSQL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIMER.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'DDT.INC'
*        DDT()
         &CODE = 1
*
* CREATE THE PSQL OBJECT
*
         PSQL = SEND(PSQL_CLASS, 'NEW')
*
* OPEN THE PSQL CONNECTION. NOTE THE &ERRLIMIT SETTING TO PREVENT
* PROBLEMS IF THE POSTGRESQL SERVER CANNOT BE REACHED.
*
         &ERRLIMIT = 1
         SEND(PSQL, 'OPEN')
*
* GET THE PIPE NAME CONNECTING TO PSQL
*
         P = SEND(PSQL, 'GET_PIPE')
*
* A SIMPLE PSQL COMMAND
*
         $P = "SELECT version();"                                :F(END)
         OUTPUT = SEND(PSQL, 'OUTPUT')                           :F(END)
*
* ANOTHER COMMAND
*
         $P = "SELECT 1 + 1;"                                    :F(END)
         OUTPUT = SEND(PSQL, 'OUTPUT')                           :F(END)
*
* CREATE THE WEATHER TABLE. DROP IT FIRST IN CASE IT EXISTS
*
         $P = "DROP TABLE weather;"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
         $P = "CREATE TABLE weather ("
         $P = "  city    VARCHAR(80),"
         $P = "  temp_lo INT,         -- low temperature"
         $P = "  temp_hi INT,         -- high temperature"
         $P = "  prcp    REAL,        -- precipitation"
         $P = "  date    DATE"
         $P = ");"
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* INSERT TWO ROWS INTO THE WEATHER TABLE
*
         $P = "INSERT INTO weather"                              :F(END)
         $P = PSQL_INSERT(
+           #("city=San Francisco,temp_lo=46,temp_hi=50,prcp=0.25,"
+           "date=1994-11-27")) ";"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
         $P = "INSERT INTO weather"                              :F(END)
         $P = PSQL_INSERT(
+           #"city=Hayward,temp_lo=37,temp_hi=55,date=1994-11-29")
+           ";"                                                  :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* SELECT FROM WEATHER TABLE, FOR A CITY THAT DOESN'T EXIST. WE EXPECT
* NO RESULTS FROM THIS
*
         $P = "SELECT * FROM weather"                            :F(END)
         $P = "WHERE city = 'xx';"                               :F(END)
         S = SEND(PSQL, 'OUTPUT')                                :F(END)
         IDENT(S)                                                :F(END)
*
* SELECT EVERYTHING FROM TABLE WEATHER. WE EXPECT TWO ROWS. NOTE THE
* USE OF PSQL_INSERT() TO FORMAT A ROW FOR DEBUG DISPLAY
*
         $P = "SELECT * FROM weather;"                           :F(END)
         R = PSQL_RESULT(SEND(PSQL, 'OUTPUT'))                   :F(END)
         EQ(PROTOTYPE(R), 2)                                     :F(END)
         OUTPUT = PSQL_INSERT(R<1>)                              :F(END)
         OUTPUT = PSQL_INSERT(R<2>)                              :F(END)
*
* USE 'AS' TO NAME A RESULT COLUMNS. RETRIEVE THE RESULT AND DISPLAY
*
         $P = 'SELECT 1 + 1 AS result;'                          :F(END)
         T = PSQL_RESULT(SEND(PSQL, 'OUTPUT'))                   :F(END)
         EQ(T<1><'result'>, 2)                                   :F(END)
         OUTPUT = T<1><'result'>
*
* SOME TIMING
*
* TIME SIMPLE SELECT AND RESULT ANALYSIS
*
         TIMER(" $P = 'SELECT 1 + 1 AS result;'; "
+              " T = PSQL_RESULT(SEND(PSQL, 'OUTPUT')) ")
*
* A SIMPLE SELECT, DISCARDING RESULTS
*
         TIMER(" $P = 'SELECT 1 + 1 AS result;'; "
+              " SEND(PSQL, 'DISCARD') ")
*
* A TABLE SELECT, AND RESULT ANALYSIS
*
         TIMER(" $P = 'SELECT * FROM weather;'; "
+              " R = PSQL_RESULT(SEND(PSQL, 'OUTPUT')) ")
*
* A TABLE SELECT, DISCARDING RESULTS
*
         TIMER(" $P = 'SELECT * FROM weather;'; "
+              " SEND(PSQL, 'DISCARD') ")
*
* DROP THE WEATHER TABLE
*
         $P = "DROP TABLE weather;"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* CLOSE PSQL, FREEING THE PIPE AND UNIT
*
         SEND(PSQL, 'CLOSE')                                     :F(END)
*
* SEE IF WE HAVE ANY ZOMBIES
*
         OUTPUT = BQ('ps ax | grep " Z "')
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL PSQL
-EJECT
*
************************************************************************
*                                                                      *
*                  ######    #####    #####   #                        *
*                  #     #  #     #  #     #  #                        *
*                  #     #  #        #     #  #                        *
*                  ######    #####   #     #  #                        *
*                  #              #  #   # #  #                        *
*                  #        #     #  #    #   #                        *
*                  #         #####    #### #  #######                  *
*                                                                      *
* PSQL                 INTERFACE TO POSTGRESQL                         *
*                                                                      *
************************************************************************
*
* PSQL.lss
*
<<PSQL>>
*
* CE: .F.MSNOBOL4;
@
-LINE 69 "PSQL.lss"
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'COUNT.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'UNIQUE.INC'
-STITL PSQL
-EJECT
-LINE 382 "PSQL.lss"
*
************************************************************************
*                                                                      *
*                  ######    #####    #####   #                        *
*                  #     #  #     #  #     #  #                        *
*                  #     #  #        #     #  #                        *
*                  ######    #####   #     #  #                        *
*                  #              #  #   # #  #                        *
*                  #        #     #  #    #   #                        *
*                  #         #####    #### #  #######                  *
*                                                                      *
* PSQL                 INTERFACE TO POSTGRESQL                         *
*                                                                      *
************************************************************************
*
* PSQL.lss
*
-LINE 116 "PSQL.lss"
-MODULE PSQL
*
* THESE THREE ARE FUNCTIONS -- SIMPLY EASIER THAT WAY.
*
-PUBLIC PSQL_INSERT(), PSQL_RESULT(), PSQL_ESCAPE()
         DEFINE('PSQL_INSERT(T)N,V,I')
         DEFINE('PSQL_RESULT(S)I,N,R,T,KEY,DAT')
         DEFINE('PSQL_ESCAPE(S)')
*
* CREATE CLASS PSQL_CLASS AND POPULATE ITS METHODS
*
-PUBLIC CLASS:PSQL_CLASS
         PSQL_CLASS = SEND(CLASS, 'NEW_CLASS', 'PSQL_CLASS')
         DEFINE('PSQL_OPEN()L')
-PUBLIC PSQL_CLASS:'OPEN'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'OPEN', 'PSQL_OPEN')
         DEFINE('PSQL_CLOSE()PID')
-PUBLIC PSQL_CLASS:'CLOSE'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'CLOSE', 'PSQL_CLOSE')
-PUBLIC PSQL_CLASS:'GET_PIPE'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'GET_PIPE', CODE(
+           ' SEND = |.PIPE :(RETURN)'))
         DEFINE('PSQL_DISCARD()L')
-PUBLIC PSQL_CLASS:'DISCARD'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'DISCARD', 'PSQL_DISCARD')
         DEFINE('PSQL_OUTPUT()L')
-PUBLIC PSQL_CLASS:'OUTPUT'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'OUTPUT', 'PSQL_OUTPUT')
*
                                                             :(PSQL_END)
*
* CONVERT TABLE TO "(NAME, ...) VALUES (DATA, ...)" READY FOR SQL
* INSERT. USES PSQL_ESCAPE() TO ENSURE THAT VALUES ARE QUOTED CORRECTLY.
*
PSQL_INSERT
         T = CONVERT(T, 'ARRAY')
         SEQ(' N = N T<I, 1> ", "; '
+            ' V = V PSQL_ESCAPE(T<I, 2>) ", " ', .I)
         IDENT(N)                                            :S(FRETURN)
         N ', ' RPOS(0) =
         V ', ' RPOS(0) =
         PSQL_INSERT = '(' N ') VALUES (' V ')'                :(RETURN)
*
* CONVERT PSQL_OUTPUT() INTO ARRAY OF TABLES
*
PSQL_RESULT
         IDENT(S)                                            :S(FRETURN)
         S = S CHARS_NL
         N = COUNT(S, CHARS_NL CHARS_NL)
         EQ(N)                                               :S(FRETURN)
         PSQL_RESULT = ARRAY(N)
PSQL5    S POS(0) ARB . T CHARS_NL CHARS_NL REM . S           :F(RETURN)
         R = TABLE()
PSQL6    T POS(0) BREAK('|') . KEY '|'
+          BRKREM(CHARS_NL) . DAT (CHARS_NL | RPOS(0)) =       :F(PSQL7)
         R<KEY> = DAT                                           :(PSQL6)
PSQL7    I = I + 1
         PSQL_RESULT<I> = R                                     :(PSQL5)
*
* ESCAPE AND QUOTE AN SQL STRING
*
PSQL_ESCAPE
         PSQL_ESCAPE = "'" REPL(S, "'", "''") "'"              :(RETURN)
*
* DISCARD OUTPUT FROM LAST SQL COMMAND.
*
PSQL_DISCARD
         L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                  :S(RETURN)F(PSQL_DISCARD)
*
* GATHER AND RETURN OUTPUT FROM SQL COMMAND. DISCARD COMMAND ECHO,
* RETURNING ONLY RESULTS.
*
PSQL_OUTPUT
PSQL2    L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                                  :S(PSQL3)
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
PSQL3    PSQL_OUTPUT CHARS_NL CHARS_NL RPOS(0) = CHARS_NL      :S(PSQL3)
PSQL4    PSQL_OUTPUT BREAK(CHARS_NL) CHARS_NL REM . PSQL_OUTPUT
+                                                            :F(FRETURN)
         PSQL_OUTPUT POS(0) '# '                      :S(PSQL4)F(RETURN)
*
* OPEN PSQL COMMAND. SEND COMMANDS TO MAKE PSQL_OUTPUT() EASIER,
* PSQL_RESULT() FOR PARSING SELECT RESULTS AND BUILDING RESULT ARRAYS.
*
PSQL_OPEN
         |.UNIT = IO_FINDUNIT()                              :F(FRETURN)
         |.PIPE = UNIQUE()
         INPUT(|.PIPE, |.UNIT, 'U', '||/usr/bin/psql -q')    :F(FRETURN)
         OUTPUT(|.PIPE, |.UNIT)                              :F(FRETURN)
         $|.PIPE = "\set PROMPT1 '\n*\n'"                    :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\set PROMPT2 '# '"                       :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\pset pager off"                         :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\a"                                      :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\x on"                                   :F(FRETURN)
         SELF('DISCARD')                            :F(FRETURN)S(RETURN)
*
* CLOSE PSQL
*
PSQL_CLOSE
         $|.PIPE = '\q'                                      :F(FRETURN)
         ENDFILE(|.UNIT)                                     :F(FRETURN)
         DETACH(|.PIPE)                                      :F(FRETURN)
*
* ENDFILE() CLOSES PSQL. INDEED, WE SEND A QUIT COMMAND (\q) FIRST!
* BUT... THE CLOSE CODE IN THE INTERPRETER DOES NOT REAP THE ZOMBIE.
* WAIT() IS DEFINED IN CSNOBOL4, USE WAIT() TO REAP. THIS IS WRONG,
* WE MAY REAP THE WRONG PROCESS! SHOULD FIX THIS IN IO.C - THE CODE
* IS IN IO.C, BUT ISN'T WORKING (?)
*
         PID = WAIT()                               :S(RETURN)F(FRETURN)
*
PSQL_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>PSQL - Interface to PostgreSQL</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Interface to PostgreSQL. Uses <i>psql</i>. This is a crude
implementation because we want to be able to quickly modify the
API. <font face="Source Code Pro">SELECT</font> results should be directly compatible with HTML
templating.  This is a thin layer on top of <i>psql</i>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">PSQL = SEND(PSQL_CLASS,'NEW')</font> creates a new PSQL object.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SEND(PSQL,'OPEN')</font> opens the connection to PSQL.  </font></p><pre><font face="Source Code Pro">PIPE =
SEND(PSQL,'GET_PIPE')</font></pre> returns a pipe that can be written to with
<font face="Source Code Pro">$PIPE = 'sql statement;'</font>.  After a command is written to the
pipe, <font face="Source Code Pro">SEND(PSQL,'OUTPUT')</font> gathers the results and removes the
command echo. Results can be processed by function <font face="Source Code Pro">PSQL_RESULT()</font>
which returns an <font face="Source Code Pro">ARRAY</font> of <font face="Source Code Pro">TABLE</font>s or <font face="Source Code Pro">NULL</font> if no results
are available.  If there are no result rows, message 'OUTPUT' will
return <font face="Source Code Pro">NULL</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If command output is not needed, <font face="Source Code Pro">SEND(PSQL,'DISCARD')</font> can be
used. Either message 'OUTPUT' or 'DISCARD' must be used after a
command is issued, because data from <i>psql</i> must be read, and
we have to wait for the next prompt. Multiple line commands can be
issued. The command will be executed on receiving the <font face="Source Code Pro">;</font>
command delimiter, or at the end of the line for <font face="Source Code Pro">\</font> commands
(for example, to establish a different database or user).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
A <font face="Source Code Pro">TABLE</font> can be passed to <font face="Source Code Pro">PSQL_INSERT()</font> which will convert it
to <font face="Source Code Pro">(NAME,...) VALUES (VALUE,...)</font> ready to be combined into an SQL
<font face="Source Code Pro">INSERT</font> statement.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Function <font face="Source Code Pro">PSQL_INSERT()</font> uses <font face="Source Code Pro">PSQL_ESCAPE()</font> to escape and
quote SQL strings.  <font face="Source Code Pro">PSQL_INSERT()</font> can also be used to display
the contents of a <font face="Source Code Pro">PSQL TABLE</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SEND(PSQL,'CLOSE')</font> closes the connection to <i>psql</i>.
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
It would be useful to catch the error, so we should probably use
<font face="Source Code Pro">PSQL_OUTPUT()</font> from <font face="Source Code Pro">PSQL_OPEN()</font>. Not being done now, and
will probably never be done because this should use a socket level
interface.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">&ERRLIMIT</font> is used to prevent error code 11 if (for example), the
PostgreSQL server is not running. If the server is not running, output
is sent back from the first result of reading <font face="Source Code Pro">PSQL_PIPE</font> with the
error message (in <font face="Source Code Pro">PSQL_DISCARD</font>). We throw the error message away.
After the error message, the next read causes an error because the
psql process is no longer running. Setting <font face="Source Code Pro">&ERRLIMIT</font> converts
the error into a failure, which is propagated back to <font face="Source Code Pro">PSQL_OPEN()</font>
and the calling program.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="COUNT.html">COUNT</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SCOOP.html">SCOOP</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="HASH.html">HASH</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="BQ.html">BQ</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BRKREM.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;COUNT.INC&#39;
-INCLUDE &#39;CSNOBOL4.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
-INCLUDE &#39;SCOOP.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<p align="justify"><font face="Sorts Mill Goudy">
We use a <font face="Source Code Pro">PTY</font> to communicate with <i>psql</i>. This shouldn't be
necessary, a simple bi-directional pipe should be sufficient. The
protocol is to allow the caller to write to the pipe. The final
thing written should activate the command. If a pipe is used for
communication, when the 'DISCARD' or 'OUTPUT' message is sent, an
echo command is used to generate a marker for the end of input.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If a <font face="Source Code Pro">PTY</font> is used, the marker is generated by modifying the
<i>psql</i> prompts (<font face="Source Code Pro">PROMPT1</font> and <font face="Source Code Pro">PROMPT2</font>). Command echo has
to be stripped in the <font face="Source Code Pro">PSQL_OUTPUT()</font> function as well.
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
If pipes are used, this PSQL implementation fails with <font face="Source Code Pro">errno = 29</font>
(<font face="Source Code Pro">ESPIPE</font>, seek on pipe).  The interpreter was modified to display
errno in these cases. I suspect that this has to do with process
timing. Using the <font face="Source Code Pro">PTY</font> appears reliable.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
For performance reasons using <font face="Source Code Pro">PTY</font> may not be a desirable
solution. CSNOBOL4 now uses <font face="Source Code Pro">FFI</font> to allow access to <font face="Source Code Pro">io_getfp()</font>
which returns the <font face="Source Code Pro">FILE *</font> (C library file pointer) associated with
a unit. Also <font face="Source Code Pro">fileno()</font> is published which returns the underlying
<font face="Source Code Pro">fd</font> (file descriptor) for a <font face="Source Code Pro">FILE *</font>. These can be used to
generate alternate I/O routines later.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Pipes work, but the best solution would be to use a socket level
interface to PostgreSQL.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Performance is 500 to 1,000 SQL statements per second on my netbook
(1.6Ghz Atom) and 1,000 to 3,000 statements per second (1.4Ghz Intel
i3).  This is far from stellar. SQL commands are always parsed since
the interface is via the <i>psql</i> utility. A direct socket interface
would be helpful, but this current interface should be sufficient
for the near term. The <i>psql</i> process is started and can be left
open for a long duration (for the entire application execution).
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;PSQL&raquo;&equiv;</b>
-MODULE PSQL
%SET (USE_PTY,1)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THESE THREE ARE FUNCTIONS -- SIMPLY EASIER THAT WAY.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC PSQL_INSERT(), PSQL_RESULT(), PSQL_ESCAPE()
         DEFINE(&#39;PSQL_INSERT(T)N,V,I&#39;)
         DEFINE(&#39;PSQL_RESULT(S)I,N,R,T,KEY,DAT&#39;)
         DEFINE(&#39;PSQL_ESCAPE(S)&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE CLASS PSQL_CLASS AND POPULATE ITS METHODS</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC CLASS:PSQL_CLASS
         PSQL_CLASS = SEND(CLASS, &#39;NEW_CLASS&#39;, &#39;PSQL_CLASS&#39;)
         DEFINE(&#39;PSQL_OPEN()L&#39;)
-PUBLIC PSQL_CLASS:&#39;OPEN&#39;
         SEND(PSQL_CLASS, &#39;ADD_METHOD&#39;, &#39;OPEN&#39;, &#39;PSQL_OPEN&#39;)
         DEFINE(&#39;PSQL_CLOSE()PID&#39;)
-PUBLIC PSQL_CLASS:&#39;CLOSE&#39;
         SEND(PSQL_CLASS, &#39;ADD_METHOD&#39;, &#39;CLOSE&#39;, &#39;PSQL_CLOSE&#39;)
-PUBLIC PSQL_CLASS:&#39;GET_PIPE&#39;
         SEND(PSQL_CLASS, &#39;ADD_METHOD&#39;, &#39;GET_PIPE&#39;, CODE(
+           &#39; SEND = |.PIPE :(RETURN)&#39;))
         DEFINE(&#39;PSQL_DISCARD()L&#39;)
-PUBLIC PSQL_CLASS:&#39;DISCARD&#39;
         SEND(PSQL_CLASS, &#39;ADD_METHOD&#39;, &#39;DISCARD&#39;, &#39;PSQL_DISCARD&#39;)
         DEFINE(&#39;PSQL_OUTPUT()L&#39;)
-PUBLIC PSQL_CLASS:&#39;OUTPUT&#39;
         SEND(PSQL_CLASS, &#39;ADD_METHOD&#39;, &#39;OUTPUT&#39;, &#39;PSQL_OUTPUT&#39;)
<font color="#818181"><i>*</i></font>
                                                             <b>:(PSQL_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONVERT TABLE TO &quot;(NAME, ...) VALUES (DATA, ...)&quot; READY FOR SQL</i></font>
<font color="#818181"><i>* INSERT. USES PSQL_ESCAPE() TO ENSURE THAT VALUES ARE QUOTED CORRECTLY.</i></font>
<font color="#818181"><i>*</i></font>
PSQL_INSERT
         T = CONVERT(T, &#39;ARRAY&#39;)
         SEQ(&#39; N = N T&lt;I, 1&gt; &quot;, &quot;; &#39;
+            &#39; V = V PSQL_ESCAPE(T&lt;I, 2&gt;) &quot;, &quot; &#39;, .I)
         IDENT(N)                                            <b>:S(FRETURN)</b>
         N &#39;, &#39; RPOS(0) =
         V &#39;, &#39; RPOS(0) =
         PSQL_INSERT = &#39;(&#39; N &#39;) VALUES (&#39; V &#39;)&#39;                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CONVERT PSQL_OUTPUT() INTO ARRAY OF TABLES</i></font>
<font color="#818181"><i>*</i></font>
PSQL_RESULT
         IDENT(S)                                            <b>:S(FRETURN)</b>
         S = S CHARS_NL
         N = COUNT(S, CHARS_NL CHARS_NL)
         EQ(N)                                               <b>:S(FRETURN)</b>
         PSQL_RESULT = ARRAY(N)
PSQL5    S POS(0) ARB . T CHARS_NL CHARS_NL REM . S           <b>:F(RETURN)</b>
         R = TABLE()
PSQL6    T POS(0) BREAK(&#39;|&#39;) . KEY &#39;|&#39;
+          BRKREM(CHARS_NL) . DAT (CHARS_NL | RPOS(0)) =       <b>:F(PSQL7)</b>
         R&lt;KEY&gt; = DAT                                           <b>:(PSQL6)</b>
PSQL7    I = I + 1
         PSQL_RESULT&lt;I&gt; = R                                     <b>:(PSQL5)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ESCAPE AND QUOTE AN SQL STRING</i></font>
<font color="#818181"><i>*</i></font>
PSQL_ESCAPE
         PSQL_ESCAPE = &quot;&#39;&quot; REPL(S, &quot;&#39;&quot;, &quot;&#39;&#39;&quot;) &quot;&#39;&quot;              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISCARD OUTPUT FROM LAST SQL COMMAND.</i></font>
<font color="#818181"><i>*</i></font>
PSQL_DISCARD
%IF (USE_PTY)
         L = $|.PIPE                                         <b>:F(FRETURN)</b>
         L POS(0) &#39;*&#39; RPOS(0)                  <b>:S(RETURN)F(PSQL_DISCARD)</b>
%ELSE
         $|.PIPE = &#39;\echo *&#39;                                 <b>:F(FRETURN)</b>
PSQL_D2  L = $|.PIPE
         L POS(0) &#39;*&#39; RPOS(0)                       <b>:S(RETURN)F(PSQL_D2)</b>
%ENDIF
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GATHER AND RETURN OUTPUT FROM SQL COMMAND. DISCARD COMMAND ECHO,</i></font>
<font color="#818181"><i>* RETURNING ONLY RESULTS.</i></font>
<font color="#818181"><i>*</i></font>
PSQL_OUTPUT
%IF (USE_PTY)
PSQL2    L = $|.PIPE                                         <b>:F(FRETURN)</b>
         L POS(0) &#39;*&#39; RPOS(0)                                  <b>:S(PSQL3)</b>
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   <b>:(PSQL2)</b>
PSQL3    PSQL_OUTPUT CHARS_NL CHARS_NL RPOS(0) = CHARS_NL      <b>:S(PSQL3)</b>
PSQL4    PSQL_OUTPUT BREAK(CHARS_NL) CHARS_NL REM . PSQL_OUTPUT
+                                                            <b>:F(FRETURN)</b>
         PSQL_OUTPUT POS(0) &#39;# &#39;                      <b>:S(PSQL4)F(RETURN)</b>
%ELSE
         $|.PIPE = &#39;\echo *&#39;                                 <b>:F(FRETURN)</b>
PSQL2    L = $|.PIPE                                         <b>:F(FRETURN)</b>
         L POS(0) &#39;*&#39; RPOS(0)                                 <b>:S(RETURN)</b>
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   <b>:(PSQL2)</b>
%ENDIF
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OPEN PSQL COMMAND. SEND COMMANDS TO MAKE PSQL_OUTPUT() EASIER,</i></font>
<font color="#818181"><i>* PSQL_RESULT() FOR PARSING SELECT RESULTS AND BUILDING RESULT ARRAYS.</i></font>
<font color="#818181"><i>*</i></font>
PSQL_OPEN
         |.UNIT = IO_FINDUNIT()                              <b>:F(FRETURN)</b>
         |.PIPE = UNIQUE()
%IF (USE_PTY)
         INPUT(|.PIPE, |.UNIT, &#39;U&#39;, &#39;||/usr/bin/psql -q&#39;)    <b>:F(FRETURN)</b>
%ELSE
         INPUT(|.PIPE, |.UNIT, &#39;U&#39;, &#39;|/usr/bin/psql -q&#39;)     <b>:F(FRETURN)</b>
%ENDIF
         OUTPUT(|.PIPE, |.UNIT)                              <b>:F(FRETURN)</b>
%IF (USE_PTY)
         $|.PIPE = &quot;\set PROMPT1 &#39;\n*\n&#39;&quot;                    <b>:F(FRETURN)</b>
         SELF(&#39;DISCARD&#39;)                                     <b>:F(FRETURN)</b>
         $|.PIPE = &quot;\set PROMPT2 &#39;# &#39;&quot;                       <b>:F(FRETURN)</b>
         SELF(&#39;DISCARD&#39;)                                     <b>:F(FRETURN)</b>
%ENDIF
         $|.PIPE = &quot;\pset pager off&quot;                         <b>:F(FRETURN)</b>
         SELF(&#39;DISCARD&#39;)                                     <b>:F(FRETURN)</b>
         $|.PIPE = &quot;\a&quot;                                      <b>:F(FRETURN)</b>
         SELF(&#39;DISCARD&#39;)                                     <b>:F(FRETURN)</b>
         $|.PIPE = &quot;\x on&quot;                                   <b>:F(FRETURN)</b>
         SELF(&#39;DISCARD&#39;)                            <b>:F(FRETURN)S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CLOSE PSQL</i></font>
<font color="#818181"><i>*</i></font>
PSQL_CLOSE
         $|.PIPE = &#39;\q&#39;                                      <b>:F(FRETURN)</b>
         ENDFILE(|.UNIT)                                     <b>:F(FRETURN)</b>
         DETACH(|.PIPE)                                      <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ENDFILE() CLOSES PSQL. INDEED, WE SEND A QUIT COMMAND (\q) FIRST!</i></font>
<font color="#818181"><i>* BUT... THE CLOSE CODE IN THE INTERPRETER DOES NOT REAP THE ZOMBIE.</i></font>
<font color="#818181"><i>* WAIT() IS DEFINED IN CSNOBOL4, USE WAIT() TO REAP. THIS IS WRONG,</i></font>
<font color="#818181"><i>* WE MAY REAP THE WRONG PROCESS! SHOULD FIX THIS IN IO.C - THE CODE</i></font>
<font color="#818181"><i>* IS IN IO.C, BUT ISN&#39;T WORKING (?)</i></font>
<font color="#818181"><i>*</i></font>
         PID = WAIT()                               <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
PSQL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TIMER.INC&#39;
-INCLUDE &#39;PSQL.INC&#39;
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;DDT.INC&#39;
<font color="#818181"><i>*        DDT()</i></font>
         &amp;CODE = 1
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE THE PSQL OBJECT</i></font>
<font color="#818181"><i>*</i></font>
         PSQL = SEND(PSQL_CLASS, &#39;NEW&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OPEN THE PSQL CONNECTION. NOTE THE &amp;ERRLIMIT SETTING TO PREVENT</i></font>
<font color="#818181"><i>* PROBLEMS IF THE POSTGRESQL SERVER CANNOT BE REACHED.</i></font>
<font color="#818181"><i>*</i></font>
         &amp;ERRLIMIT = 1
         SEND(PSQL, &#39;OPEN&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* GET THE PIPE NAME CONNECTING TO PSQL</i></font>
<font color="#818181"><i>*</i></font>
         P = SEND(PSQL, &#39;GET_PIPE&#39;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A SIMPLE PSQL COMMAND</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;SELECT version();&quot;                                <b>:F(END)</b>
         OUTPUT = SEND(PSQL, &#39;OUTPUT&#39;)                           <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ANOTHER COMMAND</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;SELECT 1 + 1;&quot;                                    <b>:F(END)</b>
         OUTPUT = SEND(PSQL, &#39;OUTPUT&#39;)                           <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE THE WEATHER TABLE. DROP IT FIRST IN CASE IT EXISTS</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;DROP TABLE weather;&quot;                              <b>:F(END)</b>
         SEND(PSQL, &#39;DISCARD&#39;)                                   <b>:F(END)</b>
         $P = &quot;CREATE TABLE weather (&quot;
         $P = &quot;  city    VARCHAR(80),&quot;
         $P = &quot;  temp_lo INT,         -- low temperature&quot;
         $P = &quot;  temp_hi INT,         -- high temperature&quot;
         $P = &quot;  prcp    REAL,        -- precipitation&quot;
         $P = &quot;  date    DATE&quot;
         $P = &quot;);&quot;
         SEND(PSQL, &#39;DISCARD&#39;)                                   <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INSERT TWO ROWS INTO THE WEATHER TABLE</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;INSERT INTO weather&quot;                              <b>:F(END)</b>
         $P = PSQL_INSERT(
+           #(&quot;city=San Francisco,temp_lo=46,temp_hi=50,prcp=0.25,&quot;
+           &quot;date=1994-11-27&quot;)) &quot;;&quot;                              <b>:F(END)</b>
         SEND(PSQL, &#39;DISCARD&#39;)                                   <b>:F(END)</b>
         $P = &quot;INSERT INTO weather&quot;                              <b>:F(END)</b>
         $P = PSQL_INSERT(
+           #&quot;city=Hayward,temp_lo=37,temp_hi=55,date=1994-11-29&quot;)
+           &quot;;&quot;                                                  <b>:F(END)</b>
         SEND(PSQL, &#39;DISCARD&#39;)                                   <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SELECT FROM WEATHER TABLE, FOR A CITY THAT DOESN&#39;T EXIST. WE EXPECT</i></font>
<font color="#818181"><i>* NO RESULTS FROM THIS</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;SELECT * FROM weather&quot;                            <b>:F(END)</b>
         $P = &quot;WHERE city = &#39;xx&#39;;&quot;                               <b>:F(END)</b>
         S = SEND(PSQL, &#39;OUTPUT&#39;)                                <b>:F(END)</b>
         IDENT(S)                                                <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SELECT EVERYTHING FROM TABLE WEATHER. WE EXPECT TWO ROWS. NOTE THE</i></font>
<font color="#818181"><i>* USE OF PSQL_INSERT() TO FORMAT A ROW FOR DEBUG DISPLAY</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;SELECT * FROM weather;&quot;                           <b>:F(END)</b>
         R = PSQL_RESULT(SEND(PSQL, &#39;OUTPUT&#39;))                   <b>:F(END)</b>
         EQ(PROTOTYPE(R), 2)                                     <b>:F(END)</b>
         OUTPUT = PSQL_INSERT(R&lt;1&gt;)                              <b>:F(END)</b>
         OUTPUT = PSQL_INSERT(R&lt;2&gt;)                              <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* USE &#39;AS&#39; TO NAME A RESULT COLUMNS. RETRIEVE THE RESULT AND DISPLAY</i></font>
<font color="#818181"><i>*</i></font>
         $P = &#39;SELECT 1 + 1 AS result;&#39;                          <b>:F(END)</b>
         T = PSQL_RESULT(SEND(PSQL, &#39;OUTPUT&#39;))                   <b>:F(END)</b>
         EQ(T&lt;1&gt;&lt;&#39;result&#39;&gt;, 2)                                   <b>:F(END)</b>
         OUTPUT = T&lt;1&gt;&lt;&#39;result&#39;&gt;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SOME TIMING</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIME SIMPLE SELECT AND RESULT ANALYSIS</i></font>
<font color="#818181"><i>*</i></font>
         TIMER(&quot; $P = &#39;SELECT 1 + 1 AS result;&#39;; &quot;
+              &quot; T = PSQL_RESULT(SEND(PSQL, &#39;OUTPUT&#39;)) &quot;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A SIMPLE SELECT, DISCARDING RESULTS</i></font>
<font color="#818181"><i>*</i></font>
         TIMER(&quot; $P = &#39;SELECT 1 + 1 AS result;&#39;; &quot;
+              &quot; SEND(PSQL, &#39;DISCARD&#39;) &quot;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A TABLE SELECT, AND RESULT ANALYSIS</i></font>
<font color="#818181"><i>*</i></font>
         TIMER(&quot; $P = &#39;SELECT * FROM weather;&#39;; &quot;
+              &quot; R = PSQL_RESULT(SEND(PSQL, &#39;OUTPUT&#39;)) &quot;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* A TABLE SELECT, DISCARDING RESULTS</i></font>
<font color="#818181"><i>*</i></font>
         TIMER(&quot; $P = &#39;SELECT * FROM weather;&#39;; &quot;
+              &quot; SEND(PSQL, &#39;DISCARD&#39;) &quot;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DROP THE WEATHER TABLE</i></font>
<font color="#818181"><i>*</i></font>
         $P = &quot;DROP TABLE weather;&quot;                              <b>:F(END)</b>
         SEND(PSQL, &#39;DISCARD&#39;)                                   <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CLOSE PSQL, FREEING THE PIPE AND UNIT</i></font>
<font color="#818181"><i>*</i></font>
         SEND(PSQL, &#39;CLOSE&#39;)                                     <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SEE IF WE HAVE ANY ZOMBIES</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = BQ(&#39;ps ax | grep &quot; Z &quot;&#39;)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL PSQL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  ######    #####    #####   #                        *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #     #  #                        *</i></font>
<font color="#818181"><i>*                  #     #  #        #     #  #                        *</i></font>
<font color="#818181"><i>*                  ######    #####   #     #  #                        *</i></font>
<font color="#818181"><i>*                  #              #  #   # #  #                        *</i></font>
<font color="#818181"><i>*                  #        #     #  #    #   #                        *</i></font>
<font color="#818181"><i>*                  #         #####    #### #  #######                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PSQL                 INTERFACE TO POSTGRESQL                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PSQL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;PSQL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:36 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIMER.INC'
-LINE 259 "PSQL.lss"
-INCLUDE 'PSQL.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'DDT.INC'
*        DDT()
         &CODE = 1
*
* CREATE THE PSQL OBJECT
*
         PSQL = SEND(PSQL_CLASS, 'NEW')
*
* OPEN THE PSQL CONNECTION. NOTE THE &ERRLIMIT SETTING TO PREVENT
* PROBLEMS IF THE POSTGRESQL SERVER CANNOT BE REACHED.
*
         &ERRLIMIT = 1
         SEND(PSQL, 'OPEN')
*
* GET THE PIPE NAME CONNECTING TO PSQL
*
         P = SEND(PSQL, 'GET_PIPE')
*
* A SIMPLE PSQL COMMAND
*
         $P = "SELECT version();"                                :F(END)
         OUTPUT = SEND(PSQL, 'OUTPUT')                           :F(END)
*
* ANOTHER COMMAND
*
         $P = "SELECT 1 + 1;"                                    :F(END)
         OUTPUT = SEND(PSQL, 'OUTPUT')                           :F(END)
*
* CREATE THE WEATHER TABLE. DROP IT FIRST IN CASE IT EXISTS
*
         $P = "DROP TABLE weather;"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
         $P = "CREATE TABLE weather ("
         $P = "  city    VARCHAR(80),"
         $P = "  temp_lo INT,         -- low temperature"
         $P = "  temp_hi INT,         -- high temperature"
         $P = "  prcp    REAL,        -- precipitation"
         $P = "  date    DATE"
         $P = ");"
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* INSERT TWO ROWS INTO THE WEATHER TABLE
*
         $P = "INSERT INTO weather"                              :F(END)
         $P = PSQL_INSERT(
+           #("city=San Francisco,temp_lo=46,temp_hi=50,prcp=0.25,"
+           "date=1994-11-27")) ";"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
         $P = "INSERT INTO weather"                              :F(END)
         $P = PSQL_INSERT(
+           #"city=Hayward,temp_lo=37,temp_hi=55,date=1994-11-29")
+           ";"                                                  :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* SELECT FROM WEATHER TABLE, FOR A CITY THAT DOESN'T EXIST. WE EXPECT
* NO RESULTS FROM THIS
*
         $P = "SELECT * FROM weather"                            :F(END)
         $P = "WHERE city = 'xx';"                               :F(END)
         S = SEND(PSQL, 'OUTPUT')                                :F(END)
         IDENT(S)                                                :F(END)
*
* SELECT EVERYTHING FROM TABLE WEATHER. WE EXPECT TWO ROWS. NOTE THE
* USE OF PSQL_INSERT() TO FORMAT A ROW FOR DEBUG DISPLAY
*
         $P = "SELECT * FROM weather;"                           :F(END)
         R = PSQL_RESULT(SEND(PSQL, 'OUTPUT'))                   :F(END)
         EQ(PROTOTYPE(R), 2)                                     :F(END)
         OUTPUT = PSQL_INSERT(R<1>)                              :F(END)
         OUTPUT = PSQL_INSERT(R<2>)                              :F(END)
*
* USE 'AS' TO NAME A RESULT COLUMNS. RETRIEVE THE RESULT AND DISPLAY
*
         $P = 'SELECT 1 + 1 AS result;'                          :F(END)
         T = PSQL_RESULT(SEND(PSQL, 'OUTPUT'))                   :F(END)
         EQ(T<1><'result'>, 2)                                   :F(END)
         OUTPUT = T<1><'result'>
*
* SOME TIMING
*
* TIME SIMPLE SELECT AND RESULT ANALYSIS
*
         TIMER(" $P = 'SELECT 1 + 1 AS result;'; "
+              " T = PSQL_RESULT(SEND(PSQL, 'OUTPUT')) ")
*
* A SIMPLE SELECT, DISCARDING RESULTS
*
         TIMER(" $P = 'SELECT 1 + 1 AS result;'; "
+              " SEND(PSQL, 'DISCARD') ")
*
* A TABLE SELECT, AND RESULT ANALYSIS
*
         TIMER(" $P = 'SELECT * FROM weather;'; "
+              " R = PSQL_RESULT(SEND(PSQL, 'OUTPUT')) ")
*
* A TABLE SELECT, DISCARDING RESULTS
*
         TIMER(" $P = 'SELECT * FROM weather;'; "
+              " SEND(PSQL, 'DISCARD') ")
*
* DROP THE WEATHER TABLE
*
         $P = "DROP TABLE weather;"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* CLOSE PSQL, FREEING THE PIPE AND UNIT
*
         SEND(PSQL, 'CLOSE')                                     :F(END)
*
* SEE IF WE HAVE ANY ZOMBIES
*
         OUTPUT = BQ('ps ax | grep " Z "')
         &CODE = 0
END
<h1>QUOTE - Quote a string</h1>

[[QUOTE(S)]] will convert its argument to a string which will resemble
a SNOBOL4 expression which, when evaluated, will yield the original
string [[S]].

<h2>Uses</h2>
<a href="REPL.html">REPL</a><br>

<<INCLUDES>>=
-INCLUDE 'REPL.INC'
@

<<QUOTE>>=
-MODULE QUOTE
-PUBLIC QUOTE()
         DEFINE('QUOTE(S)Q,QQ')                             :(QUOTE_END)
*
QUOTE    Q = "'"; QQ = '"'
         QUOTE = Q REPL(S, Q, Q ' ' QQ Q QQ ' ' Q) Q           :(RETURN)
*
QUOTE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'QUOTE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL QUOTE
-EJECT
*
************************************************************************
*                                                                      *
*               #####   #     #  #######  #######  #######             *
*              #     #  #     #  #     #     #     #                   *
*              #     #  #     #  #     #     #     #                   *
*              #     #  #     #  #     #     #     #####               *
*              #   # #  #     #  #     #     #     #                   *
*              #    #   #     #  #     #     #     #                   *
*               #### #   #####   #######     #     #######             *
*                                                                      *
* QUOTE                      QUOTE A STRING                            *
*                                                                      *
************************************************************************
*
* QUOTE.lss
*
<<QUOTE>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "QUOTE.lss"
-INCLUDE 'REPL.INC'
-STITL QUOTE
-EJECT
-LINE 38 "QUOTE.lss"
*
************************************************************************
*                                                                      *
*               #####   #     #  #######  #######  #######             *
*              #     #  #     #  #     #     #     #                   *
*              #     #  #     #  #     #     #     #                   *
*              #     #  #     #  #     #     #     #####               *
*              #   # #  #     #  #     #     #     #                   *
*              #    #   #     #  #     #     #     #                   *
*               #### #   #####   #######     #     #######             *
*                                                                      *
* QUOTE                      QUOTE A STRING                            *
*                                                                      *
************************************************************************
*
* QUOTE.lss
*
-LINE 15 "QUOTE.lss"
-MODULE QUOTE
-PUBLIC QUOTE()
         DEFINE('QUOTE(S)Q,QQ')                             :(QUOTE_END)
*
QUOTE    Q = "'"; QQ = '"'
         QUOTE = Q REPL(S, Q, Q ' ' QQ Q QQ ' ' Q) Q           :(RETURN)
*
QUOTE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>QUOTE - Quote a string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">QUOTE(S)</font> will convert its argument to a string which will resemble
a SNOBOL4 expression which, when evaluated, will yield the original
string <font face="Source Code Pro">S</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="REPL.html">REPL</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;REPL.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;QUOTE&raquo;&equiv;</b>
-MODULE QUOTE
-PUBLIC QUOTE()
         DEFINE(&#39;QUOTE(S)Q,QQ&#39;)                             <b>:(QUOTE_END)</b>
<font color="#818181"><i>*</i></font>
QUOTE    Q = &quot;&#39;&quot;; QQ = &#39;&quot;&#39;
         QUOTE = Q REPL(S, Q, Q &#39; &#39; QQ Q QQ &#39; &#39; Q) Q           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
QUOTE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;QUOTE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL QUOTE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #####   #     #  #######  #######  #######             *</i></font>
<font color="#818181"><i>*              #     #  #     #  #     #     #     #                   *</i></font>
<font color="#818181"><i>*              #     #  #     #  #     #     #     #                   *</i></font>
<font color="#818181"><i>*              #     #  #     #  #     #     #     #####               *</i></font>
<font color="#818181"><i>*              #   # #  #     #  #     #     #     #                   *</i></font>
<font color="#818181"><i>*              #    #   #     #  #     #     #     #                   *</i></font>
<font color="#818181"><i>*               #### #   #####   #######     #     #######             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* QUOTE                      QUOTE A STRING                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* QUOTE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;QUOTE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:16 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'QUOTE.INC'
-LINE 29 "QUOTE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>RANDOM - Random number functions</h1>

Random number functions. [[RANDOMI(N)]] generates random numbers
from 1 to n. If an empty argument is supplied, 0 to 1 (real).

<h2>Uses</h2>

<<INCLUDES>>=
@

<<RANDOM>>=
-MODULE RANDOM
-PUBLIC RANDOM(), SRANDOM(), SRANDOMDEV() RANDOMI()
         LOAD('RANDOM()INTEGER')
         LOAD('SRANDOM(INTEGER)STRING')
         LOAD('SRANDOMDEV()STRING')
         DEFINE('RANDOMI(N)')                              :(RANDOM_END)
*
* RANDOM() RETURNS INTEGER 0 .. 2 ** 31 - 1
* RETURN 1 .. N
*
RANDOMI  RANDOMI = RANDOM()
         RANDOMI = RANDOMI / 2147483647.0
         RANDOMI = NE(N, 0) CONVERT(RANDOMI * N, 'INTEGER') + 1
                                                               :(RETURN)
RANDOM_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'RANDOM.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL RANDOM
-EJECT
*
************************************************************************
*                                                                      *
*         ######      #     #     #  ######   #######  #     #         *
*         #     #    # #    ##    #  #     #  #     #  ##   ##         *
*         #     #   #   #   # #   #  #     #  #     #  # # # #         *
*         ######   #     #  #  #  #  #     #  #     #  #  #  #         *
*         #   #    #######  #   # #  #     #  #     #  #     #         *
*         #    #   #     #  #    ##  #     #  #     #  #     #         *
*         #     #  #     #  #     #  ######   #######  #     #         *
*                                                                      *
* RANDOM                 RANDOM NUMBER FUNCTIONS                       *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 4, 2011                                                      *
*                                                                      *
************************************************************************
*
* RANDOM.lss
*
<<RANDOM>>
*
* CE: .MSNOBOL4;
@
-STITL RANDOM
-EJECT
*
-LINE 42 "RANDOM.lss"
************************************************************************
*                                                                      *
*         ######      #     #     #  ######   #######  #     #         *
*         #     #    # #    ##    #  #     #  #     #  ##   ##         *
*         #     #   #   #   # #   #  #     #  #     #  # # # #         *
*         ######   #     #  #  #  #  #     #  #     #  #  #  #         *
*         #   #    #######  #   # #  #     #  #     #  #     #         *
*         #    #   #     #  #    ##  #     #  #     #  #     #         *
*         #     #  #     #  #     #  ######   #######  #     #         *
*                                                                      *
* RANDOM                 RANDOM NUMBER FUNCTIONS                       *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 4, 2011                                                      *
*                                                                      *
************************************************************************
*
* RANDOM.lss
*
-LINE 12 "RANDOM.lss"
-MODULE RANDOM
-PUBLIC RANDOM(), SRANDOM(), SRANDOMDEV() RANDOMI()
         LOAD('RANDOM()INTEGER')
         LOAD('SRANDOM(INTEGER)STRING')
         LOAD('SRANDOMDEV()STRING')
         DEFINE('RANDOMI(N)')                              :(RANDOM_END)
*
* RANDOM() RETURNS INTEGER 0 .. 2 ** 31 - 1
* RETURN 1 .. N
*
RANDOMI  RANDOMI = RANDOM()
         RANDOMI = RANDOMI / 2147483647.0
         RANDOMI = NE(N, 0) CONVERT(RANDOMI * N, 'INTEGER') + 1
                                                               :(RETURN)
RANDOM_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>RANDOM - Random number functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Random number functions. <font face="Source Code Pro">RANDOMI(N)</font> generates random numbers
from 1 to n. If an empty argument is supplied, 0 to 1 (real).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;RANDOM&raquo;&equiv;</b>
-MODULE RANDOM
-PUBLIC RANDOM(), SRANDOM(), SRANDOMDEV() RANDOMI()
         LOAD(&#39;RANDOM()INTEGER&#39;)
         LOAD(&#39;SRANDOM(INTEGER)STRING&#39;)
         LOAD(&#39;SRANDOMDEV()STRING&#39;)
         DEFINE(&#39;RANDOMI(N)&#39;)                              <b>:(RANDOM_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RANDOM() RETURNS INTEGER 0 .. 2 ** 31 - 1</i></font>
<font color="#818181"><i>* RETURN 1 .. N</i></font>
<font color="#818181"><i>*</i></font>
RANDOMI  RANDOMI = RANDOM()
         RANDOMI = RANDOMI / 2147483647.0
         RANDOMI = NE(N, 0) CONVERT(RANDOMI * N, &#39;INTEGER&#39;) + 1
                                                               <b>:(RETURN)</b>
RANDOM_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;RANDOM.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL RANDOM
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*         ######      #     #     #  ######   #######  #     #         *</i></font>
<font color="#818181"><i>*         #     #    # #    ##    #  #     #  #     #  ##   ##         *</i></font>
<font color="#818181"><i>*         #     #   #   #   # #   #  #     #  #     #  # # # #         *</i></font>
<font color="#818181"><i>*         ######   #     #  #  #  #  #     #  #     #  #  #  #         *</i></font>
<font color="#818181"><i>*         #   #    #######  #   # #  #     #  #     #  #     #         *</i></font>
<font color="#818181"><i>*         #    #   #     #  #    ##  #     #  #     #  #     #         *</i></font>
<font color="#818181"><i>*         #     #  #     #  #     #  ######   #######  #     #         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* RANDOM                 RANDOM NUMBER FUNCTIONS                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                       *</i></font>
<font color="#818181"><i>* JANUARY 4, 2011                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RANDOM.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;RANDOM&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:17 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'RANDOM.INC'
-LINE 33 "RANDOM.lss"
         &CODE = 1
         &CODE = 0
END
<h1>READFILE - Read complete file into string</h1>

Reads a complete file into a string. No conversions are done. Uses
'B,65536' (binary, 64k byte buffer) for the INPUT() function. This
is specific to CSNOBOL4.

This is used to bring in content from disk (say, images, templates
or html). This content can then be left in memory if needed.

Tested w/ 1024..256K buffer size. Default 64K buffer.

If used with SPITBOL, reads a line at a time, adding newlines.

Also implements WRITEFILE(). Note that SPITBOL will form lines and
thus can only read or write text. CSNOBOL4 will read and write an
arbitrary binary string.

<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>

<<INCLUDES>>=
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'SYSTEM.INC'
@

<<READFILE>>=
-MODULE READFILE
-PUBLIC WRITEFILE(), READFILE()
         DEFINE('WRITEFILE(FILE,S)F,U,E,T')
         DEFINE('READFILE(FILE)F,U,E')                   :(READFILE_END)
*
WRITEFILE
         SYSTEM() 'CSNOBOL4'                              :S(WRITEFILE3)
         U = 20
         OUTPUT(.F, U, FILE)                                 :F(FRETURN)
WRITEFILE2
         S BRKREM(CHARS_NL) . T (CHARS_NL | NULL) =
         F = T
         IDENT(S)                             :S(READFILE4)F(WRITEFILE2)
WRITEFILE3
         U = IO_FINDUNIT()
         OUTPUT(.F, U, 'B,65536', FILE)
WRITEFILE4
         T = LT(SIZE(S), 65536) S                         :F(WRITEFILE6)
         S =
WRITEFILE5
         F = T
         IDENT(S)                             :S(READFILE4)F(WRITEFILE4)
WRITEFILE6
         S LEN(65536) . T REM . S                          :(WRITEFILE5)
*
READFILE SYSTEM() 'CSNOBOL4'                               :S(READFILE3)
         U = 20
         E = CHARS_NL
         INPUT(.F, U, FILE)                      :S(READFILE2)F(FRETURN)
READFILE3
         U = IO_FINDUNIT()                                   :F(FRETURN)
         INPUT(.F, U, 'B,65536', FILE)                       :F(FRETURN)
READFILE2
         READFILE = READFILE F E                           :S(READFILE2)
READFILE4
         ENDFILE(U)
         DETACH(.F)                                            :(RETURN)
*
READFILE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'READFILE.INC'
         &CODE = 1
         OUTPUT = READFILE('sample.tmpl')                        :F(END)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL READLINE
-EJECT
*
************************************************************************
*                                                                      *
*  ######   #######     #     ######   #######  ###  #        #######  *
*  #     #  #          # #    #     #  #         #   #        #        *
*  #     #  #         #   #   #     #  #         #   #        #        *
*  ######   #####    #     #  #     #  #####     #   #        #####    *
*  #   #    #        #######  #     #  #         #   #        #        *
*  #    #   #        #     #  #     #  #         #   #        #        *
*  #     #  #######  #     #  ######   #        ###  #######  #######  *
*                                                                      *
* READFILE          READ COMPLETE FILE INTO STRING                     *
*                                                                      *
************************************************************************
*
* READFILE.lss
*
<<READFILE>>
*
* CE: .F.MSNOBOL4;
@
-LINE 24 "READFILE.lss"
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'SYSTEM.INC'
-STITL READLINE
-EJECT
-LINE 85 "READFILE.lss"
*
************************************************************************
*                                                                      *
*  ######   #######     #     ######   #######  ###  #        #######  *
*  #     #  #          # #    #     #  #         #   #        #        *
*  #     #  #         #   #   #     #  #         #   #        #        *
*  ######   #####    #     #  #     #  #####     #   #        #####    *
*  #   #    #        #######  #     #  #         #   #        #        *
*  #    #   #        #     #  #     #  #         #   #        #        *
*  #     #  #######  #     #  ######   #        ###  #######  #######  *
*                                                                      *
* READFILE          READ COMPLETE FILE INTO STRING                     *
*                                                                      *
************************************************************************
*
* READFILE.lss
*
-LINE 30 "READFILE.lss"
-MODULE READFILE
-PUBLIC WRITEFILE(), READFILE()
         DEFINE('WRITEFILE(FILE,S)F,U,E,T')
         DEFINE('READFILE(FILE)F,U,E')                   :(READFILE_END)
*
WRITEFILE
         SYSTEM() 'CSNOBOL4'                              :S(WRITEFILE3)
         U = 20
         OUTPUT(.F, U, FILE)                                 :F(FRETURN)
WRITEFILE2
         S BRKREM(CHARS_NL) . T (CHARS_NL | NULL) =
         F = T
         IDENT(S)                             :S(READFILE4)F(WRITEFILE2)
WRITEFILE3
         U = IO_FINDUNIT()
         OUTPUT(.F, U, 'B,65536', FILE)
WRITEFILE4
         T = LT(SIZE(S), 65536) S                         :F(WRITEFILE6)
         S =
WRITEFILE5
         F = T
         IDENT(S)                             :S(READFILE4)F(WRITEFILE4)
WRITEFILE6
         S LEN(65536) . T REM . S                          :(WRITEFILE5)
*
READFILE SYSTEM() 'CSNOBOL4'                               :S(READFILE3)
         U = 20
         E = CHARS_NL
         INPUT(.F, U, FILE)                      :S(READFILE2)F(FRETURN)
READFILE3
         U = IO_FINDUNIT()                                   :F(FRETURN)
         INPUT(.F, U, 'B,65536', FILE)                       :F(FRETURN)
READFILE2
         READFILE = READFILE F E                           :S(READFILE2)
READFILE4
         ENDFILE(U)
         DETACH(.F)                                            :(RETURN)
*
READFILE_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>READFILE - Read complete file into string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Reads a complete file into a string. No conversions are done. Uses
'B,65536' (binary, 64k byte buffer) for the INPUT() function. This
is specific to CSNOBOL4.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This is used to bring in content from disk (say, images, templates
or html). This content can then be left in memory if needed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Tested w/ 1024..256K buffer size. Default 64K buffer.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If used with SPITBOL, reads a line at a time, adding newlines.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Also implements WRITEFILE(). Note that SPITBOL will form lines and
thus can only read or write text. CSNOBOL4 will read and write an
arbitrary binary string.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BRKREM.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;SYSTEM.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READFILE&raquo;&equiv;</b>
-MODULE READFILE
-PUBLIC WRITEFILE(), READFILE()
         DEFINE(&#39;WRITEFILE(FILE,S)F,U,E,T&#39;)
         DEFINE(&#39;READFILE(FILE)F,U,E&#39;)                   <b>:(READFILE_END)</b>
<font color="#818181"><i>*</i></font>
WRITEFILE
         SYSTEM() &#39;CSNOBOL4&#39;                              <b>:S(WRITEFILE3)</b>
         U = 20
         OUTPUT(.F, U, FILE)                                 <b>:F(FRETURN)</b>
WRITEFILE2
         S BRKREM(CHARS_NL) . T (CHARS_NL | NULL) =
         F = T
         IDENT(S)                             <b>:S(READFILE4)F(WRITEFILE2)</b>
WRITEFILE3
         U = IO_FINDUNIT()
         OUTPUT(.F, U, &#39;B,65536&#39;, FILE)
WRITEFILE4
         T = LT(SIZE(S), 65536) S                         <b>:F(WRITEFILE6)</b>
         S =
WRITEFILE5
         F = T
         IDENT(S)                             <b>:S(READFILE4)F(WRITEFILE4)</b>
WRITEFILE6
         S LEN(65536) . T REM . S                          <b>:(WRITEFILE5)</b>
<font color="#818181"><i>*</i></font>
READFILE SYSTEM() &#39;CSNOBOL4&#39;                               <b>:S(READFILE3)</b>
         U = 20
         E = CHARS_NL
         INPUT(.F, U, FILE)                      <b>:S(READFILE2)F(FRETURN)</b>
READFILE3
         U = IO_FINDUNIT()                                   <b>:F(FRETURN)</b>
         INPUT(.F, U, &#39;B,65536&#39;, FILE)                       <b>:F(FRETURN)</b>
READFILE2
         READFILE = READFILE F E                           <b>:S(READFILE2)</b>
READFILE4
         ENDFILE(U)
         DETACH(.F)                                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
READFILE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;READFILE.INC&#39;
         &amp;CODE = 1
         OUTPUT = READFILE(&#39;sample.tmpl&#39;)                        <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL READLINE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*  ######   #######     #     ######   #######  ###  #        #######  *</i></font>
<font color="#818181"><i>*  #     #  #          # #    #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*  #     #  #         #   #   #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*  ######   #####    #     #  #     #  #####     #   #        #####    *</i></font>
<font color="#818181"><i>*  #   #    #        #######  #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*  #    #   #        #     #  #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*  #     #  #######  #     #  ######   #        ###  #######  #######  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* READFILE          READ COMPLETE FILE INTO STRING                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READFILE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;READFILE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:41 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'READFILE.INC'
-LINE 75 "READFILE.lss"
         &CODE = 1
         OUTPUT = READFILE('sample.tmpl')                        :F(END)
         &CODE = 0
END
<h1>READLINE - Interface to readline and history functions</h1>

The [[READLINE]] library offers convenient command editing and history
retrieval features. This is provided both internally in CSNOBOL4 and
with the [[editline.so]] loadable library.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<READLINE>>=
-SNOBOL SLOAD('BQ.INC')
-SNOBOL SLOAD('DYNAMIC.INC')
-SNOBOL SLOAD('WRAPPER.INC')
-SNOBOL SLOAD('CRACK.INC')
-SNOBOL SLOAD('SEQ.INC')
-SNOBOL TERMINAL = 'READLINE (MON NOV 11 12:50:40 EST 2013)'
@

<<READLINE>>=
-EMBED C 'editline'
@

<<READLINE,TYPE=C>>=
-SNOBOL WRAPPER_STARTFILE(.EMBED)

/* Adds some functions enhancing CSNOBOL4 READLINE().
 *
 * EDITLINE(PROMPT, LINE)STRING uses gnu readline to edit a line
 * RLAPPNAME(NAME) sets the appname for readline, allowing readline
 *     config to conditionally configure for application.
 * CLEAR_HISTORY() clears history
 * STIFLE_HISTORY(INTEGER) stifles history to (max) n items
 * READ_HISTORY(STRING)INTEGER reads history from fname
 * WRITE_HISTORY(STRING)INTEGER writes history to fname
 *
 * Base code generated by WRAPPER on 11/01/2013 15:30:10
 */

#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <readline/history.h>

static char *editline_s = NULL;

static int prehook(void)
{
    rl_insert_text(editline_s);
    rl_beg_of_line(0, 0);
    rl_redisplay();
    return 1;
}

/* EDITLINE(STRING,STRING)STRING_FREE
 *
 * First STRING is the prompt, second string is the initial value
 */
EDITLINE( LA_ALIST ) LA_DCL
{
    void *old = rl_pre_input_hook;
    char *result;
    char prompt[1024];
    char initial_line[1024];
    getstring(LA_PTR(0), prompt, sizeof(prompt));
    getstring(LA_PTR(1), initial_line, sizeof(initial_line));
    editline_s = initial_line;
    rl_pre_input_hook = prehook;
    result = readline(prompt);
    rl_pre_input_hook = old;
    RETSTR_FREE(result);
}

RLAPPNAME( LA_ALIST) LA_DCL
{
    static char rlapp[1024];
    getstring(LA_PTR(0), rlapp, sizeof(rlapp));
    rl_readline_name = rlapp;
    RETNULL;
}

CLEAR_HISTORY( LA_ALIST ) LA_DCL
{
    clear_history();
    RETNULL;
}

STIFLE_HISTORY( LA_ALIST ) LA_DCL
{
    stifle_history(LA_INT(0));
    RETNULL;
}

READ_HISTORY( LA_ALIST ) LA_DCL
{
    char *s;
    char fname[1024];
    getstring(LA_PTR(0), fname, sizeof(fname));
    if (strlen(fname) == 0)
	s = NULL;
    else
	s = fname;
    RETINT(read_history(s));
}

WRITE_HISTORY( LA_ALIST ) LA_DCL
{
    char *s;
    static char fname[1024];
    getstring(LA_PTR(0), fname, sizeof(fname));
    if (strlen(fname) == 0)
	s = NULL;
    else
	s = fname;
    RETINT(write_history(s));
}
-END
@

<<READLINE>>=
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(editline) :F(ERROR) ;
-SNOBOL LIBS = '-lreadline'
-SNOBOL OBJECTS = editline ; OBJECTS '.c' = '.o'
-SNOBOL LINK_DYNAMIC('./editline', OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS editline.so
-CMNT -SNOBOL A = CRACK(editline ' ' OBJECTS, ' ')
-CMNT -SNOBOL SEQ(' DELETE(A<K>) ', .K)
@


<<READLINE>>=
-PUBLIC READLINE(), ADD_HISTORY(), HISTORY_EXPAND()
READLINE LOAD('READLINE(STRING)STRING')
         LOAD('ADD_HISTORY(STRING)STRING')
         LOAD('HISTORY_EXPAND(STRING)STRING')
*
-PUBLIC EDITLINE(), RLAPPNAME(), CLEAR_HISTORY(), STIFLE_HISTORY()
-PUBLIC READ_HISTORY(), WRITE_HISTORY()
         LOAD('EDITLINE(STRING,STRING)STRING', 'editline.so')
         LOAD('RLAPPNAME(STRING)', 'editline.so')
         LOAD('CLEAR_HISTORY()', 'editline.so')
         LOAD('STIFLE_HISTORY(INTEGER)', 'editline.so')
         LOAD('READ_HISTORY(STRING)INTEGER', 'editline.so')
         LOAD('WRITE_HISTORY(STRING)INTEGER', 'editline.so')
*
         CODE('READLINE')
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'READLINE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE READLINE
-STITL READLINE
-EJECT
*
************************************************************************
*                                                                      *
*  ######   #######     #     ######   #        ###  #     #  #######  *
*  #     #  #          # #    #     #  #         #   ##    #  #        *
*  #     #  #         #   #   #     #  #         #   # #   #  #        *
*  ######   #####    #     #  #     #  #         #   #  #  #  #####    *
*  #   #    #        #######  #     #  #         #   #   # #  #        *
*  #    #   #        #     #  #     #  #         #   #    ##  #        *
*  #     #  #######  #     #  ######   #######  ###  #     #  #######  *
*                                                                      *
* READLINE                 READLINE FUNCTIONS                          *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 3, 2011                                                      *
*                                                                      *
************************************************************************
*
* READLINE.lss
*
<<READLINE>>
*
* CE: .MSNOBOL4;
@
-MODULE READLINE
-STITL READLINE
-EJECT
-LINE 166 "READLINE.lss"
*
************************************************************************
*                                                                      *
*  ######   #######     #     ######   #        ###  #     #  #######  *
*  #     #  #          # #    #     #  #         #   ##    #  #        *
*  #     #  #         #   #   #     #  #         #   # #   #  #        *
*  ######   #####    #     #  #     #  #         #   #  #  #  #####    *
*  #   #    #        #######  #     #  #         #   #   # #  #        *
*  #    #   #        #     #  #     #  #         #   #    ##  #        *
*  #     #  #######  #     #  ######   #######  ###  #     #  #######  *
*                                                                      *
* READLINE                 READLINE FUNCTIONS                          *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 3, 2011                                                      *
*                                                                      *
************************************************************************
*
* READLINE.lss
*
-LINE 13 "READLINE.lss"
-LINE 14 "READLINE.lss"
-LINE 15 "READLINE.lss"
-LINE 16 "READLINE.lss"
-LINE 17 "READLINE.lss"
-LINE 18 "READLINE.lss"
-LINE 19 "READLINE.lss"
-LINE 22 "READLINE.lss"
         editline = 'editline.c'
-LINE 122 "READLINE.lss"
-LINE 123 "READLINE.lss"
-LINE 124 "READLINE.lss"
-LINE 125 "READLINE.lss"
-LINE 126 "READLINE.lss"
-LINE 127 "READLINE.lss"
-LINE 136 "READLINE.lss"
-PUBLIC READLINE(), ADD_HISTORY(), HISTORY_EXPAND()
READLINE LOAD('READLINE(STRING)STRING')
         LOAD('ADD_HISTORY(STRING)STRING')
         LOAD('HISTORY_EXPAND(STRING)STRING')
*
-PUBLIC EDITLINE(), RLAPPNAME(), CLEAR_HISTORY(), STIFLE_HISTORY()
-PUBLIC READ_HISTORY(), WRITE_HISTORY()
         LOAD('EDITLINE(STRING,STRING)STRING', 'editline.so')
         LOAD('RLAPPNAME(STRING)', 'editline.so')
         LOAD('CLEAR_HISTORY()', 'editline.so')
         LOAD('STIFLE_HISTORY(INTEGER)', 'editline.so')
         LOAD('READ_HISTORY(STRING)INTEGER', 'editline.so')
         LOAD('WRITE_HISTORY(STRING)INTEGER', 'editline.so')
*
         CODE('READLINE')
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>READLINE - Interface to readline and history functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The <font face="Source Code Pro">READLINE</font> library offers convenient command editing and history
retrieval features. This is provided both internally in CSNOBOL4 and
with the <font face="Source Code Pro">editline.so</font> loadable library.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READLINE&raquo;&equiv;</b>
-SNOBOL SLOAD(&#39;BQ.INC&#39;)
-SNOBOL SLOAD(&#39;DYNAMIC.INC&#39;)
-SNOBOL SLOAD(&#39;WRAPPER.INC&#39;)
-SNOBOL SLOAD(&#39;CRACK.INC&#39;)
-SNOBOL SLOAD(&#39;SEQ.INC&#39;)
-SNOBOL TERMINAL = &#39;READLINE (MON NOV 11 12:50:40 EST 2013)&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READLINE&raquo;&equiv;</b>
-EMBED C &#39;editline&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READLINE,TYPE=C&raquo;&equiv;</b>
-SNOBOL WRAPPER_STARTFILE(.EMBED)

/* Adds some functions enhancing CSNOBOL4 READLINE().
 *
 * EDITLINE(PROMPT, LINE)STRING uses gnu readline to edit a line
 * RLAPPNAME(NAME) sets the appname for readline, allowing readline
 *     config to conditionally configure for application.
 * CLEAR_HISTORY() clears history
 * STIFLE_HISTORY(INTEGER) stifles history to (max) n items
 * READ_HISTORY(STRING)INTEGER reads history from fname
 * WRITE_HISTORY(STRING)INTEGER writes history to fname
 *
 * Base code generated by WRAPPER on 11/01/2013 15:30:10
 */

<font color="#818181"><i>#include &lt;stdio.h&gt;</i></font>
<font color="#818181"><i>#include &lt;stdlib.h&gt;</i></font>
<font color="#818181"><i>#include &lt;readline/readline.h&gt;</i></font>
<font color="#818181"><i>#include &lt;readline/history.h&gt;</i></font>

static char *editline_s = NULL;

static int prehook(void)
{
    rl_insert_text(editline_s);
    rl_beg_of_line(0, 0);
    rl_redisplay();
    return 1;
}

/* EDITLINE(STRING,STRING)STRING_FREE
 *
 * First STRING is the prompt, second string is the initial value
 */
EDITLINE( LA_ALIST ) LA_DCL
{
    void *old = rl_pre_input_hook;
    char *result;
    char prompt[1024];
    char initial_line[1024];
    getstring(LA_PTR(0), prompt, sizeof(prompt));
    getstring(LA_PTR(1), initial_line, sizeof(initial_line));
    editline_s = initial_line;
    rl_pre_input_hook = prehook;
    result = readline(prompt);
    rl_pre_input_hook = old;
    RETSTR_FREE(result);
}

RLAPPNAME( LA_ALIST) LA_DCL
{
    static char rlapp[1024];
    getstring(LA_PTR(0), rlapp, sizeof(rlapp));
    rl_readline_name = rlapp;
    RETNULL;
}

CLEAR_HISTORY( LA_ALIST ) LA_DCL
{
    clear_history();
    RETNULL;
}

STIFLE_HISTORY( LA_ALIST ) LA_DCL
{
    stifle_history(LA_INT(0));
    RETNULL;
}

READ_HISTORY( LA_ALIST ) LA_DCL
{
    char *s;
    char fname[1024];
    getstring(LA_PTR(0), fname, sizeof(fname));
    if (strlen(fname) == 0)
	s = NULL;
    else
	s = fname;
    RETINT(read_history(s));
}

WRITE_HISTORY( LA_ALIST ) LA_DCL
{
    char *s;
    static char fname[1024];
    getstring(LA_PTR(0), fname, sizeof(fname));
    if (strlen(fname) == 0)
	s = NULL;
    else
	s = fname;
    RETINT(write_history(s));
}
-END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READLINE&raquo;&equiv;</b>
-SNOBOL DYNAMIC_DEBUG = 1
-SNOBOL COMPILE_DYNAMIC(editline) :F(ERROR) ;
-SNOBOL LIBS = &#39;-lreadline&#39;
-SNOBOL OBJECTS = editline ; OBJECTS &#39;.c&#39; = &#39;.o&#39;
-SNOBOL LINK_DYNAMIC(&#39;./editline&#39;, OBJECTS, LIBS) :F(ERROR) ;
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON&#39;T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS editline.so
-CMNT -SNOBOL A = CRACK(editline &#39; &#39; OBJECTS, &#39; &#39;)
-CMNT -SNOBOL SEQ(&#39; DELETE(A&lt;K&gt;) &#39;, .K)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READLINE&raquo;&equiv;</b>
-PUBLIC READLINE(), ADD_HISTORY(), HISTORY_EXPAND()
READLINE LOAD(&#39;READLINE(STRING)STRING&#39;)
         LOAD(&#39;ADD_HISTORY(STRING)STRING&#39;)
         LOAD(&#39;HISTORY_EXPAND(STRING)STRING&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC EDITLINE(), RLAPPNAME(), CLEAR_HISTORY(), STIFLE_HISTORY()
-PUBLIC READ_HISTORY(), WRITE_HISTORY()
         LOAD(&#39;EDITLINE(STRING,STRING)STRING&#39;, &#39;editline.so&#39;)
         LOAD(&#39;RLAPPNAME(STRING)&#39;, &#39;editline.so&#39;)
         LOAD(&#39;CLEAR_HISTORY()&#39;, &#39;editline.so&#39;)
         LOAD(&#39;STIFLE_HISTORY(INTEGER)&#39;, &#39;editline.so&#39;)
         LOAD(&#39;READ_HISTORY(STRING)INTEGER&#39;, &#39;editline.so&#39;)
         LOAD(&#39;WRITE_HISTORY(STRING)INTEGER&#39;, &#39;editline.so&#39;)
<font color="#818181"><i>*</i></font>
         CODE(&#39;READLINE&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;READLINE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE READLINE
-STITL READLINE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*  ######   #######     #     ######   #        ###  #     #  #######  *</i></font>
<font color="#818181"><i>*  #     #  #          # #    #     #  #         #   ##    #  #        *</i></font>
<font color="#818181"><i>*  #     #  #         #   #   #     #  #         #   # #   #  #        *</i></font>
<font color="#818181"><i>*  ######   #####    #     #  #     #  #         #   #  #  #  #####    *</i></font>
<font color="#818181"><i>*  #   #    #        #######  #     #  #         #   #   # #  #        *</i></font>
<font color="#818181"><i>*  #    #   #        #     #  #     #  #         #   #    ##  #        *</i></font>
<font color="#818181"><i>*  #     #  #######  #     #  ######   #######  ###  #     #  #######  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* READLINE                 READLINE FUNCTIONS                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                       *</i></font>
<font color="#818181"><i>* JANUARY 3, 2011                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READLINE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;READLINE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Sun Jun  8 22:40:34 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'READLINE.INC'
-LINE 157 "READLINE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>READL - Read lines to list</h1>

[[REAL(P,.F)]] will read in a sequence of items from F, placing them
in a list, and return the head of a list.  P is a pattern to indicate
the end of the list.

Example: [[READL(POS(0) 'STOP')]] will read a sequence of strings up
to but not including the first string having 'STOP' in column 1.

<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>

<<INCLUDES>>=
-INCLUDE 'LINK.INC'
@

<<READL>>=
-MODULE READL
-PUBLIC READL()
         DEFINE('READL(P,IN)N,S')                           :(READL_END)
*
READL    P = IDENT(P) ABORT
         IN = IDENT(IN) .INPUT
         N = .READL
READL_1  S = $IN                                              :F(RETURN)
         S P                                                  :S(RETURN)
         $N = LINK(S)
         N = .NEXT($N)                                        :(READL_1)
*
READL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'READL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL READL
-EJECT
*
************************************************************************
*                                                                      *
*             ######   #######     #     ######   #                    *
*             #     #  #          # #    #     #  #                    *
*             #     #  #         #   #   #     #  #                    *
*             ######   #####    #     #  #     #  #                    *
*             #   #    #        #######  #     #  #                    *
*             #    #   #        #     #  #     #  #                    *
*             #     #  #######  #     #  ######   #######              *
*                                                                      *
* READL                      READ LIST                                 *
*                                                                      *
************************************************************************
*
* READL.lss
*
<<READL>>
*
* CE: .MSNOBOL4;
@
-LINE 14 "READL.lss"
-INCLUDE 'LINK.INC'
-STITL READL
-EJECT
-LINE 46 "READL.lss"
*
************************************************************************
*                                                                      *
*             ######   #######     #     ######   #                    *
*             #     #  #          # #    #     #  #                    *
*             #     #  #         #   #   #     #  #                    *
*             ######   #####    #     #  #     #  #                    *
*             #   #    #        #######  #     #  #                    *
*             #    #   #        #     #  #     #  #                    *
*             #     #  #######  #     #  ######   #######              *
*                                                                      *
* READL                      READ LIST                                 *
*                                                                      *
************************************************************************
*
* READL.lss
*
-LINE 18 "READL.lss"
-MODULE READL
-PUBLIC READL()
         DEFINE('READL(P,IN)N,S')                           :(READL_END)
*
READL    P = IDENT(P) ABORT
         IN = IDENT(IN) .INPUT
         N = .READL
READL_1  S = $IN                                              :F(RETURN)
         S P                                                  :S(RETURN)
         $N = LINK(S)
         N = .NEXT($N)                                        :(READL_1)
*
READL_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>READL - Read lines to list</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">REAL(P,.F)</font> will read in a sequence of items from F, placing them
in a list, and return the head of a list.  P is a pattern to indicate
the end of the list.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Example: <font face="Source Code Pro">READL(POS(0) 'STOP')</font> will read a sequence of strings up
to but not including the first string having 'STOP' in column 1.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LINK.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;READL&raquo;&equiv;</b>
-MODULE READL
-PUBLIC READL()
         DEFINE(&#39;READL(P,IN)N,S&#39;)                           <b>:(READL_END)</b>
<font color="#818181"><i>*</i></font>
READL    P = IDENT(P) ABORT
         IN = IDENT(IN) .INPUT
         N = .READL
READL_1  S = $IN                                              <b>:F(RETURN)</b>
         S P                                                  <b>:S(RETURN)</b>
         $N = LINK(S)
         N = .NEXT($N)                                        <b>:(READL_1)</b>
<font color="#818181"><i>*</i></font>
READL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;READL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL READL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             ######   #######     #     ######   #                    *</i></font>
<font color="#818181"><i>*             #     #  #          # #    #     #  #                    *</i></font>
<font color="#818181"><i>*             #     #  #         #   #   #     #  #                    *</i></font>
<font color="#818181"><i>*             ######   #####    #     #  #     #  #                    *</i></font>
<font color="#818181"><i>*             #   #    #        #######  #     #  #                    *</i></font>
<font color="#818181"><i>*             #    #   #        #     #  #     #  #                    *</i></font>
<font color="#818181"><i>*             #     #  #######  #     #  ######   #######              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* READL                      READ LIST                                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* READL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;READL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:38 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'READL.INC'
-LINE 37 "READL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>REDEFINE - Redefine operators</h1>

[[REDEFINE(OP,DEF,LBL)]] will redefine the built-in operator [[OP]]
to the name of the function given with prototype [[DEF]] and entry
label [[LBL]].  The old definition of the operator is preserved in
the function name with appended period.

{{
<b>C<small>AUTION</small></b> - This cannot be used with SPITBOL,
which does not permit the redefinition of built-in operators.
}}

<h2>Uses</h2>

<<INCLUDES>>=
@

<<REDEFINE>>=
-MODULE REDEFINE
-PUBLIC REDEFINE(), REDEFINERESTORE()
         DEFINE('REDEFINE(OP,DEF,LBL)NAME,N,FLAG')
         DEFINE('REDEFINERESTORE(OP,DEF)NAME,N,FLAG')
         DEFINE('REDEFINECOMMON()')                      :(REDEFINE_END)
*
REDEFINECOMMON
         DEF BREAK('(') . NAME '(' BREAK('),') LEN(1) . FLAG
         N = 1
         N = IDENT(FLAG, ',') 2
         N = IDENT(OP)
         OP = IDENT(OP) NAME
                                                               :(RETURN)
*
REDEFINE REDEFINECOMMON()
         OPSYN(NAME '.', OP, N)
         DEFINE(DEF, LBL)
         OPSYN(OP, NAME, N)                                    :(RETURN)
*
REDEFINERESTORE
         REDEFINECOMMON()
         OPSYN(OP, NAME '.', N)                                :(RETURN)
*
REDEFINE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'REDEFINE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL REDEFINE
-EJECT
*
************************************************************************
*                                                                      *
*  ######   #######  ######   #######  #######  ###  #     #  #######  *
*  #     #  #        #     #  #        #         #   ##    #  #        *
*  #     #  #        #     #  #        #         #   # #   #  #        *
*  ######   #####    #     #  #####    #####     #   #  #  #  #####    *
*  #   #    #        #     #  #        #         #   #   # #  #        *
*  #    #   #        #     #  #        #         #   #    ##  #        *
*  #     #  #######  ######   #######  #        ###  #     #  #######  *
*                                                                      *
* REDEFINE             REDEFINE OPERATORS                              *
*                                                                      *
************************************************************************
*
* REDEFINE.lss
*
* FMGW:
*
* - ADD REDEFINERESTORE() TO ALLOW INFINIP.SNO TO ENABLE/DISABLE
*   LONG INTEGERS
* - FACTOR REDEFINECOMMON() TO ALLOW REDEFINE() AND REDEFINERESTORE()
*   TO SHARE CODE
*
<<REDEFINE>>
*
* CE: .MSNOBOL4;
@
-STITL REDEFINE
-EJECT
*
-LINE 58 "REDEFINE.lss"
************************************************************************
*                                                                      *
*  ######   #######  ######   #######  #######  ###  #     #  #######  *
*  #     #  #        #     #  #        #         #   ##    #  #        *
*  #     #  #        #     #  #        #         #   # #   #  #        *
*  ######   #####    #     #  #####    #####     #   #  #  #  #####    *
*  #   #    #        #     #  #        #         #   #   # #  #        *
*  #    #   #        #     #  #        #         #   #    ##  #        *
*  #     #  #######  ######   #######  #        ###  #     #  #######  *
*                                                                      *
* REDEFINE             REDEFINE OPERATORS                              *
*                                                                      *
************************************************************************
*
* REDEFINE.lss
*
* FMGW:
*
* - ADD REDEFINERESTORE() TO ALLOW INFINIP.SNO TO ENABLE/DISABLE
*   LONG INTEGERS
* - FACTOR REDEFINECOMMON() TO ALLOW REDEFINE() AND REDEFINERESTORE()
*   TO SHARE CODE
*
-LINE 19 "REDEFINE.lss"
-MODULE REDEFINE
-PUBLIC REDEFINE(), REDEFINERESTORE()
         DEFINE('REDEFINE(OP,DEF,LBL)NAME,N,FLAG')
         DEFINE('REDEFINERESTORE(OP,DEF)NAME,N,FLAG')
         DEFINE('REDEFINECOMMON()')                      :(REDEFINE_END)
*
REDEFINECOMMON
         DEF BREAK('(') . NAME '(' BREAK('),') LEN(1) . FLAG
         N = 1
         N = IDENT(FLAG, ',') 2
         N = IDENT(OP)
         OP = IDENT(OP) NAME
                                                               :(RETURN)
*
REDEFINE REDEFINECOMMON()
         OPSYN(NAME '.', OP, N)
         DEFINE(DEF, LBL)
         OPSYN(OP, NAME, N)                                    :(RETURN)
*
REDEFINERESTORE
         REDEFINECOMMON()
         OPSYN(OP, NAME '.', N)                                :(RETURN)
*
REDEFINE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>REDEFINE - Redefine operators</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">REDEFINE(OP,DEF,LBL)</font> will redefine the built-in operator <font face="Source Code Pro">OP</font>
to the name of the function given with prototype <font face="Source Code Pro">DEF</font> and entry
label <font face="Source Code Pro">LBL</font>.  The old definition of the operator is preserved in
the function name with appended period.
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
<b>C<small>AUTION</small></b> - This cannot be used with SPITBOL,
which does not permit the redefinition of built-in operators.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;REDEFINE&raquo;&equiv;</b>
-MODULE REDEFINE
-PUBLIC REDEFINE(), REDEFINERESTORE()
         DEFINE(&#39;REDEFINE(OP,DEF,LBL)NAME,N,FLAG&#39;)
         DEFINE(&#39;REDEFINERESTORE(OP,DEF)NAME,N,FLAG&#39;)
         DEFINE(&#39;REDEFINECOMMON()&#39;)                      <b>:(REDEFINE_END)</b>
<font color="#818181"><i>*</i></font>
REDEFINECOMMON
         DEF BREAK(&#39;(&#39;) . NAME &#39;(&#39; BREAK(&#39;),&#39;) LEN(1) . FLAG
         N = 1
         N = IDENT(FLAG, &#39;,&#39;) 2
         N = IDENT(OP)
         OP = IDENT(OP) NAME
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
REDEFINE REDEFINECOMMON()
         OPSYN(NAME &#39;.&#39;, OP, N)
         DEFINE(DEF, LBL)
         OPSYN(OP, NAME, N)                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
REDEFINERESTORE
         REDEFINECOMMON()
         OPSYN(OP, NAME &#39;.&#39;, N)                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
REDEFINE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;REDEFINE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL REDEFINE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*  ######   #######  ######   #######  #######  ###  #     #  #######  *</i></font>
<font color="#818181"><i>*  #     #  #        #     #  #        #         #   ##    #  #        *</i></font>
<font color="#818181"><i>*  #     #  #        #     #  #        #         #   # #   #  #        *</i></font>
<font color="#818181"><i>*  ######   #####    #     #  #####    #####     #   #  #  #  #####    *</i></font>
<font color="#818181"><i>*  #   #    #        #     #  #        #         #   #   # #  #        *</i></font>
<font color="#818181"><i>*  #    #   #        #     #  #        #         #   #    ##  #        *</i></font>
<font color="#818181"><i>*  #     #  #######  ######   #######  #        ###  #     #  #######  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* REDEFINE             REDEFINE OPERATORS                              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REDEFINE.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FMGW:</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* - ADD REDEFINERESTORE() TO ALLOW INFINIP.SNO TO ENABLE/DISABLE</i></font>
<font color="#818181"><i>*   LONG INTEGERS</i></font>
<font color="#818181"><i>* - FACTOR REDEFINECOMMON() TO ALLOW REDEFINE() AND REDEFINERESTORE()</i></font>
<font color="#818181"><i>*   TO SHARE CODE</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;REDEFINE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:18 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'REDEFINE.INC'
-LINE 49 "REDEFINE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>REPL - Replace strings</h1>

[[REPL(S1,S2,S3)]] will do a string-by-string replacement (as opposed
to a character-by-character replacement ala [[REPLACE]]) on the string
[[S1]].  The string [[S1]] is scanned for instances of the string
[[S2]] and each is replaced by [[S3]]. Portions of [[S1]] already
scanned and the replaced string are not reexamined for instances of
[[S2]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<REPL>>=
-MODULE REPL
-PUBLIC REPL()
         DEFINE('REPL(S1,S2,S3)C,T,FINDC')                   :(REPL_END)
*
REPL     S2 LEN(1) . C =                                     :F(FRETURN)
         FINDC = BREAK(C) . T LEN(1)
         S2 = POS(0) S2
REPL_1   S1 FINDC =                                           :F(REPL_2)
         S1 S2 =                                              :F(REPL_3)
         REPL = REPL T S3                                      :(REPL_1)
REPL_3   REPL = REPL T C                                       :(REPL_1)
REPL_2   REPL = REPL S1                                        :(RETURN)
*
REPL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'REPL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL REPL
-EJECT
*
************************************************************************
*                                                                      *
*                   ######   #######  ######   #                       *
*                   #     #  #        #     #  #                       *
*                   #     #  #        #     #  #                       *
*                   ######   #####    ######   #                       *
*                   #   #    #        #        #                       *
*                   #    #   #        #        #                       *
*                   #     #  #######  #        #######                 *
*                                                                      *
* REPL                   REPLACE STRINGS                               *
*                                                                      *
************************************************************************
*
* REPL.lss
*
<<REPL>>
*
* CE: .MSNOBOL4;
@
-STITL REPL
-EJECT
*
-LINE 45 "REPL.lss"
************************************************************************
*                                                                      *
*                   ######   #######  ######   #                       *
*                   #     #  #        #     #  #                       *
*                   #     #  #        #     #  #                       *
*                   ######   #####    ######   #                       *
*                   #   #    #        #        #                       *
*                   #    #   #        #        #                       *
*                   #     #  #######  #        #######                 *
*                                                                      *
* REPL                   REPLACE STRINGS                               *
*                                                                      *
************************************************************************
*
* REPL.lss
*
-LINE 16 "REPL.lss"
-MODULE REPL
-PUBLIC REPL()
         DEFINE('REPL(S1,S2,S3)C,T,FINDC')                   :(REPL_END)
*
REPL     S2 LEN(1) . C =                                     :F(FRETURN)
         FINDC = BREAK(C) . T LEN(1)
         S2 = POS(0) S2
REPL_1   S1 FINDC =                                           :F(REPL_2)
         S1 S2 =                                              :F(REPL_3)
         REPL = REPL T S3                                      :(REPL_1)
REPL_3   REPL = REPL T C                                       :(REPL_1)
REPL_2   REPL = REPL S1                                        :(RETURN)
*
REPL_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>REPL - Replace strings</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">REPL(S1,S2,S3)</font> will do a string-by-string replacement (as opposed
to a character-by-character replacement ala <font face="Source Code Pro">REPLACE</font>) on the string
<font face="Source Code Pro">S1</font>.  The string <font face="Source Code Pro">S1</font> is scanned for instances of the string
<font face="Source Code Pro">S2</font> and each is replaced by <font face="Source Code Pro">S3</font>. Portions of <font face="Source Code Pro">S1</font> already
scanned and the replaced string are not reexamined for instances of
<font face="Source Code Pro">S2</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;REPL&raquo;&equiv;</b>
-MODULE REPL
-PUBLIC REPL()
         DEFINE(&#39;REPL(S1,S2,S3)C,T,FINDC&#39;)                   <b>:(REPL_END)</b>
<font color="#818181"><i>*</i></font>
REPL     S2 LEN(1) . C =                                     <b>:F(FRETURN)</b>
         FINDC = BREAK(C) . T LEN(1)
         S2 = POS(0) S2
REPL_1   S1 FINDC =                                           <b>:F(REPL_2)</b>
         S1 S2 =                                              <b>:F(REPL_3)</b>
         REPL = REPL T S3                                      <b>:(REPL_1)</b>
REPL_3   REPL = REPL T C                                       <b>:(REPL_1)</b>
REPL_2   REPL = REPL S1                                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
REPL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;REPL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL REPL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   ######   #######  ######   #                       *</i></font>
<font color="#818181"><i>*                   #     #  #        #     #  #                       *</i></font>
<font color="#818181"><i>*                   #     #  #        #     #  #                       *</i></font>
<font color="#818181"><i>*                   ######   #####    ######   #                       *</i></font>
<font color="#818181"><i>*                   #   #    #        #        #                       *</i></font>
<font color="#818181"><i>*                   #    #   #        #        #                       *</i></font>
<font color="#818181"><i>*                   #     #  #######  #        #######                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* REPL                   REPLACE STRINGS                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REPL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;REPL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:18 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'REPL.INC'
-LINE 36 "REPL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>RESOL - Timer resolution in milliseconds</h1>

[[RESOLUTION()]] returns the clock resolution of the machine as a
REAL number of milliseconds.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<RESOL>>=
-MODULE RESOL
%SET(CSNOBOL4,(?(SYSTEM ? 'CSNOBOL4') 1))
-PUBLIC RESOLUTION()
         DEFINE('RESOLUTION()T,N,R,T2')                :(RESOLUTION_END)
*
RESOLUTION
         DIFFER(RESOLUTION_)                                 :S(RESOL_4)
         R = 0.0
         T = TIME()
RESOL_1  EQ(T, TIME())                                       :S(RESOL_1)
         T = TIME()
RESOL_2  T2 = TIME()
RESOL_3  EQ(T2, TIME())                                      :S(RESOL_3)
         RESOLUTION_ = TIME() - T
%IF(CSNOBOL4)
         R = R + (TIME() - T2)
         N = N + 1
         LE(N, 100000)                                       :S(RESOL_2)
         RESOLUTION_ = R / 100000
%ENDIF
RESOL_4  RESOLUTION = RESOLUTION_                              :(RETURN)
*
RESOLUTION_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'RESOL.INC'
         &CODE = 1
         OUTPUT = RESOLUTION()
         &CODE = 0
END
@

<<>>=
-STITL RESOL
-EJECT
*
************************************************************************
*                                                                      *
*                 ######   #######   #####   #######  #                *
*                 #     #  #        #     #  #     #  #                *
*                 #     #  #        #        #     #  #                *
*                 ######   #####     #####   #     #  #                *
*                 #   #    #              #  #     #  #                *
*                 #    #   #        #     #  #     #  #                *
*                 #     #  #######   #####   #######  #######          *
*                                                                      *
* RESOL             TIMER RESOLUTION IN MILLISECONDS                   *
*                                                                      *
************************************************************************
*
* RESOL.lss
*
<<RESOL>>
*
* CE: .MSNOBOL4;
@
-STITL RESOL
-EJECT
*
-LINE 51 "RESOL.lss"
************************************************************************
*                                                                      *
*                 ######   #######   #####   #######  #                *
*                 #     #  #        #     #  #     #  #                *
*                 #     #  #        #        #     #  #                *
*                 ######   #####     #####   #     #  #                *
*                 #   #    #              #  #     #  #                *
*                 #    #   #        #     #  #     #  #                *
*                 #     #  #######   #####   #######  #######          *
*                                                                      *
* RESOL             TIMER RESOLUTION IN MILLISECONDS                   *
*                                                                      *
************************************************************************
*
* RESOL.lss
*
-LINE 12 "RESOL.lss"
-MODULE RESOL
-PUBLIC RESOLUTION()
         DEFINE('RESOLUTION()T,N,R,T2')                :(RESOLUTION_END)
*
RESOLUTION
         DIFFER(RESOLUTION_)                                 :S(RESOL_4)
         R = 0.0
         T = TIME()
RESOL_1  EQ(T, TIME())                                       :S(RESOL_1)
         T = TIME()
RESOL_2  T2 = TIME()
RESOL_3  EQ(T2, TIME())                                      :S(RESOL_3)
         RESOLUTION_ = TIME() - T
         R = R + (TIME() - T2)
         N = N + 1
         LE(N, 100000)                                       :S(RESOL_2)
         RESOLUTION_ = R / 100000
RESOL_4  RESOLUTION = RESOLUTION_                              :(RETURN)
*
RESOLUTION_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>RESOL - Timer resolution in milliseconds</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">RESOLUTION()</font> returns the clock resolution of the machine as a
REAL number of milliseconds.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;RESOL&raquo;&equiv;</b>
-MODULE RESOL
%SET(CSNOBOL4,(?(SYSTEM ? &#39;CSNOBOL4&#39;) 1))
-PUBLIC RESOLUTION()
         DEFINE(&#39;RESOLUTION()T,N,R,T2&#39;)                <b>:(RESOLUTION_END)</b>
<font color="#818181"><i>*</i></font>
RESOLUTION
         DIFFER(RESOLUTION_)                                 <b>:S(RESOL_4)</b>
         R = 0.0
         T = TIME()
RESOL_1  EQ(T, TIME())                                       <b>:S(RESOL_1)</b>
         T = TIME()
RESOL_2  T2 = TIME()
RESOL_3  EQ(T2, TIME())                                      <b>:S(RESOL_3)</b>
         RESOLUTION_ = TIME() - T
%IF(CSNOBOL4)
         R = R + (TIME() - T2)
         N = N + 1
         LE(N, 100000)                                       <b>:S(RESOL_2)</b>
         RESOLUTION_ = R / 100000
%ENDIF
RESOL_4  RESOLUTION = RESOLUTION_                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
RESOLUTION_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;RESOL.INC&#39;
         &amp;CODE = 1
         OUTPUT = RESOLUTION()
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL RESOL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 ######   #######   #####   #######  #                *</i></font>
<font color="#818181"><i>*                 #     #  #        #     #  #     #  #                *</i></font>
<font color="#818181"><i>*                 #     #  #        #        #     #  #                *</i></font>
<font color="#818181"><i>*                 ######   #####     #####   #     #  #                *</i></font>
<font color="#818181"><i>*                 #   #    #              #  #     #  #                *</i></font>
<font color="#818181"><i>*                 #    #   #        #     #  #     #  #                *</i></font>
<font color="#818181"><i>*                 #     #  #######   #####   #######  #######          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* RESOL             TIMER RESOLUTION IN MILLISECONDS                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* RESOL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;RESOL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:19 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'RESOL.INC'
-LINE 41 "RESOL.lss"
         &CODE = 1
         OUTPUT = RESOLUTION()
         &CODE = 0
END
<h1>REVL - Reverse list</h1>

[[REVL(L)]] returns the reverse of the list passed. Many recursive
list algorithms cons the results and thus return the answer as
a list that needs reversing.

<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>

<<INCLUDES>>=
-INCLUDE 'LINK.INC'
@

<<REVL>>=
-MODULE REVL
-PUBLIC REVL()
         DEFINE('REVL(L)T')                                  :(REVL_END)
*
REVL     REVL = L
         IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
         L = NEXT(REVL)
         NEXT(REVL) =
REVL_1   IDENT(L)                                             :S(RETURN)
         T = NEXT(L)
         NEXT(L) = REVL
         REVL = L
         L = T                                                 :(REVL_1)
*
REVL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'REVL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL REVL
-EJECT
*
************************************************************************
*                                                                      *
*                    ######   #######  #     #  #                      *
*                    #     #  #        #     #  #                      *
*                    #     #  #        #     #  #                      *
*                    ######   #####    #     #  #                      *
*                    #   #    #         #   #   #                      *
*                    #    #   #          # #    #                      *
*                    #     #  #######     #     #######                *
*                                                                      *
* REVL                      REVERSE LIST                               *
*                                                                      *
************************************************************************
*
* REVL.lss
*
<<REVL>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "REVL.lss"
-INCLUDE 'LINK.INC'
-STITL REVL
-EJECT
-LINE 45 "REVL.lss"
*
************************************************************************
*                                                                      *
*                    ######   #######  #     #  #                      *
*                    #     #  #        #     #  #                      *
*                    #     #  #        #     #  #                      *
*                    ######   #####    #     #  #                      *
*                    #   #    #         #   #   #                      *
*                    #    #   #          # #    #                      *
*                    #     #  #######     #     #######                *
*                                                                      *
* REVL                      REVERSE LIST                               *
*                                                                      *
************************************************************************
*
* REVL.lss
*
-LINE 15 "REVL.lss"
-MODULE REVL
-PUBLIC REVL()
         DEFINE('REVL(L)T')                                  :(REVL_END)
*
REVL     REVL = L
         IDENT(DATATYPE(L), 'LINK')                           :F(RETURN)
         L = NEXT(REVL)
         NEXT(REVL) =
REVL_1   IDENT(L)                                             :S(RETURN)
         T = NEXT(L)
         NEXT(L) = REVL
         REVL = L
         L = T                                                 :(REVL_1)
*
REVL_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>REVL - Reverse list</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">REVL(L)</font> returns the reverse of the list passed. Many recursive
list algorithms cons the results and thus return the answer as
a list that needs reversing.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LINK.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;REVL&raquo;&equiv;</b>
-MODULE REVL
-PUBLIC REVL()
         DEFINE(&#39;REVL(L)T&#39;)                                  <b>:(REVL_END)</b>
<font color="#818181"><i>*</i></font>
REVL     REVL = L
         IDENT(DATATYPE(L), &#39;LINK&#39;)                           <b>:F(RETURN)</b>
         L = NEXT(REVL)
         NEXT(REVL) =
REVL_1   IDENT(L)                                             <b>:S(RETURN)</b>
         T = NEXT(L)
         NEXT(L) = REVL
         REVL = L
         L = T                                                 <b>:(REVL_1)</b>
<font color="#818181"><i>*</i></font>
REVL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;REVL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL REVL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    ######   #######  #     #  #                      *</i></font>
<font color="#818181"><i>*                    #     #  #        #     #  #                      *</i></font>
<font color="#818181"><i>*                    #     #  #        #     #  #                      *</i></font>
<font color="#818181"><i>*                    ######   #####    #     #  #                      *</i></font>
<font color="#818181"><i>*                    #   #    #         #   #   #                      *</i></font>
<font color="#818181"><i>*                    #    #   #          # #    #                      *</i></font>
<font color="#818181"><i>*                    #     #  #######     #     #######                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* REVL                      REVERSE LIST                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REVL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;REVL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:19 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'REVL.INC'
-LINE 36 "REVL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>ROMAN - Roman numerals</h1>

[[ROMAN(N)]] will return the roman numeral representation of the
integer [[N]]. [[ARABIC(R)]] will return the arabic numeral for the
roman numeral [[R]].

<b>N<small>OTE</small></b> - [[0 < N < 4000]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<ROMAN>>=
-MODULE ROMAN
-PUBLIC ROMAN()
         DEFINE('ROMAN(N)T')                                :(ROMAN_END)
*
ROMAN    N RPOS(1) LEN(1) . T =                               :F(RETURN)
         '0,1I,2II,3III,4IV,5V,6VI,7VII,8VIII,9IX,'
+           T BREAK(',') . T                                 :F(FRETURN)
         ROMAN = REPLACE(ROMAN(N), 'IVXLCDM', 'XLCDM**') T
+                                                   :S(RETURN)F(FRETURN)
*
ROMAN_END
*
-PUBLIC ARABIC()
         DEFINE('ARABIC(R)T,X')                            :(ARABIC_END)
*
ARABIC   R RPOS(1) LEN(1) . T =                               :F(RETURN)
         'M1000,D500,C100,L50,X10,V5,I1,' T BREAK(',') . T   :F(FRETURN)
         T = LT(T, X) -T
         ARABIC = ARABIC + (X = T)                             :(ARABIC)
*
ARABIC_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ROMAN.INC'
         &CODE = 1
LOOP     I = I + 1
         R = ROMAN(I)
         N = ARABIC(R)
         OUTPUT = NE(I, N) 'FAIL: ' I ' ' R ' ' N
         EQ(I, N)                                                :F(END)
         LT(I, 3999)                                            :S(LOOP)
         &CODE = 0
END
@

<<>>=
-STITL ROMAN
-EJECT
*
************************************************************************
*                                                                      *
*             ######   #######  #     #     #     #     #              *
*             #     #  #     #  ##   ##    # #    ##    #              *
*             #     #  #     #  # # # #   #   #   # #   #              *
*             ######   #     #  #  #  #  #     #  #  #  #              *
*             #   #    #     #  #     #  #######  #   # #              *
*             #    #   #     #  #     #  #     #  #    ##              *
*             #     #  #######  #     #  #     #  #     #              *
*                                                                      *
* ROMAN                      ROMAN NUMERAL                             *
*                                                                      *
************************************************************************
*
* ROMAN.lss
*
<<ROMAN>>
*
* CE: .MSNOBOL4;
@
-STITL ROMAN
-EJECT
*
-LINE 57 "ROMAN.lss"
************************************************************************
*                                                                      *
*             ######   #######  #     #     #     #     #              *
*             #     #  #     #  ##   ##    # #    ##    #              *
*             #     #  #     #  # # # #   #   #   # #   #              *
*             ######   #     #  #  #  #  #     #  #  #  #              *
*             #   #    #     #  #     #  #######  #   # #              *
*             #    #   #     #  #     #  #     #  #    ##              *
*             #     #  #######  #     #  #     #  #     #              *
*                                                                      *
* ROMAN                      ROMAN NUMERAL                             *
*                                                                      *
************************************************************************
*
* ROMAN.lss
*
-LINE 15 "ROMAN.lss"
-MODULE ROMAN
-PUBLIC ROMAN()
         DEFINE('ROMAN(N)T')                                :(ROMAN_END)
*
ROMAN    N RPOS(1) LEN(1) . T =                               :F(RETURN)
         '0,1I,2II,3III,4IV,5V,6VI,7VII,8VIII,9IX,'
+           T BREAK(',') . T                                 :F(FRETURN)
         ROMAN = REPLACE(ROMAN(N), 'IVXLCDM', 'XLCDM**') T
+                                                   :S(RETURN)F(FRETURN)
*
ROMAN_END
*
-PUBLIC ARABIC()
         DEFINE('ARABIC(R)T,X')                            :(ARABIC_END)
*
ARABIC   R RPOS(1) LEN(1) . T =                               :F(RETURN)
         'M1000,D500,C100,L50,X10,V5,I1,' T BREAK(',') . T   :F(FRETURN)
         T = LT(T, X) -T
         ARABIC = ARABIC + (X = T)                             :(ARABIC)
*
ARABIC_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ROMAN - Roman numerals</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ROMAN(N)</font> will return the roman numeral representation of the
integer <font face="Source Code Pro">N</font>. <font face="Source Code Pro">ARABIC(R)</font> will return the arabic numeral for the
roman numeral <font face="Source Code Pro">R</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<b>N<small>OTE</small></b> - <font face="Source Code Pro">0 < N < 4000</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ROMAN&raquo;&equiv;</b>
-MODULE ROMAN
-PUBLIC ROMAN()
         DEFINE(&#39;ROMAN(N)T&#39;)                                <b>:(ROMAN_END)</b>
<font color="#818181"><i>*</i></font>
ROMAN    N RPOS(1) LEN(1) . T =                               <b>:F(RETURN)</b>
         &#39;0,1I,2II,3III,4IV,5V,6VI,7VII,8VIII,9IX,&#39;
+           T BREAK(&#39;,&#39;) . T                                 <b>:F(FRETURN)</b>
         ROMAN = REPLACE(ROMAN(N), &#39;IVXLCDM&#39;, &#39;XLCDM**&#39;) T
+                                                   <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
ROMAN_END
<font color="#818181"><i>*</i></font>
-PUBLIC ARABIC()
         DEFINE(&#39;ARABIC(R)T,X&#39;)                            <b>:(ARABIC_END)</b>
<font color="#818181"><i>*</i></font>
ARABIC   R RPOS(1) LEN(1) . T =                               <b>:F(RETURN)</b>
         &#39;M1000,D500,C100,L50,X10,V5,I1,&#39; T BREAK(&#39;,&#39;) . T   <b>:F(FRETURN)</b>
         T = LT(T, X) -T
         ARABIC = ARABIC + (X = T)                             <b>:(ARABIC)</b>
<font color="#818181"><i>*</i></font>
ARABIC_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ROMAN.INC&#39;
         &amp;CODE = 1
LOOP     I = I + 1
         R = ROMAN(I)
         N = ARABIC(R)
         OUTPUT = NE(I, N) &#39;FAIL: &#39; I &#39; &#39; R &#39; &#39; N
         EQ(I, N)                                                <b>:F(END)</b>
         LT(I, 3999)                                            <b>:S(LOOP)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL ROMAN
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             ######   #######  #     #     #     #     #              *</i></font>
<font color="#818181"><i>*             #     #  #     #  ##   ##    # #    ##    #              *</i></font>
<font color="#818181"><i>*             #     #  #     #  # # # #   #   #   # #   #              *</i></font>
<font color="#818181"><i>*             ######   #     #  #  #  #  #     #  #  #  #              *</i></font>
<font color="#818181"><i>*             #   #    #     #  #     #  #######  #   # #              *</i></font>
<font color="#818181"><i>*             #    #   #     #  #     #  #     #  #    ##              *</i></font>
<font color="#818181"><i>*             #     #  #######  #     #  #     #  #     #              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ROMAN                      ROMAN NUMERAL                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ROMAN.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ROMAN&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:20 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ROMAN.INC'
-LINE 42 "ROMAN.lss"
         &CODE = 1
LOOP     I = I + 1
         R = ROMAN(I)
         N = ARABIC(R)
         OUTPUT = NE(I, N) 'FAIL: ' I ' ' R ' ' N
         EQ(I, N)                                                :F(END)
         LT(I, 3999)                                            :S(LOOP)
         &CODE = 0
END
<h1>ROTATER - Rotate string</h1>

[[ROTATER(S,N)]] will rotate the string [[S]] right by [[N]]
characters. If [[N]] is negative, rotation is to the left.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<ROTATER>>=
-MODULE ROTATER
-PUBLIC ROTATER()
         DEFINE('ROTATER(S,N)S1')                         :(ROTATER_END)
*
ROTATER  IDENT(S)                                             :S(RETURN)
         N = REMDR(N, SIZE(S))
         N = LT(N, 0) SIZE(S) + N
         S RTAB(N) . S  REM . S1 = S1 S
         ROTATER = S                                           :(RETURN)
*
ROTATER_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ROTATER.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL ROTATER
-EJECT
*
************************************************************************
*                                                                      *
*    ######   #######  #######     #     #######  #######  ######      *
*    #     #  #     #     #       # #       #     #        #     #     *
*    #     #  #     #     #      #   #      #     #        #     #     *
*    ######   #     #     #     #     #     #     #####    ######      *
*    #   #    #     #     #     #######     #     #        #   #       *
*    #    #   #     #     #     #     #     #     #        #    #      *
*    #     #  #######     #     #     #     #     #######  #     #     *
*                                                                      *
* ROTATER                    ROTATE STRING                             *
*                                                                      *
************************************************************************
*
* ROTATER.lss
*
<<ROTATER>>
*
* CE: .MSNOBOL4;
@
-STITL ROTATER
-EJECT
*
-LINE 38 "ROTATER.lss"
************************************************************************
*                                                                      *
*    ######   #######  #######     #     #######  #######  ######      *
*    #     #  #     #     #       # #       #     #        #     #     *
*    #     #  #     #     #      #   #      #     #        #     #     *
*    ######   #     #     #     #     #     #     #####    ######      *
*    #   #    #     #     #     #######     #     #        #   #       *
*    #    #   #     #     #     #     #     #     #        #    #      *
*    #     #  #######     #     #     #     #     #######  #     #     *
*                                                                      *
* ROTATER                    ROTATE STRING                             *
*                                                                      *
************************************************************************
*
* ROTATER.lss
*
-LINE 12 "ROTATER.lss"
-MODULE ROTATER
-PUBLIC ROTATER()
         DEFINE('ROTATER(S,N)S1')                         :(ROTATER_END)
*
ROTATER  IDENT(S)                                             :S(RETURN)
         N = REMDR(N, SIZE(S))
         N = LT(N, 0) SIZE(S) + N
         S RTAB(N) . S  REM . S1 = S1 S
         ROTATER = S                                           :(RETURN)
*
ROTATER_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ROTATER - Rotate string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ROTATER(S,N)</font> will rotate the string <font face="Source Code Pro">S</font> right by <font face="Source Code Pro">N</font>
characters. If <font face="Source Code Pro">N</font> is negative, rotation is to the left.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ROTATER&raquo;&equiv;</b>
-MODULE ROTATER
-PUBLIC ROTATER()
         DEFINE(&#39;ROTATER(S,N)S1&#39;)                         <b>:(ROTATER_END)</b>
<font color="#818181"><i>*</i></font>
ROTATER  IDENT(S)                                             <b>:S(RETURN)</b>
         N = REMDR(N, SIZE(S))
         N = LT(N, 0) SIZE(S) + N
         S RTAB(N) . S  REM . S1 = S1 S
         ROTATER = S                                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
ROTATER_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ROTATER.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL ROTATER
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    ######   #######  #######     #     #######  #######  ######      *</i></font>
<font color="#818181"><i>*    #     #  #     #     #       # #       #     #        #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #     #      #   #      #     #        #     #     *</i></font>
<font color="#818181"><i>*    ######   #     #     #     #     #     #     #####    ######      *</i></font>
<font color="#818181"><i>*    #   #    #     #     #     #######     #     #        #   #       *</i></font>
<font color="#818181"><i>*    #    #   #     #     #     #     #     #     #        #    #      *</i></font>
<font color="#818181"><i>*    #     #  #######     #     #     #     #     #######  #     #     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ROTATER                    ROTATE STRING                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ROTATER.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ROTATER&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:20 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'ROTATER.INC'
-LINE 29 "ROTATER.lss"
         &CODE = 1
         &CODE = 0
END
<h1>ROUTING - Routing support for CGI</h1>

[[ROUTING]] implements routing for HTTP requests. The route table is
a pattern that matches the method and path_info. It sets variables
in the table passed in to ROUTING(), and sets ACTION.

<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="SDIFF.html">SDIFF</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>

<h2>See Also</h2>
<a href="CGI.html">CGI</a>

<<INCLUDES>>=
-INCLUDE 'BRKREM.INC'
-INCLUDE 'SDIFF.INC'
-INCLUDE 'UNIQUE.INC'
@

<<ROUTING>>=
-MODULE ROUTING
-PUBLIC ROUTING_INIT(), ROUTING_ADD(), ROUTING()
         DEFINE('ROUTING_INIT()')
         DEFINE('ROUTING_ADD(ROUTE,PATTERN,ACTION_)NAME,P')
         DEFINE('ROUTING(METHOD,ROUTE,VARS_)P,S')
*
         ROUTING_VAR = ':'
         ROUTING_NAME_C = &UCASE &LCASE '0123456789' '._'
         ROUTING_NAME = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789._')
         MAKE_UNIQUE('ROUTING')
*
                                                          :(ROUTING_END)
*
* INITIALIZE ROUTE. THE INITIAL ROUTE ALWAYS FAILS.
*
ROUTING_INIT
         UNIQUE_ROUTING('CLEAR')
         ROUTING_INIT = ABORT                                  :(RETURN)
*
* ADD PATTERN TO ROUTE, WITH ACTION. ON MATCH, YIELDS ACTION, AND
* SUCCESS.
*
ROUTING_ADD
         NAME = UNIQUE_ROUTING()
         $NAME = ACTION_
         P = EVAL('PATTERN *?(ACTION = ' NAME ')')
         ROUTING_ADD = P | ROUTE                               :(RETURN)
*
* MAKE A ROUTING PATTERN. METHOD WILL BE SOMETHING LIKE 'GET', 'POST',
* '', ('GET' | 'POST'). ROUTE WILL BE '/A/B/C', '/A/:VAR/C'
*
ROUTING  METHOD = IDENT(METHOD) BREAK('\')
ROUTE_3  ROUTE POS(0) BRKREM(ROUTING_VAR) . S =
         P = DIFFER(S) P S
         IDENT(ROUTE)                                        :S(ROUTE_9)
         ROUTE POS(0) LEN(1) BRKREM(ROUTING_NAME) . S =
         IDENT(S)                                            :S(ROUTE_3)
         ROUTE LEN(1) . B =                                  :F(ROUTE_4)
         P = P BREAK(B) . ($VARS_)<S> B                       :(ROUTE_3)
ROUTE_4  P = P REM . ($VARS_)<S>
ROUTE_9  ROUTING = METHOD '\' P                                :(RETURN)
*         
ROUTING_END
*
@

<<unit_test>>=
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'ROUTING.INC'
-INCLUDE 'DDT.INC'
*
         &CODE = 1
         ROUTING = ROUTING_INIT()
         ROUTING = ROUTING_ADD(ROUTING, 'A', 'ACTION 1')
         ROUTING = ROUTING_ADD(ROUTING, 'B', 'ACTION 2')
         &FULLSCAN = 1
         ACTION =
         'A' ROUTING
         OUTPUT = ACTION
         ACTION =
         'B' ROUTING
         OUTPUT = ACTION
*
* TEST COMPILING ROUTES
*
* V IS A TABLE THAT WILL STORE THE VARIABLES. METHOD WILL BE SEPARATED
* FROM PATH_INFO WITH A '\'.
*
***         DDT()
         V = TABLE()
         P = ROUTING('', '/A/B', .V)
         V = TABLE()
         '\/A/B' P :F(NOTOK)
         'POST\/A/B' P :F(NOTOK)
*
         P = ROUTING('', ':VAR', .V)
         '\/A/B' P :F(NOTOK)
         OUTPUT = V<'VAR'>
*
         P = ROUTING('', '/:VAR', .V)
         'POST\/A/B' P :F(NOTOK)
         OUTPUT = V<'VAR'>
*
         P = ROUTING('', '/:VARA/B', .V)
         '\/A/B' P :F(NOTOK)
         OUTPUT = V<'VARA'>
*
         P = ROUTING(('GET' | 'POST'), '/:VARA/:VARB', .V)
         'GET\/A/B' P :F(NOTOK)
         OUTPUT = V<'VARA'> ' ' V<'VARB'>
*
         &CODE = 0 :(END)
NOTOK    OUTPUT = 'NOT OK'
*
END
@

<<>>=
<<INCLUDES>>
-STITL ROUTING
-EJECT
*
************************************************************************
*                                                                      *
*      ######   #######  #     #  #######  ###  #     #   #####        *
*      #     #  #     #  #     #     #      #   ##    #  #     #       *
*      #     #  #     #  #     #     #      #   # #   #  #             *
*      ######   #     #  #     #     #      #   #  #  #  #  ####       *
*      #   #    #     #  #     #     #      #   #   # #  #     #       *
*      #    #   #     #  #     #     #      #   #    ##  #     #       *
*      #     #  #######   #####      #     ###  #     #   #####        *
*                                                                      *
* ROUTING                   ROUTING FOR CGI                            *
*                                                                      *
************************************************************************
*
* ROUTING.lss
*
<<ROUTING>>
*
* CE: .F.MSNOBOL4;
@
-LINE 16 "ROUTING.lss"
-INCLUDE 'BRKREM.INC'
-INCLUDE 'SDIFF.INC'
-INCLUDE 'UNIQUE.INC'
-STITL ROUTING
-EJECT
-LINE 124 "ROUTING.lss"
*
************************************************************************
*                                                                      *
*      ######   #######  #     #  #######  ###  #     #   #####        *
*      #     #  #     #  #     #     #      #   ##    #  #     #       *
*      #     #  #     #  #     #     #      #   # #   #  #             *
*      ######   #     #  #     #     #      #   #  #  #  #  ####       *
*      #   #    #     #  #     #     #      #   #   # #  #     #       *
*      #    #   #     #  #     #     #      #   #    ##  #     #       *
*      #     #  #######   #####      #     ###  #     #   #####        *
*                                                                      *
* ROUTING                   ROUTING FOR CGI                            *
*                                                                      *
************************************************************************
*
* ROUTING.lss
*
-LINE 22 "ROUTING.lss"
-MODULE ROUTING
-PUBLIC ROUTING_INIT(), ROUTING_ADD(), ROUTING()
         DEFINE('ROUTING_INIT()')
         DEFINE('ROUTING_ADD(ROUTE,PATTERN,ACTION_)NAME,P')
         DEFINE('ROUTING(METHOD,ROUTE,VARS_)P,S')
*
         ROUTING_VAR = ':'
         ROUTING_NAME_C = &UCASE &LCASE '0123456789' '._'
         ROUTING_NAME = SDIFF(&ALPHABET, &UCASE &LCASE '0123456789._')
         MAKE_UNIQUE('ROUTING')
*
                                                          :(ROUTING_END)
*
* INITIALIZE ROUTE. THE INITIAL ROUTE ALWAYS FAILS.
*
ROUTING_INIT
         UNIQUE_ROUTING('CLEAR')
         ROUTING_INIT = ABORT                                  :(RETURN)
*
* ADD PATTERN TO ROUTE, WITH ACTION. ON MATCH, YIELDS ACTION, AND
* SUCCESS.
*
ROUTING_ADD
         NAME = UNIQUE_ROUTING()
         $NAME = ACTION_
         P = EVAL('PATTERN *?(ACTION = ' NAME ')')
         ROUTING_ADD = P | ROUTE                               :(RETURN)
*
* MAKE A ROUTING PATTERN. METHOD WILL BE SOMETHING LIKE 'GET', 'POST',
* '', ('GET' | 'POST'). ROUTE WILL BE '/A/B/C', '/A/:VAR/C'
*
ROUTING  METHOD = IDENT(METHOD) BREAK('\')
ROUTE_3  ROUTE POS(0) BRKREM(ROUTING_VAR) . S =
         P = DIFFER(S) P S
         IDENT(ROUTE)                                        :S(ROUTE_9)
         ROUTE POS(0) LEN(1) BRKREM(ROUTING_NAME) . S =
         IDENT(S)                                            :S(ROUTE_3)
         ROUTE LEN(1) . B =                                  :F(ROUTE_4)
         P = P BREAK(B) . ($VARS_)<S> B                       :(ROUTE_3)
ROUTE_4  P = P REM . ($VARS_)<S>
ROUTE_9  ROUTING = METHOD '\' P                                :(RETURN)
*
ROUTING_END
*
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>ROUTING - Routing support for CGI</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ROUTING</font> implements routing for HTTP requests. The route table is
a pattern that matches the method and path_info. It sets variables
in the table passed in to ROUTING(), and sets ACTION.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="SDIFF.html">SDIFF</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="CGI.html">CGI</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BRKREM.INC&#39;
-INCLUDE &#39;SDIFF.INC&#39;
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;ROUTING&raquo;&equiv;</b>
-MODULE ROUTING
-PUBLIC ROUTING_INIT(), ROUTING_ADD(), ROUTING()
         DEFINE(&#39;ROUTING_INIT()&#39;)
         DEFINE(&#39;ROUTING_ADD(ROUTE,PATTERN,ACTION_)NAME,P&#39;)
         DEFINE(&#39;ROUTING(METHOD,ROUTE,VARS_)P,S&#39;)
<font color="#818181"><i>*</i></font>
         ROUTING_VAR = &#39;:&#39;
         ROUTING_NAME_C = &amp;UCASE &amp;LCASE &#39;0123456789&#39; &#39;._&#39;
         ROUTING_NAME = SDIFF(&amp;ALPHABET, &amp;UCASE &amp;LCASE &#39;0123456789._&#39;)
         MAKE_UNIQUE(&#39;ROUTING&#39;)
<font color="#818181"><i>*</i></font>
                                                          <b>:(ROUTING_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INITIALIZE ROUTE. THE INITIAL ROUTE ALWAYS FAILS.</i></font>
<font color="#818181"><i>*</i></font>
ROUTING_INIT
         UNIQUE_ROUTING(&#39;CLEAR&#39;)
         ROUTING_INIT = ABORT                                  <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ADD PATTERN TO ROUTE, WITH ACTION. ON MATCH, YIELDS ACTION, AND</i></font>
<font color="#818181"><i>* SUCCESS.</i></font>
<font color="#818181"><i>*</i></font>
ROUTING_ADD
         NAME = UNIQUE_ROUTING()
         $NAME = ACTION_
         P = EVAL(&#39;PATTERN *?(ACTION = &#39; NAME &#39;)&#39;)
         ROUTING_ADD = P | ROUTE                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAKE A ROUTING PATTERN. METHOD WILL BE SOMETHING LIKE &#39;GET&#39;, &#39;POST&#39;,</i></font>
<font color="#818181"><i>* &#39;&#39;, (&#39;GET&#39; | &#39;POST&#39;). ROUTE WILL BE &#39;/A/B/C&#39;, &#39;/A/:VAR/C&#39;</i></font>
<font color="#818181"><i>*</i></font>
ROUTING  METHOD = IDENT(METHOD) BREAK(&#39;\&#39;)
ROUTE_3  ROUTE POS(0) BRKREM(ROUTING_VAR) . S =
         P = DIFFER(S) P S
         IDENT(ROUTE)                                        <b>:S(ROUTE_9)</b>
         ROUTE POS(0) LEN(1) BRKREM(ROUTING_NAME) . S =
         IDENT(S)                                            <b>:S(ROUTE_3)</b>
         ROUTE LEN(1) . B =                                  <b>:F(ROUTE_4)</b>
         P = P BREAK(B) . ($VARS_)&lt;S&gt; B                       <b>:(ROUTE_3)</b>
ROUTE_4  P = P REM . ($VARS_)&lt;S&gt;
ROUTE_9  ROUTING = METHOD &#39;\&#39; P                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
ROUTING_END
<font color="#818181"><i>*</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;ROUTING.INC&#39;
-INCLUDE &#39;DDT.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         ROUTING = ROUTING_INIT()
         ROUTING = ROUTING_ADD(ROUTING, &#39;A&#39;, &#39;ACTION 1&#39;)
         ROUTING = ROUTING_ADD(ROUTING, &#39;B&#39;, &#39;ACTION 2&#39;)
         &amp;FULLSCAN = 1
         ACTION =
         &#39;A&#39; ROUTING
         OUTPUT = ACTION
         ACTION =
         &#39;B&#39; ROUTING
         OUTPUT = ACTION
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TEST COMPILING ROUTES</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* V IS A TABLE THAT WILL STORE THE VARIABLES. METHOD WILL BE SEPARATED</i></font>
<font color="#818181"><i>* FROM PATH_INFO WITH A &#39;\&#39;.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>***         DDT()</i></font>
         V = TABLE()
         P = ROUTING(&#39;&#39;, &#39;/A/B&#39;, .V)
         V = TABLE()
         &#39;\/A/B&#39; P <b>:F(NOTOK)</b>
         &#39;POST\/A/B&#39; P <b>:F(NOTOK)</b>
<font color="#818181"><i>*</i></font>
         P = ROUTING(&#39;&#39;, &#39;:VAR&#39;, .V)
         &#39;\/A/B&#39; P <b>:F(NOTOK)</b>
         OUTPUT = V&lt;&#39;VAR&#39;&gt;
<font color="#818181"><i>*</i></font>
         P = ROUTING(&#39;&#39;, &#39;/:VAR&#39;, .V)
         &#39;POST\/A/B&#39; P <b>:F(NOTOK)</b>
         OUTPUT = V&lt;&#39;VAR&#39;&gt;
<font color="#818181"><i>*</i></font>
         P = ROUTING(&#39;&#39;, &#39;/:VARA/B&#39;, .V)
         &#39;\/A/B&#39; P <b>:F(NOTOK)</b>
         OUTPUT = V&lt;&#39;VARA&#39;&gt;
<font color="#818181"><i>*</i></font>
         P = ROUTING((&#39;GET&#39; | &#39;POST&#39;), &#39;/:VARA/:VARB&#39;, .V)
         &#39;GET\/A/B&#39; P <b>:F(NOTOK)</b>
         OUTPUT = V&lt;&#39;VARA&#39;&gt; &#39; &#39; V&lt;&#39;VARB&#39;&gt;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 0 <b>:(END)</b>
NOTOK    OUTPUT = &#39;NOT OK&#39;
<font color="#818181"><i>*</i></font>
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL ROUTING
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*      ######   #######  #     #  #######  ###  #     #   #####        *</i></font>
<font color="#818181"><i>*      #     #  #     #  #     #     #      #   ##    #  #     #       *</i></font>
<font color="#818181"><i>*      #     #  #     #  #     #     #      #   # #   #  #             *</i></font>
<font color="#818181"><i>*      ######   #     #  #     #     #      #   #  #  #  #  ####       *</i></font>
<font color="#818181"><i>*      #   #    #     #  #     #     #      #   #   # #  #     #       *</i></font>
<font color="#818181"><i>*      #    #   #     #  #     #     #      #   #    ##  #     #       *</i></font>
<font color="#818181"><i>*      #     #  #######   #####      #     ###  #     #   #####        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* ROUTING                   ROUTING FOR CGI                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ROUTING.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;ROUTING&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:47 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'ROUTING.INC'
-LINE 72 "ROUTING.lss"
-INCLUDE 'DDT.INC'
*
         &CODE = 1
         ROUTING = ROUTING_INIT()
         ROUTING = ROUTING_ADD(ROUTING, 'A', 'ACTION 1')
         ROUTING = ROUTING_ADD(ROUTING, 'B', 'ACTION 2')
         &FULLSCAN = 1
         ACTION =
         'A' ROUTING
         OUTPUT = ACTION
         ACTION =
         'B' ROUTING
         OUTPUT = ACTION
*
* TEST COMPILING ROUTES
*
* V IS A TABLE THAT WILL STORE THE VARIABLES. METHOD WILL BE SEPARATED
* FROM PATH_INFO WITH A '\'.
*
***         DDT()
         V = TABLE()
         P = ROUTING('', '/A/B', .V)
         V = TABLE()
         '\/A/B' P :F(NOTOK)
         'POST\/A/B' P :F(NOTOK)
*
         P = ROUTING('', ':VAR', .V)
         '\/A/B' P :F(NOTOK)
         OUTPUT = V<'VAR'>
*
         P = ROUTING('', '/:VAR', .V)
         'POST\/A/B' P :F(NOTOK)
         OUTPUT = V<'VAR'>
*
         P = ROUTING('', '/:VARA/B', .V)
         '\/A/B' P :F(NOTOK)
         OUTPUT = V<'VARA'>
*
         P = ROUTING(('GET' | 'POST'), '/:VARA/:VARB', .V)
         'GET\/A/B' P :F(NOTOK)
         OUTPUT = V<'VARA'> ' ' V<'VARB'>
*
         &CODE = 0 :(END)
NOTOK    OUTPUT = 'NOT OK'
*
END
<h1>rseq</h1>

Add sequence numbers on right for FORTRAN.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<rseq>>=
         TERMINAL = 'RSEQ (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 72)
         Z = DUPL('0', 7)
         N = 10
*
TOP      (INPUT S) LEN(72) . L                                   :F(END)
         (Z N) LEN(7) . R RPOS(0)
         N = N + 10
         OUTPUT = L ' ' R                                         :(TOP)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM RSEQ
-TITLE RSEQ
START
*
************************************************************************
*                                                                      *
*                  ######    #####   #######   #####                   *
*                  #     #  #     #  #        #     #                  *
*                  #     #  #        #        #     #                  *
*                  ######    #####   #####    #     #                  *
*                  #   #          #  #        #   # #                  *
*                  #    #   #     #  #        #    #                   *
*                  #     #   #####   #######   #### #                  *
*                                                                      *
* RSEQ            SEQUENCE NUMBER A SOURCE DECK (73-80)                *
*                                                                      *
************************************************************************
*
* rseq.lss
*
<<rseq>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM RSEQ
-LINE 29 "rseq.lss"
-TITLE RSEQ
START
*
************************************************************************
*                                                                      *
*                  ######    #####   #######   #####                   *
*                  #     #  #     #  #        #     #                  *
*                  #     #  #        #        #     #                  *
*                  ######    #####   #####    #     #                  *
*                  #   #          #  #        #   # #                  *
*                  #    #   #     #  #        #    #                   *
*                  #     #   #####   #######   #### #                  *
*                                                                      *
* RSEQ            SEQUENCE NUMBER A SOURCE DECK (73-80)                *
*                                                                      *
************************************************************************
*
* rseq.lss
*
-LINE 11 "rseq.lss"
         TERMINAL = 'RSEQ (SUN JUN 16 14:13:20 EDT 2013)'
*
         S = DUPL(' ', 72)
         Z = DUPL('0', 7)
         N = 10
*
TOP      (INPUT S) LEN(72) . L                                   :F(END)
         (Z N) LEN(7) . R RPOS(0)
         N = N + 10
         OUTPUT = L ' ' R                                         :(TOP)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>rseq</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Add sequence numbers on right for FORTRAN.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;rseq&raquo;&equiv;</b>
         TERMINAL = &#39;RSEQ (SUN JUN 16 14:13:20 EDT 2013)&#39;
<font color="#818181"><i>*</i></font>
         S = DUPL(&#39; &#39;, 72)
         Z = DUPL(&#39;0&#39;, 7)
         N = 10
<font color="#818181"><i>*</i></font>
TOP      (INPUT S) LEN(72) . L                                   <b>:F(END)</b>
         (Z N) LEN(7) . R RPOS(0)
         N = N + 10
         OUTPUT = L &#39; &#39; R                                         <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM RSEQ
-TITLE RSEQ
START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  ######    #####   #######   #####                   *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #        #     #                  *</i></font>
<font color="#818181"><i>*                  #     #  #        #        #     #                  *</i></font>
<font color="#818181"><i>*                  ######    #####   #####    #     #                  *</i></font>
<font color="#818181"><i>*                  #   #          #  #        #   # #                  *</i></font>
<font color="#818181"><i>*                  #    #   #     #  #        #    #                   *</i></font>
<font color="#818181"><i>*                  #     #   #####   #######   #### #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* RSEQ            SEQUENCE NUMBER A SOURCE DECK (73-80)                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* rseq.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;rseq&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:21 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<H1>scan - Scan extension for cpmed</H1>

Use passed pattern to scan input. Output line deltas to next match
line.

Usage: as an editor command for [[cpmed]], try:

[[
b-#.!scan /G %LAST
.n$
&amp;l
&amp;l
]]

This sequence sets the current point to the beginning of the buffer.
All lines are piped to the [[scan]] command with an argument of
[['LAST']].  The output which is the line deltas to each matching
line are save to file [[$]] (the default transfer file). Set the index
file to [[$]].  Read the index file, and move forward that many lines,
positioning to the first occurence of [['LAST']]. Repeat.

Using <i>scan</i> from <i>cpmed</i> is slightly automated. The |
command in <i>cpmed</i> calls the scan command. This feature is still
being refined.

Command quoting is a bit tricky, because [[shell]] must be accomodated.
Also, only a single file can be edited by [[cpmed]] at a time. The
transfer file is automatically erased by [[cpmed]]. Any SNOBOL4
pattern can be used.

We ease quoting the following way. If an argument begins with %, we
strip the % and surround the argument with single quotes ('). Since
arguments are delimited by spaces and we put a single space between
when assembling the command, this works well (saves many 3 characters
per literal).

The first argument can be / which is followed by G. If /G is specified
for a FIND, all matching lines numbers are output.

A substitute is identified if one of the arguments is =.  If substitute
then substituted line is output, else relative line from top of file,
followed by relative line from current line (cpmed L arguments).

G for substitute means substitute on all lines, all occurences on each
line. Not using G only substitutes the first occurence on each of the
lines.

<h2>Uses</h2>
<a href="HOST.html">HOST</a><br>
<a href="SLOAD.html">SLOAD</a><br>

<<INCLUDES>>=
-INCLUDE 'HOST.INC'
-INCLUDE 'SLOAD.INC'
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM SCAN
-TITLE SCAN
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                   #####    #####      #     #     #                  *
*                  #     #  #     #    # #    ##    #                  *
*                  #        #         #   #   # #   #                  *
*                   #####   #        #     #  #  #  #                  *
*                        #  #        #######  #   # #                  *
*                  #     #  #     #  #     #  #    ##                  *
*                   #####    #####   #     #  #     #                  *
*                                                                      *
* SCAN                  SCAN LINES FOR PATTERN                         *
*                                                                      *
************************************************************************
*
* scan.lss
*
         TERMINAL = 'SCAN (MON JAN 27 14:19:34 EST 2014)'
*
         &CODE = 1
         SLOAD('SCAN.INC')
         LINE_NUMBER =
         LAST_LINE = 1
         N = HOST(HOST_FIRSTARG)
* POSSIBLE /G ARGUMENT
         O = HOST(HOST_ARGN, N)                                  :F(END)
         O POS(0) '/'                                            :F(CLL)
         N = N + 1
         G = ?(O ? ANY('Gg')) 1
                                                                 :(CLL2)
* COLLECT FIND OR SUBSTITUTE STATEMENT. IF '=' IS ARGUMENT THEN
* COMMAND IS SUBSTITUTE
CLL      SUB = ?(O ? (POS(0) '=' RPOS(0))) 1                    :S(ADDS)
         O POS(0) '%'                                           :F(ADDS)
         O POS(0) LEN(1) REM . O
         O = "'" O "'"
ADDS     S = S ' ' O
         N = N + 1
CLL2     O = HOST(HOST_ARGN, N)                                  :S(CLL)
*
TOPAT    TERMINAL = IDENT(SUB) 'FIND: ' S
         TERMINAL = DIFFER(SUB) IDENT(G) 'SUBSTITUTE: ' S
         TERMINAL = DIFFER(SUB) DIFFER(G) 'SUBSTITUTE GLOBAL: ' S
* EMPTY STATEMENT IS NO OPERATION
         S = TRIM(S)
         IDENT(S)                                                :S(END)
* COMPILE STATEMENT AS A NON-G COMMAND FIRST. ADDS LABELS
         LB = DIFFER(SUB) ' :(BTM)'
         LB = IDENT(SUB) ' :S(BTM)F(TOP)'
         C = CODE(' LINE ' S LB)                              :F(SYNTAX)
         IDENT(SUB)                                              :S(TOP)
         IDENT(G)                                                :S(TOP)
* IF S AND G, ADD LOCAL LOOP.
         C = CODE('LUP LINE ' S ' :S(LUP)F(BTM)')             :F(SYNTAX)
*
TOP      LINE = INPUT                                            :F(END)
         LINE_NUMBER = LINE_NUMBER + 1                              :<C>
*
BTM      &CODE = 0
         OUTPUT = DIFFER(SUB) LINE                              :S(BTM2)
         OUTPUT = LINE_NUMBER - LAST_LINE
         LAST_LINE = LINE_NUMBER
BTM2     DIFFER(SUB)                                             :S(TOP)
         IDENT(G)                                          :S(END)F(TOP)
SYNTAX   TERMINAL = 'SYNTAX ERROR IN ' S
END
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM SCAN
-LINE 61 "scan.lss"
-TITLE SCAN
START
-LINE 53 "scan.lss"
-INCLUDE 'HOST.INC'
-INCLUDE 'SLOAD.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                   #####    #####      #     #     #                  *
*                  #     #  #     #    # #    ##    #                  *
*                  #        #         #   #   # #   #                  *
*                   #####   #        #     #  #  #  #                  *
*                        #  #        #######  #   # #                  *
*                  #     #  #     #  #     #  #    ##                  *
*                   #####    #####   #     #  #     #                  *
*                                                                      *
* SCAN                  SCAN LINES FOR PATTERN                         *
*                                                                      *
************************************************************************
*
* scan.lss
*
         TERMINAL = 'SCAN (MON JAN 27 14:19:34 EST 2014)'
*
         &CODE = 1
         SLOAD('SCAN.INC')
         LINE_NUMBER =
         LAST_LINE = 1
         N = HOST(HOST_FIRSTARG)
* POSSIBLE /G ARGUMENT
         O = HOST(HOST_ARGN, N)                                  :F(END)
         O POS(0) '/'                                            :F(CLL)
         N = N + 1
         G = ?(O ? ANY('Gg')) 1
                                                                 :(CLL2)
* COLLECT FIND OR SUBSTITUTE STATEMENT. IF '=' IS ARGUMENT THEN
* COMMAND IS SUBSTITUTE
CLL      SUB = ?(O ? (POS(0) '=' RPOS(0))) 1                    :S(ADDS)
         O POS(0) '%'                                           :F(ADDS)
         O POS(0) LEN(1) REM . O
         O = "'" O "'"
ADDS     S = S ' ' O
         N = N + 1
CLL2     O = HOST(HOST_ARGN, N)                                  :S(CLL)
*
TOPAT    TERMINAL = IDENT(SUB) 'FIND: ' S
         TERMINAL = DIFFER(SUB) IDENT(G) 'SUBSTITUTE: ' S
         TERMINAL = DIFFER(SUB) DIFFER(G) 'SUBSTITUTE GLOBAL: ' S
* EMPTY STATEMENT IS NO OPERATION
         S = TRIM(S)
         IDENT(S)                                                :S(END)
* COMPILE STATEMENT AS A NON-G COMMAND FIRST. ADDS LABELS
         LB = DIFFER(SUB) ' :(BTM)'
         LB = IDENT(SUB) ' :S(BTM)F(TOP)'
         C = CODE(' LINE ' S LB)                              :F(SYNTAX)
         IDENT(SUB)                                              :S(TOP)
         IDENT(G)                                                :S(TOP)
* IF S AND G, ADD LOCAL LOOP.
         C = CODE('LUP LINE ' S ' :S(LUP)F(BTM)')             :F(SYNTAX)
*
TOP      LINE = INPUT                                            :F(END)
         LINE_NUMBER = LINE_NUMBER + 1                              :<C>
*
BTM      &CODE = 0
         OUTPUT = DIFFER(SUB) LINE                              :S(BTM2)
         OUTPUT = LINE_NUMBER - LAST_LINE
         LAST_LINE = LINE_NUMBER
BTM2     DIFFER(SUB)                                             :S(TOP)
         IDENT(G)                                          :S(END)F(TOP)
SYNTAX   TERMINAL = 'SYNTAX ERROR IN ' S
END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>scan - Scan extension for cpmed</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Use passed pattern to scan input. Output line deltas to next match
line.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Usage: as an editor command for <font face="Source Code Pro">cpmed</font>, try:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| b-#.!scan /G %LAST
| .n$
| &amp;l
| &amp;l
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This sequence sets the current point to the beginning of the buffer.
All lines are piped to the <font face="Source Code Pro">scan</font> command with an argument of
<font face="Source Code Pro">'LAST'</font>.  The output which is the line deltas to each matching
line are save to file <font face="Source Code Pro">$</font> (the default transfer file). Set the index
file to <font face="Source Code Pro">$</font>.  Read the index file, and move forward that many lines,
positioning to the first occurence of <font face="Source Code Pro">'LAST'</font>. Repeat.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Using <i>scan</i> from <i>cpmed</i> is slightly automated. The |
command in <i>cpmed</i> calls the scan command. This feature is still
being refined.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Command quoting is a bit tricky, because <font face="Source Code Pro">shell</font> must be accomodated.
Also, only a single file can be edited by <font face="Source Code Pro">cpmed</font> at a time. The
transfer file is automatically erased by <font face="Source Code Pro">cpmed</font>. Any SNOBOL4
pattern can be used.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
We ease quoting the following way. If an argument begins with %, we
strip the % and surround the argument with single quotes ('). Since
arguments are delimited by spaces and we put a single space between
when assembling the command, this works well (saves many 3 characters
per literal).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The first argument can be / which is followed by G. If /G is specified
for a FIND, all matching lines numbers are output.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
A substitute is identified if one of the arguments is =.  If substitute
then substituted line is output, else relative line from top of file,
followed by relative line from current line (cpmed L arguments).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
G for substitute means substitute on all lines, all occurences on each
line. Not using G only substitutes the first occurence on each of the
lines.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="HOST.html">HOST</a><br>
<a href="SLOAD.html">SLOAD</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;SLOAD.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM SCAN
-TITLE SCAN
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   #####    #####      #     #     #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #    # #    ##    #                  *</i></font>
<font color="#818181"><i>*                  #        #         #   #   # #   #                  *</i></font>
<font color="#818181"><i>*                   #####   #        #     #  #  #  #                  *</i></font>
<font color="#818181"><i>*                        #  #        #######  #   # #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #     #  #    ##                  *</i></font>
<font color="#818181"><i>*                   #####    #####   #     #  #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SCAN                  SCAN LINES FOR PATTERN                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* scan.lss</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;SCAN (MON JAN 27 14:19:34 EST 2014)&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         SLOAD(&#39;SCAN.INC&#39;)
         LINE_NUMBER =
         LAST_LINE = 1
         N = HOST(HOST_FIRSTARG)
<font color="#818181"><i>* POSSIBLE /G ARGUMENT</i></font>
         O = HOST(HOST_ARGN, N)                                  <b>:F(END)</b>
         O POS(0) &#39;/&#39;                                            <b>:F(CLL)</b>
         N = N + 1
         G = ?(O ? ANY(&#39;Gg&#39;)) 1
                                                                 <b>:(CLL2)</b>
<font color="#818181"><i>* COLLECT FIND OR SUBSTITUTE STATEMENT. IF &#39;=&#39; IS ARGUMENT THEN</i></font>
<font color="#818181"><i>* COMMAND IS SUBSTITUTE</i></font>
CLL      SUB = ?(O ? (POS(0) &#39;=&#39; RPOS(0))) 1                    <b>:S(ADDS)</b>
         O POS(0) &#39;%&#39;                                           <b>:F(ADDS)</b>
         O POS(0) LEN(1) REM . O
         O = &quot;&#39;&quot; O &quot;&#39;&quot;
ADDS     S = S &#39; &#39; O
         N = N + 1
CLL2     O = HOST(HOST_ARGN, N)                                  <b>:S(CLL)</b>
<font color="#818181"><i>*</i></font>
TOPAT    TERMINAL = IDENT(SUB) &#39;FIND: &#39; S
         TERMINAL = DIFFER(SUB) IDENT(G) &#39;SUBSTITUTE: &#39; S
         TERMINAL = DIFFER(SUB) DIFFER(G) &#39;SUBSTITUTE GLOBAL: &#39; S
<font color="#818181"><i>* EMPTY STATEMENT IS NO OPERATION</i></font>
         S = TRIM(S)
         IDENT(S)                                                <b>:S(END)</b>
<font color="#818181"><i>* COMPILE STATEMENT AS A NON-G COMMAND FIRST. ADDS LABELS</i></font>
         LB = DIFFER(SUB) &#39; :(BTM)&#39;
         LB = IDENT(SUB) &#39; :S(BTM)F(TOP)&#39;
         C = CODE(&#39; LINE &#39; S LB)                              <b>:F(SYNTAX)</b>
         IDENT(SUB)                                              <b>:S(TOP)</b>
         IDENT(G)                                                <b>:S(TOP)</b>
<font color="#818181"><i>* IF S AND G, ADD LOCAL LOOP.</i></font>
         C = CODE(&#39;LUP LINE &#39; S &#39; :S(LUP)F(BTM)&#39;)             <b>:F(SYNTAX)</b>
<font color="#818181"><i>*</i></font>
TOP      LINE = INPUT                                            <b>:F(END)</b>
         LINE_NUMBER = LINE_NUMBER + 1                              <b>:&lt;C&gt;</b>
<font color="#818181"><i>*</i></font>
BTM      &amp;CODE = 0
         OUTPUT = DIFFER(SUB) LINE                              <b>:S(BTM2)</b>
         OUTPUT = LINE_NUMBER - LAST_LINE
         LAST_LINE = LINE_NUMBER
BTM2     DIFFER(SUB)                                             <b>:S(TOP)</b>
         IDENT(G)                                          <b>:S(END)F(TOP)</b>
SYNTAX   TERMINAL = &#39;SYNTAX ERROR IN &#39; S
END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:38 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>SCOOP - Object Oriented Programming</h1>

SCOOP implements a simple OOP system. Single inheritance only. Allows
creation of classes and objects. Does not dispatch based on type of
arguments; simply on method name. STACK illustrates another way to
do OOP programming. SCOOP is (likely) better for structuring
larger programs. STACK is far better for performance. STACK creates
a family of routines, with no overhead for dispatch.

SCOOP is deliberately simple. It is designed to provide a very
thin object layer to allow better variable control, and allow the
elimination of some labels. It is designed to allow for trivial
monkey patching. Indeed, that is the normal way to add methods.
Methods may also be added to objects directly!

[[THIS]] refers to the receiver of a message (sometimes known as
self). [[SELF()]] dispatches messages from a method to the same
receiver. [[SUPER()]] does the same, but begins the dispatch search
with the superclass of the receiver.

[[
IVARS(THIS)<'VARIABLE NAME'>
]]

accesses instance variable [[VARIABLE NAME]] in the receiver. We
OPSYN unary operator | to simplify this. [[|'var']] or [[|.var]]
refers to instance variable [[var]] and can be used on either the
left or right side of an assignment.

{{
[[^]] is usable as a unary operator in CSNOBOL4. SPITBOL.EXE does
not support this. To accomodate, [[|]] is now used as the instance
variable access operator. This works on both systems. Change the
[[OPSYN()]] statement as appropriate if you want another operator.
}}

[[SEND(OBJECT,MESSAGE,ARGS)]] dispatches a message to the receiver,
with up to eight arguments.

SCOOP is very useful in hiding variables. SNOBOL4 does not have
any concept of scope. Bundling variables together into an object is
one way of controlling this complexity. Thus the given name SCOOP
which evokes OOP, scope and ice-cream scoops. Or SNOBOL4 Crummy
Object Oriented Programming.

[[ADD_METHOD]] can add either a name of a function to dispatch, or
[[CODE()]]. The code compiled is run in the context of [[SEND()]].
Arguments A1 through A8 are available, and three temporaries T1 through
T3. The method result should be assigned to the variable [[SEND]].
[[THIS]] is assigned to the receiver object.

[[CLASS_OF()]] is primarily for development. It returns the name of
the class the object is in. It does so without using [[SEND()]],
but is aware of object structure. [[CLASS(OBJECT)]] evaluates to
the class of an object. [[CLASS(CLASS(OBJECT))]] is the superclass
(base class). Every object has a class, <i>including</i> classes!
The only exception is the [[CLASS]] class, which has a [[NULL]] class.

[[IS_A]] succeeds if the object is in the class given, or in a
subclass. If not, it fails.

After initialize, only a single class exists: [[CLASS]]. [[CLASS]]
has methods [[NEW_CLASS]], [[NEW]], [[ADD_METHOD]], [[INIT]], [[IS_A]]
and [[DOES_NOT_UNDERSTAND]] pre-defined.

Objects are created with [[NEW]]. After the object is created, it
should be initialized, so [[NEW]] dispatches the message [[INIT]]
to the newly created object. The CLASS class implements an empty
[[INIT]] method, ensuring that this will not cause problems if not
implemented in sub-classes.

The [[SEND()]] function can be used outside or inside of
a method.  [[SELF()]] and [[SUPER()]] can only be used inside a
method. [[IVAR()]], [[CVAR()]] (and the [[^]] operator) are restricted
to within a method only. [[CLASS_OF()]] can be used wherever [[SEND()]]
can be used.

If a selector (method) is not matched, the search is done again,
dispatching selector 'DOES_NOT_UNDERSTAND' to the object. If a class
contains an implementation for this message, the exception can be
handled (say, by loading the method implementation, dispatching it
again, and returning the result). The [[CLASS]] class implementation
for [[DOES_NOT_UNDERSTAND]] displays an error and terminates the
program.

We don't expect the class tree to be very deep. SCOOP is designed
as a light OOP tool to aid in variable management. Some subclassing
is expected, but very deep class trees are not well (effiently)
supported. There is no method caching, so every method dispatch will
do a tree search.

String comparisions in SNOBOL4 are inexpensive. A string compare is
a pointer compare. This means that representing messages by strings
is a reasonable choice.

<h2>Uses</h2>
<a href="VDIFFER.html">VDIFFER</a><br>

<h2>See Also</h2>
<a href="STACK.html">STACK</a>

<<INCLUDES>>=
-INCLUDE 'VDIFFER.INC'
@

<<SCOOP>>=
-MODULE SCOOP
-PUBLIC OBJECT()
         DATA('OBJECT(CLASS,IVARS,METHODS)')
*
-PUBLIC SEND(), SUPER(), SELF(), IVAR(), CVAR(), CLASS_OF(), |1
         DEFINE('SEND(THIS,METHOD,A1,A2,A3,A4,A5,A6,A7,A8)'
+               'C,M,M_CLASS,T1,T2,T3')
         DEFINE('SUPER(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
         DEFINE('SELF(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
         DEFINE('FIND_METHOD(OBJ,METHOD)')
         DEFINE('IVAR(NAME)')
         DEFINE('CVAR(NAME)')
         DEFINE('CLASS_OF(OBJ)')
         OPSYN('|', 'IVAR', 1)
*
* INITIALIZE OOP SYSTEM, CREATE ROOT CLASS. MAKE SURE ROOT CLASS CAN
* ANSWER NEW_CLASS, NEW, INIT, DOES_NOT_UNDERSTAND AND ADD_METHOD
* MESSAGES. ALSO, ANSWER THE IS_A MESSAGE.
*
-PUBLIC CLASS:CLASS
         CLASS = OBJECT(, TABLE(), TABLE())
         IVARS(CLASS)<'CLASS'> = 'CLASS'
-PUBLIC CLASS:'ADD_METHOD'
         METHODS(CLASS)<'ADD_METHOD'> =
+           CODE(
+              ' METHODS(THIS) = IDENT(METHODS(THIS)) TABLE();'
+              ' THAW(METHODS(THIS));'
+              ' METHODS(THIS)<A1> = A2;'
+              ' FREEZE(METHODS(THIS)) :(RETURN)')
*
-PUBLIC CLASS:'NEW_CLASS'
         SEND(CLASS, 'ADD_METHOD', 'NEW_CLASS',
+           CODE(
+              ' THIS = OBJECT(THIS);'
+              ' IVAR("CLASS") = A1;'
+              ' SEND = THIS :(RETURN)'))
-PUBLIC CLASS:'INIT'
         SEND(CLASS, 'ADD_METHOD', 'INIT',
+           CODE(' :(RETURN)'))
-PUBLIC CLASS:'NEW'
         SEND(CLASS, 'ADD_METHOD', 'NEW',
+           CODE(
+              ' THIS = OBJECT(THIS);'
+              ' SELF("INIT", A1, A2, A3, A4, A5, A6, A7, A8);'
+              ' SEND = THIS :(RETURN)'))
-PUBLIC CLASS:'DOES_NOT_UNDERSTAND'
         SEND(CLASS, 'ADD_METHOD', 'DOES_NOT_UNDERSTAND',
+           CODE(
+            " TERMINAL = 'SCOOP: DOES NOT UNDERSTAND ' METHOD :(END)"))
         DEFINE('IS_A(ACLASS)')
-PUBLIC CLASS:'IS_A'
         SEND(CLASS, 'ADD_METHOD', 'IS_A', 'IS_A')
                                                              :(OOP_END)
*
* IS_A - IS OBJECT IN CLASS? ACLASS CAN BE A STRING WITH A CLASS NAME
*        OR A CLASS OBJECT
*
IS_A     T1 = THIS
IS_A_2   T1 = CLASS(T1)
         IDENT(T1)                                           :S(FRETURN)
         IDENT(T1, ACLASS)                                    :S(RETURN)
         IDENT(IVARS(T1)<'CLASS'>, ACLASS)           :S(RETURN)F(IS_A_2)
*
* ACCESS INSTANCE VARIABLE. CREATE THE INSTANCE VARIABLES IF THEY DO
* NOT YET EXIST.
*
IVAR     IVARS(THIS) = IDENT(IVARS(THIS)) TABLE()
         IVAR = .(IVARS(THIS)<NAME>)                          :(NRETURN)
*
* ACCESS CLASS VARIABLE
*
CVAR     IVARS(CLASS(THIS)) = IDENT(IVARS(CLASS(THIS))) TABLE()
         CVAR = .(IVARS(CLASS(THIS))<NAME>)                   :(NRETURN)
*
* CLASS_OF RETURNS THE NAME OF THE CLASS OF THE PASSED OBJECT. THE
* CLASS NAMES SHOULD BE UNIQUE WITHIN A PROGRAM. THE ROOT CLASS HAS
* NAME 'CLASS' (ROOT'S SUPERCLASS IS NULL)
*
CLASS_OF CLASS_OF = IVARS(CLASS(OBJ))<'CLASS'>                 :(RETURN)
*
* FIND METHOD BEGINNING AT OBJ SEARCHING UP TO THE ROOT CLASS
*
FIND_METHOD
         M_CLASS =
         IDENT(OBJ)                                          :S(FRETURN)
         C = OBJ
FIND_METHOD2
         FIND_METHOD = VDIFFER(METHODS(C))<METHOD>
         DIFFER(FIND_METHOD)                            :F(FIND_METHOD3)
         M_CLASS = C                                           :(RETURN)
FIND_METHOD3
         IDENT(C = CLASS(C))                  :S(FRETURN)F(FIND_METHOD2)
*
* DISPATCH TO THE PARENT CLASS. THAT, IN TURN, MAY DISPATCH TO ITS
* PARENT. THIS IS USED WITH 'INIT' (FOR EXAMPLE).
*
* TO IMPLEMENT SUPER, WE WANT TO START SEARCHING WITH THE CLASS OF THE
* CLASS WE FOUND THE METHOD IN. THIS IS IN LOCAL SEND() VARIABLE
* M_CLASS WHICH IS SET IN FIND_METHOD.
*
SUPER    SUPER = THIS
         IDENT(M_CLASS)                                       :S(RETURN)
         M = FIND_METHOD(CLASS(M_CLASS), METHOD)     :F(RETURN)S(SEND_3)
*
* DISPATCH METHOD FROM WITHIN A METHOD
*
SELF     SELF = THIS                                           :(SEND_2)
*
* DISPATCH METHOD TO OBJECT. DEFAULT ANSWER IS SIMPLY 'THIS' TO ALLOW
* CHAINED METHODS
*
SEND     SEND = THIS
*
* ENSURE THAT THIS PARAMETER IS AN OBJECT (OR CLASS).
*
%IF(SAFE)
         IDENT(THIS)                                         :S(FRETURN)
         IDENT(DATATYPE(THIS), 'OBJECT')                      :S(SEND_2)
         TERMINAL = 'SCOOP: SEND NEEDS OBJECT AS RECEIVER'        :(END)
%ENDIF
*
SEND_2   M = FIND_METHOD(THIS, METHOD)                        :S(SEND_3)
         M = FIND_METHOD(THIS, 'DOES_NOT_UNDERSTAND')         :S(SEND_3)
*
* THIS ERROR SHOULD NOT HAPPEN! (THE ROOT CLASS SHOULD ALWAYS ANSWER
* DOES_NOT_UNDERSTAND).
*
         TERMINAL =
+           'SCOOP: ROOT CLASS MISSING DOES_NOT_UNDERSTAND'       :(END)
*
* WE HAVE THE METHOD, DISPATCH IT. SINCE ALL VARIABLES ARE GLOBAL,
* ACCESS TO 'THIS' WILL SIMPLY REFER TO SELF AS PASSED TO SEND()
* WHICH IS WHAT WE WANT.
*
* IF THE METHOD IS CODE, EXECUTE IT. OTHERWISE, APPLY M TO THE PASSED
* ARGUMENTS.
*
SEND_3   IDENT(DATATYPE(M), 'CODE')                                :S<M>
         SEND = APPLY(M, A1, A2, A3, A4, A5, A6, A7, A8)
+                                                   :S(RETURN)F(FRETURN)
*
OOP_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SCOOP.INC'
-INCLUDE 'TIMER.INC'
         &CODE = 1
         SHAPE_CLASS = SEND(CLASS, 'NEW_CLASS', 'SHAPE')
         SQUARE_CLASS = SEND(SHAPE_CLASS, 'NEW_CLASS', 'SQUARE')
         CIRCLE_CLASS = SEND(SHAPE_CLASS, 'NEW_CLASS', 'CIRCLE')
*
         M = CODE(' EQ(A1, 5) :F(END)S(RETURN)')
         SEND(SHAPE_CLASS, 'ADD_METHOD', 'AMETHOD', M)
*
         SQUARE = SEND(SQUARE_CLASS, 'NEW')
         SEND(SQUARE, 'AMETHOD', 5)
*
         IDENT(CLASS_OF(SQUARE), 'SQUARE')                       :F(END)
         IDENT(CLASS_OF(CLASS(SQUARE)), 'SHAPE')                 :F(END)
         IDENT(CLASS_OF(CLASS(CLASS(SQUARE))), 'CLASS')          :F(END)
*
         SEND(SQUARE, 'IS_A', SQUARE_CLASS)                      :F(END)
         SEND(SQUARE_CLASS, 'IS_A', 'SHAPE')                     :F(END)
         SEND(SQUARE, 'IS_A', 'CIRCLE')                          :S(END)
*
* TIME METHOD DISPATCH WHERE THE METHOD IS IN A SUPERCLASS
*
         TIMER(" SEND(SQUARE, 'AMETHOD', 5) ")
*
* TIME METHOD DISPATCH WHERE THE METHOD IS IN THE CLASS
*
         SEND(SQUARE_CLASS, 'ADD_METHOD', 'AMETHOD', M)
         TIMER(" SEND(SQUARE, 'AMETHOD', 5) ")
*
* TIME METHOD DISPATCH WHERE THE METHOD IS IN THE OBJECT
*
         SEND(SQUARE, 'ADD_METHOD', 'AMETHOD', M)
         TIMER(" SEND(SQUARE, 'AMETHOD', 5) ")
*
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-EJECT
-STITL SCOOP
-EJECT
*
************************************************************************
*                                                                      *
*              #####    #####   #######  #######  ######               *
*             #     #  #     #  #     #  #     #  #     #              *
*             #        #        #     #  #     #  #     #              *
*              #####   #        #     #  #     #  ######               *
*                   #  #        #     #  #     #  #                    *
*             #     #  #     #  #     #  #     #  #                    *
*              #####    #####   #######  #######  #                    *
*                                                                      *
* SCOOP            OBJECT ORIENTED PROGRAMMING                         *
*                                                                      *
************************************************************************
*
* SCOOP.lss
*
* THE SAFETY FLAG. IF 0, SOME CHECKS ARE NOT COMPILED IN. I RECOMMEND
* THAT IT ALWAYS BE ENABLED.
*
%SET(SAFE,1)
<<SCOOP>>
*
* CE: .F.MSNOBOL4;
@
-LINE 103 "SCOOP.lss"
-INCLUDE 'VDIFFER.INC'
-EJECT
-STITL SCOOP
-LINE 297 "SCOOP.lss"
-EJECT
*
************************************************************************
*                                                                      *
*              #####    #####   #######  #######  ######               *
*             #     #  #     #  #     #  #     #  #     #              *
*             #        #        #     #  #     #  #     #              *
*              #####   #        #     #  #     #  ######               *
*                   #  #        #     #  #     #  #                    *
*             #     #  #     #  #     #  #     #  #                    *
*              #####    #####   #######  #######  #                    *
*                                                                      *
* SCOOP            OBJECT ORIENTED PROGRAMMING                         *
*                                                                      *
************************************************************************
*
* SCOOP.lss
*
* THE SAFETY FLAG. IF 0, SOME CHECKS ARE NOT COMPILED IN. I RECOMMEND
* THAT IT ALWAYS BE ENABLED.
*
-LINE 107 "SCOOP.lss"
-MODULE SCOOP
-PUBLIC OBJECT()
         DATA('OBJECT(CLASS,IVARS,METHODS)')
*
-PUBLIC SEND(), SUPER(), SELF(), IVAR(), CVAR(), CLASS_OF(), |1
         DEFINE('SEND(THIS,METHOD,A1,A2,A3,A4,A5,A6,A7,A8)'
+               'C,M,M_CLASS,T1,T2,T3')
         DEFINE('SUPER(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
         DEFINE('SELF(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3')
         DEFINE('FIND_METHOD(OBJ,METHOD)')
         DEFINE('IVAR(NAME)')
         DEFINE('CVAR(NAME)')
         DEFINE('CLASS_OF(OBJ)')
         OPSYN('|', 'IVAR', 1)
*
* INITIALIZE OOP SYSTEM, CREATE ROOT CLASS. MAKE SURE ROOT CLASS CAN
* ANSWER NEW_CLASS, NEW, INIT, DOES_NOT_UNDERSTAND AND ADD_METHOD
* MESSAGES. ALSO, ANSWER THE IS_A MESSAGE.
*
-PUBLIC CLASS:CLASS
         CLASS = OBJECT(, TABLE(), TABLE())
         IVARS(CLASS)<'CLASS'> = 'CLASS'
-PUBLIC CLASS:'ADD_METHOD'
         METHODS(CLASS)<'ADD_METHOD'> =
+           CODE(
+              ' METHODS(THIS) = IDENT(METHODS(THIS)) TABLE();'
+              ' THAW(METHODS(THIS));'
+              ' METHODS(THIS)<A1> = A2;'
+              ' FREEZE(METHODS(THIS)) :(RETURN)')
*
-PUBLIC CLASS:'NEW_CLASS'
         SEND(CLASS, 'ADD_METHOD', 'NEW_CLASS',
+           CODE(
+              ' THIS = OBJECT(THIS);'
+              ' IVAR("CLASS") = A1;'
+              ' SEND = THIS :(RETURN)'))
-PUBLIC CLASS:'INIT'
         SEND(CLASS, 'ADD_METHOD', 'INIT',
+           CODE(' :(RETURN)'))
-PUBLIC CLASS:'NEW'
         SEND(CLASS, 'ADD_METHOD', 'NEW',
+           CODE(
+              ' THIS = OBJECT(THIS);'
+              ' SELF("INIT", A1, A2, A3, A4, A5, A6, A7, A8);'
+              ' SEND = THIS :(RETURN)'))
-PUBLIC CLASS:'DOES_NOT_UNDERSTAND'
         SEND(CLASS, 'ADD_METHOD', 'DOES_NOT_UNDERSTAND',
+           CODE(
+            " TERMINAL = 'SCOOP: DOES NOT UNDERSTAND ' METHOD :(END)"))
         DEFINE('IS_A(ACLASS)')
-PUBLIC CLASS:'IS_A'
         SEND(CLASS, 'ADD_METHOD', 'IS_A', 'IS_A')
                                                              :(OOP_END)
*
* IS_A - IS OBJECT IN CLASS? ACLASS CAN BE A STRING WITH A CLASS NAME
*        OR A CLASS OBJECT
*
IS_A     T1 = THIS
IS_A_2   T1 = CLASS(T1)
         IDENT(T1)                                           :S(FRETURN)
         IDENT(T1, ACLASS)                                    :S(RETURN)
         IDENT(IVARS(T1)<'CLASS'>, ACLASS)           :S(RETURN)F(IS_A_2)
*
* ACCESS INSTANCE VARIABLE. CREATE THE INSTANCE VARIABLES IF THEY DO
* NOT YET EXIST.
*
IVAR     IVARS(THIS) = IDENT(IVARS(THIS)) TABLE()
         IVAR = .(IVARS(THIS)<NAME>)                          :(NRETURN)
*
* ACCESS CLASS VARIABLE
*
CVAR     IVARS(CLASS(THIS)) = IDENT(IVARS(CLASS(THIS))) TABLE()
         CVAR = .(IVARS(CLASS(THIS))<NAME>)                   :(NRETURN)
*
* CLASS_OF RETURNS THE NAME OF THE CLASS OF THE PASSED OBJECT. THE
* CLASS NAMES SHOULD BE UNIQUE WITHIN A PROGRAM. THE ROOT CLASS HAS
* NAME 'CLASS' (ROOT'S SUPERCLASS IS NULL)
*
CLASS_OF CLASS_OF = IVARS(CLASS(OBJ))<'CLASS'>                 :(RETURN)
*
* FIND METHOD BEGINNING AT OBJ SEARCHING UP TO THE ROOT CLASS
*
FIND_METHOD
         M_CLASS =
         IDENT(OBJ)                                          :S(FRETURN)
         C = OBJ
FIND_METHOD2
         FIND_METHOD = VDIFFER(METHODS(C))<METHOD>
         DIFFER(FIND_METHOD)                            :F(FIND_METHOD3)
         M_CLASS = C                                           :(RETURN)
FIND_METHOD3
         IDENT(C = CLASS(C))                  :S(FRETURN)F(FIND_METHOD2)
*
* DISPATCH TO THE PARENT CLASS. THAT, IN TURN, MAY DISPATCH TO ITS
* PARENT. THIS IS USED WITH 'INIT' (FOR EXAMPLE).
*
* TO IMPLEMENT SUPER, WE WANT TO START SEARCHING WITH THE CLASS OF THE
* CLASS WE FOUND THE METHOD IN. THIS IS IN LOCAL SEND() VARIABLE
* M_CLASS WHICH IS SET IN FIND_METHOD.
*
SUPER    SUPER = THIS
         IDENT(M_CLASS)                                       :S(RETURN)
         M = FIND_METHOD(CLASS(M_CLASS), METHOD)     :F(RETURN)S(SEND_3)
*
* DISPATCH METHOD FROM WITHIN A METHOD
*
SELF     SELF = THIS                                           :(SEND_2)
*
* DISPATCH METHOD TO OBJECT. DEFAULT ANSWER IS SIMPLY 'THIS' TO ALLOW
* CHAINED METHODS
*
SEND     SEND = THIS
*
* ENSURE THAT THIS PARAMETER IS AN OBJECT (OR CLASS).
*
         IDENT(THIS)                                         :S(FRETURN)
         IDENT(DATATYPE(THIS), 'OBJECT')                      :S(SEND_2)
         TERMINAL = 'SCOOP: SEND NEEDS OBJECT AS RECEIVER'        :(END)
*
SEND_2   M = FIND_METHOD(THIS, METHOD)                        :S(SEND_3)
         M = FIND_METHOD(THIS, 'DOES_NOT_UNDERSTAND')         :S(SEND_3)
*
* THIS ERROR SHOULD NOT HAPPEN! (THE ROOT CLASS SHOULD ALWAYS ANSWER
* DOES_NOT_UNDERSTAND).
*
         TERMINAL =
+           'SCOOP: ROOT CLASS MISSING DOES_NOT_UNDERSTAND'       :(END)
*
* WE HAVE THE METHOD, DISPATCH IT. SINCE ALL VARIABLES ARE GLOBAL,
* ACCESS TO 'THIS' WILL SIMPLY REFER TO SELF AS PASSED TO SEND()
* WHICH IS WHAT WE WANT.
*
* IF THE METHOD IS CODE, EXECUTE IT. OTHERWISE, APPLY M TO THE PASSED
* ARGUMENTS.
*
SEND_3   IDENT(DATATYPE(M), 'CODE')                                :S<M>
         SEND = APPLY(M, A1, A2, A3, A4, A5, A6, A7, A8)
+                                                   :S(RETURN)F(FRETURN)
*
OOP_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SCOOP - Object Oriented Programming</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
SCOOP implements a simple OOP system. Single inheritance only. Allows
creation of classes and objects. Does not dispatch based on type of
arguments; simply on method name. STACK illustrates another way to
do OOP programming. SCOOP is (likely) better for structuring
larger programs. STACK is far better for performance. STACK creates
a family of routines, with no overhead for dispatch.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
SCOOP is deliberately simple. It is designed to provide a very
thin object layer to allow better variable control, and allow the
elimination of some labels. It is designed to allow for trivial
monkey patching. Indeed, that is the normal way to add methods.
Methods may also be added to objects directly!
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">THIS</font> refers to the receiver of a message (sometimes known as
self). <font face="Source Code Pro">SELF()</font> dispatches messages from a method to the same
receiver. <font face="Source Code Pro">SUPER()</font> does the same, but begins the dispatch search
with the superclass of the receiver.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| IVARS(THIS)<'VARIABLE NAME'>
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
accesses instance variable <font face="Source Code Pro">VARIABLE NAME</font> in the receiver. We
OPSYN unary operator | to simplify this. <font face="Source Code Pro">|'var'</font> or <font face="Source Code Pro">|.var</font>
refers to instance variable <font face="Source Code Pro">var</font> and can be used on either the
left or right side of an assignment.
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
<font face="Source Code Pro">^</font> is usable as a unary operator in CSNOBOL4. SPITBOL.EXE does
not support this. To accomodate, <font face="Source Code Pro">|</font> is now used as the instance
variable access operator. This works on both systems. Change the
<font face="Source Code Pro">OPSYN()</font> statement as appropriate if you want another operator.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SEND(OBJECT,MESSAGE,ARGS)</font> dispatches a message to the receiver,
with up to eight arguments.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
SCOOP is very useful in hiding variables. SNOBOL4 does not have
any concept of scope. Bundling variables together into an object is
one way of controlling this complexity. Thus the given name SCOOP
which evokes OOP, scope and ice-cream scoops. Or SNOBOL4 Crummy
Object Oriented Programming.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">ADD_METHOD</font> can add either a name of a function to dispatch, or
<font face="Source Code Pro">CODE()</font>. The code compiled is run in the context of <font face="Source Code Pro">SEND()</font>.
Arguments A1 through A8 are available, and three temporaries T1 through
T3. The method result should be assigned to the variable <font face="Source Code Pro">SEND</font>.
<font face="Source Code Pro">THIS</font> is assigned to the receiver object.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">CLASS_OF()</font> is primarily for development. It returns the name of
the class the object is in. It does so without using <font face="Source Code Pro">SEND()</font>,
but is aware of object structure. <font face="Source Code Pro">CLASS(OBJECT)</font> evaluates to
the class of an object. <font face="Source Code Pro">CLASS(CLASS(OBJECT))</font> is the superclass
(base class). Every object has a class, <i>including</i> classes!
The only exception is the <font face="Source Code Pro">CLASS</font> class, which has a <font face="Source Code Pro">NULL</font> class.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">IS_A</font> succeeds if the object is in the class given, or in a
subclass. If not, it fails.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
After initialize, only a single class exists: <font face="Source Code Pro">CLASS</font>. <font face="Source Code Pro">CLASS</font>
has methods <font face="Source Code Pro">NEW_CLASS</font>, <font face="Source Code Pro">NEW</font>, <font face="Source Code Pro">ADD_METHOD</font>, <font face="Source Code Pro">INIT</font>, <font face="Source Code Pro">IS_A</font>
and <font face="Source Code Pro">DOES_NOT_UNDERSTAND</font> pre-defined.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Objects are created with <font face="Source Code Pro">NEW</font>. After the object is created, it
should be initialized, so <font face="Source Code Pro">NEW</font> dispatches the message <font face="Source Code Pro">INIT</font>
to the newly created object. The CLASS class implements an empty
<font face="Source Code Pro">INIT</font> method, ensuring that this will not cause problems if not
implemented in sub-classes.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The <font face="Source Code Pro">SEND()</font> function can be used outside or inside of
a method.  <font face="Source Code Pro">SELF()</font> and <font face="Source Code Pro">SUPER()</font> can only be used inside a
method. <font face="Source Code Pro">IVAR()</font>, <font face="Source Code Pro">CVAR()</font> (and the <font face="Source Code Pro">^</font> operator) are restricted
to within a method only. <font face="Source Code Pro">CLASS_OF()</font> can be used wherever <font face="Source Code Pro">SEND()</font>
can be used.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If a selector (method) is not matched, the search is done again,
dispatching selector 'DOES_NOT_UNDERSTAND' to the object. If a class
contains an implementation for this message, the exception can be
handled (say, by loading the method implementation, dispatching it
again, and returning the result). The <font face="Source Code Pro">CLASS</font> class implementation
for <font face="Source Code Pro">DOES_NOT_UNDERSTAND</font> displays an error and terminates the
program.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
We don't expect the class tree to be very deep. SCOOP is designed
as a light OOP tool to aid in variable management. Some subclassing
is expected, but very deep class trees are not well (effiently)
supported. There is no method caching, so every method dispatch will
do a tree search.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
String comparisions in SNOBOL4 are inexpensive. A string compare is
a pointer compare. This means that representing messages by strings
is a reasonable choice.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="STACK.html">STACK</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SCOOP&raquo;&equiv;</b>
-MODULE SCOOP
-PUBLIC OBJECT()
         DATA(&#39;OBJECT(CLASS,IVARS,METHODS)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC SEND(), SUPER(), SELF(), IVAR(), CVAR(), CLASS_OF(), |1
         DEFINE(&#39;SEND(THIS,METHOD,A1,A2,A3,A4,A5,A6,A7,A8)&#39;
+               &#39;C,M,M_CLASS,T1,T2,T3&#39;)
         DEFINE(&#39;SUPER(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3&#39;)
         DEFINE(&#39;SELF(METHOD,A1,A2,A3,A4,A5,A6,A7,A8)T1,T2,T3&#39;)
         DEFINE(&#39;FIND_METHOD(OBJ,METHOD)&#39;)
         DEFINE(&#39;IVAR(NAME)&#39;)
         DEFINE(&#39;CVAR(NAME)&#39;)
         DEFINE(&#39;CLASS_OF(OBJ)&#39;)
         OPSYN(&#39;|&#39;, &#39;IVAR&#39;, 1)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INITIALIZE OOP SYSTEM, CREATE ROOT CLASS. MAKE SURE ROOT CLASS CAN</i></font>
<font color="#818181"><i>* ANSWER NEW_CLASS, NEW, INIT, DOES_NOT_UNDERSTAND AND ADD_METHOD</i></font>
<font color="#818181"><i>* MESSAGES. ALSO, ANSWER THE IS_A MESSAGE.</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC CLASS:CLASS
         CLASS = OBJECT(, TABLE(), TABLE())
         IVARS(CLASS)&lt;&#39;CLASS&#39;&gt; = &#39;CLASS&#39;
-PUBLIC CLASS:&#39;ADD_METHOD&#39;
         METHODS(CLASS)&lt;&#39;ADD_METHOD&#39;&gt; =
+           CODE(
+              &#39; METHODS(THIS) = IDENT(METHODS(THIS)) TABLE();&#39;
+              &#39; THAW(METHODS(THIS));&#39;
+              &#39; METHODS(THIS)&lt;A1&gt; = A2;&#39;
+              &#39; FREEZE(METHODS(THIS)) :(RETURN)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC CLASS:&#39;NEW_CLASS&#39;
         SEND(CLASS, &#39;ADD_METHOD&#39;, &#39;NEW_CLASS&#39;,
+           CODE(
+              &#39; THIS = OBJECT(THIS);&#39;
+              &#39; IVAR(&quot;CLASS&quot;) = A1;&#39;
+              &#39; SEND = THIS :(RETURN)&#39;))
-PUBLIC CLASS:&#39;INIT&#39;
         SEND(CLASS, &#39;ADD_METHOD&#39;, &#39;INIT&#39;,
+           CODE(&#39; :(RETURN)&#39;))
-PUBLIC CLASS:&#39;NEW&#39;
         SEND(CLASS, &#39;ADD_METHOD&#39;, &#39;NEW&#39;,
+           CODE(
+              &#39; THIS = OBJECT(THIS);&#39;
+              &#39; SELF(&quot;INIT&quot;, A1, A2, A3, A4, A5, A6, A7, A8);&#39;
+              &#39; SEND = THIS :(RETURN)&#39;))
-PUBLIC CLASS:&#39;DOES_NOT_UNDERSTAND&#39;
         SEND(CLASS, &#39;ADD_METHOD&#39;, &#39;DOES_NOT_UNDERSTAND&#39;,
+           CODE(
+            &quot; TERMINAL = &#39;SCOOP: DOES NOT UNDERSTAND &#39; METHOD :(END)&quot;))
         DEFINE(&#39;IS_A(ACLASS)&#39;)
-PUBLIC CLASS:&#39;IS_A&#39;
         SEND(CLASS, &#39;ADD_METHOD&#39;, &#39;IS_A&#39;, &#39;IS_A&#39;)
                                                              <b>:(OOP_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IS_A - IS OBJECT IN CLASS? ACLASS CAN BE A STRING WITH A CLASS NAME</i></font>
<font color="#818181"><i>*        OR A CLASS OBJECT</i></font>
<font color="#818181"><i>*</i></font>
IS_A     T1 = THIS
IS_A_2   T1 = CLASS(T1)
         IDENT(T1)                                           <b>:S(FRETURN)</b>
         IDENT(T1, ACLASS)                                    <b>:S(RETURN)</b>
         IDENT(IVARS(T1)&lt;&#39;CLASS&#39;&gt;, ACLASS)           <b>:S(RETURN)F(IS_A_2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ACCESS INSTANCE VARIABLE. CREATE THE INSTANCE VARIABLES IF THEY DO</i></font>
<font color="#818181"><i>* NOT YET EXIST.</i></font>
<font color="#818181"><i>*</i></font>
IVAR     IVARS(THIS) = IDENT(IVARS(THIS)) TABLE()
         IVAR = .(IVARS(THIS)&lt;NAME&gt;)                          <b>:(NRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ACCESS CLASS VARIABLE</i></font>
<font color="#818181"><i>*</i></font>
CVAR     IVARS(CLASS(THIS)) = IDENT(IVARS(CLASS(THIS))) TABLE()
         CVAR = .(IVARS(CLASS(THIS))&lt;NAME&gt;)                   <b>:(NRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CLASS_OF RETURNS THE NAME OF THE CLASS OF THE PASSED OBJECT. THE</i></font>
<font color="#818181"><i>* CLASS NAMES SHOULD BE UNIQUE WITHIN A PROGRAM. THE ROOT CLASS HAS</i></font>
<font color="#818181"><i>* NAME &#39;CLASS&#39; (ROOT&#39;S SUPERCLASS IS NULL)</i></font>
<font color="#818181"><i>*</i></font>
CLASS_OF CLASS_OF = IVARS(CLASS(OBJ))&lt;&#39;CLASS&#39;&gt;                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIND METHOD BEGINNING AT OBJ SEARCHING UP TO THE ROOT CLASS</i></font>
<font color="#818181"><i>*</i></font>
FIND_METHOD
         M_CLASS =
         IDENT(OBJ)                                          <b>:S(FRETURN)</b>
         C = OBJ
FIND_METHOD2
         FIND_METHOD = VDIFFER(METHODS(C))&lt;METHOD&gt;
         DIFFER(FIND_METHOD)                            <b>:F(FIND_METHOD3)</b>
         M_CLASS = C                                           <b>:(RETURN)</b>
FIND_METHOD3
         IDENT(C = CLASS(C))                  <b>:S(FRETURN)F(FIND_METHOD2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPATCH TO THE PARENT CLASS. THAT, IN TURN, MAY DISPATCH TO ITS</i></font>
<font color="#818181"><i>* PARENT. THIS IS USED WITH &#39;INIT&#39; (FOR EXAMPLE).</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TO IMPLEMENT SUPER, WE WANT TO START SEARCHING WITH THE CLASS OF THE</i></font>
<font color="#818181"><i>* CLASS WE FOUND THE METHOD IN. THIS IS IN LOCAL SEND() VARIABLE</i></font>
<font color="#818181"><i>* M_CLASS WHICH IS SET IN FIND_METHOD.</i></font>
<font color="#818181"><i>*</i></font>
SUPER    SUPER = THIS
         IDENT(M_CLASS)                                       <b>:S(RETURN)</b>
         M = FIND_METHOD(CLASS(M_CLASS), METHOD)     <b>:F(RETURN)S(SEND_3)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPATCH METHOD FROM WITHIN A METHOD</i></font>
<font color="#818181"><i>*</i></font>
SELF     SELF = THIS                                           <b>:(SEND_2)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISPATCH METHOD TO OBJECT. DEFAULT ANSWER IS SIMPLY &#39;THIS&#39; TO ALLOW</i></font>
<font color="#818181"><i>* CHAINED METHODS</i></font>
<font color="#818181"><i>*</i></font>
SEND     SEND = THIS
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ENSURE THAT THIS PARAMETER IS AN OBJECT (OR CLASS).</i></font>
<font color="#818181"><i>*</i></font>
%IF(SAFE)
         IDENT(THIS)                                         <b>:S(FRETURN)</b>
         IDENT(DATATYPE(THIS), &#39;OBJECT&#39;)                      <b>:S(SEND_2)</b>
         TERMINAL = &#39;SCOOP: SEND NEEDS OBJECT AS RECEIVER&#39;        <b>:(END)</b>
%ENDIF
<font color="#818181"><i>*</i></font>
SEND_2   M = FIND_METHOD(THIS, METHOD)                        <b>:S(SEND_3)</b>
         M = FIND_METHOD(THIS, &#39;DOES_NOT_UNDERSTAND&#39;)         <b>:S(SEND_3)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THIS ERROR SHOULD NOT HAPPEN! (THE ROOT CLASS SHOULD ALWAYS ANSWER</i></font>
<font color="#818181"><i>* DOES_NOT_UNDERSTAND).</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL =
+           &#39;SCOOP: ROOT CLASS MISSING DOES_NOT_UNDERSTAND&#39;       <b>:(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WE HAVE THE METHOD, DISPATCH IT. SINCE ALL VARIABLES ARE GLOBAL,</i></font>
<font color="#818181"><i>* ACCESS TO &#39;THIS&#39; WILL SIMPLY REFER TO SELF AS PASSED TO SEND()</i></font>
<font color="#818181"><i>* WHICH IS WHAT WE WANT.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF THE METHOD IS CODE, EXECUTE IT. OTHERWISE, APPLY M TO THE PASSED</i></font>
<font color="#818181"><i>* ARGUMENTS.</i></font>
<font color="#818181"><i>*</i></font>
SEND_3   IDENT(DATATYPE(M), &#39;CODE&#39;)                                <b>:S&lt;M&gt;</b>
         SEND = APPLY(M, A1, A2, A3, A4, A5, A6, A7, A8)
+                                                   <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
OOP_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SCOOP.INC&#39;
-INCLUDE &#39;TIMER.INC&#39;
         &amp;CODE = 1
         SHAPE_CLASS = SEND(CLASS, &#39;NEW_CLASS&#39;, &#39;SHAPE&#39;)
         SQUARE_CLASS = SEND(SHAPE_CLASS, &#39;NEW_CLASS&#39;, &#39;SQUARE&#39;)
         CIRCLE_CLASS = SEND(SHAPE_CLASS, &#39;NEW_CLASS&#39;, &#39;CIRCLE&#39;)
<font color="#818181"><i>*</i></font>
         M = CODE(&#39; EQ(A1, 5) :F(END)S(RETURN)&#39;)
         SEND(SHAPE_CLASS, &#39;ADD_METHOD&#39;, &#39;AMETHOD&#39;, M)
<font color="#818181"><i>*</i></font>
         SQUARE = SEND(SQUARE_CLASS, &#39;NEW&#39;)
         SEND(SQUARE, &#39;AMETHOD&#39;, 5)
<font color="#818181"><i>*</i></font>
         IDENT(CLASS_OF(SQUARE), &#39;SQUARE&#39;)                       <b>:F(END)</b>
         IDENT(CLASS_OF(CLASS(SQUARE)), &#39;SHAPE&#39;)                 <b>:F(END)</b>
         IDENT(CLASS_OF(CLASS(CLASS(SQUARE))), &#39;CLASS&#39;)          <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
         SEND(SQUARE, &#39;IS_A&#39;, SQUARE_CLASS)                      <b>:F(END)</b>
         SEND(SQUARE_CLASS, &#39;IS_A&#39;, &#39;SHAPE&#39;)                     <b>:F(END)</b>
         SEND(SQUARE, &#39;IS_A&#39;, &#39;CIRCLE&#39;)                          <b>:S(END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIME METHOD DISPATCH WHERE THE METHOD IS IN A SUPERCLASS</i></font>
<font color="#818181"><i>*</i></font>
         TIMER(&quot; SEND(SQUARE, &#39;AMETHOD&#39;, 5) &quot;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIME METHOD DISPATCH WHERE THE METHOD IS IN THE CLASS</i></font>
<font color="#818181"><i>*</i></font>
         SEND(SQUARE_CLASS, &#39;ADD_METHOD&#39;, &#39;AMETHOD&#39;, M)
         TIMER(&quot; SEND(SQUARE, &#39;AMETHOD&#39;, 5) &quot;)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIME METHOD DISPATCH WHERE THE METHOD IS IN THE OBJECT</i></font>
<font color="#818181"><i>*</i></font>
         SEND(SQUARE, &#39;ADD_METHOD&#39;, &#39;AMETHOD&#39;, M)
         TIMER(&quot; SEND(SQUARE, &#39;AMETHOD&#39;, 5) &quot;)
<font color="#818181"><i>*</i></font>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-EJECT
-STITL SCOOP
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*              #####    #####   #######  #######  ######               *</i></font>
<font color="#818181"><i>*             #     #  #     #  #     #  #     #  #     #              *</i></font>
<font color="#818181"><i>*             #        #        #     #  #     #  #     #              *</i></font>
<font color="#818181"><i>*              #####   #        #     #  #     #  ######               *</i></font>
<font color="#818181"><i>*                   #  #        #     #  #     #  #                    *</i></font>
<font color="#818181"><i>*             #     #  #     #  #     #  #     #  #                    *</i></font>
<font color="#818181"><i>*              #####    #####   #######  #######  #                    *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SCOOP            OBJECT ORIENTED PROGRAMMING                         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SCOOP.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THE SAFETY FLAG. IF 0, SOME CHECKS ARE NOT COMPILED IN. I RECOMMEND</i></font>
<font color="#818181"><i>* THAT IT ALWAYS BE ENABLED.</i></font>
<font color="#818181"><i>*</i></font>
%SET(SAFE,1)
<b>&laquo;SCOOP&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:39 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SCOOP.INC'
-LINE 255 "SCOOP.lss"
-INCLUDE 'TIMER.INC'
         &CODE = 1
         SHAPE_CLASS = SEND(CLASS, 'NEW_CLASS', 'SHAPE')
         SQUARE_CLASS = SEND(SHAPE_CLASS, 'NEW_CLASS', 'SQUARE')
         CIRCLE_CLASS = SEND(SHAPE_CLASS, 'NEW_CLASS', 'CIRCLE')
*
         M = CODE(' EQ(A1, 5) :F(END)S(RETURN)')
         SEND(SHAPE_CLASS, 'ADD_METHOD', 'AMETHOD', M)
*
         SQUARE = SEND(SQUARE_CLASS, 'NEW')
         SEND(SQUARE, 'AMETHOD', 5)
*
         IDENT(CLASS_OF(SQUARE), 'SQUARE')                       :F(END)
         IDENT(CLASS_OF(CLASS(SQUARE)), 'SHAPE')                 :F(END)
         IDENT(CLASS_OF(CLASS(CLASS(SQUARE))), 'CLASS')          :F(END)
*
         SEND(SQUARE, 'IS_A', SQUARE_CLASS)                      :F(END)
         SEND(SQUARE_CLASS, 'IS_A', 'SHAPE')                     :F(END)
         SEND(SQUARE, 'IS_A', 'CIRCLE')                          :S(END)
*
* TIME METHOD DISPATCH WHERE THE METHOD IS IN A SUPERCLASS
*
         TIMER(" SEND(SQUARE, 'AMETHOD', 5) ")
*
* TIME METHOD DISPATCH WHERE THE METHOD IS IN THE CLASS
*
         SEND(SQUARE_CLASS, 'ADD_METHOD', 'AMETHOD', M)
         TIMER(" SEND(SQUARE, 'AMETHOD', 5) ")
*
* TIME METHOD DISPATCH WHERE THE METHOD IS IN THE OBJECT
*
         SEND(SQUARE, 'ADD_METHOD', 'AMETHOD', M)
         TIMER(" SEND(SQUARE, 'AMETHOD', 5) ")
*
         &CODE = 0
END
<h1>SDIFF - Set difference</h1>

[[SDIFF(S1, S2)]] will return the set difference, [[S1 - S2]], which
is a string containing all those characters that are in [[S1]] and not
[[S2]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<SDIFF>>=
-MODULE SDIFF
-PUBLIC SDIFF()
         DEFINE('SDIFF(S1,S2)')                             :(SDIFF_END)
*
SDIFF    SDIFF = S1
         IDENT(S2, NULL)                                      :S(RETURN)
         S2 = SPAN(S2)
SDIFF_1  SDIFF S2 =                                 :S(SDIFF_1)F(RETURN)
*
SDIFF_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SDIFF.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL SDIFF
-EJECT
*
************************************************************************
*                                                                      *
*                #####   ######   ###  #######  #######                *
*               #     #  #     #   #   #        #                      *
*               #        #     #   #   #        #                      *
*                #####   #     #   #   #####    #####                  *
*                     #  #     #   #   #        #                      *
*               #     #  #     #   #   #        #                      *
*                #####   ######   ###  #        #                      *
*                                                                      *
* SDIFF                     SET DIFFERENCE                             *
*                                                                      *
************************************************************************
*
* SDIFF.lss
*
<<SDIFF>>
*
* CE: .MSNOBOL4;
-STITL SDIFF
-EJECT
*
-LINE 38 "SDIFF.lss"
************************************************************************
*                                                                      *
*                #####   ######   ###  #######  #######                *
*               #     #  #     #   #   #        #                      *
*               #        #     #   #   #        #                      *
*                #####   #     #   #   #####    #####                  *
*                     #  #     #   #   #        #                      *
*               #     #  #     #   #   #        #                      *
*                #####   ######   ###  #        #                      *
*                                                                      *
* SDIFF                     SET DIFFERENCE                             *
*                                                                      *
************************************************************************
*
* SDIFF.lss
*
-LINE 13 "SDIFF.lss"
-MODULE SDIFF
-PUBLIC SDIFF()
         DEFINE('SDIFF(S1,S2)')                             :(SDIFF_END)
*
SDIFF    SDIFF = S1
         IDENT(S2, NULL)                                      :S(RETURN)
         S2 = SPAN(S2)
SDIFF_1  SDIFF S2 =                                 :S(SDIFF_1)F(RETURN)
*
SDIFF_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SDIFF - Set difference</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SDIFF(S1, S2)</font> will return the set difference, <font face="Source Code Pro">S1 - S2</font>, which
is a string containing all those characters that are in <font face="Source Code Pro">S1</font> and not
<font face="Source Code Pro">S2</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SDIFF&raquo;&equiv;</b>
-MODULE SDIFF
-PUBLIC SDIFF()
         DEFINE(&#39;SDIFF(S1,S2)&#39;)                             <b>:(SDIFF_END)</b>
<font color="#818181"><i>*</i></font>
SDIFF    SDIFF = S1
         IDENT(S2, NULL)                                      <b>:S(RETURN)</b>
         S2 = SPAN(S2)
SDIFF_1  SDIFF S2 =                                 <b>:S(SDIFF_1)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
SDIFF_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SDIFF.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL SDIFF
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                #####   ######   ###  #######  #######                *</i></font>
<font color="#818181"><i>*               #     #  #     #   #   #        #                      *</i></font>
<font color="#818181"><i>*               #        #     #   #   #        #                      *</i></font>
<font color="#818181"><i>*                #####   #     #   #   #####    #####                  *</i></font>
<font color="#818181"><i>*                     #  #     #   #   #        #                      *</i></font>
<font color="#818181"><i>*               #     #  #     #   #   #        #                      *</i></font>
<font color="#818181"><i>*                #####   ######   ###  #        #                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SDIFF                     SET DIFFERENCE                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SDIFF.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SDIFF&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
</pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:21 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SDIFF.INC'
-LINE 29 "SDIFF.lss"
         &CODE = 1
         &CODE = 0
END
<H1>SEQ - Sequence statement with counter</H1>

[[SEQ(ARG_S,ARG_NAME,START,END)]] will sequence through a set of
statements until failure is detected. The indexing variable is given
by the name [[ARG_NAME]]. Can be profitably used to index the entries
of an array.

If [[START]] is omitted, the indexing begins at [[1]]. If [[END]]
is given, it will be the last index attempted. Both [[START]] and
[[END]] are optional.

Most simple arrays are served by assuming indexing begins at [[1]].
However [[SEQ(S, .I, LOWA(A))]] will begin indexing at the lowest
index of [[A]].

Note that [[SEQ()]] will fail if indexing a zero length array
([[ARRAY0]]). 

Since [[SEQ()]] is of more general use than just sequencing arrays,
these issues will not be addressed.

Sample usage:

[[
    SEQ(' A<K> = INPUT ', .K)
]]

<h2>Uses</h2>

<h2>See Also</h2>
<a href="SIZEA.html">SIZEA</a>

<<INCLUDES>>=
@

<<SEQ>>=
-MODULE SEQ
-PUBLIC SEQ()
         DEFINE('SEQ(ARG_S,ARG_NAME,START,END)')              :(SEQ_END)
*
SEQ      START = IDENT(START) 1
         $ARG_NAME = START - 1
         ARG_S = CODE(ARG_S  ' :S(SEQ_1)F(SEQ_2)')             :F(ERROR)
SEQ_1    DIFFER(END) GE($ARG_NAME, END)                       :S(RETURN)
         $ARG_NAME = $ARG_NAME + 1                              :<ARG_S>
SEQ_2    EQ($ARG_NAME, START)                       :S(FRETURN)F(RETURN)
*
SEQ_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SEQ.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL SEQ
-EJECT
*
************************************************************************
*                                                                      *
*                       #####   #######   #####                        *
*                      #     #  #        #     #                       *
*                      #        #        #     #                       *
*                       #####   #####    #     #                       *
*                            #  #        #   # #                       *
*                      #     #  #        #    #                        *
*                       #####   #######   #### #                       *
*                                                                      *
* SEQ                SEQUENCE STATEMENT WITH COUNTER                   *
*                                                                      *
************************************************************************
*
* SEQ.lss
*
<<SEQ>>
*
* CE: .MSNOBOL4;
@
-STITL SEQ
-EJECT
*
-LINE 64 "SEQ.lss"
************************************************************************
*                                                                      *
*                       #####   #######   #####                        *
*                      #     #  #        #     #                       *
*                      #        #        #     #                       *
*                       #####   #####    #     #                       *
*                            #  #        #   # #                       *
*                      #     #  #        #    #                        *
*                       #####   #######   #### #                       *
*                                                                      *
* SEQ                SEQUENCE STATEMENT WITH COUNTER                   *
*                                                                      *
************************************************************************
*
* SEQ.lss
*
-LINE 37 "SEQ.lss"
-MODULE SEQ
-PUBLIC SEQ()
         DEFINE('SEQ(ARG_S,ARG_NAME,START,END)')              :(SEQ_END)
*
SEQ      START = IDENT(START) 1
         $ARG_NAME = START - 1
         ARG_S = CODE(ARG_S  ' :S(SEQ_1)F(SEQ_2)')             :F(ERROR)
SEQ_1    DIFFER(END) GE($ARG_NAME, END)                       :S(RETURN)
         $ARG_NAME = $ARG_NAME + 1                              :<ARG_S>
SEQ_2    EQ($ARG_NAME, START)                       :S(FRETURN)F(RETURN)
*
SEQ_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>SEQ - Sequence statement with counter</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SEQ(ARG_S,ARG_NAME,START,END)</font> will sequence through a set of
statements until failure is detected. The indexing variable is given
by the name <font face="Source Code Pro">ARG_NAME</font>. Can be profitably used to index the entries
of an array.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If <font face="Source Code Pro">START</font> is omitted, the indexing begins at <font face="Source Code Pro">1</font>. If <font face="Source Code Pro">END</font>
is given, it will be the last index attempted. Both <font face="Source Code Pro">START</font> and
<font face="Source Code Pro">END</font> are optional.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Most simple arrays are served by assuming indexing begins at <font face="Source Code Pro">1</font>.
However <font face="Source Code Pro">SEQ(S, .I, LOWA(A))</font> will begin indexing at the lowest
index of <font face="Source Code Pro">A</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Note that <font face="Source Code Pro">SEQ()</font> will fail if indexing a zero length array
(<font face="Source Code Pro">ARRAY0</font>).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Since <font face="Source Code Pro">SEQ()</font> is of more general use than just sequencing arrays,
these issues will not be addressed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Sample usage:
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
|     SEQ(' A<K> = INPUT ', .K)
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="SIZEA.html">SIZEA</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SEQ&raquo;&equiv;</b>
-MODULE SEQ
-PUBLIC SEQ()
         DEFINE(&#39;SEQ(ARG_S,ARG_NAME,START,END)&#39;)              <b>:(SEQ_END)</b>
<font color="#818181"><i>*</i></font>
SEQ      START = IDENT(START) 1
         $ARG_NAME = START - 1
         ARG_S = CODE(ARG_S  &#39; :S(SEQ_1)F(SEQ_2)&#39;)             <b>:F(ERROR)</b>
SEQ_1    DIFFER(END) GE($ARG_NAME, END)                       <b>:S(RETURN)</b>
         $ARG_NAME = $ARG_NAME + 1                              <b>:&lt;ARG_S&gt;</b>
SEQ_2    EQ($ARG_NAME, START)                       <b>:S(FRETURN)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
SEQ_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SEQ.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL SEQ
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                       #####   #######   #####                        *</i></font>
<font color="#818181"><i>*                      #     #  #        #     #                       *</i></font>
<font color="#818181"><i>*                      #        #        #     #                       *</i></font>
<font color="#818181"><i>*                       #####   #####    #     #                       *</i></font>
<font color="#818181"><i>*                            #  #        #   # #                       *</i></font>
<font color="#818181"><i>*                      #     #  #        #    #                        *</i></font>
<font color="#818181"><i>*                       #####   #######   #### #                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SEQ                SEQUENCE STATEMENT WITH COUNTER                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SEQ.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SEQ&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:22 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SEQ.INC'
-LINE 55 "SEQ.lss"
         &CODE = 1
         &CODE = 0
END
<h1>SESSION - CGI SESSION Support</h1>

CGI support functions for session handling.

Session handling. Session variables are stored in a table.  Scalar
string and numeric variables can be persisted. The table contains
control entries [[UUID]], [[EXPIRE_TIME]] and [[EXPIRE]]. [[UUID]] is
the unique identifier for this session (generated by [[uuid -v1]]). The
filename that the session is saved to is [[session_UUID.db]] in
directory [[SESSION_PERSIST_DIR]].

[[EXPIRE_TIME]] is the number of seconds for the expiration of
the session file. Default if not specified is 10 minutes (600)
[[EXPIRE_TIME]] can be something like 31536000 (one year) to
effectively create a permanent session file.

[[EXPIRE]] is the time after which the file should be expired. It is
in seconds after the Unix epoch (in UTC).

[[SESSION_TOUCH(SESSION)]] updates the [[EXPIRE]]
variable. [[SESSION_CREATE(EXPIRE_TIME)]] creates a new
session.  [[SESSION_PERSIST(SESSION)]] saves the session to
disk. [[SESSION_LOAD(UUID)]] loads the session from disk.

[[SESSION_TOUCH(SESSION)]] is called automatically from
[[SESSION_PERSIST(SESSION)]] and so normally doesn't need to be
called directly. [[SESSION_DELETE(SESSION)]] removes the session from
disk. [[SESSION_EXPIRE(SESSION)]] expires the session files in the
session file directory ([[SESSION_PERSIST_DIR]])

Only numbers and strings can be persisted. Other objects should be
serialized when stored into the SESSION table (arrays, tables, data).
This may be done with [[JSON]] (or other means, if appropriate).

Using [[apache]], under [[systemd]], [[/tmp/session_...]]
gets redirected to [[/tmp/systemd-private-09Kkk/tmp...]]  (for
example). This redirection happens with (eg) [[touch /tmp/afile]]
as well (if [[touch]] is launched from the [[CGI]] script). For this
reason [[SESSION_PERSIST_DIR]] is set to the directory we want the
persisted sessions to be stored in, and is [[/var/lib/SESSION/]]
by default.

[[SESSION_LOAD()]] sanitizes its incoming [[UUID]]. Character set
[[0-9 a-f]] and [['-']] is enforced. Single and double quotes are
stripped, spaces and tabs are removed.

After the session is created, the [[UUID]] is expected to always be
generated from the client. The server should only examine the session
files for expiry, and to load them based on client direction. A client
could attempt to load another clients session, by altering the [[UUID]]
sent. This may be a potential security issue. Possible mitigations
would be to store the client IP address within the session, and to
ensure that the client IP is the same after loading. This issue is
left to the calling program to resolve. Since [[uuid]] would only
partially validate the [[UUID]], we do not use [[uuid]] for validation.
If the session file exists, [[SESSION_LOAD()]] will load it, and an
additional validation should be made (like IP validation). This may
not be practical for very long-lived sessions (that would persist
across client machines, for example). That data should probably be
stored as cookies only, or be accessed from a more permanent database
store (and then put into a session).

The format of the SESSION file may be NDBM or JSON. JSON is preferred,
because it is human readable.

[[uuid]] is presumed to provide unique ids, even if running in
multiple processes on the same machine. -v1 or -v4 are (presumed)
useful, and -v1 is the default in this code.

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="JSON.html">JSON</a><br>
<a href="NDBM.html">NDBM</a><br>
<a href="READFILE.html">READFILE</a><br>
<a href="REPL.html">REPL</a><br>
<a href="TIME.html">TIME</a><br>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'NDBM.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'TIME.INC'
@

<<SESSION>>=
-MODULE SESSION
-PUBLIC SESSION_CREATE(), SESSION_DELETE(), SESSION_TOUCH()
-PUBLIC SESSION_PERSIST(), SESSION_LOAD(), SESSION_EXPIRE()
-PUBLIC SESSION_PERSIST_DIR
         DEFINE('SESSION_CREATE(EXPIRE_TIME)')
         DEFINE('SESSION_DELETE(SESSION)')
         DEFINE('SESSION_TOUCH(SESSION)')
         DEFINE('SESSION_PERSIST(SESSION)FILE,HANDLE,A,I')
         DEFINE('SESSION_LOAD(UUID)FILE,HANDLE,KEY,DATA,I')
         DEFINE('SESSION_EXPIRE()SESSION,TIME,UUID,L,I,S,P')
*
         SESSION_PERSIST_DIR = '/var/lib/SESSION/'        :(SESSION_END)
*
* CREATE NEW SESSION. GENERATE UUID FOR SESSION. DEFAULT SESSION
* EXPIRATION TO 10 MINUTES (UNLESS SPECIFIED).
*
SESSION_CREATE
         SESSION_CREATE = TABLE()
         SESSION_CREATE<'UUID'> = BQ('/usr/bin/uuid -v1')    :F(FRETURN)
         EXPIRE_TIME = IDENT(EXPIRE_TIME) 600
         SESSION_CREATE<'EXPIRE_TIME'> = EXPIRE_TIME           :(RETURN)
*
* TOUCH THE SESSION; SETS THE 'EXPIRE' TIME FOR NOW + EXPIRE_TIME.
*
SESSION_TOUCH
         IDENT(SESSION)                                      :S(FRETURN)
         SESSION<'EXPIRE'> = TV_SEC(GETTIMEOFDAY()) +
+                               SESSION<'EXPIRE_TIME'>        :S(RETURN)
*
* PERSIST SESSION TO DISK. SCALAR VARIABLES ONLY. ARRAYS AND TABLES
* ARE NOT PERSISTED (ONLY AS THEY PRINT).
*
SESSION_PERSIST
         FILE = SESSION_PERSIST_DIR 'session_' SESSION<'UUID'>
         SESSION_DELETE(SESSION)
         SESSION_TOUCH(SESSION)                              :F(FRETURN)
*        A = CONVERT(SESSION, 'ARRAY')                       :F(FRETURN)
*        HANDLE = DBM_OPEN(FILE, 'CW', '0660')               :F(FRETURN)
*        SEQ(' DBM_STORE('
*+                'HANDLE, A<I, 1>, VDIFFER(A<I, 2>), DBM_INSERT) ', .I)
*        A<I>                                                :S(FRETURN)
*        DBM_CLOSE(HANDLE)                          :S(RETURN)F(FRETURN)
         WRITEFILE(FILE '.db', JSON_ENCODE(SESSION))
+                                                   :S(RETURN)F(FRETURN)
*
* DELETE SESSION
*
SESSION_DELETE
         DELETE(SESSION_PERSIST_DIR 'session_' SESSION<'UUID'> '.db')
+                                                              :(RETURN)
*
* LOAD SESSION GIVEN UUID. USUALLY, THE UUID COMES FROM A COOKIE.
*
SESSION_LOAD
         UUID = REPL(UUID, ' ', '')
         UUID = REPL(UUID, CHARS_TAB, '')
         UUID = REPLACE(UUID, &UCASE, &LCASE)
         UUID POS(0) ANY('"' "'") REM . UUID
         UUID POS(0) SPAN(&DIGITS 'abcdef-') . UUID
*        SESSION_LOAD = TABLE()
         FILE = SESSION_PERSIST_DIR 'session_' UUID
*        HANDLE = DBM_OPEN(FILE, 'R')                        :F(FRETURN)
*        KEY = DBM_FIRSTKEY(HANDLE)                    :F(SESSION_LOAD2)
*        SEQ(' DATA = DBM_FETCH(HANDLE, KEY);'
*+           ' SESSION_LOAD<KEY> = DATA;'
*+           ' KEY = DBM_NEXTKEY(HANDLE) ', .I)
*        DBM_CLOSE(HANDLE)                                   :F(FRETURN)
         SESSION_LOAD = JSON_DECODE(READFILE(FILE '.db'))    :F(FRETURN)
         IDENT(UUID, SESSION_LOAD<'UUID'>)          :S(RETURN)F(FRETURN)
SESSION_LOAD2
         DBM_CLOSE(HANDLE)                                    :(FRETURN)
*
* REMOVE EXPIRED SESSIONS FROM DISK.
*
SESSION_EXPIRE
         L = BQ('ls ' SESSION_PERSIST_DIR 'session_*.db 2>/dev/null')
+                                                             :F(RETURN)
         TIME = TV_SEC(GETTIMEOFDAY())
         L = CRACK(L, ' ')
         P = SESSION_PERSIST_DIR 'session_' BREAK('.') . UUID '.db'
SESSION_EXPIRE2
         I = I + 1
         S = L<I>                                             :F(RETURN)
         S P                                                  :F(RETURN)
         SESSION = SESSION_LOAD(UUID)                :F(SESSION_EXPIRE2)
         GE(SESSION<'EXPIRE'>, TIME)                 :S(SESSION_EXPIRE2)
         SESSION_DELETE(SESSION)                      :(SESSION_EXPIRE2)
*
SESSION_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SESSION.INC'
         &CODE = 1
* REMOVE ALL SESSIONS
         BQ('rm -f ' SESSION_PERSIST_DIR 'session_*.db')
* EXPIRE, EMPTY SESSIONS
         SESSION_EXPIRE()
* CREATE A 'PERMANENT' SESSION (1 YEAR EXPIRY)
         SESSION = SESSION_CREATE(31536000)
         UUID1 = SESSION<'UUID'>
         SESSION<'VAR'> = 'FIRST'
* PERSIST THE SESSION
         SESSION_PERSIST(SESSION)                                :F(END)
* EXPIRE, SHOULDN'T DO ANYTHING
         SESSION_EXPIRE()
* CREATE A SHORT-LIVED SESSION, 5 SECONDS. NOTE THAT THE UNIT TEST
* WILL TAKE AT LEAST THIS TIME TO RUN.
         SESSION = SESSION_CREATE(5)
         UUID2 = SESSION<'UUID'>
         SESSION<'VAR'> = 'SECOND'
         SESSION_PERSIST(SESSION)                                :F(END)
* LOAD AND CHECK FIRST SESSION
         SESS = SESSION_LOAD(UUID1)                              :F(END)
         IDENT(SESS<'VAR'>, 'FIRST')                             :F(END)
* LOAD AND CHECK SECOND SESSION
         SESS = SESSION_LOAD(UUID2)                              :F(END)
         IDENT(SESS<'VAR'>, 'SECOND')                            :F(END)
* WAIT LONGER THAN 5 SECONDS (EXPIRY TIME OF SECOND SESSION)
         SLEEP(6)
* EXPIRE, SHOULD REMOVE SECOND SESSION
         SESSION_EXPIRE()
* TRY LOADING SESSIONS, UUID2 SHOULD BE EXPIRED AND FAIL
         SESSION = SESSION_LOAD(UUID2)                           :S(END)
         SESSION = SESSION_LOAD(UUID1)                           :F(END)
* DELETE SESSION UUID1
         SESSION_DELETE(SESSION)
* SESSION UUID1 SHOULD NOW FAIL WHEN LOAD ATTEMPTED
         SESSION = SESSION_LOAD(UUID1)                           :S(END)
*
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL SESSION
-EJECT
*
************************************************************************
*                                                                      *
*       #####   #######   #####    #####   ###  #######  #     #       *
*      #     #  #        #     #  #     #   #   #     #  ##    #       *
*      #        #        #        #         #   #     #  # #   #       *
*       #####   #####     #####    #####    #   #     #  #  #  #       *
*            #  #              #        #   #   #     #  #   # #       *
*      #     #  #        #     #  #     #   #   #     #  #    ##       *
*       #####   #######   #####    #####   ###  #######  #     #       *
*                                                                      *
* SESSION               SESSION SUPPORT FOR CGI                        *
*                                                                      *
************************************************************************
*
* SESSION.lss
*
<<SESSION>>
*
* CE: .F.MSNOBOL4;
@
-LINE 81 "SESSION.lss"
-INCLUDE 'BQ.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'NDBM.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'TIME.INC'
-STITL SESSION
-EJECT
-LINE 232 "SESSION.lss"
*
************************************************************************
*                                                                      *
*       #####   #######   #####    #####   ###  #######  #     #       *
*      #     #  #        #     #  #     #   #   #     #  ##    #       *
*      #        #        #        #         #   #     #  # #   #       *
*       #####   #####     #####    #####    #   #     #  #  #  #       *
*            #  #              #        #   #   #     #  #   # #       *
*      #     #  #        #     #  #     #   #   #     #  #    ##       *
*       #####   #######   #####    #####   ###  #######  #     #       *
*                                                                      *
* SESSION               SESSION SUPPORT FOR CGI                        *
*                                                                      *
************************************************************************
*
* SESSION.lss
*
-LINE 92 "SESSION.lss"
-MODULE SESSION
-PUBLIC SESSION_CREATE(), SESSION_DELETE(), SESSION_TOUCH()
-PUBLIC SESSION_PERSIST(), SESSION_LOAD(), SESSION_EXPIRE()
-PUBLIC SESSION_PERSIST_DIR
         DEFINE('SESSION_CREATE(EXPIRE_TIME)')
         DEFINE('SESSION_DELETE(SESSION)')
         DEFINE('SESSION_TOUCH(SESSION)')
         DEFINE('SESSION_PERSIST(SESSION)FILE,HANDLE,A,I')
         DEFINE('SESSION_LOAD(UUID)FILE,HANDLE,KEY,DATA,I')
         DEFINE('SESSION_EXPIRE()SESSION,TIME,UUID,L,I,S,P')
*
         SESSION_PERSIST_DIR = '/var/lib/SESSION/'        :(SESSION_END)
*
* CREATE NEW SESSION. GENERATE UUID FOR SESSION. DEFAULT SESSION
* EXPIRATION TO 10 MINUTES (UNLESS SPECIFIED).
*
SESSION_CREATE
         SESSION_CREATE = TABLE()
         SESSION_CREATE<'UUID'> = BQ('/usr/bin/uuid -v1')    :F(FRETURN)
         EXPIRE_TIME = IDENT(EXPIRE_TIME) 600
         SESSION_CREATE<'EXPIRE_TIME'> = EXPIRE_TIME           :(RETURN)
*
* TOUCH THE SESSION; SETS THE 'EXPIRE' TIME FOR NOW + EXPIRE_TIME.
*
SESSION_TOUCH
         IDENT(SESSION)                                      :S(FRETURN)
         SESSION<'EXPIRE'> = TV_SEC(GETTIMEOFDAY()) +
+                               SESSION<'EXPIRE_TIME'>        :S(RETURN)
*
* PERSIST SESSION TO DISK. SCALAR VARIABLES ONLY. ARRAYS AND TABLES
* ARE NOT PERSISTED (ONLY AS THEY PRINT).
*
SESSION_PERSIST
         FILE = SESSION_PERSIST_DIR 'session_' SESSION<'UUID'>
         SESSION_DELETE(SESSION)
         SESSION_TOUCH(SESSION)                              :F(FRETURN)
*        A = CONVERT(SESSION, 'ARRAY')                       :F(FRETURN)
*        HANDLE = DBM_OPEN(FILE, 'CW', '0660')               :F(FRETURN)
*        SEQ(' DBM_STORE('
*+                'HANDLE, A<I, 1>, VDIFFER(A<I, 2>), DBM_INSERT) ', .I)
*        A<I>                                                :S(FRETURN)
*        DBM_CLOSE(HANDLE)                          :S(RETURN)F(FRETURN)
         WRITEFILE(FILE '.db', JSON_ENCODE(SESSION))
+                                                   :S(RETURN)F(FRETURN)
*
* DELETE SESSION
*
SESSION_DELETE
         DELETE(SESSION_PERSIST_DIR 'session_' SESSION<'UUID'> '.db')
+                                                              :(RETURN)
*
* LOAD SESSION GIVEN UUID. USUALLY, THE UUID COMES FROM A COOKIE.
*
SESSION_LOAD
         UUID = REPL(UUID, ' ', '')
         UUID = REPL(UUID, CHARS_TAB, '')
         UUID = REPLACE(UUID, &UCASE, &LCASE)
         UUID POS(0) ANY('"' "'") REM . UUID
         UUID POS(0) SPAN(&DIGITS 'abcdef-') . UUID
*        SESSION_LOAD = TABLE()
         FILE = SESSION_PERSIST_DIR 'session_' UUID
*        HANDLE = DBM_OPEN(FILE, 'R')                        :F(FRETURN)
*        KEY = DBM_FIRSTKEY(HANDLE)                    :F(SESSION_LOAD2)
*        SEQ(' DATA = DBM_FETCH(HANDLE, KEY);'
*+           ' SESSION_LOAD<KEY> = DATA;'
*+           ' KEY = DBM_NEXTKEY(HANDLE) ', .I)
*        DBM_CLOSE(HANDLE)                                   :F(FRETURN)
         SESSION_LOAD = JSON_DECODE(READFILE(FILE '.db'))    :F(FRETURN)
         IDENT(UUID, SESSION_LOAD<'UUID'>)          :S(RETURN)F(FRETURN)
SESSION_LOAD2
         DBM_CLOSE(HANDLE)                                    :(FRETURN)
*
* REMOVE EXPIRED SESSIONS FROM DISK.
*
SESSION_EXPIRE
         L = BQ('ls ' SESSION_PERSIST_DIR 'session_*.db 2>/dev/null')
+                                                             :F(RETURN)
         TIME = TV_SEC(GETTIMEOFDAY())
         L = CRACK(L, ' ')
         P = SESSION_PERSIST_DIR 'session_' BREAK('.') . UUID '.db'
SESSION_EXPIRE2
         I = I + 1
         S = L<I>                                             :F(RETURN)
         S P                                                  :F(RETURN)
         SESSION = SESSION_LOAD(UUID)                :F(SESSION_EXPIRE2)
         GE(SESSION<'EXPIRE'>, TIME)                 :S(SESSION_EXPIRE2)
         SESSION_DELETE(SESSION)                      :(SESSION_EXPIRE2)
*
SESSION_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SESSION - CGI SESSION Support</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
CGI support functions for session handling.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Session handling. Session variables are stored in a table.  Scalar
string and numeric variables can be persisted. The table contains
control entries <font face="Source Code Pro">UUID</font>, <font face="Source Code Pro">EXPIRE_TIME</font> and <font face="Source Code Pro">EXPIRE</font>. <font face="Source Code Pro">UUID</font> is
the unique identifier for this session (generated by <font face="Source Code Pro">uuid -v1</font>). The
filename that the session is saved to is <font face="Source Code Pro">session_UUID.db</font> in
directory <font face="Source Code Pro">SESSION_PERSIST_DIR</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">EXPIRE_TIME</font> is the number of seconds for the expiration of
the session file. Default if not specified is 10 minutes (600)
<font face="Source Code Pro">EXPIRE_TIME</font> can be something like 31536000 (one year) to
effectively create a permanent session file.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">EXPIRE</font> is the time after which the file should be expired. It is
in seconds after the Unix epoch (in UTC).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SESSION_TOUCH(SESSION)</font> updates the <font face="Source Code Pro">EXPIRE</font>
variable. <font face="Source Code Pro">SESSION_CREATE(EXPIRE_TIME)</font> creates a new
session.  <font face="Source Code Pro">SESSION_PERSIST(SESSION)</font> saves the session to
disk. <font face="Source Code Pro">SESSION_LOAD(UUID)</font> loads the session from disk.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SESSION_TOUCH(SESSION)</font> is called automatically from
<font face="Source Code Pro">SESSION_PERSIST(SESSION)</font> and so normally doesn't need to be
called directly. <font face="Source Code Pro">SESSION_DELETE(SESSION)</font> removes the session from
disk. <font face="Source Code Pro">SESSION_EXPIRE(SESSION)</font> expires the session files in the
session file directory (<font face="Source Code Pro">SESSION_PERSIST_DIR</font>)
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Only numbers and strings can be persisted. Other objects should be
serialized when stored into the SESSION table (arrays, tables, data).
This may be done with <font face="Source Code Pro">JSON</font> (or other means, if appropriate).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Using <font face="Source Code Pro">apache</font>, under <font face="Source Code Pro">systemd</font>, <font face="Source Code Pro">/tmp/session_...</font>
gets redirected to <font face="Source Code Pro">/tmp/systemd-private-09Kkk/tmp...</font>  (for
example). This redirection happens with (eg) <font face="Source Code Pro">touch /tmp/afile</font>
as well (if <font face="Source Code Pro">touch</font> is launched from the <font face="Source Code Pro">CGI</font> script). For this
reason <font face="Source Code Pro">SESSION_PERSIST_DIR</font> is set to the directory we want the
persisted sessions to be stored in, and is <font face="Source Code Pro">/var/lib/SESSION/</font>
by default.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SESSION_LOAD()</font> sanitizes its incoming <font face="Source Code Pro">UUID</font>. Character set
<font face="Source Code Pro">0-9 a-f</font> and <font face="Source Code Pro">'-'</font> is enforced. Single and double quotes are
stripped, spaces and tabs are removed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
After the session is created, the <font face="Source Code Pro">UUID</font> is expected to always be
generated from the client. The server should only examine the session
files for expiry, and to load them based on client direction. A client
could attempt to load another clients session, by altering the <font face="Source Code Pro">UUID</font>
sent. This may be a potential security issue. Possible mitigations
would be to store the client IP address within the session, and to
ensure that the client IP is the same after loading. This issue is
left to the calling program to resolve. Since <font face="Source Code Pro">uuid</font> would only
partially validate the <font face="Source Code Pro">UUID</font>, we do not use <font face="Source Code Pro">uuid</font> for validation.
If the session file exists, <font face="Source Code Pro">SESSION_LOAD()</font> will load it, and an
additional validation should be made (like IP validation). This may
not be practical for very long-lived sessions (that would persist
across client machines, for example). That data should probably be
stored as cookies only, or be accessed from a more permanent database
store (and then put into a session).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The format of the SESSION file may be NDBM or JSON. JSON is preferred,
because it is human readable.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">uuid</font> is presumed to provide unique ids, even if running in
multiple processes on the same machine. -v1 or -v4 are (presumed)
useful, and -v1 is the default in this code.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="JSON.html">JSON</a><br>
<a href="NDBM.html">NDBM</a><br>
<a href="READFILE.html">READFILE</a><br>
<a href="REPL.html">REPL</a><br>
<a href="TIME.html">TIME</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BQ.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;JSON.INC&#39;
-INCLUDE &#39;NDBM.INC&#39;
-INCLUDE &#39;READFILE.INC&#39;
-INCLUDE &#39;REPL.INC&#39;
-INCLUDE &#39;TIME.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SESSION&raquo;&equiv;</b>
-MODULE SESSION
-PUBLIC SESSION_CREATE(), SESSION_DELETE(), SESSION_TOUCH()
-PUBLIC SESSION_PERSIST(), SESSION_LOAD(), SESSION_EXPIRE()
-PUBLIC SESSION_PERSIST_DIR
         DEFINE(&#39;SESSION_CREATE(EXPIRE_TIME)&#39;)
         DEFINE(&#39;SESSION_DELETE(SESSION)&#39;)
         DEFINE(&#39;SESSION_TOUCH(SESSION)&#39;)
         DEFINE(&#39;SESSION_PERSIST(SESSION)FILE,HANDLE,A,I&#39;)
         DEFINE(&#39;SESSION_LOAD(UUID)FILE,HANDLE,KEY,DATA,I&#39;)
         DEFINE(&#39;SESSION_EXPIRE()SESSION,TIME,UUID,L,I,S,P&#39;)
<font color="#818181"><i>*</i></font>
         SESSION_PERSIST_DIR = &#39;/var/lib/SESSION/&#39;        <b>:(SESSION_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CREATE NEW SESSION. GENERATE UUID FOR SESSION. DEFAULT SESSION</i></font>
<font color="#818181"><i>* EXPIRATION TO 10 MINUTES (UNLESS SPECIFIED).</i></font>
<font color="#818181"><i>*</i></font>
SESSION_CREATE
         SESSION_CREATE = TABLE()
         SESSION_CREATE&lt;&#39;UUID&#39;&gt; = BQ(&#39;/usr/bin/uuid -v1&#39;)    <b>:F(FRETURN)</b>
         EXPIRE_TIME = IDENT(EXPIRE_TIME) 600
         SESSION_CREATE&lt;&#39;EXPIRE_TIME&#39;&gt; = EXPIRE_TIME           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TOUCH THE SESSION; SETS THE &#39;EXPIRE&#39; TIME FOR NOW + EXPIRE_TIME.</i></font>
<font color="#818181"><i>*</i></font>
SESSION_TOUCH
         IDENT(SESSION)                                      <b>:S(FRETURN)</b>
         SESSION&lt;&#39;EXPIRE&#39;&gt; = TV_SEC(GETTIMEOFDAY()) +
+                               SESSION&lt;&#39;EXPIRE_TIME&#39;&gt;        <b>:S(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PERSIST SESSION TO DISK. SCALAR VARIABLES ONLY. ARRAYS AND TABLES</i></font>
<font color="#818181"><i>* ARE NOT PERSISTED (ONLY AS THEY PRINT).</i></font>
<font color="#818181"><i>*</i></font>
SESSION_PERSIST
         FILE = SESSION_PERSIST_DIR &#39;session_&#39; SESSION&lt;&#39;UUID&#39;&gt;
         SESSION_DELETE(SESSION)
         SESSION_TOUCH(SESSION)                              <b>:F(FRETURN)</b>
<font color="#818181"><i>*        A = CONVERT(SESSION, &#39;ARRAY&#39;)                       <b>:F(FRETURN)</b></i></font>
<font color="#818181"><i>*        HANDLE = DBM_OPEN(FILE, &#39;CW&#39;, &#39;0660&#39;)               <b>:F(FRETURN)</b></i></font>
<font color="#818181"><i>*        SEQ(&#39; DBM_STORE(&#39;</i></font>
<font color="#818181"><i>*+                &#39;HANDLE, A&lt;I, 1&gt;, VDIFFER(A&lt;I, 2&gt;), DBM_INSERT) &#39;, .I)</i></font>
<font color="#818181"><i>*        A&lt;I&gt;                                                <b>:S(FRETURN)</b></i></font>
<font color="#818181"><i>*        DBM_CLOSE(HANDLE)                          <b>:S(RETURN)F(FRETURN)</b></i></font>
         WRITEFILE(FILE &#39;.db&#39;, JSON_ENCODE(SESSION))
+                                                   <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DELETE SESSION</i></font>
<font color="#818181"><i>*</i></font>
SESSION_DELETE
         DELETE(SESSION_PERSIST_DIR &#39;session_&#39; SESSION&lt;&#39;UUID&#39;&gt; &#39;.db&#39;)
+                                                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* LOAD SESSION GIVEN UUID. USUALLY, THE UUID COMES FROM A COOKIE.</i></font>
<font color="#818181"><i>*</i></font>
SESSION_LOAD
         UUID = REPL(UUID, &#39; &#39;, &#39;&#39;)
         UUID = REPL(UUID, CHARS_TAB, &#39;&#39;)
         UUID = REPLACE(UUID, &amp;UCASE, &amp;LCASE)
         UUID POS(0) ANY(&#39;&quot;&#39; &quot;&#39;&quot;) REM . UUID
         UUID POS(0) SPAN(&amp;DIGITS &#39;abcdef-&#39;) . UUID
<font color="#818181"><i>*        SESSION_LOAD = TABLE()</i></font>
         FILE = SESSION_PERSIST_DIR &#39;session_&#39; UUID
<font color="#818181"><i>*        HANDLE = DBM_OPEN(FILE, &#39;R&#39;)                        <b>:F(FRETURN)</b></i></font>
<font color="#818181"><i>*        KEY = DBM_FIRSTKEY(HANDLE)                    <b>:F(SESSION_LOAD2)</b></i></font>
<font color="#818181"><i>*        SEQ(&#39; DATA = DBM_FETCH(HANDLE, KEY);&#39;</i></font>
<font color="#818181"><i>*+           &#39; SESSION_LOAD&lt;KEY&gt; = DATA;&#39;</i></font>
<font color="#818181"><i>*+           &#39; KEY = DBM_NEXTKEY(HANDLE) &#39;, .I)</i></font>
<font color="#818181"><i>*        DBM_CLOSE(HANDLE)                                   <b>:F(FRETURN)</b></i></font>
         SESSION_LOAD = JSON_DECODE(READFILE(FILE &#39;.db&#39;))    <b>:F(FRETURN)</b>
         IDENT(UUID, SESSION_LOAD&lt;&#39;UUID&#39;&gt;)          <b>:S(RETURN)F(FRETURN)</b>
SESSION_LOAD2
         DBM_CLOSE(HANDLE)                                    <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REMOVE EXPIRED SESSIONS FROM DISK.</i></font>
<font color="#818181"><i>*</i></font>
SESSION_EXPIRE
         L = BQ(&#39;ls &#39; SESSION_PERSIST_DIR &#39;session_*.db 2&gt;/dev/null&#39;)
+                                                             <b>:F(RETURN)</b>
         TIME = TV_SEC(GETTIMEOFDAY())
         L = CRACK(L, &#39; &#39;)
         P = SESSION_PERSIST_DIR &#39;session_&#39; BREAK(&#39;.&#39;) . UUID &#39;.db&#39;
SESSION_EXPIRE2
         I = I + 1
         S = L&lt;I&gt;                                             <b>:F(RETURN)</b>
         S P                                                  <b>:F(RETURN)</b>
         SESSION = SESSION_LOAD(UUID)                <b>:F(SESSION_EXPIRE2)</b>
         GE(SESSION&lt;&#39;EXPIRE&#39;&gt;, TIME)                 <b>:S(SESSION_EXPIRE2)</b>
         SESSION_DELETE(SESSION)                      <b>:(SESSION_EXPIRE2)</b>
<font color="#818181"><i>*</i></font>
SESSION_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SESSION.INC&#39;
         &amp;CODE = 1
<font color="#818181"><i>* REMOVE ALL SESSIONS</i></font>
         BQ(&#39;rm -f &#39; SESSION_PERSIST_DIR &#39;session_*.db&#39;)
<font color="#818181"><i>* EXPIRE, EMPTY SESSIONS</i></font>
         SESSION_EXPIRE()
<font color="#818181"><i>* CREATE A &#39;PERMANENT&#39; SESSION (1 YEAR EXPIRY)</i></font>
         SESSION = SESSION_CREATE(31536000)
         UUID1 = SESSION&lt;&#39;UUID&#39;&gt;
         SESSION&lt;&#39;VAR&#39;&gt; = &#39;FIRST&#39;
<font color="#818181"><i>* PERSIST THE SESSION</i></font>
         SESSION_PERSIST(SESSION)                                <b>:F(END)</b>
<font color="#818181"><i>* EXPIRE, SHOULDN&#39;T DO ANYTHING</i></font>
         SESSION_EXPIRE()
<font color="#818181"><i>* CREATE A SHORT-LIVED SESSION, 5 SECONDS. NOTE THAT THE UNIT TEST</i></font>
<font color="#818181"><i>* WILL TAKE AT LEAST THIS TIME TO RUN.</i></font>
         SESSION = SESSION_CREATE(5)
         UUID2 = SESSION&lt;&#39;UUID&#39;&gt;
         SESSION&lt;&#39;VAR&#39;&gt; = &#39;SECOND&#39;
         SESSION_PERSIST(SESSION)                                <b>:F(END)</b>
<font color="#818181"><i>* LOAD AND CHECK FIRST SESSION</i></font>
         SESS = SESSION_LOAD(UUID1)                              <b>:F(END)</b>
         IDENT(SESS&lt;&#39;VAR&#39;&gt;, &#39;FIRST&#39;)                             <b>:F(END)</b>
<font color="#818181"><i>* LOAD AND CHECK SECOND SESSION</i></font>
         SESS = SESSION_LOAD(UUID2)                              <b>:F(END)</b>
         IDENT(SESS&lt;&#39;VAR&#39;&gt;, &#39;SECOND&#39;)                            <b>:F(END)</b>
<font color="#818181"><i>* WAIT LONGER THAN 5 SECONDS (EXPIRY TIME OF SECOND SESSION)</i></font>
         SLEEP(6)
<font color="#818181"><i>* EXPIRE, SHOULD REMOVE SECOND SESSION</i></font>
         SESSION_EXPIRE()
<font color="#818181"><i>* TRY LOADING SESSIONS, UUID2 SHOULD BE EXPIRED AND FAIL</i></font>
         SESSION = SESSION_LOAD(UUID2)                           <b>:S(END)</b>
         SESSION = SESSION_LOAD(UUID1)                           <b>:F(END)</b>
<font color="#818181"><i>* DELETE SESSION UUID1</i></font>
         SESSION_DELETE(SESSION)
<font color="#818181"><i>* SESSION UUID1 SHOULD NOW FAIL WHEN LOAD ATTEMPTED</i></font>
         SESSION = SESSION_LOAD(UUID1)                           <b>:S(END)</b>
<font color="#818181"><i>*</i></font>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL SESSION
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*       #####   #######   #####    #####   ###  #######  #     #       *</i></font>
<font color="#818181"><i>*      #     #  #        #     #  #     #   #   #     #  ##    #       *</i></font>
<font color="#818181"><i>*      #        #        #        #         #   #     #  # #   #       *</i></font>
<font color="#818181"><i>*       #####   #####     #####    #####    #   #     #  #  #  #       *</i></font>
<font color="#818181"><i>*            #  #              #        #   #   #     #  #   # #       *</i></font>
<font color="#818181"><i>*      #     #  #        #     #  #     #   #   #     #  #    ##       *</i></font>
<font color="#818181"><i>*       #####   #######   #####    #####   ###  #######  #     #       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SESSION               SESSION SUPPORT FOR CGI                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SESSION.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SESSION&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:41 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SESSION.INC'
-LINE 187 "SESSION.lss"
         &CODE = 1
* REMOVE ALL SESSIONS
         BQ('rm -f ' SESSION_PERSIST_DIR 'session_*.db')
* EXPIRE, EMPTY SESSIONS
         SESSION_EXPIRE()
* CREATE A 'PERMANENT' SESSION (1 YEAR EXPIRY)
         SESSION = SESSION_CREATE(31536000)
         UUID1 = SESSION<'UUID'>
         SESSION<'VAR'> = 'FIRST'
* PERSIST THE SESSION
         SESSION_PERSIST(SESSION)                                :F(END)
* EXPIRE, SHOULDN'T DO ANYTHING
         SESSION_EXPIRE()
* CREATE A SHORT-LIVED SESSION, 5 SECONDS. NOTE THAT THE UNIT TEST
* WILL TAKE AT LEAST THIS TIME TO RUN.
         SESSION = SESSION_CREATE(5)
         UUID2 = SESSION<'UUID'>
         SESSION<'VAR'> = 'SECOND'
         SESSION_PERSIST(SESSION)                                :F(END)
* LOAD AND CHECK FIRST SESSION
         SESS = SESSION_LOAD(UUID1)                              :F(END)
         IDENT(SESS<'VAR'>, 'FIRST')                             :F(END)
* LOAD AND CHECK SECOND SESSION
         SESS = SESSION_LOAD(UUID2)                              :F(END)
         IDENT(SESS<'VAR'>, 'SECOND')                            :F(END)
* WAIT LONGER THAN 5 SECONDS (EXPIRY TIME OF SECOND SESSION)
         SLEEP(6)
* EXPIRE, SHOULD REMOVE SECOND SESSION
         SESSION_EXPIRE()
* TRY LOADING SESSIONS, UUID2 SHOULD BE EXPIRED AND FAIL
         SESSION = SESSION_LOAD(UUID2)                           :S(END)
         SESSION = SESSION_LOAD(UUID1)                           :F(END)
* DELETE SESSION UUID1
         SESSION_DELETE(SESSION)
* SESSION UUID1 SHOULD NOW FAIL WHEN LOAD ATTEMPTED
         SESSION = SESSION_LOAD(UUID1)                           :S(END)
*
         &CODE = 0
END
<h1>SIZEA - Array size, first dimension</h1>

[[SIZEA(A)]] returns the number of elements in array [[A]]. The number
of elements in the first (leftmost) dimension is returned. [[ARRAY0]]
is the array with no elements.

Warning: this doesn't work with SPITBOL. We do accomodate SPITBOL by
defining a specific legal array as ARRAY0, and checking for that
object is [[SIZEA()]] and [[LOWA()]].

The null string is assumed to be an array with no elements. Otherwise,
if the datatype is not array, [[SIZEA()]] fails. The prototype is
analyzed to determine the single size, or upper:lower, the number of
elements is computed and returned.

[[LOWA(A)]] returns the index of the first element of array [[A]].

<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="SWAP.html">SWAP</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>

<<INCLUDES>>=
-INCLUDE 'BRKREM.INC'
-INCLUDE 'SWAP.INC'
-INCLUDE 'SYSTEM.INC'
@

<<SIZEA>>=
-MODULE SIZEA
-PUBLIC SIZEA(), LOWA(), ARRAY0
         DEFINE('SIZEA(A)L,U')
         DEFINE('LOWA(A)L,U')
         ARRAY0 = ?(SYSTEM() ? 'SPITBOL')
+                                   ARRAY('-10000:-10000') :S(SIZEA_END)
         ARRAY0 = ARRAY('0:-1')                             :(SIZEA_END)
*
LOWA     LOWA = IDENT(A) 0                                    :S(RETURN)
         LOWA = IDENT(A, ARRAY0) 0                            :S(RETURN)
         IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
         PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
         IDENT(L)                                            :S(FRETURN)
         LOWA = L
         LOWA = IDENT(U) 1                                     :(RETURN)
*
SIZEA    SIZEA = IDENT(A) 0                                   :S(RETURN)
         SIZEA = IDENT(A, ARRAY0) 0                           :S(RETURN)
         IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
         L =
         U =
         PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
         IDENT(L)                                            :S(FRETURN)
         U = IDENT(U) 1                                      :F(SIZEA_2)
         SWAP(.L, .U)
SIZEA_2  SIZEA = LT(U, L) 0                                   :S(RETURN)
         SIZEA = U - L + 1                                     :(RETURN)
*
SIZEA_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'SIZEA.INC'
*
         &CODE = 1
         OUTPUT = 'SIZEA/LOWA ARRAY(10)'
         OUTPUT = SIZEA(ARRAY(10))
         OUTPUT = LOWA(ARRAY(10))
         OUTPUT = 'SIZEA/LOWA NULL'
         OUTPUT = SIZEA('')
         OUTPUT = LOWA('')
         OUTPUT = 'SIZEA/LOWA ARRAY(-10:10)'
         OUTPUT = SIZEA(ARRAY('-10:10'))
         OUTPUT = LOWA(ARRAY('-10:10'))
         OUTPUT = 'SIZEA/LOWA ARRAY0'
         OUTPUT = SIZEA(ARRAY0)
         OUTPUT = LOWA(ARRAY0)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL SIZEA
-EJECT
*
************************************************************************
*                                                                      *
*                 #####   ###  #######  #######     #                  *
*                #     #   #        #   #          # #                 *
*                #         #       #    #         #   #                *
*                 #####    #     #      #####    #     #               *
*                      #   #    #       #        #######               *
*                #     #   #   #        #        #     #               *
*                 #####   ###  #######  #######  #     #               *
*                                                                      *
* SIZEA                       SIZE OF ARRAY                            *
*                                                                      *
************************************************************************
*
* SIZEA.lss
*
<<SIZEA>>
*
* CE: .F.MSNOBOL4;
@
-LINE 24 "SIZEA.lss"
-INCLUDE 'BRKREM.INC'
-INCLUDE 'SWAP.INC'
-INCLUDE 'SYSTEM.INC'
-STITL SIZEA
-EJECT
-LINE 87 "SIZEA.lss"
*
************************************************************************
*                                                                      *
*                 #####   ###  #######  #######     #                  *
*                #     #   #        #   #          # #                 *
*                #         #       #    #         #   #                *
*                 #####    #     #      #####    #     #               *
*                      #   #    #       #        #######               *
*                #     #   #   #        #        #     #               *
*                 #####   ###  #######  #######  #     #               *
*                                                                      *
* SIZEA                       SIZE OF ARRAY                            *
*                                                                      *
************************************************************************
*
* SIZEA.lss
*
-LINE 30 "SIZEA.lss"
-MODULE SIZEA
-PUBLIC SIZEA(), LOWA(), ARRAY0
         DEFINE('SIZEA(A)L,U')
         DEFINE('LOWA(A)L,U')
         ARRAY0 = ?(SYSTEM() ? 'SPITBOL')
+                                   ARRAY('-10000:-10000') :S(SIZEA_END)
         ARRAY0 = ARRAY('0:-1')                             :(SIZEA_END)
*
LOWA     LOWA = IDENT(A) 0                                    :S(RETURN)
         LOWA = IDENT(A, ARRAY0) 0                            :S(RETURN)
         IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
         PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
         IDENT(L)                                            :S(FRETURN)
         LOWA = L
         LOWA = IDENT(U) 1                                     :(RETURN)
*
SIZEA    SIZEA = IDENT(A) 0                                   :S(RETURN)
         SIZEA = IDENT(A, ARRAY0) 0                           :S(RETURN)
         IDENT(DATATYPE(A), 'ARRAY')                         :F(FRETURN)
         L =
         U =
         PROTOTYPE(A) (BRKREM(':,') . L) ((':' BRKREM(',') . U) | NULL)
         IDENT(L)                                            :S(FRETURN)
         U = IDENT(U) 1                                      :F(SIZEA_2)
         SWAP(.L, .U)
SIZEA_2  SIZEA = LT(U, L) 0                                   :S(RETURN)
         SIZEA = U - L + 1                                     :(RETURN)
*
SIZEA_END
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SIZEA - Array size, first dimension</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SIZEA(A)</font> returns the number of elements in array <font face="Source Code Pro">A</font>. The number
of elements in the first (leftmost) dimension is returned. <font face="Source Code Pro">ARRAY0</font>
is the array with no elements.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Warning: this doesn't work with SPITBOL. We do accomodate SPITBOL by
defining a specific legal array as ARRAY0, and checking for that
object is <font face="Source Code Pro">SIZEA()</font> and <font face="Source Code Pro">LOWA()</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
The null string is assumed to be an array with no elements. Otherwise,
if the datatype is not array, <font face="Source Code Pro">SIZEA()</font> fails. The prototype is
analyzed to determine the single size, or upper:lower, the number of
elements is computed and returned.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">LOWA(A)</font> returns the index of the first element of array <font face="Source Code Pro">A</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="SWAP.html">SWAP</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BRKREM.INC&#39;
-INCLUDE &#39;SWAP.INC&#39;
-INCLUDE &#39;SYSTEM.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SIZEA&raquo;&equiv;</b>
-MODULE SIZEA
-PUBLIC SIZEA(), LOWA(), ARRAY0
         DEFINE(&#39;SIZEA(A)L,U&#39;)
         DEFINE(&#39;LOWA(A)L,U&#39;)
         ARRAY0 = ?(SYSTEM() ? &#39;SPITBOL&#39;)
+                                   ARRAY(&#39;-10000:-10000&#39;) <b>:S(SIZEA_END)</b>
         ARRAY0 = ARRAY(&#39;0:-1&#39;)                             <b>:(SIZEA_END)</b>
<font color="#818181"><i>*</i></font>
LOWA     LOWA = IDENT(A) 0                                    <b>:S(RETURN)</b>
         LOWA = IDENT(A, ARRAY0) 0                            <b>:S(RETURN)</b>
         IDENT(DATATYPE(A), &#39;ARRAY&#39;)                         <b>:F(FRETURN)</b>
         PROTOTYPE(A) (BRKREM(&#39;:,&#39;) . L) ((&#39;:&#39; BRKREM(&#39;,&#39;) . U) | NULL)
         IDENT(L)                                            <b>:S(FRETURN)</b>
         LOWA = L
         LOWA = IDENT(U) 1                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SIZEA    SIZEA = IDENT(A) 0                                   <b>:S(RETURN)</b>
         SIZEA = IDENT(A, ARRAY0) 0                           <b>:S(RETURN)</b>
         IDENT(DATATYPE(A), &#39;ARRAY&#39;)                         <b>:F(FRETURN)</b>
         L =
         U =
         PROTOTYPE(A) (BRKREM(&#39;:,&#39;) . L) ((&#39;:&#39; BRKREM(&#39;,&#39;) . U) | NULL)
         IDENT(L)                                            <b>:S(FRETURN)</b>
         U = IDENT(U) 1                                      <b>:F(SIZEA_2)</b>
         SWAP(.L, .U)
SIZEA_2  SIZEA = LT(U, L) 0                                   <b>:S(RETURN)</b>
         SIZEA = U - L + 1                                     <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SIZEA_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;/usr/local/bin/snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SIZEA.INC&#39;
<font color="#818181"><i>*</i></font>
         &amp;CODE = 1
         OUTPUT = &#39;SIZEA/LOWA ARRAY(10)&#39;
         OUTPUT = SIZEA(ARRAY(10))
         OUTPUT = LOWA(ARRAY(10))
         OUTPUT = &#39;SIZEA/LOWA NULL&#39;
         OUTPUT = SIZEA(&#39;&#39;)
         OUTPUT = LOWA(&#39;&#39;)
         OUTPUT = &#39;SIZEA/LOWA ARRAY(-10:10)&#39;
         OUTPUT = SIZEA(ARRAY(&#39;-10:10&#39;))
         OUTPUT = LOWA(ARRAY(&#39;-10:10&#39;))
         OUTPUT = &#39;SIZEA/LOWA ARRAY0&#39;
         OUTPUT = SIZEA(ARRAY0)
         OUTPUT = LOWA(ARRAY0)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL SIZEA
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 #####   ###  #######  #######     #                  *</i></font>
<font color="#818181"><i>*                #     #   #        #   #          # #                 *</i></font>
<font color="#818181"><i>*                #         #       #    #         #   #                *</i></font>
<font color="#818181"><i>*                 #####    #     #      #####    #     #               *</i></font>
<font color="#818181"><i>*                      #   #    #       #        #######               *</i></font>
<font color="#818181"><i>*                #     #   #   #        #        #     #               *</i></font>
<font color="#818181"><i>*                 #####   ###  #######  #######  #     #               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SIZEA                       SIZE OF ARRAY                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SIZEA.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SIZEA&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Sun Jun  8 01:21:14 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "/usr/local/bin/snobol4" "-b" "$0" "$@"
-INCLUDE 'SIZEA.INC'
-LINE 65 "SIZEA.lss"
*
         &CODE = 1
         OUTPUT = 'SIZEA/LOWA ARRAY(10)'
         OUTPUT = SIZEA(ARRAY(10))
         OUTPUT = LOWA(ARRAY(10))
         OUTPUT = 'SIZEA/LOWA NULL'
         OUTPUT = SIZEA('')
         OUTPUT = LOWA('')
         OUTPUT = 'SIZEA/LOWA ARRAY(-10:10)'
         OUTPUT = SIZEA(ARRAY('-10:10'))
         OUTPUT = LOWA(ARRAY('-10:10'))
         OUTPUT = 'SIZEA/LOWA ARRAY0'
         OUTPUT = SIZEA(ARRAY0)
         OUTPUT = LOWA(ARRAY0)
         &CODE = 0
END
<h1>SIZET - Number of items in table</h1>

[[SIZET(T)]] returns the number of items in table [[T]].

<h2>Uses</h2>
<a href="HASH.html">HASH</a><br>
<a href="SIZEA.html">SIZEA</a><br>

<<INCLUDES>>= 
-INCLUDE 'HASH.INC'
-INCLUDE 'SIZEA.INC'
@

<<SIZET>>=
-PUBLIC SIZET()
*
         DEFINE('SIZET(T)')                                 :(END_SIZET)
*
SIZET    SIZET =  SIZEA(KEYST(T))                              :(RETURN)
*
END_SIZET
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SIZET.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE SIZEL
-IN72
<<INCLUDES>>
-STITL SIZET
-EJECT
*
************************************************************************
*                                                                      *
*                #####   ###  #######  #######  #######                *
*               #     #   #        #   #           #                   *
*               #         #       #    #           #                   *
*                #####    #     #      #####       #                   *
*                     #   #    #       #           #                   *
*               #     #   #   #        #           #                   *
*                #####   ###  #######  #######     #                   *
*                                                                      *
* SIZET                    SIZE OF TABLE                               *
*                                                                      *
************************************************************************
*
* SIZET.lss
*
<<SIZET>>
*
* CE: .MSNOBOL4;
@
-MODULE SIZEL
-IN72
-LINE 10 "SIZET.lss"
-INCLUDE 'HASH.INC'
-INCLUDE 'SIZEA.INC'
-LINE 37 "SIZET.lss"
-STITL SIZET
-EJECT
*
************************************************************************
*                                                                      *
*                #####   ###  #######  #######  #######                *
*               #     #   #        #   #           #                   *
*               #         #       #    #           #                   *
*                #####    #     #      #####       #                   *
*                     #   #    #       #           #                   *
*               #     #   #   #        #           #                   *
*                #####   ###  #######  #######     #                   *
*                                                                      *
* SIZET                    SIZE OF TABLE                               *
*                                                                      *
************************************************************************
*
* SIZET.lss
*
-LINE 15 "SIZET.lss"
-PUBLIC SIZET()
*
         DEFINE('SIZET(T)')                                 :(END_SIZET)
*
SIZET    SIZET =  SIZEA(KEYST(T))                              :(RETURN)
*
END_SIZET
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SIZET - Number of items in table</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SIZET(T)</font> returns the number of items in table <font face="Source Code Pro">T</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="HASH.html">HASH</a><br>
<a href="SIZEA.html">SIZEA</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;HASH.INC&#39;
-INCLUDE &#39;SIZEA.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SIZET&raquo;&equiv;</b>
-PUBLIC SIZET()
<font color="#818181"><i>*</i></font>
         DEFINE(&#39;SIZET(T)&#39;)                                 <b>:(END_SIZET)</b>
<font color="#818181"><i>*</i></font>
SIZET    SIZET =  SIZEA(KEYST(T))                              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END_SIZET
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SIZET.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE SIZEL
-IN72
<b>&laquo;INCLUDES&raquo;</b>
-STITL SIZET
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                #####   ###  #######  #######  #######                *</i></font>
<font color="#818181"><i>*               #     #   #        #   #           #                   *</i></font>
<font color="#818181"><i>*               #         #       #    #           #                   *</i></font>
<font color="#818181"><i>*                #####    #     #      #####       #                   *</i></font>
<font color="#818181"><i>*                     #   #    #       #           #                   *</i></font>
<font color="#818181"><i>*               #     #   #   #        #           #                   *</i></font>
<font color="#818181"><i>*                #####   ###  #######  #######     #                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SIZET                    SIZE OF TABLE                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SIZET.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SIZET&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Tue Jun 10 06:49:26 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SIZET.INC'
-LINE 28 "SIZET.lss"
         &CODE = 1
         &CODE = 0
END
<h1>SKIM - Skim unique characters</h1>

[[SKIM(S)]] skims off the first appearance of each different
character of [[S]] and returns the result. [[SKIM('MISSISSIPPI')]]
returns [['MISP']].

<h2>Uses</h2>
<a href="SDIFF.html">SDIFF</a><br>

<<INCLUDES>>=
-INCLUDE 'SDIFF.INC'
@

<<SKIM>>=
-MODULE SKIM
-PUBLIC SKIM()
         DEFINE('SKIM(S)C')                                  :(SKIM_END)
*
SKIM     S LEN(1) . C =                                       :F(RETURN)
         SKIM C                                               :S(SKIM_D)
         SKIM = SKIM C                                           :(SKIM)
SKIM_D   S = SDIFF(S, SKIM)                                      :(SKIM)
*
SKIM_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SKIM.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL SKIM
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                    #####   #    #  ###  #     #                      *
*                   #     #  #   #    #   ##   ##                      *
*                   #        #  #     #   # # # #                      *
*                    #####   ###      #   #  #  #                      *
*                         #  #  #     #   #     #                      *
*                   #     #  #   #    #   #     #                      *
*                    #####   #    #  ###  #     #                      *
*                                                                      *
* SKIM                 SKIM UNIQUE CHARACTERS                          *
*                                                                      *
************************************************************************
*
* SKIM.lss
*
<<SKIM>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "SKIM.lss"
-INCLUDE 'SDIFF.INC'
-STITL SKIM
-EJECT
-LINE 40 "SKIM.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*                    #####   #    #  ###  #     #                      *
*                   #     #  #   #    #   ##   ##                      *
*                   #        #  #     #   # # # #                      *
*                    #####   ###      #   #  #  #                      *
*                         #  #  #     #   #     #                      *
*                   #     #  #   #    #   #     #                      *
*                    #####   #    #  ###  #     #                      *
*                                                                      *
* SKIM                 SKIM UNIQUE CHARACTERS                          *
*                                                                      *
************************************************************************
*
* SKIM.lss
*
-LINE 15 "SKIM.lss"
-MODULE SKIM
-PUBLIC SKIM()
         DEFINE('SKIM(S)C')                                  :(SKIM_END)
*
SKIM     S LEN(1) . C =                                       :F(RETURN)
         SKIM C                                               :S(SKIM_D)
         SKIM = SKIM C                                           :(SKIM)
SKIM_D   S = SDIFF(S, SKIM)                                      :(SKIM)
*
SKIM_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SKIM - Skim unique characters</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SKIM(S)</font> skims off the first appearance of each different
character of <font face="Source Code Pro">S</font> and returns the result. <font face="Source Code Pro">SKIM('MISSISSIPPI')</font>
returns <font face="Source Code Pro">'MISP'</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SDIFF.html">SDIFF</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SDIFF.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SKIM&raquo;&equiv;</b>
-MODULE SKIM
-PUBLIC SKIM()
         DEFINE(&#39;SKIM(S)C&#39;)                                  <b>:(SKIM_END)</b>
<font color="#818181"><i>*</i></font>
SKIM     S LEN(1) . C =                                       <b>:F(RETURN)</b>
         SKIM C                                               <b>:S(SKIM_D)</b>
         SKIM = SKIM C                                           <b>:(SKIM)</b>
SKIM_D   S = SDIFF(S, SKIM)                                      <b>:(SKIM)</b>
<font color="#818181"><i>*</i></font>
SKIM_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SKIM.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL SKIM
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #####   #    #  ###  #     #                      *</i></font>
<font color="#818181"><i>*                   #     #  #   #    #   ##   ##                      *</i></font>
<font color="#818181"><i>*                   #        #  #     #   # # # #                      *</i></font>
<font color="#818181"><i>*                    #####   ###      #   #  #  #                      *</i></font>
<font color="#818181"><i>*                         #  #  #     #   #     #                      *</i></font>
<font color="#818181"><i>*                   #     #  #   #    #   #     #                      *</i></font>
<font color="#818181"><i>*                    #####   #    #  ###  #     #                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SKIM                 SKIM UNIQUE CHARACTERS                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SKIM.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SKIM&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:22 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SKIM.INC'
-LINE 31 "SKIM.lss"
         &CODE = 1
         &CODE = 0
END
<h1>SLOAD - Load SNOBOL4 source</h1>

Find and load a SNOBOL4 source file. Recursively load any INCLUDE
files needed.

<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="HOST.html">HOST</a><br>
<a href="TRIMB.html">TRIMB</a><br>

<<INCLUDES>>=
-INCLUDE 'CRACK.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'TRIMB.INC'
@

<<SLOAD>>=
-MODULE SLOAD
-PUBLIC SLOAD()
         DEFINE('SLOAD(FILENAME)'
+               'LIB,CODE,PATH,X,A,I,P,PS,DS,TRIM_SAV,POSITION,UNIT')
         Q_ = "'"
         QQ_ = '"'
         SLOAD_STMT = ARBNO(Q_ BREAK(Q_) Q_ | QQ_ BREAK(QQ_) QQ_ |
+                     NOTANY(Q_ QQ_) BREAK(Q_ QQ_ ';')) ';'
         SLOAD_STMTS = FENCE (';' ARBNO(SLOAD_STMT)) . X '*' REM
* NOTE THAT ; FOLLOWED BY ANYTHING OTHER THAN . OR + IS ALSO A COMMENT
         SLOAD_CCPAT = FENCE ('*' | '-' | '#' | '!' | '|' | RPOS(0))
         SLOAD_CNPAT = FENCE (';.' | ';+')
         SLOAD_INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                                (ANY('Cc') ('OPY' | 'opy')))
+                      BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
         SLOAD_TAB = TABLE()                                :(SLOAD_END)
*
* FUNCTION TO READ AND COMPILE SNOBOL4 FUNCTIONS FROM A DISK FILE.
* THE FILENAME IS SPECIFIED AS THE ARGUMENT TO FUNCTION SLOAD.
*
SLOAD    UNIT = IO_FINDUNIT()
         PATH = FILENAME
         INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, 'SNOPATH')                    :S(SLOAD_8)
         X = HOST(HOST_GETENV, 'SNOLIB')                     :S(SLOAD_8)
         X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
SLOAD_8  A = CRACK(X, PS)
         I = 1
SLOAD_10 P = TRIMB(A<I>)                                     :F(FRETURN)
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
         I = I + 1                                           :(SLOAD_10)
*
SLOAD_0  TRIM_SAV = &TRIM
         &TRIM = 1
*
SLOAD_1  X = LIB                                             :F(SLOAD_2)
         X SLOAD_CCPAT                                       :S(SLOAD_4)
         X = ';' X
         X SLOAD_CNPAT = ' '
         X SLOAD_STMTS
         CODE = CODE X                                        :(SLOAD_1)
*
SLOAD_4  X SLOAD_INPAT                                       :F(SLOAD_1)
         DIFFER(SLOAD_TAB<X>)                                :S(SLOAD_1)
*
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
*
         SLOAD(X)                                            :F(FRETURN)
*
         INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
*
         SLOAD_TAB<X> = 1
         FILENAME FENCE '/dev/'                              :S(SLOAD_1)
         EQ(SET(UNIT, POSITION, 0), POSITION)      :S(SLOAD_1)F(FRETURN)
*
SLOAD_2  ENDFILE(UNIT)
         DETACH(.LIB)
         CODE = CODE(CODE '; :(SLOAD_3)')                       :S<CODE>
         TERMINAL = 'COMPILATION ERROR, FILE: ' FILENAME
*
* ERROR. TAKE CODE APART STATEMENT BY STATEMENT TO FIND THE PROBLEM.
* FIRST REMOVE FROM INCLUDE FILE TABLE, THEN REMOVE INITIAL ';'
*
         SLOAD_TAB<X> =
         CODE = SUBSTR(CODE, 2)
SLOAD_6  CODE FENCE SLOAD_STMT . X =                         :F(SLOAD_7)
         CODE(X)                                             :S(SLOAD_6)
         X RTAB(1) . TERMINAL
SLOAD_7  &TRIM = TRIM_SAV
         TERMINAL = &ERRTEXT                                  :(FRETURN)
*
SLOAD_3  &TRIM = TRIM_SAV                                      :(RETURN)
*
SLOAD_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SLOAD.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL SLOAD
-EJECT
*
************************************************************************
*                                                                      *
*              #####   #        #######     #     ######               *
*             #     #  #        #     #    # #    #     #              *
*             #        #        #     #   #   #   #     #              *
*              #####   #        #     #  #     #  #     #              *
*                   #  #        #     #  #######  #     #              *
*             #     #  #        #     #  #     #  #     #              *
*              #####   #######  #######  #     #  ######               *
*                                                                      *
* SLOAD                LOAD SNOBOL4 SOURCE                             *
*                                                                      *
* (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *
*                                                                      *
* MODIFIED TO SUPPORT /DEV FILES, SEARCH CSNOBOL4 PATHS                *
*                                                                      *
************************************************************************
*
* SLOAD.lss
*
<<SLOAD>>
*
* CE: .MSNOBOL4;
@
-LINE 12 "SLOAD.lss"
-INCLUDE 'CRACK.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'TRIMB.INC'
-STITL SLOAD
-EJECT
-LINE 112 "SLOAD.lss"
*
************************************************************************
*                                                                      *
*              #####   #        #######     #     ######               *
*             #     #  #        #     #    # #    #     #              *
*             #        #        #     #   #   #   #     #              *
*              #####   #        #     #  #     #  #     #              *
*                   #  #        #     #  #######  #     #              *
*             #     #  #        #     #  #     #  #     #              *
*              #####   #######  #######  #     #  ######               *
*                                                                      *
* SLOAD                LOAD SNOBOL4 SOURCE                             *
*                                                                      *
* (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *
*                                                                      *
* MODIFIED TO SUPPORT /DEV FILES, SEARCH CSNOBOL4 PATHS                *
*                                                                      *
************************************************************************
*
* SLOAD.lss
*
-LINE 18 "SLOAD.lss"
-MODULE SLOAD
-PUBLIC SLOAD()
         DEFINE('SLOAD(FILENAME)'
+               'LIB,CODE,PATH,X,A,I,P,PS,DS,TRIM_SAV,POSITION,UNIT')
         Q_ = "'"
         QQ_ = '"'
         SLOAD_STMT = ARBNO(Q_ BREAK(Q_) Q_ | QQ_ BREAK(QQ_) QQ_ |
+                     NOTANY(Q_ QQ_) BREAK(Q_ QQ_ ';')) ';'
         SLOAD_STMTS = FENCE (';' ARBNO(SLOAD_STMT)) . X '*' REM
* NOTE THAT ; FOLLOWED BY ANYTHING OTHER THAN . OR + IS ALSO A COMMENT
         SLOAD_CCPAT = FENCE ('*' | '-' | '#' | '!' | '|' | RPOS(0))
         SLOAD_CNPAT = FENCE (';.' | ';+')
         SLOAD_INPAT = FENCE '-' ((ANY('Ii') ('NCLUDE' | 'nclude')) |
+                                (ANY('Cc') ('OPY' | 'opy')))
+                      BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
         SLOAD_TAB = TABLE()                                :(SLOAD_END)
*
* FUNCTION TO READ AND COMPILE SNOBOL4 FUNCTIONS FROM A DISK FILE.
* THE FILENAME IS SPECIFIED AS THE ARGUMENT TO FUNCTION SLOAD.
*
SLOAD    UNIT = IO_FINDUNIT()
         PATH = FILENAME
         INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, 'SNOPATH')                    :S(SLOAD_8)
         X = HOST(HOST_GETENV, 'SNOLIB')                     :S(SLOAD_8)
         X = HOST(HOST_SNOLIB_DIR)                           :F(FRETURN)
SLOAD_8  A = CRACK(X, PS)
         I = 1
SLOAD_10 P = TRIMB(A<I>)                                     :F(FRETURN)
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                            :S(SLOAD_0)
         I = I + 1                                           :(SLOAD_10)
*
SLOAD_0  TRIM_SAV = &TRIM
         &TRIM = 1
*
SLOAD_1  X = LIB                                             :F(SLOAD_2)
         X SLOAD_CCPAT                                       :S(SLOAD_4)
         X = ';' X
         X SLOAD_CNPAT = ' '
         X SLOAD_STMTS
         CODE = CODE X                                        :(SLOAD_1)
*
SLOAD_4  X SLOAD_INPAT                                       :F(SLOAD_1)
         DIFFER(SLOAD_TAB<X>)                                :S(SLOAD_1)
*
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
*
         SLOAD(X)                                            :F(FRETURN)
*
         INPUT(.LIB, UNIT,, PATH)                            :F(FRETURN)
*
         SLOAD_TAB<X> = 1
         FILENAME FENCE '/dev/'                              :S(SLOAD_1)
         EQ(SET(UNIT, POSITION, 0), POSITION)      :S(SLOAD_1)F(FRETURN)
*
SLOAD_2  ENDFILE(UNIT)
         DETACH(.LIB)
         CODE = CODE(CODE '; :(SLOAD_3)')                       :S<CODE>
         TERMINAL = 'COMPILATION ERROR, FILE: ' FILENAME
*
* ERROR. TAKE CODE APART STATEMENT BY STATEMENT TO FIND THE PROBLEM.
* FIRST REMOVE FROM INCLUDE FILE TABLE, THEN REMOVE INITIAL ';'
*
         SLOAD_TAB<X> =
         CODE = SUBSTR(CODE, 2)
SLOAD_6  CODE FENCE SLOAD_STMT . X =                         :F(SLOAD_7)
         CODE(X)                                             :S(SLOAD_6)
         X RTAB(1) . TERMINAL
SLOAD_7  &TRIM = TRIM_SAV
         TERMINAL = &ERRTEXT                                  :(FRETURN)
*
SLOAD_3  &TRIM = TRIM_SAV                                      :(RETURN)
*
SLOAD_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SLOAD - Load SNOBOL4 source</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Find and load a SNOBOL4 source file. Recursively load any INCLUDE
files needed.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="HOST.html">HOST</a><br>
<a href="TRIMB.html">TRIMB</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SLOAD&raquo;&equiv;</b>
-MODULE SLOAD
-PUBLIC SLOAD()
         DEFINE(&#39;SLOAD(FILENAME)&#39;
+               &#39;LIB,CODE,PATH,X,A,I,P,PS,DS,TRIM_SAV,POSITION,UNIT&#39;)
         Q_ = &quot;&#39;&quot;
         QQ_ = &#39;&quot;&#39;
         SLOAD_STMT = ARBNO(Q_ BREAK(Q_) Q_ | QQ_ BREAK(QQ_) QQ_ |
+                     NOTANY(Q_ QQ_) BREAK(Q_ QQ_ &#39;;&#39;)) &#39;;&#39;
         SLOAD_STMTS = FENCE (&#39;;&#39; ARBNO(SLOAD_STMT)) . X &#39;*&#39; REM
<font color="#818181"><i>* NOTE THAT ; FOLLOWED BY ANYTHING OTHER THAN . OR + IS ALSO A COMMENT</i></font>
         SLOAD_CCPAT = FENCE (&#39;*&#39; | &#39;-&#39; | &#39;#&#39; | &#39;!&#39; | &#39;|&#39; | RPOS(0))
         SLOAD_CNPAT = FENCE (&#39;;.&#39; | &#39;;+&#39;)
         SLOAD_INPAT = FENCE &#39;-&#39; ((ANY(&#39;Ii&#39;) (&#39;NCLUDE&#39; | &#39;nclude&#39;)) |
+                                (ANY(&#39;Cc&#39;) (&#39;OPY&#39; | &#39;opy&#39;)))
+                      BREAK(QQ_ Q_) LEN(1) BREAK(QQ_ Q_) . X
         SLOAD_TAB = TABLE()                                <b>:(SLOAD_END)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FUNCTION TO READ AND COMPILE SNOBOL4 FUNCTIONS FROM A DISK FILE.</i></font>
<font color="#818181"><i>* THE FILENAME IS SPECIFIED AS THE ARGUMENT TO FUNCTION SLOAD.</i></font>
<font color="#818181"><i>*</i></font>
SLOAD    UNIT = IO_FINDUNIT()
         PATH = FILENAME
         INPUT(.LIB, UNIT,, PATH)                            <b>:S(SLOAD_0)</b>
         DS = HOST(HOST_DIR_SEP)
         PS = HOST(HOST_PATH_SEP)
         X = HOST(HOST_GETENV, &#39;SNOPATH&#39;)                    <b>:S(SLOAD_8)</b>
         X = HOST(HOST_GETENV, &#39;SNOLIB&#39;)                     <b>:S(SLOAD_8)</b>
         X = HOST(HOST_SNOLIB_DIR)                           <b>:F(FRETURN)</b>
SLOAD_8  A = CRACK(X, PS)
         I = 1
SLOAD_10 P = TRIMB(A&lt;I&gt;)                                     <b>:F(FRETURN)</b>
         PATH = P DS FILENAME
         INPUT(.LIB, UNIT,, PATH)                            <b>:S(SLOAD_0)</b>
         I = I + 1                                           <b>:(SLOAD_10)</b>
<font color="#818181"><i>*</i></font>
SLOAD_0  TRIM_SAV = &amp;TRIM
         &amp;TRIM = 1
<font color="#818181"><i>*</i></font>
SLOAD_1  X = LIB                                             <b>:F(SLOAD_2)</b>
         X SLOAD_CCPAT                                       <b>:S(SLOAD_4)</b>
         X = &#39;;&#39; X
         X SLOAD_CNPAT = &#39; &#39;
         X SLOAD_STMTS
         CODE = CODE X                                        <b>:(SLOAD_1)</b>
<font color="#818181"><i>*</i></font>
SLOAD_4  X SLOAD_INPAT                                       <b>:F(SLOAD_1)</b>
         DIFFER(SLOAD_TAB&lt;X&gt;)                                <b>:S(SLOAD_1)</b>
<font color="#818181"><i>*</i></font>
         POSITION = SET(UNIT, 0, 1)
         ENDFILE(UNIT)
         DETACH(.LIB)
<font color="#818181"><i>*</i></font>
         SLOAD(X)                                            <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         INPUT(.LIB, UNIT,, PATH)                            <b>:F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
         SLOAD_TAB&lt;X&gt; = 1
         FILENAME FENCE &#39;/dev/&#39;                              <b>:S(SLOAD_1)</b>
         EQ(SET(UNIT, POSITION, 0), POSITION)      <b>:S(SLOAD_1)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
SLOAD_2  ENDFILE(UNIT)
         DETACH(.LIB)
         CODE = CODE(CODE &#39;; :(SLOAD_3)&#39;)                       <b>:S&lt;CODE&gt;</b>
         TERMINAL = &#39;COMPILATION ERROR, FILE: &#39; FILENAME
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ERROR. TAKE CODE APART STATEMENT BY STATEMENT TO FIND THE PROBLEM.</i></font>
<font color="#818181"><i>* FIRST REMOVE FROM INCLUDE FILE TABLE, THEN REMOVE INITIAL &#39;;&#39;</i></font>
<font color="#818181"><i>*</i></font>
         SLOAD_TAB&lt;X&gt; =
         CODE = SUBSTR(CODE, 2)
SLOAD_6  CODE FENCE SLOAD_STMT . X =                         <b>:F(SLOAD_7)</b>
         CODE(X)                                             <b>:S(SLOAD_6)</b>
         X RTAB(1) . TERMINAL
SLOAD_7  &amp;TRIM = TRIM_SAV
         TERMINAL = &amp;ERRTEXT                                  <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
SLOAD_3  &amp;TRIM = TRIM_SAV                                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SLOAD_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SLOAD.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL SLOAD
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*              #####   #        #######     #     ######               *</i></font>
<font color="#818181"><i>*             #     #  #        #     #    # #    #     #              *</i></font>
<font color="#818181"><i>*             #        #        #     #   #   #   #     #              *</i></font>
<font color="#818181"><i>*              #####   #        #     #  #     #  #     #              *</i></font>
<font color="#818181"><i>*                   #  #        #     #  #######  #     #              *</i></font>
<font color="#818181"><i>*             #     #  #        #     #  #     #  #     #              *</i></font>
<font color="#818181"><i>*              #####   #######  #######  #     #  ######               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SLOAD                LOAD SNOBOL4 SOURCE                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* (C) COPYRIGHT 1985, 1987 - CATSPAW, INCORPORATED                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* MODIFIED TO SUPPORT /DEV FILES, SEARCH CSNOBOL4 PATHS                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SLOAD.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SLOAD&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:23 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SLOAD.INC'
-LINE 103 "SLOAD.lss"
         &CODE = 1
         &CODE = 0
END
<H1>snofmt</H1>

A simple and stupid SNOBOL4 formatter. Uses simple patterns. Does
<b>not</b> parse the code. I use this to clean up foreign code,
and to tidy up lines after editing.

<h2>Uses</h2>
<a href="BALX.html">BALX</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>

<<INCLUDES>>=
-INCLUDE 'BALX.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'VDIFFER.INC'
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM SNOFMT
-TITLE SNOFMT
START
<<INCLUDES>>
-STITL
-EJECT
************************************************************************
*                                                                      *
*          #####   #     #  #######  #######  #     #  #######         *
*         #     #  ##    #  #     #  #        ##   ##     #            *
*         #        # #   #  #     #  #        # # # #     #            *
*          #####   #  #  #  #     #  #####    #  #  #     #            *
*               #  #   # #  #     #  #        #     #     #            *
*         #     #  #    ##  #     #  #        #     #     #            *
*          #####   #     #  #######  #        #     #     #            *
*                                                                      *
* SNOFMT                   SNOBOL4 FORMATTER                           *
*                                                                      *
************************************************************************
*
* BASIC SIMPLE SNOBOL4 FORMATTING (TO MY STYLE) STATEMENTS BEGIN IN
* COLUMN 10, LABELS ARE ALIGNED TO END IN COLUMN 72. CONTINUATION
* LINES ARE INDENTED TO BEGIN AT COLUMN 13. REALLY, ONLY USED FOR
* "OTHER PEOPLES CODE" AND TO TIDY LINES AFTER EDITS.
*
* snofmt.lss
*
         TERMINAL = 'SNOFMT (MON NOV 25 15:35:24 EST 2013)'
*
         DELR = TABLE()
         DELR<'('> = ')'
         DELR<'<'> = '>'
         OPTWS = SPAN(' ' CHARS_TAB) | ''
         BEX = BALX('(<[]>)', "'" '"')
         GB = ANY('(<') $ DELL BEX *DELR<DELL>
         GC = OPTWS (ANY('SFsf') | '') OPTWS GB
         GP = (':' GC (GC | '') OPTWS RPOS(0)) . G
*
TOP      S = TRIM(INPUT)                                         :F(END)
         LABEL =
         G =
*
* COMMENTS GO THROUGH UNCHANGED
*
         S FENCE (ANY('*-#!|') | RPOS(0))                        :S(OUT)
*
* DETAB THE LINE, ASSUMING TABS AT 8 COLUMNS
*
DETAB    S CHARS_TAB @N = LPAD('', 8 - REMDR(N - 1, 8), ' ')   :S(DETAB)
*
* EMPTY LINES REPLACED WITH * COMMENT LINES
*
         S = TRIM(S)
         S = IDENT(S) '*'                                        :S(OUT)
*
* INDENT CONTINUATION LINES (NO LABEL PADDING)
*
         S FENCE ANY('+.') =                                    :F(LEXT)
TRIMIT   S FENCE ' ' =                                        :S(TRIMIT)
         S = '+           ' S                                     :(XBR)
*
* EXTRACT THE LABEL
*
LEXT     S FENCE ' '                                            :S(STMT)
*
* IF WE DO HAVE A LABEL, IT MAY BE THE ONLY THING ON THE LINE
*
         S BREAK(' ') . LABEL =                                  :F(OUT)
*
* STATEMENT, KILL LEADING SPACES
*
STMT     S FENCE ' ' =                                          :S(STMT)
*
* IF THE LABEL IS GREATER THAN 8 CHARACTERS, OUTPUT IT ON A LINE BY
* ITSELF
*
         OUTPUT = GT(SIZE(LABEL), 8) LABEL
         LABEL = GT(SIZE(LABEL), 8) ''
*
* PAD THE LABEL TO 9 CHARACTERS
*
         LABEL FENCE ('END' | 'end') RPOS(0)                    :F(PAD9)
         LABEL = LABEL ' '                                        :(XBR)
PAD9     LABEL = RPAD(LABEL, 9)
*
* EXTACT BRANCH PART -- PATTERN ALSO USED IN SWEAVE
*
XBR      S GP =
         G = ' ' VDIFFER(G)
*
* REMOVE SPACES BETWEEN STATEMENT AND BRANCH
*
         S = TRIM(S)
*
* IF THE ENTIRE STATEMENT GREATER THAN 72 COLUMNS, OUTPUT IT AS LABEL
* STATEMENT, AND THEN BRANCH AS CONTINUATION
*
         GT(SIZE(S) + SIZE(G) + 9, 72)                         :S(STMT3)
*
* ASSEMBLE THE OUTPUT: LABEL FOLLOWED BY STATEMENT, AND THEN BRANCH
* PADDED TO COLUMN 72
*
         S = LABEL S
         S = S LPAD('', 72 - SIZE(S) - SIZE(G)) G                 :(OUT)
*
STMT3    S = IDENT(G) LABEL S                                    :S(OUT)
         OUTPUT = LABEL S
         S = '+' LPAD('', 71 - SIZE(G)) VDIFFER(G)
*
* OUTPUT THE STATEMENT
*
OUT      OUTPUT = TRIM(S)                                         :(TOP)
*
END START
*
* CE: .F.MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM SNOFMT
-LINE 22 "snofmt.lss"
-TITLE SNOFMT
START
-LINE 13 "snofmt.lss"
-INCLUDE 'BALX.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'VDIFFER.INC'
-STITL
-EJECT
************************************************************************
*                                                                      *
*          #####   #     #  #######  #######  #     #  #######         *
*         #     #  ##    #  #     #  #        ##   ##     #            *
*         #        # #   #  #     #  #        # # # #     #            *
*          #####   #  #  #  #     #  #####    #  #  #     #            *
*               #  #   # #  #     #  #        #     #     #            *
*         #     #  #    ##  #     #  #        #     #     #            *
*          #####   #     #  #######  #        #     #     #            *
*                                                                      *
* SNOFMT                   SNOBOL4 FORMATTER                           *
*                                                                      *
************************************************************************
*
* BASIC SIMPLE SNOBOL4 FORMATTING (TO MY STYLE) STATEMENTS BEGIN IN
* COLUMN 10, LABELS ARE ALIGNED TO END IN COLUMN 72. CONTINUATION
* LINES ARE INDENTED TO BEGIN AT COLUMN 13. REALLY, ONLY USED FOR
* "OTHER PEOPLES CODE" AND TO TIDY LINES AFTER EDITS.
*
* snofmt.lss
*
         TERMINAL = 'SNOFMT (MON NOV 25 15:35:24 EST 2013)'
*
         DELR = TABLE()
         DELR<'('> = ')'
         DELR<'<'> = '>'
         OPTWS = SPAN(' ' CHARS_TAB) | ''
         BEX = BALX('(<[]>)', "'" '"')
         GB = ANY('(<') $ DELL BEX *DELR<DELL>
         GC = OPTWS (ANY('SFsf') | '') OPTWS GB
         GP = (':' GC (GC | '') OPTWS RPOS(0)) . G
*
TOP      S = TRIM(INPUT)                                         :F(END)
         LABEL =
         G =
*
* COMMENTS GO THROUGH UNCHANGED
*
         S FENCE (ANY('*-#!|') | RPOS(0))                        :S(OUT)
*
* DETAB THE LINE, ASSUMING TABS AT 8 COLUMNS
*
DETAB    S CHARS_TAB @N = LPAD('', 8 - REMDR(N - 1, 8), ' ')   :S(DETAB)
*
* EMPTY LINES REPLACED WITH * COMMENT LINES
*
         S = TRIM(S)
         S = IDENT(S) '*'                                        :S(OUT)
*
* INDENT CONTINUATION LINES (NO LABEL PADDING)
*
         S FENCE ANY('+.') =                                    :F(LEXT)
TRIMIT   S FENCE ' ' =                                        :S(TRIMIT)
         S = '+           ' S                                     :(XBR)
*
* EXTRACT THE LABEL
*
LEXT     S FENCE ' '                                            :S(STMT)
*
* IF WE DO HAVE A LABEL, IT MAY BE THE ONLY THING ON THE LINE
*
         S BREAK(' ') . LABEL =                                  :F(OUT)
*
* STATEMENT, KILL LEADING SPACES
*
STMT     S FENCE ' ' =                                          :S(STMT)
*
* IF THE LABEL IS GREATER THAN 8 CHARACTERS, OUTPUT IT ON A LINE BY
* ITSELF
*
         OUTPUT = GT(SIZE(LABEL), 8) LABEL
         LABEL = GT(SIZE(LABEL), 8) ''
*
* PAD THE LABEL TO 9 CHARACTERS
*
         LABEL FENCE ('END' | 'end') RPOS(0)                    :F(PAD9)
         LABEL = LABEL ' '                                        :(XBR)
PAD9     LABEL = RPAD(LABEL, 9)
*
* EXTACT BRANCH PART -- PATTERN ALSO USED IN SWEAVE
*
XBR      S GP =
         G = ' ' VDIFFER(G)
*
* REMOVE SPACES BETWEEN STATEMENT AND BRANCH
*
         S = TRIM(S)
*
* IF THE ENTIRE STATEMENT GREATER THAN 72 COLUMNS, OUTPUT IT AS LABEL
* STATEMENT, AND THEN BRANCH AS CONTINUATION
*
         GT(SIZE(S) + SIZE(G) + 9, 72)                         :S(STMT3)
*
* ASSEMBLE THE OUTPUT: LABEL FOLLOWED BY STATEMENT, AND THEN BRANCH
* PADDED TO COLUMN 72
*
         S = LABEL S
         S = S LPAD('', 72 - SIZE(S) - SIZE(G)) G                 :(OUT)
*
STMT3    S = IDENT(G) LABEL S                                    :S(OUT)
         OUTPUT = LABEL S
         S = '+' LPAD('', 71 - SIZE(G)) VDIFFER(G)
*
* OUTPUT THE STATEMENT
*
OUT      OUTPUT = TRIM(S)                                         :(TOP)
*
END START
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>snofmt</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
A simple and stupid SNOBOL4 formatter. Uses simple patterns. Does
<b>not</b> parse the code. I use this to clean up foreign code,
and to tidy up lines after editing.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="BALX.html">BALX</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="VDIFFER.html">VDIFFER</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;BALX.INC&#39;
-INCLUDE &#39;CHARS.INC&#39;
-INCLUDE &#39;VDIFFER.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM SNOFMT
-TITLE SNOFMT
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*          #####   #     #  #######  #######  #     #  #######         *</i></font>
<font color="#818181"><i>*         #     #  ##    #  #     #  #        ##   ##     #            *</i></font>
<font color="#818181"><i>*         #        # #   #  #     #  #        # # # #     #            *</i></font>
<font color="#818181"><i>*          #####   #  #  #  #     #  #####    #  #  #     #            *</i></font>
<font color="#818181"><i>*               #  #   # #  #     #  #        #     #     #            *</i></font>
<font color="#818181"><i>*         #     #  #    ##  #     #  #        #     #     #            *</i></font>
<font color="#818181"><i>*          #####   #     #  #######  #        #     #     #            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SNOFMT                   SNOBOL4 FORMATTER                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* BASIC SIMPLE SNOBOL4 FORMATTING (TO MY STYLE) STATEMENTS BEGIN IN</i></font>
<font color="#818181"><i>* COLUMN 10, LABELS ARE ALIGNED TO END IN COLUMN 72. CONTINUATION</i></font>
<font color="#818181"><i>* LINES ARE INDENTED TO BEGIN AT COLUMN 13. REALLY, ONLY USED FOR</i></font>
<font color="#818181"><i>* &quot;OTHER PEOPLES CODE&quot; AND TO TIDY LINES AFTER EDITS.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* snofmt.lss</i></font>
<font color="#818181"><i>*</i></font>
         TERMINAL = &#39;SNOFMT (MON NOV 25 15:35:24 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         DELR = TABLE()
         DELR&lt;&#39;(&#39;&gt; = &#39;)&#39;
         DELR&lt;&#39;&lt;&#39;&gt; = &#39;&gt;&#39;
         OPTWS = SPAN(&#39; &#39; CHARS_TAB) | &#39;&#39;
         BEX = BALX(&#39;(&lt;[]&gt;)&#39;, &quot;&#39;&quot; &#39;&quot;&#39;)
         GB = ANY(&#39;(&lt;&#39;) $ DELL BEX *DELR&lt;DELL&gt;
         GC = OPTWS (ANY(&#39;SFsf&#39;) | &#39;&#39;) OPTWS GB
         GP = (&#39;:&#39; GC (GC | &#39;&#39;) OPTWS RPOS(0)) . G
<font color="#818181"><i>*</i></font>
TOP      S = TRIM(INPUT)                                         <b>:F(END)</b>
         LABEL =
         G =
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* COMMENTS GO THROUGH UNCHANGED</i></font>
<font color="#818181"><i>*</i></font>
         S FENCE (ANY(&#39;*-#!|&#39;) | RPOS(0))                        <b>:S(OUT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DETAB THE LINE, ASSUMING TABS AT 8 COLUMNS</i></font>
<font color="#818181"><i>*</i></font>
DETAB    S CHARS_TAB @N = LPAD(&#39;&#39;, 8 - REMDR(N - 1, 8), &#39; &#39;)   <b>:S(DETAB)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EMPTY LINES REPLACED WITH * COMMENT LINES</i></font>
<font color="#818181"><i>*</i></font>
         S = TRIM(S)
         S = IDENT(S) &#39;*&#39;                                        <b>:S(OUT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* INDENT CONTINUATION LINES (NO LABEL PADDING)</i></font>
<font color="#818181"><i>*</i></font>
         S FENCE ANY(&#39;+.&#39;) =                                    <b>:F(LEXT)</b>
TRIMIT   S FENCE &#39; &#39; =                                        <b>:S(TRIMIT)</b>
         S = &#39;+           &#39; S                                     <b>:(XBR)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EXTRACT THE LABEL</i></font>
<font color="#818181"><i>*</i></font>
LEXT     S FENCE &#39; &#39;                                            <b>:S(STMT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF WE DO HAVE A LABEL, IT MAY BE THE ONLY THING ON THE LINE</i></font>
<font color="#818181"><i>*</i></font>
         S BREAK(&#39; &#39;) . LABEL =                                  <b>:F(OUT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* STATEMENT, KILL LEADING SPACES</i></font>
<font color="#818181"><i>*</i></font>
STMT     S FENCE &#39; &#39; =                                          <b>:S(STMT)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF THE LABEL IS GREATER THAN 8 CHARACTERS, OUTPUT IT ON A LINE BY</i></font>
<font color="#818181"><i>* ITSELF</i></font>
<font color="#818181"><i>*</i></font>
         OUTPUT = GT(SIZE(LABEL), 8) LABEL
         LABEL = GT(SIZE(LABEL), 8) &#39;&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PAD THE LABEL TO 9 CHARACTERS</i></font>
<font color="#818181"><i>*</i></font>
         LABEL FENCE (&#39;END&#39; | &#39;end&#39;) RPOS(0)                    <b>:F(PAD9)</b>
         LABEL = LABEL &#39; &#39;                                        <b>:(XBR)</b>
PAD9     LABEL = RPAD(LABEL, 9)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* EXTACT BRANCH PART -- PATTERN ALSO USED IN SWEAVE</i></font>
<font color="#818181"><i>*</i></font>
XBR      S GP =
         G = &#39; &#39; VDIFFER(G)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* REMOVE SPACES BETWEEN STATEMENT AND BRANCH</i></font>
<font color="#818181"><i>*</i></font>
         S = TRIM(S)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* IF THE ENTIRE STATEMENT GREATER THAN 72 COLUMNS, OUTPUT IT AS LABEL</i></font>
<font color="#818181"><i>* STATEMENT, AND THEN BRANCH AS CONTINUATION</i></font>
<font color="#818181"><i>*</i></font>
         GT(SIZE(S) + SIZE(G) + 9, 72)                         <b>:S(STMT3)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* ASSEMBLE THE OUTPUT: LABEL FOLLOWED BY STATEMENT, AND THEN BRANCH</i></font>
<font color="#818181"><i>* PADDED TO COLUMN 72</i></font>
<font color="#818181"><i>*</i></font>
         S = LABEL S
         S = S LPAD(&#39;&#39;, 72 - SIZE(S) - SIZE(G)) G                 <b>:(OUT)</b>
<font color="#818181"><i>*</i></font>
STMT3    S = IDENT(G) LABEL S                                    <b>:S(OUT)</b>
         OUTPUT = LABEL S
         S = &#39;+&#39; LPAD(&#39;&#39;, 71 - SIZE(G)) VDIFFER(G)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OUTPUT THE STATEMENT</i></font>
<font color="#818181"><i>*</i></font>
OUT      OUTPUT = TRIM(S)                                         <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
END START
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:23 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>SOUNDEX - NARA SOUNDEX</h1>

Return NARA SOUNDEX code.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<SOUNDEX>>=
-MODULE SOUNDEX
-PUBLIC SOUNDEX()
         DEFINE('SOUNDEX(STR)SDXMAP,INIT,CH')             :(SOUNDEX_END)
*
SOUNDEX  SDXMAP = '01230127022455012623017202'
         STR = REPLACE(STR, &LCASE, &UCASE)
SDX1     STR NOTANY(&UCASE) =                                   :S(SDX1)
         INIT = SUBSTR(STR, 1, 1)
         STR = REPLACE(STR, &UCASE, SDXMAP)
SDX2     STR LEN(1) $ CH SPAN(*CH) = CH                         :S(SDX2)
* OMIT NEXT LINE FOR KNUTH'S SIMPLE SOUNDEX
SDX3     STR LEN(1) $ CH ('7' *CH) = CH                         :S(SDX3)
         STR LEN(1) = INIT
SDX4     STR ANY('07') =                                        :S(SDX4)
         STR = SUBSTR(STR, 1, 4)
         STR = LT(SIZE(STR), 4) STR DUPL('0', 4 - SIZE(STR))
         SOUNDEX = STR                                         :(RETURN)
*
SOUNDEX_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SOUNDEX.INC'
         &CODE = 1
         IDENT(SOUNDEX('washington'), 'W252')                    :F(END)
         &CODE = 0
END
@

<<>>=
-STITL SOUNDEX
-EJECT
*
************************************************************************
*                                                                      *
*     #####   #######  #     #  #     #  ######   #######  #     #     *
*    #     #  #     #  #     #  ##    #  #     #  #         #   #      *
*    #        #     #  #     #  # #   #  #     #  #          # #       *
*     #####   #     #  #     #  #  #  #  #     #  #####       #        *
*          #  #     #  #     #  #   # #  #     #  #          # #       *
*    #     #  #     #  #     #  #    ##  #     #  #         #   #      *
*     #####   #######   #####   #     #  ######   #######  #     #     *
*                                                                      *
* SOUNDEX                   NARA SOUNDEX                               *
*                                                                      *
************************************************************************
*
* SOUNDEX.lss
*
<<SOUNDEX>>
*
* CE: .MSNOBOL4;
@
-STITL SOUNDEX
-EJECT
*
-LINE 46 "SOUNDEX.lss"
************************************************************************
*                                                                      *
*     #####   #######  #     #  #     #  ######   #######  #     #     *
*    #     #  #     #  #     #  ##    #  #     #  #         #   #      *
*    #        #     #  #     #  # #   #  #     #  #          # #       *
*     #####   #     #  #     #  #  #  #  #     #  #####       #        *
*          #  #     #  #     #  #   # #  #     #  #          # #       *
*    #     #  #     #  #     #  #    ##  #     #  #         #   #      *
*     #####   #######   #####   #     #  ######   #######  #     #     *
*                                                                      *
* SOUNDEX                   NARA SOUNDEX                               *
*                                                                      *
************************************************************************
*
* SOUNDEX.lss
*
-LINE 11 "SOUNDEX.lss"
-MODULE SOUNDEX
-PUBLIC SOUNDEX()
         DEFINE('SOUNDEX(STR)SDXMAP,INIT,CH')             :(SOUNDEX_END)
*
SOUNDEX  SDXMAP = '01230127022455012623017202'
         STR = REPLACE(STR, &LCASE, &UCASE)
SDX1     STR NOTANY(&UCASE) =                                   :S(SDX1)
         INIT = SUBSTR(STR, 1, 1)
         STR = REPLACE(STR, &UCASE, SDXMAP)
SDX2     STR LEN(1) $ CH SPAN(*CH) = CH                         :S(SDX2)
* OMIT NEXT LINE FOR KNUTH'S SIMPLE SOUNDEX
SDX3     STR LEN(1) $ CH ('7' *CH) = CH                         :S(SDX3)
         STR LEN(1) = INIT
SDX4     STR ANY('07') =                                        :S(SDX4)
         STR = SUBSTR(STR, 1, 4)
         STR = LT(SIZE(STR), 4) STR DUPL('0', 4 - SIZE(STR))
         SOUNDEX = STR                                         :(RETURN)
*
SOUNDEX_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SOUNDEX - NARA SOUNDEX</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Return NARA SOUNDEX code.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SOUNDEX&raquo;&equiv;</b>
-MODULE SOUNDEX
-PUBLIC SOUNDEX()
         DEFINE(&#39;SOUNDEX(STR)SDXMAP,INIT,CH&#39;)             <b>:(SOUNDEX_END)</b>
<font color="#818181"><i>*</i></font>
SOUNDEX  SDXMAP = &#39;01230127022455012623017202&#39;
         STR = REPLACE(STR, &amp;LCASE, &amp;UCASE)
SDX1     STR NOTANY(&amp;UCASE) =                                   <b>:S(SDX1)</b>
         INIT = SUBSTR(STR, 1, 1)
         STR = REPLACE(STR, &amp;UCASE, SDXMAP)
SDX2     STR LEN(1) $ CH SPAN(*CH) = CH                         <b>:S(SDX2)</b>
<font color="#818181"><i>* OMIT NEXT LINE FOR KNUTH&#39;S SIMPLE SOUNDEX</i></font>
SDX3     STR LEN(1) $ CH (&#39;7&#39; *CH) = CH                         <b>:S(SDX3)</b>
         STR LEN(1) = INIT
SDX4     STR ANY(&#39;07&#39;) =                                        <b>:S(SDX4)</b>
         STR = SUBSTR(STR, 1, 4)
         STR = LT(SIZE(STR), 4) STR DUPL(&#39;0&#39;, 4 - SIZE(STR))
         SOUNDEX = STR                                         <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SOUNDEX_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SOUNDEX.INC&#39;
         &amp;CODE = 1
         IDENT(SOUNDEX(&#39;washington&#39;), &#39;W252&#39;)                    <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL SOUNDEX
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*     #####   #######  #     #  #     #  ######   #######  #     #     *</i></font>
<font color="#818181"><i>*    #     #  #     #  #     #  ##    #  #     #  #         #   #      *</i></font>
<font color="#818181"><i>*    #        #     #  #     #  # #   #  #     #  #          # #       *</i></font>
<font color="#818181"><i>*     #####   #     #  #     #  #  #  #  #     #  #####       #        *</i></font>
<font color="#818181"><i>*          #  #     #  #     #  #   # #  #     #  #          # #       *</i></font>
<font color="#818181"><i>*    #     #  #     #  #     #  #    ##  #     #  #         #   #      *</i></font>
<font color="#818181"><i>*     #####   #######   #####   #     #  ######   #######  #     #     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SOUNDEX                   NARA SOUNDEX                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SOUNDEX.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SOUNDEX&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:24 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SOUNDEX.INC'
-LINE 36 "SOUNDEX.lss"
         &CODE = 1
         IDENT(SOUNDEX('washington'), 'W252')                    :F(END)
         &CODE = 0
END
<h1>SPELL - Spell out a number</h1>

[[SPELL(N)]] will return an english phrase designating the integer
[[N]].  Thus [[SPELL(13)]] will return [['THIRTEEN']].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<SPELL>>=
-MODULE SPELL
-PUBLIC SPELL()
         DEFINE('SPELL(N)M')                                :(SPELL_END)
*
SPELL    GE(N, 1000)                                      :S(SPELL_1000)
         GE(N, 100)                                        :S(SPELL_100)
         GE(N, 20)                                          :S(SPELL_20)
         GE(N, 13)                                          :S(SPELL_13)
         ('1ONE,2TWO,3THREE,4FOUR,5FIVE,6SIX,7SEVEN,8EIGHT,9NINE,'
+           '10TEN,11ELEVEN,12TWELVE,') N ARB . SPELL ','      :(RETURN)
SPELL_13 N 1 LEN(1) . M
         SPELL = SPELL(M 0)
         SPELL 'TY' = 'TEEN'
         SPELL 'FOR' = 'FOUR'                                  :(RETURN)
SPELL_20 N LEN(1) . M =
         '2TWEN,3THIR,4FOR,5FIF,6SIX,7SEVEN,8EIGH,9NINE,'
+           M BREAK(',') . SPELL
         SPELL = SPELL 'TY'
         SPELL = NE(N,0) SPELL '-' SPELL(N)                    :(RETURN)
SPELL_100
         N LEN(1) . M  =
         SPELL = SPELL(M) ' HUNDRED'
         SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
SPELL_1000
         N RTAB(3) . M  =
         SPELL = SPELL(M)
         SPELL 'THOUSAND' = 'MILLION'
         SPELL = SPELL ' THOUSAND'
         SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
*
SPELL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SPELL.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL SPELL
-EJECT
*
************************************************************************
*                                                                      *
*                 #####   ######   #######  #        #                 *
*                #     #  #     #  #        #        #                 *
*                #        #     #  #        #        #                 *
*                 #####   ######   #####    #        #                 *
*                      #  #        #        #        #                 *
*                #     #  #        #        #        #                 *
*                 #####   #        #######  #######  #######           *
*                                                                      *
* SPELL                    SPELL OUT A NUMBER                          *
*                                                                      *
************************************************************************
*
* SPELL.lss
*
<<SPELL>>
*
* CE: .MSNOBOL4;
@
-STITL SPELL
-EJECT
*
-LINE 58 "SPELL.lss"
************************************************************************
*                                                                      *
*                 #####   ######   #######  #        #                 *
*                #     #  #     #  #        #        #                 *
*                #        #     #  #        #        #                 *
*                 #####   ######   #####    #        #                 *
*                      #  #        #        #        #                 *
*                #     #  #        #        #        #                 *
*                 #####   #        #######  #######  #######           *
*                                                                      *
* SPELL                    SPELL OUT A NUMBER                          *
*                                                                      *
************************************************************************
*
* SPELL.lss
*
-LINE 12 "SPELL.lss"
-MODULE SPELL
-PUBLIC SPELL()
         DEFINE('SPELL(N)M')                                :(SPELL_END)
*
SPELL    GE(N, 1000)                                      :S(SPELL_1000)
         GE(N, 100)                                        :S(SPELL_100)
         GE(N, 20)                                          :S(SPELL_20)
         GE(N, 13)                                          :S(SPELL_13)
         ('1ONE,2TWO,3THREE,4FOUR,5FIVE,6SIX,7SEVEN,8EIGHT,9NINE,'
+           '10TEN,11ELEVEN,12TWELVE,') N ARB . SPELL ','      :(RETURN)
SPELL_13 N 1 LEN(1) . M
         SPELL = SPELL(M 0)
         SPELL 'TY' = 'TEEN'
         SPELL 'FOR' = 'FOUR'                                  :(RETURN)
SPELL_20 N LEN(1) . M =
         '2TWEN,3THIR,4FOR,5FIF,6SIX,7SEVEN,8EIGH,9NINE,'
+           M BREAK(',') . SPELL
         SPELL = SPELL 'TY'
         SPELL = NE(N,0) SPELL '-' SPELL(N)                    :(RETURN)
SPELL_100
         N LEN(1) . M  =
         SPELL = SPELL(M) ' HUNDRED'
         SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
SPELL_1000
         N RTAB(3) . M  =
         SPELL = SPELL(M)
         SPELL 'THOUSAND' = 'MILLION'
         SPELL = SPELL ' THOUSAND'
         SPELL = NE(N, 0) SPELL ' AND ' SPELL(+N)              :(RETURN)
*
SPELL_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SPELL - Spell out a number</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">SPELL(N)</font> will return an english phrase designating the integer
<font face="Source Code Pro">N</font>.  Thus <font face="Source Code Pro">SPELL(13)</font> will return <font face="Source Code Pro">'THIRTEEN'</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SPELL&raquo;&equiv;</b>
-MODULE SPELL
-PUBLIC SPELL()
         DEFINE(&#39;SPELL(N)M&#39;)                                <b>:(SPELL_END)</b>
<font color="#818181"><i>*</i></font>
SPELL    GE(N, 1000)                                      <b>:S(SPELL_1000)</b>
         GE(N, 100)                                        <b>:S(SPELL_100)</b>
         GE(N, 20)                                          <b>:S(SPELL_20)</b>
         GE(N, 13)                                          <b>:S(SPELL_13)</b>
         (&#39;1ONE,2TWO,3THREE,4FOUR,5FIVE,6SIX,7SEVEN,8EIGHT,9NINE,&#39;
+           &#39;10TEN,11ELEVEN,12TWELVE,&#39;) N ARB . SPELL &#39;,&#39;      <b>:(RETURN)</b>
SPELL_13 N 1 LEN(1) . M
         SPELL = SPELL(M 0)
         SPELL &#39;TY&#39; = &#39;TEEN&#39;
         SPELL &#39;FOR&#39; = &#39;FOUR&#39;                                  <b>:(RETURN)</b>
SPELL_20 N LEN(1) . M =
         &#39;2TWEN,3THIR,4FOR,5FIF,6SIX,7SEVEN,8EIGH,9NINE,&#39;
+           M BREAK(&#39;,&#39;) . SPELL
         SPELL = SPELL &#39;TY&#39;
         SPELL = NE(N,0) SPELL &#39;-&#39; SPELL(N)                    <b>:(RETURN)</b>
SPELL_100
         N LEN(1) . M  =
         SPELL = SPELL(M) &#39; HUNDRED&#39;
         SPELL = NE(N, 0) SPELL &#39; AND &#39; SPELL(+N)              <b>:(RETURN)</b>
SPELL_1000
         N RTAB(3) . M  =
         SPELL = SPELL(M)
         SPELL &#39;THOUSAND&#39; = &#39;MILLION&#39;
         SPELL = SPELL &#39; THOUSAND&#39;
         SPELL = NE(N, 0) SPELL &#39; AND &#39; SPELL(+N)              <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SPELL_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SPELL.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL SPELL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 #####   ######   #######  #        #                 *</i></font>
<font color="#818181"><i>*                #     #  #     #  #        #        #                 *</i></font>
<font color="#818181"><i>*                #        #     #  #        #        #                 *</i></font>
<font color="#818181"><i>*                 #####   ######   #####    #        #                 *</i></font>
<font color="#818181"><i>*                      #  #        #        #        #                 *</i></font>
<font color="#818181"><i>*                #     #  #        #        #        #                 *</i></font>
<font color="#818181"><i>*                 #####   #        #######  #######  #######           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SPELL                    SPELL OUT A NUMBER                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SPELL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SPELL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:24 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SPELL.INC'
-LINE 49 "SPELL.lss"
         &CODE = 1
         &CODE = 0
END
<h1>STACK - Create stack functions</h1>

[[STACK(SUF)]] will create unique stack functions with the given
suffix. [[STACK('A')]] creates functions [[PUSH_A(V)]], [[POP_A()]],
and [[TOP_A()]].

<h2>Uses</h2>
<a href="REPL.html">REPL</a><br>

<<INCLUDES>>=
-INCLUDE 'REPL.INC'
@

<<STACK>>=
-MODULE STACK
-PUBLIC STACK()
         DEFINE('STACK(SUF)S')
         STACK()
-PUBLIC PUSH(), POP(), TOP()
         OPSYN('PUSH', 'PUSH_')
         OPSYN('POP',  'POP_')
         OPSYN('TOP',  'TOP_')                              :(STACK_END)
*
STACK    S = 'PUSH_SUF STACK_SUF = LINK(V, STACK_SUF)         ;'
+            '         PUSH_SUF = .VALUE(STACK_SUF) :(NRETURN);'
+            'POP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
+            '         POP_SUF = VALUE(STACK_SUF)             ;'
+            '         STACK_SUF = NEXT(STACK_SUF)   :(RETURN);'
+            'TOP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
+            '         TOP_SUF = .VALUE(STACK_SUF)  :(NRETURN);'
         CODE(REPL(S, 'SUF', SUF))
         DEFINE('PUSH_' SUF '(V)')
         DEFINE('POP_'  SUF '()' )
         DEFINE('TOP_'  SUF '()' )                             :(RETURN)
*
STACK_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'STACK.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL STACK
-EJECT
*
************************************************************************
*                                                                      *
*               #####   #######     #      #####   #    #              *
*              #     #     #       # #    #     #  #   #               *
*              #           #      #   #   #        #  #                *
*               #####      #     #     #  #        ###                 *
*                    #     #     #######  #        #  #                *
*              #     #     #     #     #  #     #  #   #               *
*               #####      #     #     #   #####   #    #              *
*                                                                      *
* STACK                     CREATE STACK                               *
*                                                                      *
************************************************************************
*
* STACK.lss
*
<<STACK>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "STACK.lss"
-INCLUDE 'REPL.INC'
-STITL STACK
-EJECT
-LINE 52 "STACK.lss"
*
************************************************************************
*                                                                      *
*               #####   #######     #      #####   #    #              *
*              #     #     #       # #    #     #  #   #               *
*              #           #      #   #   #        #  #                *
*               #####      #     #     #  #        ###                 *
*                    #     #     #######  #        #  #                *
*              #     #     #     #     #  #     #  #   #               *
*               #####      #     #     #   #####   #    #              *
*                                                                      *
* STACK                     CREATE STACK                               *
*                                                                      *
************************************************************************
*
* STACK.lss
*
-LINE 15 "STACK.lss"
-MODULE STACK
-PUBLIC STACK()
         DEFINE('STACK(SUF)S')
         STACK()
-PUBLIC PUSH(), POP(), TOP()
         OPSYN('PUSH', 'PUSH_')
         OPSYN('POP',  'POP_')
         OPSYN('TOP',  'TOP_')                              :(STACK_END)
*
STACK    S = 'PUSH_SUF STACK_SUF = LINK(V, STACK_SUF)         ;'
+            '         PUSH_SUF = .VALUE(STACK_SUF) :(NRETURN);'
+            'POP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
+            '         POP_SUF = VALUE(STACK_SUF)             ;'
+            '         STACK_SUF = NEXT(STACK_SUF)   :(RETURN);'
+            'TOP_SUF  IDENT(STACK_SUF)            :S(FRETURN);'
+            '         TOP_SUF = .VALUE(STACK_SUF)  :(NRETURN);'
         CODE(REPL(S, 'SUF', SUF))
         DEFINE('PUSH_' SUF '(V)')
         DEFINE('POP_'  SUF '()' )
         DEFINE('TOP_'  SUF '()' )                             :(RETURN)
*
STACK_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>STACK - Create stack functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">STACK(SUF)</font> will create unique stack functions with the given
suffix. <font face="Source Code Pro">STACK('A')</font> creates functions <font face="Source Code Pro">PUSH_A(V)</font>, <font face="Source Code Pro">POP_A()</font>,
and <font face="Source Code Pro">TOP_A()</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="REPL.html">REPL</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;REPL.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;STACK&raquo;&equiv;</b>
-MODULE STACK
-PUBLIC STACK()
         DEFINE(&#39;STACK(SUF)S&#39;)
         STACK()
-PUBLIC PUSH(), POP(), TOP()
         OPSYN(&#39;PUSH&#39;, &#39;PUSH_&#39;)
         OPSYN(&#39;POP&#39;,  &#39;POP_&#39;)
         OPSYN(&#39;TOP&#39;,  &#39;TOP_&#39;)                              <b>:(STACK_END)</b>
<font color="#818181"><i>*</i></font>
STACK    S = &#39;PUSH_SUF STACK_SUF = LINK(V, STACK_SUF)         ;&#39;
+            &#39;         PUSH_SUF = .VALUE(STACK_SUF) :(NRETURN);&#39;
+            &#39;POP_SUF  IDENT(STACK_SUF)            :S(FRETURN);&#39;
+            &#39;         POP_SUF = VALUE(STACK_SUF)             ;&#39;
+            &#39;         STACK_SUF = NEXT(STACK_SUF)   :(RETURN);&#39;
+            &#39;TOP_SUF  IDENT(STACK_SUF)            :S(FRETURN);&#39;
+            &#39;         TOP_SUF = .VALUE(STACK_SUF)  :(NRETURN);&#39;
         CODE(REPL(S, &#39;SUF&#39;, SUF))
         DEFINE(&#39;PUSH_&#39; SUF &#39;(V)&#39;)
         DEFINE(&#39;POP_&#39;  SUF &#39;()&#39; )
         DEFINE(&#39;TOP_&#39;  SUF &#39;()&#39; )                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
STACK_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;STACK.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL STACK
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #####   #######     #      #####   #    #              *</i></font>
<font color="#818181"><i>*              #     #     #       # #    #     #  #   #               *</i></font>
<font color="#818181"><i>*              #           #      #   #   #        #  #                *</i></font>
<font color="#818181"><i>*               #####      #     #     #  #        ###                 *</i></font>
<font color="#818181"><i>*                    #     #     #######  #        #  #                *</i></font>
<font color="#818181"><i>*              #     #     #     #     #  #     #  #   #               *</i></font>
<font color="#818181"><i>*               #####      #     #     #   #####   #    #              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* STACK                     CREATE STACK                               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* STACK.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;STACK&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:25 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'STACK.INC'
-LINE 43 "STACK.lss"
         &CODE = 1
         &CODE = 0
END
<h1>STCL - TCL interface for CSNOBOL4</h1>

Interface to TCL.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<TCL>>=
-MODULE TCL
STCL_LOAD
*
-PUBLIC STCL_CREATEINTERP(), STCL_EVALFILE(), STCL_GETVAR()
-PUBLIC STCL_SETVAR(), STCL_EVAL(), STCL_DELETEINTERP()
         LOAD('STCL_CREATEINTERP()INTEGER')
         LOAD('STCL_EVALFILE(INTEGER,STRING)STRING')
         LOAD('STCL_GETVAR(INTEGER,STRING)STRING')
         LOAD('STCL_SETVAR(INTEGER,STRING,STRING)STRING')
         LOAD('STCL_EVAL(INTEGER,STRING)STRING')
         LOAD('STCL_DELETEINTERP(INTEGER)STRING')
*
-PUBLIC STCL_NEWSTRINGOBJ(), STCL_GETSTRINGFROMOBJ(), STCL_APPENDTOOBJ()
-PUBLIC STCL_EVALOBJEX(), STCL_GETOBJRESULT(), STCL_OBJSETVAR2()
-PUBLIC STCL_OBJGETVAR2(), STCL_RELEASEOBJ()
         LOAD('STCL_NEWSTRINGOBJ(STRING)INTEGER')
         LOAD('STCL_GETSTRINGFROMOBJ(INTEGER)STRING')
         LOAD('STCL_APPENDTOOBJ(INTEGER,STRING)STRING')
         LOAD('STCL_EVALOBJEX(INTEGER,INTEGER,INTEGER)STRING')
         LOAD('STCL_GETOBJRESULT(INTEGER)')
         LOAD('STCL_OBJSETVAR2(INTEGER,STRING,STRING,INTEGER,INTEGER)'
+             'STRING')
         LOAD('STCL_OBJGETVAR2(INTEGER,STRING,STRING,INTEGER)STRING')
         LOAD('STCL_RELEASEOBJ(INTEGER)STRING')
*
         CODE('STCL_LOAD')
@

<<>>=
-STITL STCL
-EJECT
*
************************************************************************
*                                                                      *
*                    #####   #######   #####   #                       *
*                   #     #     #     #     #  #                       *
*                   #           #     #        #                       *
*                    #####      #     #        #                       *
*                         #     #     #        #                       *
*                   #     #     #     #     #  #                       *
*                    #####      #      #####   #######                 *
*                                                                      *
* STCL                TCL INTERFACE FOR CSNOBOL4                       *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* DECEMBER 3, 2005                                                     *
*                                                                      *
* INSPIRED BY ARJEN MARKUS' 'FTCL' FORTRAN/TCL INTERFACE               *
*                                                                      *
************************************************************************
*
* STCL.lss
*
<<TCL>>
*
* CE: .MSNOBOL4;
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-TITLE TCL_TEST
START
-INCLUDE 'STCL.INC'
-STITL
-EJECT
*
         INTERP = STCL_CREATEINTERP()
         TCL_VERSION = STCL_GETVAR(INTERP, "tcl_version")
         OUTPUT = IDENT(TCL_VERSION) "COULD NOT GET TCL_VERSION" :S(END)
         OUTPUT = "TCL VERSION: " TCL_VERSION
*
* CHECK TCL VERSION
         NUM = SPAN('0123456789')
         VPAT = NUM '.' NUM
         TCL_VERSION VPAT . VER                               :S(CHECKV)
         OUTPUT = "COULD NOT PARSE TCL_VERSION"                   :(END)

CHECKV   LT(VER, 8.4)                                        :S(CHECKTK)

* TCL 8.4 AND LATER CAN DYNAMICLY LOAD TK!
         STCL_EVAL(INTERP, "package require Tk")                 :F(END)

* CHECK FOR TK
CHECKTK  TK_VERSION = STCL_GETVAR(INTERP, "tk_version")         :F(NOTK)
         DIFFER(TK_VERSION)                                   :S(HAVETK)
*
NOTK     OUTPUT = "COULD NOT FIND TK_VERSION"                     :(END)
*
HAVETK   OUTPUT = "TK VERSION: " TK_VERSION
*
         STCL_EVAL(INTERP,
+           'button .hello -text "Hello, world" '
+           '              -command {set val hello};'
+           "pack .hello;"
+           'button .other -text "Other Choice" '
+           '              -command {set val other};'
+           "pack .other;"
+           "global val;"
+           "vwait val")
*
         OUTPUT = STCL_GETVAR(INTERP, "val")
*
END START
@
-STITL STCL
-EJECT
*
-LINE 43 "STCL.lss"
************************************************************************
*                                                                      *
*                    #####   #######   #####   #                       *
*                   #     #     #     #     #  #                       *
*                   #           #     #        #                       *
*                    #####      #     #        #                       *
*                         #     #     #        #                       *
*                   #     #     #     #     #  #                       *
*                    #####      #      #####   #######                 *
*                                                                      *
* STCL                TCL INTERFACE FOR CSNOBOL4                       *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* DECEMBER 3, 2005                                                     *
*                                                                      *
* INSPIRED BY ARJEN MARKUS' 'FTCL' FORTRAN/TCL INTERFACE               *
*                                                                      *
************************************************************************
*
* STCL.lss
*
-LINE 11 "STCL.lss"
-MODULE TCL
STCL_LOAD
*
-PUBLIC STCL_CREATEINTERP(), STCL_EVALFILE(), STCL_GETVAR()
-PUBLIC STCL_SETVAR(), STCL_EVAL(), STCL_DELETEINTERP()
         LOAD('STCL_CREATEINTERP()INTEGER')
         LOAD('STCL_EVALFILE(INTEGER,STRING)STRING')
         LOAD('STCL_GETVAR(INTEGER,STRING)STRING')
         LOAD('STCL_SETVAR(INTEGER,STRING,STRING)STRING')
         LOAD('STCL_EVAL(INTEGER,STRING)STRING')
         LOAD('STCL_DELETEINTERP(INTEGER)STRING')
*
-PUBLIC STCL_NEWSTRINGOBJ(), STCL_GETSTRINGFROMOBJ(), STCL_APPENDTOOBJ()
-PUBLIC STCL_EVALOBJEX(), STCL_GETOBJRESULT(), STCL_OBJSETVAR2()
-PUBLIC STCL_OBJGETVAR2(), STCL_RELEASEOBJ()
         LOAD('STCL_NEWSTRINGOBJ(STRING)INTEGER')
         LOAD('STCL_GETSTRINGFROMOBJ(INTEGER)STRING')
         LOAD('STCL_APPENDTOOBJ(INTEGER,STRING)STRING')
         LOAD('STCL_EVALOBJEX(INTEGER,INTEGER,INTEGER)STRING')
         LOAD('STCL_GETOBJRESULT(INTEGER)')
         LOAD('STCL_OBJSETVAR2(INTEGER,STRING,STRING,INTEGER,INTEGER)'
+             'STRING')
         LOAD('STCL_OBJGETVAR2(INTEGER,STRING,STRING,INTEGER)STRING')
         LOAD('STCL_RELEASEOBJ(INTEGER)STRING')
*
         CODE('STCL_LOAD')
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>STCL - TCL interface for CSNOBOL4</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Interface to TCL.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TCL&raquo;&equiv;</b>
-MODULE TCL
STCL_LOAD
<font color="#818181"><i>*</i></font>
-PUBLIC STCL_CREATEINTERP(), STCL_EVALFILE(), STCL_GETVAR()
-PUBLIC STCL_SETVAR(), STCL_EVAL(), STCL_DELETEINTERP()
         LOAD(&#39;STCL_CREATEINTERP()INTEGER&#39;)
         LOAD(&#39;STCL_EVALFILE(INTEGER,STRING)STRING&#39;)
         LOAD(&#39;STCL_GETVAR(INTEGER,STRING)STRING&#39;)
         LOAD(&#39;STCL_SETVAR(INTEGER,STRING,STRING)STRING&#39;)
         LOAD(&#39;STCL_EVAL(INTEGER,STRING)STRING&#39;)
         LOAD(&#39;STCL_DELETEINTERP(INTEGER)STRING&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC STCL_NEWSTRINGOBJ(), STCL_GETSTRINGFROMOBJ(), STCL_APPENDTOOBJ()
-PUBLIC STCL_EVALOBJEX(), STCL_GETOBJRESULT(), STCL_OBJSETVAR2()
-PUBLIC STCL_OBJGETVAR2(), STCL_RELEASEOBJ()
         LOAD(&#39;STCL_NEWSTRINGOBJ(STRING)INTEGER&#39;)
         LOAD(&#39;STCL_GETSTRINGFROMOBJ(INTEGER)STRING&#39;)
         LOAD(&#39;STCL_APPENDTOOBJ(INTEGER,STRING)STRING&#39;)
         LOAD(&#39;STCL_EVALOBJEX(INTEGER,INTEGER,INTEGER)STRING&#39;)
         LOAD(&#39;STCL_GETOBJRESULT(INTEGER)&#39;)
         LOAD(&#39;STCL_OBJSETVAR2(INTEGER,STRING,STRING,INTEGER,INTEGER)&#39;
+             &#39;STRING&#39;)
         LOAD(&#39;STCL_OBJGETVAR2(INTEGER,STRING,STRING,INTEGER)STRING&#39;)
         LOAD(&#39;STCL_RELEASEOBJ(INTEGER)STRING&#39;)
<font color="#818181"><i>*</i></font>
         CODE(&#39;STCL_LOAD&#39;)
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL STCL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #####   #######   #####   #                       *</i></font>
<font color="#818181"><i>*                   #     #     #     #     #  #                       *</i></font>
<font color="#818181"><i>*                   #           #     #        #                       *</i></font>
<font color="#818181"><i>*                    #####      #     #        #                       *</i></font>
<font color="#818181"><i>*                         #     #     #        #                       *</i></font>
<font color="#818181"><i>*                   #     #     #     #     #  #                       *</i></font>
<font color="#818181"><i>*                    #####      #      #####   #######                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* STCL                TCL INTERFACE FOR CSNOBOL4                       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                       *</i></font>
<font color="#818181"><i>* DECEMBER 3, 2005                                                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* INSPIRED BY ARJEN MARKUS&#39; &#39;FTCL&#39; FORTRAN/TCL INTERFACE               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* STCL.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TCL&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-TITLE TCL_TEST
START
-INCLUDE &#39;STCL.INC&#39;
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
         INTERP = STCL_CREATEINTERP()
         TCL_VERSION = STCL_GETVAR(INTERP, &quot;tcl_version&quot;)
         OUTPUT = IDENT(TCL_VERSION) &quot;COULD NOT GET TCL_VERSION&quot; <b>:S(END)</b>
         OUTPUT = &quot;TCL VERSION: &quot; TCL_VERSION
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CHECK TCL VERSION</i></font>
         NUM = SPAN(&#39;0123456789&#39;)
         VPAT = NUM &#39;.&#39; NUM
         TCL_VERSION VPAT . VER                               <b>:S(CHECKV)</b>
         OUTPUT = &quot;COULD NOT PARSE TCL_VERSION&quot;                   <b>:(END)</b>

CHECKV   LT(VER, 8.4)                                        <b>:S(CHECKTK)</b>

<font color="#818181"><i>* TCL 8.4 AND LATER CAN DYNAMICLY LOAD TK!</i></font>
         STCL_EVAL(INTERP, &quot;package require Tk&quot;)                 <b>:F(END)</b>

<font color="#818181"><i>* CHECK FOR TK</i></font>
CHECKTK  TK_VERSION = STCL_GETVAR(INTERP, &quot;tk_version&quot;)         <b>:F(NOTK)</b>
         DIFFER(TK_VERSION)                                   <b>:S(HAVETK)</b>
<font color="#818181"><i>*</i></font>
NOTK     OUTPUT = &quot;COULD NOT FIND TK_VERSION&quot;                     <b>:(END)</b>
<font color="#818181"><i>*</i></font>
HAVETK   OUTPUT = &quot;TK VERSION: &quot; TK_VERSION
<font color="#818181"><i>*</i></font>
         STCL_EVAL(INTERP,
+           &#39;button .hello -text &quot;Hello, world&quot; &#39;
+           &#39;              -command {set val hello};&#39;
+           &quot;pack .hello;&quot;
+           &#39;button .other -text &quot;Other Choice&quot; &#39;
+           &#39;              -command {set val other};&#39;
+           &quot;pack .other;&quot;
+           &quot;global val;&quot;
+           &quot;vwait val&quot;)
<font color="#818181"><i>*</i></font>
         OUTPUT = STCL_GETVAR(INTERP, &quot;val&quot;)
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:26 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-TITLE TCL_TEST
-LINE 73 "STCL.lss"
START
-INCLUDE 'STCL.INC'
-STITL
-EJECT
*
         INTERP = STCL_CREATEINTERP()
         TCL_VERSION = STCL_GETVAR(INTERP, "tcl_version")
         OUTPUT = IDENT(TCL_VERSION) "COULD NOT GET TCL_VERSION" :S(END)
         OUTPUT = "TCL VERSION: " TCL_VERSION
*
* CHECK TCL VERSION
         NUM = SPAN('0123456789')
         VPAT = NUM '.' NUM
         TCL_VERSION VPAT . VER                               :S(CHECKV)
         OUTPUT = "COULD NOT PARSE TCL_VERSION"                   :(END)

CHECKV   LT(VER, 8.4)                                        :S(CHECKTK)

* TCL 8.4 AND LATER CAN DYNAMICLY LOAD TK!
         STCL_EVAL(INTERP, "package require Tk")                 :F(END)

* CHECK FOR TK
CHECKTK  TK_VERSION = STCL_GETVAR(INTERP, "tk_version")         :F(NOTK)
         DIFFER(TK_VERSION)                                   :S(HAVETK)
*
NOTK     OUTPUT = "COULD NOT FIND TK_VERSION"                     :(END)
*
HAVETK   OUTPUT = "TK VERSION: " TK_VERSION
*
         STCL_EVAL(INTERP,
+           'button .hello -text "Hello, world" '
+           '              -command {set val hello};'
+           "pack .hello;"
+           'button .other -text "Other Choice" '
+           '              -command {set val other};'
+           "pack .other;"
+           "global val;"
+           "vwait val")
*
         OUTPUT = STCL_GETVAR(INTERP, "val")
*
END START
<h1>STROUT - Array to string</h1>

[[STRINGOUT(A,SEP)]] will serve to convert from array to
string. [[SEP]] contains a separation string to be inserted between
strings of the array [[A]].

<h2>Uses</h2>

<h2>See Also</h2>
<a href="CRACK.html">CRACK</a>

<<INCLUDES>>=
@

<<STROUT>>=
-MODULE STROUT
-PUBLIC STRINGOUT()
         DEFINE('STRINGOUT(A,SEP)I')                    :(STRINGOUT_END)
*
STRINGOUT
         I = 1
         STRINGOUT = A<1>                                     :F(RETURN)
STRINGOUT_1         
         I = I + 1
         STRINGOUT = STRINGOUT SEP A<I>         :S(STRINGOUT_1)F(RETURN)
*
STRINGOUT_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'STROUT.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL STROUT
-EJECT
*
************************************************************************
*                                                                      *
*            #####   #######  ######   #######  #     #  #######       *
*           #     #     #     #     #  #     #  #     #     #          *
*           #           #     #     #  #     #  #     #     #          *
*            #####      #     ######   #     #  #     #     #          *
*                 #     #     #   #    #     #  #     #     #          *
*           #     #     #     #    #   #     #  #     #     #          *
*            #####      #     #     #  #######   #####      #          *
*                                                                      *
* STROUT                    ARRAY TO STRING                            *
*                                                                      *
************************************************************************
*
* STROUT.lss
*
<<STROUT>>
*
* CE: .MSNOBOL4;
@
-STITL STROUT
-EJECT
*
-LINE 43 "STROUT.lss"
************************************************************************
*                                                                      *
*            #####   #######  ######   #######  #     #  #######       *
*           #     #     #     #     #  #     #  #     #     #          *
*           #           #     #     #  #     #  #     #     #          *
*            #####      #     ######   #     #  #     #     #          *
*                 #     #     #   #    #     #  #     #     #          *
*           #     #     #     #    #   #     #  #     #     #          *
*            #####      #     #     #  #######   #####      #          *
*                                                                      *
* STROUT                    ARRAY TO STRING                            *
*                                                                      *
************************************************************************
*
* STROUT.lss
*
-LINE 16 "STROUT.lss"
-MODULE STROUT
-PUBLIC STRINGOUT()
         DEFINE('STRINGOUT(A,SEP)I')                    :(STRINGOUT_END)
*
STRINGOUT
         I = 1
         STRINGOUT = A<1>                                     :F(RETURN)
STRINGOUT_1
         I = I + 1
         STRINGOUT = STRINGOUT SEP A<I>         :S(STRINGOUT_1)F(RETURN)
*
STRINGOUT_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>STROUT - Array to string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">STRINGOUT(A,SEP)</font> will serve to convert from array to
string. <font face="Source Code Pro">SEP</font> contains a separation string to be inserted between
strings of the array <font face="Source Code Pro">A</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>See Also</h2>
<a href="CRACK.html">CRACK</a>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;STROUT&raquo;&equiv;</b>
-MODULE STROUT
-PUBLIC STRINGOUT()
         DEFINE(&#39;STRINGOUT(A,SEP)I&#39;)                    <b>:(STRINGOUT_END)</b>
<font color="#818181"><i>*</i></font>
STRINGOUT
         I = 1
         STRINGOUT = A&lt;1&gt;                                     <b>:F(RETURN)</b>
STRINGOUT_1
         I = I + 1
         STRINGOUT = STRINGOUT SEP A&lt;I&gt;         <b>:S(STRINGOUT_1)F(RETURN)</b>
<font color="#818181"><i>*</i></font>
STRINGOUT_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;STROUT.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL STROUT
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*            #####   #######  ######   #######  #     #  #######       *</i></font>
<font color="#818181"><i>*           #     #     #     #     #  #     #  #     #     #          *</i></font>
<font color="#818181"><i>*           #           #     #     #  #     #  #     #     #          *</i></font>
<font color="#818181"><i>*            #####      #     ######   #     #  #     #     #          *</i></font>
<font color="#818181"><i>*                 #     #     #   #    #     #  #     #     #          *</i></font>
<font color="#818181"><i>*           #     #     #     #    #   #     #  #     #     #          *</i></font>
<font color="#818181"><i>*            #####      #     #     #  #######   #####      #          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* STROUT                    ARRAY TO STRING                            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* STROUT.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;STROUT&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:26 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'STROUT.INC'
-LINE 34 "STROUT.lss"
         &CODE = 1
         &CODE = 0
END
<h1>SWAP - Swap two variables</h1>

Swap values of two variables passed by name.  [[SWAP(.N,.M)]] will
swap the contents of the two named variables.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<SWAP>>=
-MODULE SWAP
-PUBLIC SWAP()
         DEFINE('SWAP(SWAP_ARG1,SWAP_ARG2)')                 :(SWAP_END)
*
SWAP     SWAP = $SWAP_ARG1
         $SWAP_ARG1 = $SWAP_ARG2
         $SWAP_ARG2 = SWAP
         SWAP =                                                :(RETURN)
*
SWAP_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SWAP.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL SWAP
-EJECT
*
************************************************************************
*                                                                      *
*                   #####   #     #     #     ######                   *
*                  #     #  #  #  #    # #    #     #                  *
*                  #        #  #  #   #   #   #     #                  *
*                   #####   #  #  #  #     #  ######                   *
*                        #  #  #  #  #######  #                        *
*                  #     #  #  #  #  #     #  #                        *
*                   #####    ## ##   #     #  #                        *
*                                                                      *
* SWAP                    SWAP TWO VARIABLES                           *
*                                                                      *
************************************************************************
*
* SWAP.lss
*
<<SWAP>>
*
* CE: .MSNOBOL4;
@
-STITL SWAP
-EJECT
*
-LINE 37 "SWAP.lss"
************************************************************************
*                                                                      *
*                   #####   #     #     #     ######                   *
*                  #     #  #  #  #    # #    #     #                  *
*                  #        #  #  #   #   #   #     #                  *
*                   #####   #  #  #  #     #  ######                   *
*                        #  #  #  #  #######  #                        *
*                  #     #  #  #  #  #     #  #                        *
*                   #####    ## ##   #     #  #                        *
*                                                                      *
* SWAP                    SWAP TWO VARIABLES                           *
*                                                                      *
************************************************************************
*
* SWAP.lss
*
-LINE 12 "SWAP.lss"
-MODULE SWAP
-PUBLIC SWAP()
         DEFINE('SWAP(SWAP_ARG1,SWAP_ARG2)')                 :(SWAP_END)
*
SWAP     SWAP = $SWAP_ARG1
         $SWAP_ARG1 = $SWAP_ARG2
         $SWAP_ARG2 = SWAP
         SWAP =                                                :(RETURN)
*
SWAP_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SWAP - Swap two variables</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Swap values of two variables passed by name.  <font face="Source Code Pro">SWAP(.N,.M)</font> will
swap the contents of the two named variables.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SWAP&raquo;&equiv;</b>
-MODULE SWAP
-PUBLIC SWAP()
         DEFINE(&#39;SWAP(SWAP_ARG1,SWAP_ARG2)&#39;)                 <b>:(SWAP_END)</b>
<font color="#818181"><i>*</i></font>
SWAP     SWAP = $SWAP_ARG1
         $SWAP_ARG1 = $SWAP_ARG2
         $SWAP_ARG2 = SWAP
         SWAP =                                                <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SWAP_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SWAP.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL SWAP
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   #####   #     #     #     ######                   *</i></font>
<font color="#818181"><i>*                  #     #  #  #  #    # #    #     #                  *</i></font>
<font color="#818181"><i>*                  #        #  #  #   #   #   #     #                  *</i></font>
<font color="#818181"><i>*                   #####   #  #  #  #     #  ######                   *</i></font>
<font color="#818181"><i>*                        #  #  #  #  #######  #                        *</i></font>
<font color="#818181"><i>*                  #     #  #  #  #  #     #  #                        *</i></font>
<font color="#818181"><i>*                   #####    ## ##   #     #  #                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SWAP                    SWAP TWO VARIABLES                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SWAP.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SWAP&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:27 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SWAP.INC'
-LINE 28 "SWAP.lss"
         &CODE = 1
         &CODE = 0
END
<h1>SYSLOG - Interface to OPENLOG/SYSLOG/CLOSELOG</h1>

Uses FFI rather than LOAD() to access SYSLOG functions

<h2>Uses</h2>
<a href="FFI.html">FFI</a><br>
<a href="P64.html">P64</a><br>

<<INCLUDES>>=
-INCLUDE 'FFI.INC'
-INCLUDE 'P64.INC'
@

<<SYSLOG>>=
-MODULE SYSLOG
         FFI_OPENLOG = FFI_NEW('V', 'P,I,I')
         FFI_SET_CALLP(FFI_OPENLOG, DLSYM(0, 'openlog'))
         FFI_SYSLOG = FFI_NEW('V', 'I,P,P')
         FFI_SET_CALLP(FFI_SYSLOG, DLSYM(0, 'syslog'))
         FFI_CLOSELOG = FFI_NEW('V', 'V')
         FFI_SET_CALLP(FFI_CLOSELOG, DLSYM(0, 'closelog'))
*
* PRIORITY
*
-PUBLIC LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING
-PUBLIC LOG_NOTICE, LOG_INFO, LOG_DEBUG
         LOG_EMERG   = 0
         LOG_ALERT   = 1
         LOG_CRIT    = 2
         LOG_ERR     = 3
         LOG_WARNING = 4
         LOG_NOTICE  = 5
         LOG_INFO    = 6
         LOG_DEBUG   = 7
*
* FACILITY
*
-PUBLIC LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_SYSLOG
-PUBLIC LOG_LPR, LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_AUTHPRIV, LOG_FTP
-PUBLIC LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4
-PUBLIC LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7
         LOG_KERN     =  0 * 8
         LOG_USER     =  1 * 8
         LOG_MAIL     =  2 * 8
         LOG_DAEMON   =  3 * 8
         LOG_AUTH     =  4 * 8
         LOG_SYSLOG   =  5 * 8
         LOG_LPR      =  6 * 8
         LOG_NEWS     =  7 * 8
         LOG_UUCP     =  8 * 8
         LOG_CRON     =  9 * 8
         LOG_AUTHPRIV = 10 * 8
         LOG_FTP      = 11 * 8
         LOG_LOCAL0   = 16 * 8
         LOG_LOCAL1   = 17 * 8
         LOG_LOCAL2   = 18 * 8
         LOG_LOCAL3   = 19 * 8
         LOG_LOCAL4   = 20 * 8
         LOG_LOCAL5   = 21 * 8
         LOG_LOCAL6   = 22 * 8
         LOG_LOCAL7   = 23 * 8
*
* OPTIONS
*
-PUBLIC LOG_PID, LOG_CONS, LOG_ODELAY, LOG_NDELAY, LOG_NOWAIT
-PUBLIC LOG_PERROR
         LOG_PID    =  1
         LOG_CONS   =  2
         LOG_ODELAY =  4
         LOG_NDELAY =  8
         LOG_NOWAIT = 16
         LOG_PERROR = 32
*
-PUBLIC OPENLOG(), SYSLOG() CLOSELOG()
         DEFINE('OPENLOG(IDENT,OPTION,FACILITY)P')
         DEFINE('SYSLOG(PRIORITY,S)')
         DEFINE('CLOSELOG()')                           :(SYSLOG_FN_END)
*
OPENLOG  P = STRDUP(IDENT)
         FFI_PAR_N_PTR(FFI_OPENLOG, 1, P)
         FFI_PAR_N_INTEGER(FFI_OPENLOG, 2, OPTION)
         FFI_PAR_N_INTEGER(FFI_OPENLOG, 3, FACILITY)
         FFI_CALL_VOID(FFI_OPENLOG)                            :(RETURN)
*
SYSLOG   FFI_PAR_N_INTEGER(FFI_SYSLOG, 1, PRIORITY)
         FFI_PAR_N_STRING(FFI_SYSLOG, 2, '%s')
         FFI_PAR_N_STRING(FFI_SYSLOG, 3, S)
         FFI_CALL_VOID(FFI_SYSLOG)                             :(RETURN)
*
CLOSELOG FFI_CALL_VOID(FFI_CLOSELOG)                           :(RETURN)
*
SYSLOG_FN_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SYSLOG.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL SYSLOG
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*          #####   #     #   #####   #        #######   #####          *
*         #     #   #   #   #     #  #        #     #  #     #         *
*         #          # #    #        #        #     #  #               *
*          #####      #      #####   #        #     #  #  ####         *
*               #     #           #  #        #     #  #     #         *
*         #     #     #     #     #  #        #     #  #     #         *
*          #####      #      #####   #######  #######   #####          *
*                                                                      *
* SYSLOG        INTERFACE TO OPENLOG/SYSLOG/CLOSELOG                   *
*                                                                      *
************************************************************************
*
* SYSLOG.lss
*
<<SYSLOG>>
*
* CE: .MSNOBOL4;
@
-LINE 10 "SYSLOG.lss"
-INCLUDE 'FFI.INC'
-INCLUDE 'P64.INC'
-STITL SYSLOG
-EJECT
-LINE 108 "SYSLOG.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*          #####   #     #   #####   #        #######   #####          *
*         #     #   #   #   #     #  #        #     #  #     #         *
*         #          # #    #        #        #     #  #               *
*          #####      #      #####   #        #     #  #  ####         *
*               #     #           #  #        #     #  #     #         *
*         #     #     #     #     #  #        #     #  #     #         *
*          #####      #      #####   #######  #######   #####          *
*                                                                      *
* SYSLOG        INTERFACE TO OPENLOG/SYSLOG/CLOSELOG                   *
*                                                                      *
************************************************************************
*
* SYSLOG.lss
*
-LINE 15 "SYSLOG.lss"
-MODULE SYSLOG
         FFI_OPENLOG = FFI_NEW('V', 'P,I,I')
         FFI_SET_CALLP(FFI_OPENLOG, DLSYM(0, 'openlog'))
         FFI_SYSLOG = FFI_NEW('V', 'I,P,P')
         FFI_SET_CALLP(FFI_SYSLOG, DLSYM(0, 'syslog'))
         FFI_CLOSELOG = FFI_NEW('V', 'V')
         FFI_SET_CALLP(FFI_CLOSELOG, DLSYM(0, 'closelog'))
*
* PRIORITY
*
-PUBLIC LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING
-PUBLIC LOG_NOTICE, LOG_INFO, LOG_DEBUG
         LOG_EMERG   = 0
         LOG_ALERT   = 1
         LOG_CRIT    = 2
         LOG_ERR     = 3
         LOG_WARNING = 4
         LOG_NOTICE  = 5
         LOG_INFO    = 6
         LOG_DEBUG   = 7
*
* FACILITY
*
-PUBLIC LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_SYSLOG
-PUBLIC LOG_LPR, LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_AUTHPRIV, LOG_FTP
-PUBLIC LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4
-PUBLIC LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7
         LOG_KERN     =  0 * 8
         LOG_USER     =  1 * 8
         LOG_MAIL     =  2 * 8
         LOG_DAEMON   =  3 * 8
         LOG_AUTH     =  4 * 8
         LOG_SYSLOG   =  5 * 8
         LOG_LPR      =  6 * 8
         LOG_NEWS     =  7 * 8
         LOG_UUCP     =  8 * 8
         LOG_CRON     =  9 * 8
         LOG_AUTHPRIV = 10 * 8
         LOG_FTP      = 11 * 8
         LOG_LOCAL0   = 16 * 8
         LOG_LOCAL1   = 17 * 8
         LOG_LOCAL2   = 18 * 8
         LOG_LOCAL3   = 19 * 8
         LOG_LOCAL4   = 20 * 8
         LOG_LOCAL5   = 21 * 8
         LOG_LOCAL6   = 22 * 8
         LOG_LOCAL7   = 23 * 8
*
* OPTIONS
*
-PUBLIC LOG_PID, LOG_CONS, LOG_ODELAY, LOG_NDELAY, LOG_NOWAIT
-PUBLIC LOG_PERROR
         LOG_PID    =  1
         LOG_CONS   =  2
         LOG_ODELAY =  4
         LOG_NDELAY =  8
         LOG_NOWAIT = 16
         LOG_PERROR = 32
*
-PUBLIC OPENLOG(), SYSLOG() CLOSELOG()
         DEFINE('OPENLOG(IDENT,OPTION,FACILITY)P')
         DEFINE('SYSLOG(PRIORITY,S)')
         DEFINE('CLOSELOG()')                           :(SYSLOG_FN_END)
*
OPENLOG  P = STRDUP(IDENT)
         FFI_PAR_N_PTR(FFI_OPENLOG, 1, P)
         FFI_PAR_N_INTEGER(FFI_OPENLOG, 2, OPTION)
         FFI_PAR_N_INTEGER(FFI_OPENLOG, 3, FACILITY)
         FFI_CALL_VOID(FFI_OPENLOG)                            :(RETURN)
*
SYSLOG   FFI_PAR_N_INTEGER(FFI_SYSLOG, 1, PRIORITY)
         FFI_PAR_N_STRING(FFI_SYSLOG, 2, '%s')
         FFI_PAR_N_STRING(FFI_SYSLOG, 3, S)
         FFI_CALL_VOID(FFI_SYSLOG)                             :(RETURN)
*
CLOSELOG FFI_CALL_VOID(FFI_CLOSELOG)                           :(RETURN)
*
SYSLOG_FN_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SYSLOG - Interface to OPENLOG/SYSLOG/CLOSELOG</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Uses FFI rather than LOAD() to access SYSLOG functions
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="FFI.html">FFI</a><br>
<a href="P64.html">P64</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;FFI.INC&#39;
-INCLUDE &#39;P64.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SYSLOG&raquo;&equiv;</b>
-MODULE SYSLOG
         FFI_OPENLOG = FFI_NEW(&#39;V&#39;, &#39;P,I,I&#39;)
         FFI_SET_CALLP(FFI_OPENLOG, DLSYM(0, &#39;openlog&#39;))
         FFI_SYSLOG = FFI_NEW(&#39;V&#39;, &#39;I,P,P&#39;)
         FFI_SET_CALLP(FFI_SYSLOG, DLSYM(0, &#39;syslog&#39;))
         FFI_CLOSELOG = FFI_NEW(&#39;V&#39;, &#39;V&#39;)
         FFI_SET_CALLP(FFI_CLOSELOG, DLSYM(0, &#39;closelog&#39;))
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PRIORITY</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR, LOG_WARNING
-PUBLIC LOG_NOTICE, LOG_INFO, LOG_DEBUG
         LOG_EMERG   = 0
         LOG_ALERT   = 1
         LOG_CRIT    = 2
         LOG_ERR     = 3
         LOG_WARNING = 4
         LOG_NOTICE  = 5
         LOG_INFO    = 6
         LOG_DEBUG   = 7
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FACILITY</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC LOG_KERN, LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH, LOG_SYSLOG
-PUBLIC LOG_LPR, LOG_NEWS, LOG_UUCP, LOG_CRON, LOG_AUTHPRIV, LOG_FTP
-PUBLIC LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3, LOG_LOCAL4
-PUBLIC LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7
         LOG_KERN     =  0 * 8
         LOG_USER     =  1 * 8
         LOG_MAIL     =  2 * 8
         LOG_DAEMON   =  3 * 8
         LOG_AUTH     =  4 * 8
         LOG_SYSLOG   =  5 * 8
         LOG_LPR      =  6 * 8
         LOG_NEWS     =  7 * 8
         LOG_UUCP     =  8 * 8
         LOG_CRON     =  9 * 8
         LOG_AUTHPRIV = 10 * 8
         LOG_FTP      = 11 * 8
         LOG_LOCAL0   = 16 * 8
         LOG_LOCAL1   = 17 * 8
         LOG_LOCAL2   = 18 * 8
         LOG_LOCAL3   = 19 * 8
         LOG_LOCAL4   = 20 * 8
         LOG_LOCAL5   = 21 * 8
         LOG_LOCAL6   = 22 * 8
         LOG_LOCAL7   = 23 * 8
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OPTIONS</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC LOG_PID, LOG_CONS, LOG_ODELAY, LOG_NDELAY, LOG_NOWAIT
-PUBLIC LOG_PERROR
         LOG_PID    =  1
         LOG_CONS   =  2
         LOG_ODELAY =  4
         LOG_NDELAY =  8
         LOG_NOWAIT = 16
         LOG_PERROR = 32
<font color="#818181"><i>*</i></font>
-PUBLIC OPENLOG(), SYSLOG() CLOSELOG()
         DEFINE(&#39;OPENLOG(IDENT,OPTION,FACILITY)P&#39;)
         DEFINE(&#39;SYSLOG(PRIORITY,S)&#39;)
         DEFINE(&#39;CLOSELOG()&#39;)                           <b>:(SYSLOG_FN_END)</b>
<font color="#818181"><i>*</i></font>
OPENLOG  P = STRDUP(IDENT)
         FFI_PAR_N_PTR(FFI_OPENLOG, 1, P)
         FFI_PAR_N_INTEGER(FFI_OPENLOG, 2, OPTION)
         FFI_PAR_N_INTEGER(FFI_OPENLOG, 3, FACILITY)
         FFI_CALL_VOID(FFI_OPENLOG)                            <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SYSLOG   FFI_PAR_N_INTEGER(FFI_SYSLOG, 1, PRIORITY)
         FFI_PAR_N_STRING(FFI_SYSLOG, 2, &#39;%s&#39;)
         FFI_PAR_N_STRING(FFI_SYSLOG, 3, S)
         FFI_CALL_VOID(FFI_SYSLOG)                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
CLOSELOG FFI_CALL_VOID(FFI_CLOSELOG)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SYSLOG_FN_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SYSLOG.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL SYSLOG
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*          #####   #     #   #####   #        #######   #####          *</i></font>
<font color="#818181"><i>*         #     #   #   #   #     #  #        #     #  #     #         *</i></font>
<font color="#818181"><i>*         #          # #    #        #        #     #  #               *</i></font>
<font color="#818181"><i>*          #####      #      #####   #        #     #  #  ####         *</i></font>
<font color="#818181"><i>*               #     #           #  #        #     #  #     #         *</i></font>
<font color="#818181"><i>*         #     #     #     #     #  #        #     #  #     #         *</i></font>
<font color="#818181"><i>*          #####      #      #####   #######  #######   #####          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SYSLOG        INTERFACE TO OPENLOG/SYSLOG/CLOSELOG                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SYSLOG.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SYSLOG&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:27 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SYSLOG.INC'
-LINE 99 "SYSLOG.lss"
         &CODE = 1
         &CODE = 0
END
<h1>SYSTEM - Determine kind of SNOBOL4</h1>

SYSTEM() will return which of the various SNOBOL4 processors the
program may be running under.

SYSTEM() returns the SNOBOL4 processor. CSNOBOL4 may be running under
different operating systems, and different hardware platforms
(WINDOWS, LINUX, SOLARIS, AIX, HP-UX and more; INTEL, SPARC, POWER,
and more).

[[
HONEYWELL MAINBOL
IBM MAINBOL
IBM MAINBOL WITH BLOCKS
PDP-10 MAINBOL
CDC MAINBOL
UNIVAC MAINBOL
CSNOBOL4
CSNOBOL4 WITH BLOCKS
FASBOL
SITBOL
SPITBOL
]]

If source could be in CDC display code, test that first, before
ISASCII() -- '()' is ordered the same in both of these character sets.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<SYSTEM>>=
-MODULE SYSTEM
-PUBLIC SYSTEM(), ISSPITBOL(), ISSNOBOL4()
-PUBLIC ISASCII(), ISEBCDIC(), ISCDC_DISPLAY_CODE()
         DEFINE('SYSTEM()K,E,T')
         DEFINE('ISSPITBOL()')
         DEFINE('ISSNOBOL4()')
         DEFINE('ISASCII()A')
         DEFINE('ISEBCDIC()A')
         DEFINE('ISCDC_DISPLAY_CODE()A')                   :(SYSTEM_END)
*
ISASCII  A = &ANCHOR
         &ANCHOR = 0
         &ALPHABET '()'                          :S(ISASCII1)F(ISASCII2)
ISASCII1 &ANCHOR = A                                           :(RETURN)
ISASCII2 &ANCHOR = A                                          :(FRETURN)
*
* OR, TRY LLT('A',1)
ISEBCDIC A = &ANCHOR
         &ANCHOR = 0
         &ALPHABET '(+'                          :S(ISASCII1)F(ISASCII2)
*
ISCDC_DISPLAY_CODE
         A = &ANCHOR
         &ANCHOR = 0
         &ALPHABET ')*'                          :S(ISASCII1)F(ISASCII2)
*
ISSPITBOL
         DIFFER(.NAME, 'NAME')                      :S(RETURN)F(FRETURN)
*
ISSNOBOL4
         IDENT(.NAME, 'NAME')                       :S(RETURN)F(FRETURN)
*
SYSTEM   IDENT(DATATYPE(.X), 'STRING')                      :F(SYSTEM_2)
         K = SIZE(&ALPHABET)
         SYSTEM = EQ(K,512) 'HONEYWELL MAINBOL'               :S(RETURN)
         SYSTEM = EQ(K,256) 'IBM MAINBOL'                   :S(SYSTEM_0)
         SYSTEM = EQ(K,128) 'PDP-10 MAINBOL'                  :S(RETURN)
         SYSTEM =           'CDC MAINBOL'
         ISASCII()                                          :S(SYSTEM_1)
         SYSTEM =           'UNIVAC MAINBOL'                   :(RETURN)
*
* DISTINGUISH IBM MAINBOL AND CSNOBOL, ASSUME ASCII FOR CSNOBOL4.
* IBM MAINBOL RUNS ON SYSTEM/360, WHICH IS EBCDIC.
*
* AFTER 1.5 (VERSION 1.5+), CSNOBOL4 SUPPORTS BLOCKS WITH THE
* -B COMMAND LINE SWITCH AND -BLOCKS/-NOBLOCKS
*
SYSTEM_0 ISASCII()                                          :F(SYSTEM_1)
         SYSTEM = 'CSNOBOL4'
*
SYSTEM_1 E = &ERRLIMIT
         &ERRLIMIT = 1
         T = DATATYPE(1 # 1)
         &ERRLIMIT = E
         DIFFER(T, 'BLOCK')                                   :S(RETURN)
         SYSTEM = SYSTEM ' WITH BLOCKS'                        :(RETURN)
*
SYSTEM_2 SYSTEM = DIFFER(SUBSTR('ABC', 2, 1), 'B') 'FASBOL'   :S(RETURN)
         SYSTEM = EQ(SIZE(&ALPHABET), 128)         'SITBOL'   :S(RETURN)
         SYSTEM =                                  'SPITBOL'   :(RETURN)
*
SYSTEM_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SYSTEM.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL SYSTEM
-EJECT
*
************************************************************************
*                                                                      *
*          #####   #     #   #####   #######  #######  #     #         *
*         #     #   #   #   #     #     #     #        ##   ##         *
*         #          # #    #           #     #        # # # #         *
*          #####      #      #####      #     #####    #  #  #         *
*               #     #           #     #     #        #     #         *
*         #     #     #     #     #     #     #        #     #         *
*          #####      #      #####      #     #######  #     #         *
*                                                                      *
* SYSTEM            DETERMINE KIND OF SNOBOL4                          *
*                                                                      *
************************************************************************
*
* SYSTEM.lss
*
<<SYSTEM>>
*
* CE: .MSNOBOL4;
@
-STITL SYSTEM
-EJECT
*
-LINE 111 "SYSTEM.lss"
************************************************************************
*                                                                      *
*          #####   #     #   #####   #######  #######  #     #         *
*         #     #   #   #   #     #     #     #        ##   ##         *
*         #          # #    #           #     #        # # # #         *
*          #####      #      #####      #     #####    #  #  #         *
*               #     #           #     #     #        #     #         *
*         #     #     #     #     #     #     #        #     #         *
*          #####      #      #####      #     #######  #     #         *
*                                                                      *
* SYSTEM            DETERMINE KIND OF SNOBOL4                          *
*                                                                      *
************************************************************************
*
* SYSTEM.lss
*
-LINE 34 "SYSTEM.lss"
-MODULE SYSTEM
-PUBLIC SYSTEM(), ISSPITBOL(), ISSNOBOL4()
-PUBLIC ISASCII(), ISEBCDIC(), ISCDC_DISPLAY_CODE()
         DEFINE('SYSTEM()K,E,T')
         DEFINE('ISSPITBOL()')
         DEFINE('ISSNOBOL4()')
         DEFINE('ISASCII()A')
         DEFINE('ISEBCDIC()A')
         DEFINE('ISCDC_DISPLAY_CODE()A')                   :(SYSTEM_END)
*
ISASCII  A = &ANCHOR
         &ANCHOR = 0
         &ALPHABET '()'                          :S(ISASCII1)F(ISASCII2)
ISASCII1 &ANCHOR = A                                           :(RETURN)
ISASCII2 &ANCHOR = A                                          :(FRETURN)
*
* OR, TRY LLT('A',1)
ISEBCDIC A = &ANCHOR
         &ANCHOR = 0
         &ALPHABET '(+'                          :S(ISASCII1)F(ISASCII2)
*
ISCDC_DISPLAY_CODE
         A = &ANCHOR
         &ANCHOR = 0
         &ALPHABET ')*'                          :S(ISASCII1)F(ISASCII2)
*
ISSPITBOL
         DIFFER(.NAME, 'NAME')                      :S(RETURN)F(FRETURN)
*
ISSNOBOL4
         IDENT(.NAME, 'NAME')                       :S(RETURN)F(FRETURN)
*
SYSTEM   IDENT(DATATYPE(.X), 'STRING')                      :F(SYSTEM_2)
         K = SIZE(&ALPHABET)
         SYSTEM = EQ(K,512) 'HONEYWELL MAINBOL'               :S(RETURN)
         SYSTEM = EQ(K,256) 'IBM MAINBOL'                   :S(SYSTEM_0)
         SYSTEM = EQ(K,128) 'PDP-10 MAINBOL'                  :S(RETURN)
         SYSTEM =           'CDC MAINBOL'
         ISASCII()                                          :S(SYSTEM_1)
         SYSTEM =           'UNIVAC MAINBOL'                   :(RETURN)
*
* DISTINGUISH IBM MAINBOL AND CSNOBOL, ASSUME ASCII FOR CSNOBOL4.
* IBM MAINBOL RUNS ON SYSTEM/360, WHICH IS EBCDIC.
*
* AFTER 1.5 (VERSION 1.5+), CSNOBOL4 SUPPORTS BLOCKS WITH THE
* -B COMMAND LINE SWITCH AND -BLOCKS/-NOBLOCKS
*
SYSTEM_0 ISASCII()                                          :F(SYSTEM_1)
         SYSTEM = 'CSNOBOL4'
*
SYSTEM_1 E = &ERRLIMIT
         &ERRLIMIT = 1
         T = DATATYPE(1 # 1)
         &ERRLIMIT = E
         DIFFER(T, 'BLOCK')                                   :S(RETURN)
         SYSTEM = SYSTEM ' WITH BLOCKS'                        :(RETURN)
*
SYSTEM_2 SYSTEM = DIFFER(SUBSTR('ABC', 2, 1), 'B') 'FASBOL'   :S(RETURN)
         SYSTEM = EQ(SIZE(&ALPHABET), 128)         'SITBOL'   :S(RETURN)
         SYSTEM =                                  'SPITBOL'   :(RETURN)
*
SYSTEM_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>SYSTEM - Determine kind of SNOBOL4</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
SYSTEM() will return which of the various SNOBOL4 processors the
program may be running under.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
SYSTEM() returns the SNOBOL4 processor. CSNOBOL4 may be running under
different operating systems, and different hardware platforms
(WINDOWS, LINUX, SOLARIS, AIX, HP-UX and more; INTEL, SPARC, POWER,
and more).
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
</font></p><pre><font face="Source Code Pro">
| HONEYWELL MAINBOL
| IBM MAINBOL
| IBM MAINBOL WITH BLOCKS
| PDP-10 MAINBOL
| CDC MAINBOL
| UNIVAC MAINBOL
| CSNOBOL4
| CSNOBOL4 WITH BLOCKS
| FASBOL
| SITBOL
| SPITBOL
</font></pre>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If source could be in CDC display code, test that first, before
ISASCII() -- '()' is ordered the same in both of these character sets.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;SYSTEM&raquo;&equiv;</b>
-MODULE SYSTEM
-PUBLIC SYSTEM(), ISSPITBOL(), ISSNOBOL4()
-PUBLIC ISASCII(), ISEBCDIC(), ISCDC_DISPLAY_CODE()
         DEFINE(&#39;SYSTEM()K,E,T&#39;)
         DEFINE(&#39;ISSPITBOL()&#39;)
         DEFINE(&#39;ISSNOBOL4()&#39;)
         DEFINE(&#39;ISASCII()A&#39;)
         DEFINE(&#39;ISEBCDIC()A&#39;)
         DEFINE(&#39;ISCDC_DISPLAY_CODE()A&#39;)                   <b>:(SYSTEM_END)</b>
<font color="#818181"><i>*</i></font>
ISASCII  A = &amp;ANCHOR
         &amp;ANCHOR = 0
         &amp;ALPHABET &#39;()&#39;                          <b>:S(ISASCII1)F(ISASCII2)</b>
ISASCII1 &amp;ANCHOR = A                                           <b>:(RETURN)</b>
ISASCII2 &amp;ANCHOR = A                                          <b>:(FRETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OR, TRY LLT(&#39;A&#39;,1)</i></font>
ISEBCDIC A = &amp;ANCHOR
         &amp;ANCHOR = 0
         &amp;ALPHABET &#39;(+&#39;                          <b>:S(ISASCII1)F(ISASCII2)</b>
<font color="#818181"><i>*</i></font>
ISCDC_DISPLAY_CODE
         A = &amp;ANCHOR
         &amp;ANCHOR = 0
         &amp;ALPHABET &#39;)*&#39;                          <b>:S(ISASCII1)F(ISASCII2)</b>
<font color="#818181"><i>*</i></font>
ISSPITBOL
         DIFFER(.NAME, &#39;NAME&#39;)                      <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
ISSNOBOL4
         IDENT(.NAME, &#39;NAME&#39;)                       <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
SYSTEM   IDENT(DATATYPE(.X), &#39;STRING&#39;)                      <b>:F(SYSTEM_2)</b>
         K = SIZE(&amp;ALPHABET)
         SYSTEM = EQ(K,512) &#39;HONEYWELL MAINBOL&#39;               <b>:S(RETURN)</b>
         SYSTEM = EQ(K,256) &#39;IBM MAINBOL&#39;                   <b>:S(SYSTEM_0)</b>
         SYSTEM = EQ(K,128) &#39;PDP-10 MAINBOL&#39;                  <b>:S(RETURN)</b>
         SYSTEM =           &#39;CDC MAINBOL&#39;
         ISASCII()                                          <b>:S(SYSTEM_1)</b>
         SYSTEM =           &#39;UNIVAC MAINBOL&#39;                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* DISTINGUISH IBM MAINBOL AND CSNOBOL, ASSUME ASCII FOR CSNOBOL4.</i></font>
<font color="#818181"><i>* IBM MAINBOL RUNS ON SYSTEM/360, WHICH IS EBCDIC.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* AFTER 1.5 (VERSION 1.5+), CSNOBOL4 SUPPORTS BLOCKS WITH THE</i></font>
<font color="#818181"><i>* -B COMMAND LINE SWITCH AND -BLOCKS/-NOBLOCKS</i></font>
<font color="#818181"><i>*</i></font>
SYSTEM_0 ISASCII()                                          <b>:F(SYSTEM_1)</b>
         SYSTEM = &#39;CSNOBOL4&#39;
<font color="#818181"><i>*</i></font>
SYSTEM_1 E = &amp;ERRLIMIT
         &amp;ERRLIMIT = 1
         T = DATATYPE(1 # 1)
         &amp;ERRLIMIT = E
         DIFFER(T, &#39;BLOCK&#39;)                                   <b>:S(RETURN)</b>
         SYSTEM = SYSTEM &#39; WITH BLOCKS&#39;                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SYSTEM_2 SYSTEM = DIFFER(SUBSTR(&#39;ABC&#39;, 2, 1), &#39;B&#39;) &#39;FASBOL&#39;   <b>:S(RETURN)</b>
         SYSTEM = EQ(SIZE(&amp;ALPHABET), 128)         &#39;SITBOL&#39;   <b>:S(RETURN)</b>
         SYSTEM =                                  &#39;SPITBOL&#39;   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
SYSTEM_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;SYSTEM.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL SYSTEM
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*          #####   #     #   #####   #######  #######  #     #         *</i></font>
<font color="#818181"><i>*         #     #   #   #   #     #     #     #        ##   ##         *</i></font>
<font color="#818181"><i>*         #          # #    #           #     #        # # # #         *</i></font>
<font color="#818181"><i>*          #####      #      #####      #     #####    #  #  #         *</i></font>
<font color="#818181"><i>*               #     #           #     #     #        #     #         *</i></font>
<font color="#818181"><i>*         #     #     #     #     #     #     #        #     #         *</i></font>
<font color="#818181"><i>*          #####      #      #####      #     #######  #     #         *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* SYSTEM            DETERMINE KIND OF SNOBOL4                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SYSTEM.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;SYSTEM&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:28 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SYSTEM.INC'
-LINE 102 "SYSTEM.lss"
         &CODE = 1
         &CODE = 0
END
<h1>TEST - Bypass one character assumption</h1>

[[TESTP(ARG)]] accepts an unevaluated expression as argument, and
returns a pattern bypasses SNOBOL4's one-character length assumption
(quickscan heuristics).

{{
It is never necessary to use [[TESTP(ARG)]] with SPITBOL, because
SPITBOL does not have a one-character assumption.
}}

<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>

<<INCLUDES>>=
-INCLUDE 'UNIQUE.INC'
@

<<TEST>>=
-MODULE TEST
-PUBLIC TESTP()
         DEFINE('TESTP(ARG)NAME')                            :(TEST_END)
*
TESTP    IDENT(DATATYPE(ARG), 'EXPRESSION')                   :F(TEST_1)
         NAME = UNIQUE()
         $NAME = ARG
         TEST = EVAL("NULL $ *TEST('" NAME "')")               :(RETURN)
TEST_1   TEST = ?EVAL($ARG) .TEST_                 :S(NRETURN)F(FRETURN)
*
TEST_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TEST.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL TEST
-EJECT
*
************************************************************************
*                                                                      *
*                                                                      *
*                  #######  #######   #####   #######                  *
*                     #     #        #     #     #                     *
*                     #     #        #           #                     *
*                     #     #####     #####      #                     *
*                     #     #              #     #                     *
*                     #     #        #     #     #                     *
*                     #     #######   #####      #                     *
*                                                                      *
* TEST                                                                 *
*                                                                      *
************************************************************************
*
* TEST.lss
*
<<TEST>>
*
* CE: .MSNOBOL4;
@
-LINE 16 "TEST.lss"
-INCLUDE 'UNIQUE.INC'
-STITL TEST
-EJECT
-LINE 46 "TEST.lss"
*
************************************************************************
*                                                                      *
*                                                                      *
*                  #######  #######   #####   #######                  *
*                     #     #        #     #     #                     *
*                     #     #        #           #                     *
*                     #     #####     #####      #                     *
*                     #     #              #     #                     *
*                     #     #        #     #     #                     *
*                     #     #######   #####      #                     *
*                                                                      *
* TEST                                                                 *
*                                                                      *
************************************************************************
*
* TEST.lss
*
-LINE 20 "TEST.lss"
-MODULE TEST
-PUBLIC TESTP()
         DEFINE('TESTP(ARG)NAME')                            :(TEST_END)
*
TESTP    IDENT(DATATYPE(ARG), 'EXPRESSION')                   :F(TEST_1)
         NAME = UNIQUE()
         $NAME = ARG
         TEST = EVAL("NULL $ *TEST('" NAME "')")               :(RETURN)
TEST_1   TEST = ?EVAL($ARG) .TEST_                 :S(NRETURN)F(FRETURN)
*
TEST_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>TEST - Bypass one character assumption</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TESTP(ARG)</font> accepts an unevaluated expression as argument, and
returns a pattern bypasses SNOBOL4's one-character length assumption
(quickscan heuristics).
</font></p>
<div style="width:15em;margin-left:0.5em;float:right;background-image:url(blutextb.gif)">
<font face="Dijkstra"><p align="left">
It is never necessary to use <font face="Source Code Pro">TESTP(ARG)</font> with SPITBOL, because
SPITBOL does not have a one-character assumption.
</p></font></div>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="UNIQUE.html">UNIQUE</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;UNIQUE.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TEST&raquo;&equiv;</b>
-MODULE TEST
-PUBLIC TESTP()
         DEFINE(&#39;TESTP(ARG)NAME&#39;)                            <b>:(TEST_END)</b>
<font color="#818181"><i>*</i></font>
TESTP    IDENT(DATATYPE(ARG), &#39;EXPRESSION&#39;)                   <b>:F(TEST_1)</b>
         NAME = UNIQUE()
         $NAME = ARG
         TEST = EVAL(&quot;NULL $ *TEST(&#39;&quot; NAME &quot;&#39;)&quot;)               <b>:(RETURN)</b>
TEST_1   TEST = ?EVAL($ARG) .TEST_                 <b>:S(NRETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
TEST_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TEST.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL TEST
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #######  #######   #####   #######                  *</i></font>
<font color="#818181"><i>*                     #     #        #     #     #                     *</i></font>
<font color="#818181"><i>*                     #     #        #           #                     *</i></font>
<font color="#818181"><i>*                     #     #####     #####      #                     *</i></font>
<font color="#818181"><i>*                     #     #              #     #                     *</i></font>
<font color="#818181"><i>*                     #     #        #     #     #                     *</i></font>
<font color="#818181"><i>*                     #     #######   #####      #                     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TEST                                                                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TEST.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TEST&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:28 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TEST.INC'
-LINE 37 "TEST.lss"
         &CODE = 1
         &CODE = 0
END
<h1>TIMEGC - Time garbage collect</h1>

[[TIMEGC(N)]] will scatter strings, array elements and
programmer-defined data about in memory, then time a 'typical'
garbage collection. [[N]] determines the amount and type of litter.

<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
<a href="RESOL.html">RESOL</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>

<<INCLUDES>>=
-INCLUDE 'LINK.INC'
-INCLUDE 'RESOL.INC'
-INCLUDE 'SYSTEM.INC'
@

<<TIMEGC>>=
-MODULE TIMEGC
-PUBLIC TIMEGC()
         DEFINE('TIMEGC(N)I,S,A,L,T,K,FREED')              :(TIMEGC_END)
*
TIMEGC   I = ; S = ; A = ; L =
         COLLECT()
         N = IDENT(N) 25
         A = ARRAY(N)
TIMEGC_1 I = I + 1
         $I = DUPL(' ', 78) I
         A<I> = DUPL('*', I)
         L = LINK(NULL, L)
         GE(I, N)                                           :F(TIMEGC_1)
         STREM = COLLECT()
TIMEGC_2 $I = ; A<I> = ; L = NEXT(L)
         I = I - 2 GT(I, 2)                                 :S(TIMEGC_2)
         T = TIME()
         FREED = FREED + (COLLECT() - STREM)
         TIMEGC = TIMEGC + (TIME() - T)
         K = K + 1
         M = 50
         M = LT(RESOLUTION(), 0.9) 5000
         LT(TIMEGC, M * RESOLUTION())                         :S(TIMEGC)
         OUTPUT =
         OUTPUT = 'IN ' SYSTEM() ' ' K ' GARBAGE COLLECTS'
+           ' REQUIRED A TOTAL OF ' TIMEGC ' MILLISECONDS TO FREE '
+           FREED ' STORAGE UNITS.'
         TIMEGC = CONVERT(TIMEGC, 'REAL')
         OUTPUT = 'THIS AVERAGES TO ' (TIMEGC / K) ' MILLISECONDS PER'
+           ' GARBAGE COLLECT AND ' (TIMEGC * 1000000 / FREED)
+           ' NANOSECONDS PER STORAGE UNIT.'                   :(RETURN)
*
TIMEGC_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "-s" "$0" "$@"
-INCLUDE 'TIMEGC.INC'
         &CODE = 1
* DEFAULT MEMORY IS 8MB
         TIMEGC(3500)
         TIMEGC(25)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL TIMEGC
-EJECT
*
************************************************************************
*                                                                      *
*           #######  ###  #     #  #######   #####    #####            *
*              #      #   ##   ##  #        #     #  #     #           *
*              #      #   # # # #  #        #        #                 *
*              #      #   #  #  #  #####    #  ####  #                 *
*              #      #   #     #  #        #     #  #                 *
*              #      #   #     #  #        #     #  #     #           *
*              #     ###  #     #  #######   #####    #####            *
*                                                                      *
* TIMEGC                TIME GARBAGE COLLECT                           *
*                                                                      *
************************************************************************
*
* TIMEGC.lss
*
<<TIMEGC>>
*
* CE: .MSNOBOL4;
@
-LINE 13 "TIMEGC.lss"
-INCLUDE 'LINK.INC'
-INCLUDE 'RESOL.INC'
-INCLUDE 'SYSTEM.INC'
-STITL TIMEGC
-EJECT
-LINE 70 "TIMEGC.lss"
*
************************************************************************
*                                                                      *
*           #######  ###  #     #  #######   #####    #####            *
*              #      #   ##   ##  #        #     #  #     #           *
*              #      #   # # # #  #        #        #                 *
*              #      #   #  #  #  #####    #  ####  #                 *
*              #      #   #     #  #        #     #  #                 *
*              #      #   #     #  #        #     #  #     #           *
*              #     ###  #     #  #######   #####    #####            *
*                                                                      *
* TIMEGC                TIME GARBAGE COLLECT                           *
*                                                                      *
************************************************************************
*
* TIMEGC.lss
*
-LINE 19 "TIMEGC.lss"
-MODULE TIMEGC
-PUBLIC TIMEGC()
         DEFINE('TIMEGC(N)I,S,A,L,T,K,FREED')              :(TIMEGC_END)
*
TIMEGC   I = ; S = ; A = ; L =
         COLLECT()
         N = IDENT(N) 25
         A = ARRAY(N)
TIMEGC_1 I = I + 1
         $I = DUPL(' ', 78) I
         A<I> = DUPL('*', I)
         L = LINK(NULL, L)
         GE(I, N)                                           :F(TIMEGC_1)
         STREM = COLLECT()
TIMEGC_2 $I = ; A<I> = ; L = NEXT(L)
         I = I - 2 GT(I, 2)                                 :S(TIMEGC_2)
         T = TIME()
         FREED = FREED + (COLLECT() - STREM)
         TIMEGC = TIMEGC + (TIME() - T)
         K = K + 1
         M = 50
         M = LT(RESOLUTION(), 0.9) 5000
         LT(TIMEGC, M * RESOLUTION())                         :S(TIMEGC)
         OUTPUT =
         OUTPUT = 'IN ' SYSTEM() ' ' K ' GARBAGE COLLECTS'
+           ' REQUIRED A TOTAL OF ' TIMEGC ' MILLISECONDS TO FREE '
+           FREED ' STORAGE UNITS.'
         TIMEGC = CONVERT(TIMEGC, 'REAL')
         OUTPUT = 'THIS AVERAGES TO ' (TIMEGC / K) ' MILLISECONDS PER'
+           ' GARBAGE COLLECT AND ' (TIMEGC * 1000000 / FREED)
+           ' NANOSECONDS PER STORAGE UNIT.'                   :(RETURN)
*
TIMEGC_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>TIMEGC - Time garbage collect</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TIMEGC(N)</font> will scatter strings, array elements and
programmer-defined data about in memory, then time a 'typical'
garbage collection. <font face="Source Code Pro">N</font> determines the amount and type of litter.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LINK.html">LINK</a><br>
<a href="RESOL.html">RESOL</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LINK.INC&#39;
-INCLUDE &#39;RESOL.INC&#39;
-INCLUDE &#39;SYSTEM.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TIMEGC&raquo;&equiv;</b>
-MODULE TIMEGC
-PUBLIC TIMEGC()
         DEFINE(&#39;TIMEGC(N)I,S,A,L,T,K,FREED&#39;)              <b>:(TIMEGC_END)</b>
<font color="#818181"><i>*</i></font>
TIMEGC   I = ; S = ; A = ; L =
         COLLECT()
         N = IDENT(N) 25
         A = ARRAY(N)
TIMEGC_1 I = I + 1
         $I = DUPL(&#39; &#39;, 78) I
         A&lt;I&gt; = DUPL(&#39;*&#39;, I)
         L = LINK(NULL, L)
         GE(I, N)                                           <b>:F(TIMEGC_1)</b>
         STREM = COLLECT()
TIMEGC_2 $I = ; A&lt;I&gt; = ; L = NEXT(L)
         I = I - 2 GT(I, 2)                                 <b>:S(TIMEGC_2)</b>
         T = TIME()
         FREED = FREED + (COLLECT() - STREM)
         TIMEGC = TIMEGC + (TIME() - T)
         K = K + 1
         M = 50
         M = LT(RESOLUTION(), 0.9) 5000
         LT(TIMEGC, M * RESOLUTION())                         <b>:S(TIMEGC)</b>
         OUTPUT =
         OUTPUT = &#39;IN &#39; SYSTEM() &#39; &#39; K &#39; GARBAGE COLLECTS&#39;
+           &#39; REQUIRED A TOTAL OF &#39; TIMEGC &#39; MILLISECONDS TO FREE &#39;
+           FREED &#39; STORAGE UNITS.&#39;
         TIMEGC = CONVERT(TIMEGC, &#39;REAL&#39;)
         OUTPUT = &#39;THIS AVERAGES TO &#39; (TIMEGC / K) &#39; MILLISECONDS PER&#39;
+           &#39; GARBAGE COLLECT AND &#39; (TIMEGC * 1000000 / FREED)
+           &#39; NANOSECONDS PER STORAGE UNIT.&#39;                   <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
TIMEGC_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;-s&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TIMEGC.INC&#39;
         &amp;CODE = 1
<font color="#818181"><i>* DEFAULT MEMORY IS 8MB</i></font>
         TIMEGC(3500)
         TIMEGC(25)
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL TIMEGC
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*           #######  ###  #     #  #######   #####    #####            *</i></font>
<font color="#818181"><i>*              #      #   ##   ##  #        #     #  #     #           *</i></font>
<font color="#818181"><i>*              #      #   # # # #  #        #        #                 *</i></font>
<font color="#818181"><i>*              #      #   #  #  #  #####    #  ####  #                 *</i></font>
<font color="#818181"><i>*              #      #   #     #  #        #     #  #                 *</i></font>
<font color="#818181"><i>*              #      #   #     #  #        #     #  #     #           *</i></font>
<font color="#818181"><i>*              #     ###  #     #  #######   #####    #####            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TIMEGC                TIME GARBAGE COLLECT                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIMEGC.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TIMEGC&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:29 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "-s" "$0" "$@"
-INCLUDE 'TIMEGC.INC'
-LINE 58 "TIMEGC.lss"
         &CODE = 1
* DEFAULT MEMORY IS 8MB
         TIMEGC(3500)
         TIMEGC(25)
         &CODE = 0
END
<h1>TIME - Date/time functions</h1>

Date and time functions.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<TIME>>=
-MODULE TIME
-PUBLIC TIMEVAL(), TV_SEC(), TV_USEC()
         DATA('TIMEVAL(TV_SEC,TV_USEC)')
-PUBLIC TM(), TM_SEC(), TM_MIN(), TM_HOUR(), TM_MDAY(), TM_MON()
-PUBLIC TM_YEAR(), TM_WDAY(), TM_YDAY(), TM_ISDST(), TM_GMTOFF()
         DATA('TM(TM_SEC,TM_MIN,TM_HOUR,TM_MDAY,TM_MON,'
+                'TM_YEAR,TM_WDAY,TM_YDAY,TM_ISDST,TM_GMTOFF)')
*
         LOAD('GETTIMEOFDAY_(TIMEVAL)')
         LOAD('LOCALTIME_(INTEGER,TM)')
         LOAD('GMTIME_(INTEGER,TM)')
-PUBLIC STRFTIME()
         LOAD('STRFTIME(STRING,TM)STRING')
-PUBLIC MKTIME()
         LOAD('MKTIME(TM)INTEGER')
-PUBLIC SLEEP()
         LOAD('SLEEP(REAL)')
         LOAD('STRPTIME_(STRING,STRING,TM)')
*
-PUBLIC GETTIMEOFDAY()
         DEFINE('GETTIMEOFDAY()TIMEVAL')             :(GETTIMEOFDAY_END)
*
GETTIMEOFDAY
         GETTIMEOFDAY = TIMEVAL()
         GETTIMEOFDAY_(GETTIMEOFDAY)                :S(RETURN)F(FRETURN)
*
GETTIMEOFDAY_END
*
-PUBLIC LOCALTIME()
         DEFINE('LOCALTIME(T)TM')                       :(LOCALTIME_END)
*
LOCALTIME
         LOCALTIME = TM()
         LOCALTIME_(T, LOCALTIME)                   :S(RETURN)F(FRETURN)
*
LOCALTIME_END
*
-PUBLIC GMTIME()
         DEFINE('GMTIME(T)TM')                             :(GMTIME_END)
*
GMTIME   GMTIME = TM()
         GMTIME_(T, GMTIME)                         :S(RETURN)F(FRETURN)
*
GMTIME_END
*
-PUBLIC STRPTIME()
         DEFINE('STRPTIME(S,F)TM')                       :(STRPTIME_END)
*
STRPTIME STRPTIME = TM()
         STRPTIME_(S, F, STRPTIME)                  :S(RETURN)F(FRETURN)
*
STRPTIME_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIME.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL TIME
-EJECT
*
************************************************************************
*                                                                      *
*                    #######  ###  #     #  #######                    *
*                       #      #   ##   ##  #                          *
*                       #      #   # # # #  #                          *
*                       #      #   #  #  #  #####                      *
*                       #      #   #     #  #                          *
*                       #      #   #     #  #                          *
*                       #     ###  #     #  #######                    *
*                                                                      *
* TIME                    DATE/TIME FUNCTIONS                          *
*                                                                      *
* PHILE BUDNE <PHIL@ULTIMATE.COM>                                      *
* DECEMBER 15, 2010                                                    *
*                                                                      *
************************************************************************
*
* TIME.lss
*
<<TIME>>
*
* CE: .MSNOBOL4;
@
-STITL TIME
-EJECT
*
-LINE 78 "TIME.lss"
************************************************************************
*                                                                      *
*                    #######  ###  #     #  #######                    *
*                       #      #   ##   ##  #                          *
*                       #      #   # # # #  #                          *
*                       #      #   #  #  #  #####                      *
*                       #      #   #     #  #                          *
*                       #      #   #     #  #                          *
*                       #     ###  #     #  #######                    *
*                                                                      *
* TIME                    DATE/TIME FUNCTIONS                          *
*                                                                      *
* PHILE BUDNE <PHIL@ULTIMATE.COM>                                      *
* DECEMBER 15, 2010                                                    *
*                                                                      *
************************************************************************
*
* TIME.lss
*
-LINE 11 "TIME.lss"
-MODULE TIME
-PUBLIC TIMEVAL(), TV_SEC(), TV_USEC()
         DATA('TIMEVAL(TV_SEC,TV_USEC)')
-PUBLIC TM(), TM_SEC(), TM_MIN(), TM_HOUR(), TM_MDAY(), TM_MON()
-PUBLIC TM_YEAR(), TM_WDAY(), TM_YDAY(), TM_ISDST(), TM_GMTOFF()
         DATA('TM(TM_SEC,TM_MIN,TM_HOUR,TM_MDAY,TM_MON,'
+                'TM_YEAR,TM_WDAY,TM_YDAY,TM_ISDST,TM_GMTOFF)')
*
         LOAD('GETTIMEOFDAY_(TIMEVAL)')
         LOAD('LOCALTIME_(INTEGER,TM)')
         LOAD('GMTIME_(INTEGER,TM)')
-PUBLIC STRFTIME()
         LOAD('STRFTIME(STRING,TM)STRING')
-PUBLIC MKTIME()
         LOAD('MKTIME(TM)INTEGER')
-PUBLIC SLEEP()
         LOAD('SLEEP(REAL)')
         LOAD('STRPTIME_(STRING,STRING,TM)')
*
-PUBLIC GETTIMEOFDAY()
         DEFINE('GETTIMEOFDAY()TIMEVAL')             :(GETTIMEOFDAY_END)
*
GETTIMEOFDAY
         GETTIMEOFDAY = TIMEVAL()
         GETTIMEOFDAY_(GETTIMEOFDAY)                :S(RETURN)F(FRETURN)
*
GETTIMEOFDAY_END
*
-PUBLIC LOCALTIME()
         DEFINE('LOCALTIME(T)TM')                       :(LOCALTIME_END)
*
LOCALTIME
         LOCALTIME = TM()
         LOCALTIME_(T, LOCALTIME)                   :S(RETURN)F(FRETURN)
*
LOCALTIME_END
*
-PUBLIC GMTIME()
         DEFINE('GMTIME(T)TM')                             :(GMTIME_END)
*
GMTIME   GMTIME = TM()
         GMTIME_(T, GMTIME)                         :S(RETURN)F(FRETURN)
*
GMTIME_END
*
-PUBLIC STRPTIME()
         DEFINE('STRPTIME(S,F)TM')                       :(STRPTIME_END)
*
STRPTIME STRPTIME = TM()
         STRPTIME_(S, F, STRPTIME)                  :S(RETURN)F(FRETURN)
*
STRPTIME_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>TIME - Date/time functions</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Date and time functions.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TIME&raquo;&equiv;</b>
-MODULE TIME
-PUBLIC TIMEVAL(), TV_SEC(), TV_USEC()
         DATA(&#39;TIMEVAL(TV_SEC,TV_USEC)&#39;)
-PUBLIC TM(), TM_SEC(), TM_MIN(), TM_HOUR(), TM_MDAY(), TM_MON()
-PUBLIC TM_YEAR(), TM_WDAY(), TM_YDAY(), TM_ISDST(), TM_GMTOFF()
         DATA(&#39;TM(TM_SEC,TM_MIN,TM_HOUR,TM_MDAY,TM_MON,&#39;
+                &#39;TM_YEAR,TM_WDAY,TM_YDAY,TM_ISDST,TM_GMTOFF)&#39;)
<font color="#818181"><i>*</i></font>
         LOAD(&#39;GETTIMEOFDAY_(TIMEVAL)&#39;)
         LOAD(&#39;LOCALTIME_(INTEGER,TM)&#39;)
         LOAD(&#39;GMTIME_(INTEGER,TM)&#39;)
-PUBLIC STRFTIME()
         LOAD(&#39;STRFTIME(STRING,TM)STRING&#39;)
-PUBLIC MKTIME()
         LOAD(&#39;MKTIME(TM)INTEGER&#39;)
-PUBLIC SLEEP()
         LOAD(&#39;SLEEP(REAL)&#39;)
         LOAD(&#39;STRPTIME_(STRING,STRING,TM)&#39;)
<font color="#818181"><i>*</i></font>
-PUBLIC GETTIMEOFDAY()
         DEFINE(&#39;GETTIMEOFDAY()TIMEVAL&#39;)             <b>:(GETTIMEOFDAY_END)</b>
<font color="#818181"><i>*</i></font>
GETTIMEOFDAY
         GETTIMEOFDAY = TIMEVAL()
         GETTIMEOFDAY_(GETTIMEOFDAY)                <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
GETTIMEOFDAY_END
<font color="#818181"><i>*</i></font>
-PUBLIC LOCALTIME()
         DEFINE(&#39;LOCALTIME(T)TM&#39;)                       <b>:(LOCALTIME_END)</b>
<font color="#818181"><i>*</i></font>
LOCALTIME
         LOCALTIME = TM()
         LOCALTIME_(T, LOCALTIME)                   <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
LOCALTIME_END
<font color="#818181"><i>*</i></font>
-PUBLIC GMTIME()
         DEFINE(&#39;GMTIME(T)TM&#39;)                             <b>:(GMTIME_END)</b>
<font color="#818181"><i>*</i></font>
GMTIME   GMTIME = TM()
         GMTIME_(T, GMTIME)                         <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
GMTIME_END
<font color="#818181"><i>*</i></font>
-PUBLIC STRPTIME()
         DEFINE(&#39;STRPTIME(S,F)TM&#39;)                       <b>:(STRPTIME_END)</b>
<font color="#818181"><i>*</i></font>
STRPTIME STRPTIME = TM()
         STRPTIME_(S, F, STRPTIME)                  <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
STRPTIME_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TIME.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL TIME
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                    #######  ###  #     #  #######                    *</i></font>
<font color="#818181"><i>*                       #      #   ##   ##  #                          *</i></font>
<font color="#818181"><i>*                       #      #   # # # #  #                          *</i></font>
<font color="#818181"><i>*                       #      #   #  #  #  #####                      *</i></font>
<font color="#818181"><i>*                       #      #   #     #  #                          *</i></font>
<font color="#818181"><i>*                       #      #   #     #  #                          *</i></font>
<font color="#818181"><i>*                       #     ###  #     #  #######                    *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TIME                    DATE/TIME FUNCTIONS                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHILE BUDNE &lt;PHIL@ULTIMATE.COM&gt;                                      *</i></font>
<font color="#818181"><i>* DECEMBER 15, 2010                                                    *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIME.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TIME&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:29 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIME.INC'
-LINE 69 "TIME.lss"
         &CODE = 1
         &CODE = 0
END
<h1>TIMER - Time statements</h1>

[[TIMER(S)]] will time a statement (or statements) passed to it as
argument. Example: [[TIMER(' A = B + C ')]]. Multiple statements
should be separated by semicolons.

<h2>Uses</h2>
<a href="RESOL.html">RESOL</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>

<<INCLUDES>>=
-INCLUDE 'RESOL.INC'
-INCLUDE 'SYSTEM.INC'
@

<<TIMER>>=
-MODULE TIMER
-PUBLIC TIMER()
         DEFINE('TIMER(S_,N_)C_,T_,I_,M_')                  :(TIMER_END)
*
TIMER    EQ(N_, 0)                                           :F(TIMER_N)
         N_ = 10
TIMER_1  T_ = TIMER(' ;' S_, N_) - TIMER(, N_)               :F(FRETURN)
* WAS 20 * RESOLUTION. NOW THAT RESOLUTION IS ON THE ORDER OF 4
* MICROSECONDS, WE LOOK FOR 2000 * RESOLUTION (8 MILLISECONDS).
*
* FOR SPITBOL.EXE, RESOLUTION IS 1MS, CSNOBOL4, 4 MICROSECONDS FOR
* ATOM, 1.5 MICROSECONDS FOR INTEL I3
*
         M_ = RESOLUTION()
         M_ = ((LT(M_, 0.9) 2000), 20)
         N_ = LT(T_, M_ * RESOLUTION()) N_ * 2               :S(TIMER_1)
         T_ = CONVERT(T_, 'REAL')
         OUTPUT =
         OUTPUT = 'THE STATEMENT'
         OUTPUT = S_
* CALCULATE THE TIME, AND SCALE TO MICROSECONDS, MILLISECONDS OR
* SECONDS.
         T_ = T_ / N_
         C_ = ' MILLISECONDS'
         (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
         C_ = GE(T_, 1000.0) ' SECONDS'
         T_ = GE(T_, 1000.0) T_ / 1000.0                     :S(TIMER_2)
         T_ = T_ * 1000.0
         C_ = ' MICROSECONDS'
         (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
         T_ = T_ * 1000.0
         C_ = ' NANOSECONDS'
TIMER_2  OUTPUT = 'REQUIRED ' T_ C_ ' +/- 10%'
+           ' TO EXECUTE IN '  SYSTEM()                        :(RETURN)
*
TIMER_N  I_ = 1
         C_ = '          COLLECT()                             ;'
+             '          TIMER = TIME()                        ;'
+             'TIMER_4   EQ(TIMER, TIME())          :S(TIMER_4);'
+             '          TIMER = TIME()                        ;'
+             'TIMER_3 ' S_                                   ';'
+             '          I_ = I_ + 1 LT(I_, ' N_ ') :S(TIMER_3);'
+             '          TIMER = TIME() - TIMER       :(RETURN)'
         C_ = CODE(C_)                                  :S<C_>F(FRETURN)
*
TIMER_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIMER.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL TIMER
-EJECT
*
************************************************************************
*                                                                      *
*                 #######  ###  #     #  #######  ######               *
*                    #      #   ##   ##  #        #     #              *
*                    #      #   # # # #  #        #     #              *
*                    #      #   #  #  #  #####    ######               *
*                    #      #   #     #  #        #   #                *
*                    #      #   #     #  #        #    #               *
*                    #     ###  #     #  #######  #     #              *
*                                                                      *
* TIMER                       TIME STATEMENTS                          *
*                                                                      *
************************************************************************
*
* TIMER.lss
*
<<TIMER>>
*
* CE: .MSNOBOL4;
@
-LINE 12 "TIMER.lss"
-INCLUDE 'RESOL.INC'
-INCLUDE 'SYSTEM.INC'
-STITL TIMER
-EJECT
-LINE 78 "TIMER.lss"
*
************************************************************************
*                                                                      *
*                 #######  ###  #     #  #######  ######               *
*                    #      #   ##   ##  #        #     #              *
*                    #      #   # # # #  #        #     #              *
*                    #      #   #  #  #  #####    ######               *
*                    #      #   #     #  #        #   #                *
*                    #      #   #     #  #        #    #               *
*                    #     ###  #     #  #######  #     #              *
*                                                                      *
* TIMER                       TIME STATEMENTS                          *
*                                                                      *
************************************************************************
*
* TIMER.lss
*
-LINE 17 "TIMER.lss"
-MODULE TIMER
-PUBLIC TIMER()
         DEFINE('TIMER(S_,N_)C_,T_,I_,M_')                  :(TIMER_END)
*
TIMER    EQ(N_, 0)                                           :F(TIMER_N)
         N_ = 10
TIMER_1  T_ = TIMER(' ;' S_, N_) - TIMER(, N_)               :F(FRETURN)
* WAS 20 * RESOLUTION. NOW THAT RESOLUTION IS ON THE ORDER OF 4
* MICROSECONDS, WE LOOK FOR 2000 * RESOLUTION (8 MILLISECONDS).
*
* FOR SPITBOL.EXE, RESOLUTION IS 1MS, CSNOBOL4, 4 MICROSECONDS FOR
* ATOM, 1.5 MICROSECONDS FOR INTEL I3
*
         M_ = RESOLUTION()
         M_ = ((LT(M_, 0.9) 2000), 20)
         N_ = LT(T_, M_ * RESOLUTION()) N_ * 2               :S(TIMER_1)
         T_ = CONVERT(T_, 'REAL')
         OUTPUT =
         OUTPUT = 'THE STATEMENT'
         OUTPUT = S_
* CALCULATE THE TIME, AND SCALE TO MICROSECONDS, MILLISECONDS OR
* SECONDS.
         T_ = T_ / N_
         C_ = ' MILLISECONDS'
         (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
         C_ = GE(T_, 1000.0) ' SECONDS'
         T_ = GE(T_, 1000.0) T_ / 1000.0                     :S(TIMER_2)
         T_ = T_ * 1000.0
         C_ = ' MICROSECONDS'
         (GE(T_, 1.0) LT(T_, 1000.0))                        :S(TIMER_2)
         T_ = T_ * 1000.0
         C_ = ' NANOSECONDS'
TIMER_2  OUTPUT = 'REQUIRED ' T_ C_ ' +/- 10%'
+           ' TO EXECUTE IN '  SYSTEM()                        :(RETURN)
*
TIMER_N  I_ = 1
         C_ = '          COLLECT()                             ;'
+             '          TIMER = TIME()                        ;'
+             'TIMER_4   EQ(TIMER, TIME())          :S(TIMER_4);'
+             '          TIMER = TIME()                        ;'
+             'TIMER_3 ' S_                                   ';'
+             '          I_ = I_ + 1 LT(I_, ' N_ ') :S(TIMER_3);'
+             '          TIMER = TIME() - TIMER       :(RETURN)'
         C_ = CODE(C_)                                  :S<C_>F(FRETURN)
*
TIMER_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>TIMER - Time statements</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TIMER(S)</font> will time a statement (or statements) passed to it as
argument. Example: <font face="Source Code Pro">TIMER(' A = B + C ')</font>. Multiple statements
should be separated by semicolons.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="RESOL.html">RESOL</a><br>
<a href="SYSTEM.html">SYSTEM</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;RESOL.INC&#39;
-INCLUDE &#39;SYSTEM.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TIMER&raquo;&equiv;</b>
-MODULE TIMER
-PUBLIC TIMER()
         DEFINE(&#39;TIMER(S_,N_)C_,T_,I_,M_&#39;)                  <b>:(TIMER_END)</b>
<font color="#818181"><i>*</i></font>
TIMER    EQ(N_, 0)                                           <b>:F(TIMER_N)</b>
         N_ = 10
TIMER_1  T_ = TIMER(&#39; ;&#39; S_, N_) - TIMER(, N_)               <b>:F(FRETURN)</b>
<font color="#818181"><i>* WAS 20 * RESOLUTION. NOW THAT RESOLUTION IS ON THE ORDER OF 4</i></font>
<font color="#818181"><i>* MICROSECONDS, WE LOOK FOR 2000 * RESOLUTION (8 MILLISECONDS).</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FOR SPITBOL.EXE, RESOLUTION IS 1MS, CSNOBOL4, 4 MICROSECONDS FOR</i></font>
<font color="#818181"><i>* ATOM, 1.5 MICROSECONDS FOR INTEL I3</i></font>
<font color="#818181"><i>*</i></font>
         M_ = RESOLUTION()
         M_ = ((LT(M_, 0.9) 2000), 20)
         N_ = LT(T_, M_ * RESOLUTION()) N_ * 2               <b>:S(TIMER_1)</b>
         T_ = CONVERT(T_, &#39;REAL&#39;)
         OUTPUT =
         OUTPUT = &#39;THE STATEMENT&#39;
         OUTPUT = S_
<font color="#818181"><i>* CALCULATE THE TIME, AND SCALE TO MICROSECONDS, MILLISECONDS OR</i></font>
<font color="#818181"><i>* SECONDS.</i></font>
         T_ = T_ / N_
         C_ = &#39; MILLISECONDS&#39;
         (GE(T_, 1.0) LT(T_, 1000.0))                        <b>:S(TIMER_2)</b>
         C_ = GE(T_, 1000.0) &#39; SECONDS&#39;
         T_ = GE(T_, 1000.0) T_ / 1000.0                     <b>:S(TIMER_2)</b>
         T_ = T_ * 1000.0
         C_ = &#39; MICROSECONDS&#39;
         (GE(T_, 1.0) LT(T_, 1000.0))                        <b>:S(TIMER_2)</b>
         T_ = T_ * 1000.0
         C_ = &#39; NANOSECONDS&#39;
TIMER_2  OUTPUT = &#39;REQUIRED &#39; T_ C_ &#39; +/- 10%&#39;
+           &#39; TO EXECUTE IN &#39;  SYSTEM()                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
TIMER_N  I_ = 1
         C_ = &#39;          COLLECT()                             ;&#39;
+             &#39;          TIMER = TIME()                        ;&#39;
+             &#39;TIMER_4   EQ(TIMER, TIME())          :S(TIMER_4);&#39;
+             &#39;          TIMER = TIME()                        ;&#39;
+             &#39;TIMER_3 &#39; S_                                   &#39;;&#39;
+             &#39;          I_ = I_ + 1 LT(I_, &#39; N_ &#39;) :S(TIMER_3);&#39;
+             &#39;          TIMER = TIME() - TIMER       :(RETURN)&#39;
         C_ = CODE(C_)                                  <b>:S&lt;C_&gt;F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
TIMER_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TIMER.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL TIMER
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                 #######  ###  #     #  #######  ######               *</i></font>
<font color="#818181"><i>*                    #      #   ##   ##  #        #     #              *</i></font>
<font color="#818181"><i>*                    #      #   # # # #  #        #     #              *</i></font>
<font color="#818181"><i>*                    #      #   #  #  #  #####    ######               *</i></font>
<font color="#818181"><i>*                    #      #   #     #  #        #   #                *</i></font>
<font color="#818181"><i>*                    #      #   #     #  #        #    #               *</i></font>
<font color="#818181"><i>*                    #     ###  #     #  #######  #     #              *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TIMER                       TIME STATEMENTS                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TIMER.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TIMER&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:30 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIMER.INC'
-LINE 69 "TIMER.lss"
         &CODE = 1
         &CODE = 0
END
<h1>TPROFILE - Time profile</h1>

[[TPROFILE()]] will produce a time profile of the time spent in each
SNOBOL4 statement.

<h2>Uses</h2>
<a href="LPROG.html">LPROG</a><br>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>=
-INCLUDE 'LPROG.INC'
-INCLUDE 'SEQ.INC'
@

<<TPROFILE>>=
-MODULE TPROFILE
-PUBLIC TPROFILE(), TPROFILE_DUMP()
         DEFINE('TPROFILE()S,T')
         DEFINE('TPROFILE_DUMP()I')
         TP_ARY = ARRAY(LPROG())
         &STLIMIT = 999999999
         &TRACE = 999999999
         TRACE('STCOUNT', 'KEYWORD',, 'TPROFILE')        :(TPROFILE_END)
*
TPROFILE S = &LASTNO
         T = TIME()
         TP_ARY<LAST_STNO> = TP_ARY<LAST_STNO> + T - LAST_TIME
         LAST_STNO = S
         LAST_TIME = TIME()                                    :(RETURN)
*
TPROFILE_DUMP
         &STLIMIT = -1
         STOPTR('STCOUNT', 'KEYWORD')
         TERMINAL = 'TIME PROFILE'
         TERMINAL =
         SEQ(' TERMINAL = LPAD(I, 5) ": " TP_ARY<I> ', .I)
                                                               :(RETURN)
*
TPROFILE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TPROFILE.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL TPROFILE
-EJECT
*
************************************************************************
*                                                                      *
*  #######  ######   ######   #######  #######  ###  #        #######  *
*     #     #     #  #     #  #     #  #         #   #        #        *
*     #     #     #  #     #  #     #  #         #   #        #        *
*     #     ######   ######   #     #  #####     #   #        #####    *
*     #     #        #   #    #     #  #         #   #        #        *
*     #     #        #    #   #     #  #         #   #        #        *
*     #     #        #     #  #######  #        ###  #######  #######  *
*                                                                      *
* TPROFILE                 TIME PROFILE                                *
*                                                                      *
************************************************************************
*
* TPROFILE.lss
*
<<TPROFILE>>
*
* CE: .MSNOBOL4;
@
-LINE 11 "TPROFILE.lss"
-INCLUDE 'LPROG.INC'
-INCLUDE 'SEQ.INC'
-STITL TPROFILE
-EJECT
-LINE 55 "TPROFILE.lss"
*
************************************************************************
*                                                                      *
*  #######  ######   ######   #######  #######  ###  #        #######  *
*     #     #     #  #     #  #     #  #         #   #        #        *
*     #     #     #  #     #  #     #  #         #   #        #        *
*     #     ######   ######   #     #  #####     #   #        #####    *
*     #     #        #   #    #     #  #         #   #        #        *
*     #     #        #    #   #     #  #         #   #        #        *
*     #     #        #     #  #######  #        ###  #######  #######  *
*                                                                      *
* TPROFILE                 TIME PROFILE                                *
*                                                                      *
************************************************************************
*
* TPROFILE.lss
*
-LINE 16 "TPROFILE.lss"
-MODULE TPROFILE
-PUBLIC TPROFILE(), TPROFILE_DUMP()
         DEFINE('TPROFILE()S,T')
         DEFINE('TPROFILE_DUMP()I')
         TP_ARY = ARRAY(LPROG())
         &STLIMIT = 999999999
         &TRACE = 999999999
         TRACE('STCOUNT', 'KEYWORD',, 'TPROFILE')        :(TPROFILE_END)
*
TPROFILE S = &LASTNO
         T = TIME()
         TP_ARY<LAST_STNO> = TP_ARY<LAST_STNO> + T - LAST_TIME
         LAST_STNO = S
         LAST_TIME = TIME()                                    :(RETURN)
*
TPROFILE_DUMP
         &STLIMIT = -1
         STOPTR('STCOUNT', 'KEYWORD')
         TERMINAL = 'TIME PROFILE'
         TERMINAL =
         SEQ(' TERMINAL = LPAD(I, 5) ": " TP_ARY<I> ', .I)
                                                               :(RETURN)
*
TPROFILE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>TPROFILE - Time profile</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TPROFILE()</font> will produce a time profile of the time spent in each
SNOBOL4 statement.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="LPROG.html">LPROG</a><br>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;LPROG.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TPROFILE&raquo;&equiv;</b>
-MODULE TPROFILE
-PUBLIC TPROFILE(), TPROFILE_DUMP()
         DEFINE(&#39;TPROFILE()S,T&#39;)
         DEFINE(&#39;TPROFILE_DUMP()I&#39;)
         TP_ARY = ARRAY(LPROG())
         &amp;STLIMIT = 999999999
         &amp;TRACE = 999999999
         TRACE(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;,, &#39;TPROFILE&#39;)        <b>:(TPROFILE_END)</b>
<font color="#818181"><i>*</i></font>
TPROFILE S = &amp;LASTNO
         T = TIME()
         TP_ARY&lt;LAST_STNO&gt; = TP_ARY&lt;LAST_STNO&gt; + T - LAST_TIME
         LAST_STNO = S
         LAST_TIME = TIME()                                    <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
TPROFILE_DUMP
         &amp;STLIMIT = -1
         STOPTR(&#39;STCOUNT&#39;, &#39;KEYWORD&#39;)
         TERMINAL = &#39;TIME PROFILE&#39;
         TERMINAL =
         SEQ(&#39; TERMINAL = LPAD(I, 5) &quot;: &quot; TP_ARY&lt;I&gt; &#39;, .I)
                                                               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
TPROFILE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TPROFILE.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL TPROFILE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*  #######  ######   ######   #######  #######  ###  #        #######  *</i></font>
<font color="#818181"><i>*     #     #     #  #     #  #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*     #     #     #  #     #  #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*     #     ######   ######   #     #  #####     #   #        #####    *</i></font>
<font color="#818181"><i>*     #     #        #   #    #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*     #     #        #    #   #     #  #         #   #        #        *</i></font>
<font color="#818181"><i>*     #     #        #     #  #######  #        ###  #######  #######  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TPROFILE                 TIME PROFILE                                *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TPROFILE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TPROFILE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:30 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TPROFILE.INC'
-LINE 46 "TPROFILE.lss"
         &CODE = 1
         &CODE = 0
END
<h1>TRIMB - Trim both left and right of string</h1>

[[TRIMB(S)]] applies [[TRIMB()]] to both the left and right of [[S]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<TRIMB>>=
-MODULE TRIMB
-PUBLIC TRIMB()
         DEFINE('TRIMB(S)')                                 :(TRIMB_END)
*
TRIMB    TRIMB = REVERSE(TRIM(REVERSE(TRIM(S))))               :(RETURN)
*
TRIMB_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TRIMB.INC'
         &CODE = 1
         IDENT(TRIMB(' ABC '), 'ABC')                            :F(END)
         &CODE = 0
*
END
@

<<>>=
-STITL TRIMB
-EJECT
*
************************************************************************
*                                                                      *
*               #######  ######   ###  #     #  ######                 *
*                  #     #     #   #   ##   ##  #     #                *
*                  #     #     #   #   # # # #  #     #                *
*                  #     ######    #   #  #  #  ######                 *
*                  #     #   #     #   #     #  #     #                *
*                  #     #    #    #   #     #  #     #                *
*                  #     #     #  ###  #     #  ######                 *
*                                                                      *
* TRIMB            TRIM BOTH LEFT AND RIGHT OF STRING                  *
*                                                                      *
************************************************************************
*
* TRIMB.lss
*
<<TRIMB>>
*
* CE: .MSNOBOL4;
@
-STITL TRIMB
-EJECT
*
-LINE 35 "TRIMB.lss"
************************************************************************
*                                                                      *
*               #######  ######   ###  #     #  ######                 *
*                  #     #     #   #   ##   ##  #     #                *
*                  #     #     #   #   # # # #  #     #                *
*                  #     ######    #   #  #  #  ######                 *
*                  #     #   #     #   #     #  #     #                *
*                  #     #    #    #   #     #  #     #                *
*                  #     #     #  ###  #     #  ######                 *
*                                                                      *
* TRIMB            TRIM BOTH LEFT AND RIGHT OF STRING                  *
*                                                                      *
************************************************************************
*
* TRIMB.lss
*
-LINE 11 "TRIMB.lss"
-MODULE TRIMB
-PUBLIC TRIMB()
         DEFINE('TRIMB(S)')                                 :(TRIMB_END)
*
TRIMB    TRIMB = REVERSE(TRIM(REVERSE(TRIM(S))))               :(RETURN)
*
TRIMB_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>TRIMB - Trim both left and right of string</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TRIMB(S)</font> applies <font face="Source Code Pro">TRIMB()</font> to both the left and right of <font face="Source Code Pro">S</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TRIMB&raquo;&equiv;</b>
-MODULE TRIMB
-PUBLIC TRIMB()
         DEFINE(&#39;TRIMB(S)&#39;)                                 <b>:(TRIMB_END)</b>
<font color="#818181"><i>*</i></font>
TRIMB    TRIMB = REVERSE(TRIM(REVERSE(TRIM(S))))               <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
TRIMB_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TRIMB.INC&#39;
         &amp;CODE = 1
         IDENT(TRIMB(&#39; ABC &#39;), &#39;ABC&#39;)                            <b>:F(END)</b>
         &amp;CODE = 0
<font color="#818181"><i>*</i></font>
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL TRIMB
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*               #######  ######   ###  #     #  ######                 *</i></font>
<font color="#818181"><i>*                  #     #     #   #   ##   ##  #     #                *</i></font>
<font color="#818181"><i>*                  #     #     #   #   # # # #  #     #                *</i></font>
<font color="#818181"><i>*                  #     ######    #   #  #  #  ######                 *</i></font>
<font color="#818181"><i>*                  #     #   #     #   #     #  #     #                *</i></font>
<font color="#818181"><i>*                  #     #    #    #   #     #  #     #                *</i></font>
<font color="#818181"><i>*                  #     #     #  ###  #     #  ######                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TRIMB            TRIM BOTH LEFT AND RIGHT OF STRING                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TRIMB.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TRIMB&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:35 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TRIMB.INC'
-LINE 24 "TRIMB.lss"
         &CODE = 1
         IDENT(TRIMB(' ABC '), 'ABC')                            :F(END)
         &CODE = 0
*
END
<H1>TRUNC - Truncate array</H1>

[[TRUNC(A,L,H)]] will return the truncation of the singly-dimensioned
array [[A]]. That is, a new array will be created and returned
consisting of the elements
[[A<sub>L</sub>, A<sub>L+1</sub>, ..., A<sub>H</sub>]].

<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>

<<INCLUDES>>=
-INCLUDE 'SEQ.INC'
@

<<TRUNC>>=
-MODULE TRUNC
-PUBLIC TRUNC()
         DEFINE('TRUNC(A,L,H)')                             :(TRUNC_END)
*
TRUNC    TRUNC = ARRAY(H - L + 1)
         L = L - 1
         SEQ(' TRUNC<I> = A<L + I> ',.I)                       :(RETURN)
*
TRUNC_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TRUNC.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL TRUNC
-EJECT
*
************************************************************************
*                                                                      *
*             #######  ######   #     #  #     #   #####               *
*                #     #     #  #     #  ##    #  #     #              *
*                #     #     #  #     #  # #   #  #                    *
*                #     ######   #     #  #  #  #  #                    *
*                #     #   #    #     #  #   # #  #                    *
*                #     #    #   #     #  #    ##  #     #              *
*                #     #     #   #####   #     #   #####               *
*                                                                      *
* TRUNC                     TRUNCATE ARRAY                             *
*                                                                      *
************************************************************************
*
* TRUNC.lss
*
<<TRUNC>>
*
* CE: .MSNOBOL4;
@
-LINE 12 "TRUNC.lss"
-INCLUDE 'SEQ.INC'
-STITL TRUNC
-EJECT
-LINE 40 "TRUNC.lss"
*
************************************************************************
*                                                                      *
*             #######  ######   #     #  #     #   #####               *
*                #     #     #  #     #  ##    #  #     #              *
*                #     #     #  #     #  # #   #  #                    *
*                #     ######   #     #  #  #  #  #                    *
*                #     #   #    #     #  #   # #  #                    *
*                #     #    #   #     #  #    ##  #     #              *
*                #     #     #   #####   #     #   #####               *
*                                                                      *
* TRUNC                     TRUNCATE ARRAY                             *
*                                                                      *
************************************************************************
*
* TRUNC.lss
*
-LINE 16 "TRUNC.lss"
-MODULE TRUNC
-PUBLIC TRUNC()
         DEFINE('TRUNC(A,L,H)')                             :(TRUNC_END)
*
TRUNC    TRUNC = ARRAY(H - L + 1)
         L = L - 1
         SEQ(' TRUNC<I> = A<L + I> ',.I)                       :(RETURN)
*
TRUNC_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<H1>TRUNC - Truncate array</H1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">TRUNC(A,L,H)</font> will return the truncation of the singly-dimensioned
array <font face="Source Code Pro">A</font>. That is, a new array will be created and returned
consisting of the elements
<font face="Source Code Pro">A<sub>L</sub>, A<sub>L+1</sub>, ..., A<sub>H</sub></font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SEQ.html">SEQ</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SEQ.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;TRUNC&raquo;&equiv;</b>
-MODULE TRUNC
-PUBLIC TRUNC()
         DEFINE(&#39;TRUNC(A,L,H)&#39;)                             <b>:(TRUNC_END)</b>
<font color="#818181"><i>*</i></font>
TRUNC    TRUNC = ARRAY(H - L + 1)
         L = L - 1
         SEQ(&#39; TRUNC&lt;I&gt; = A&lt;L + I&gt; &#39;,.I)                       <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
TRUNC_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;TRUNC.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL TRUNC
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*             #######  ######   #     #  #     #   #####               *</i></font>
<font color="#818181"><i>*                #     #     #  #     #  ##    #  #     #              *</i></font>
<font color="#818181"><i>*                #     #     #  #     #  # #   #  #                    *</i></font>
<font color="#818181"><i>*                #     ######   #     #  #  #  #  #                    *</i></font>
<font color="#818181"><i>*                #     #   #    #     #  #   # #  #                    *</i></font>
<font color="#818181"><i>*                #     #    #   #     #  #    ##  #     #              *</i></font>
<font color="#818181"><i>*                #     #     #   #####   #     #   #####               *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* TRUNC                     TRUNCATE ARRAY                             *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TRUNC.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;TRUNC&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:31 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TRUNC.INC'
-LINE 31 "TRUNC.lss"
         &CODE = 1
         &CODE = 0
END
<h1>uban</h1>

Produces banners with line drawing characters in UTF-8. 13 of these fit
into 80 print columns (although each column is 3 characters). Allowed
characters are A..Z, 0..9, space and dash. Each character is formed
on a 6X6 grid. Each of the characters used is actually a 3 byte UTF-8
code.

<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="TRIMB.html">TRIMB</a><br>

<<INCLUDES>>=
-INCLUDE 'CRACK.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'TRIMB.INC'
@

<<UBAN>>=
         TERMINAL = 'UBAN (SAT NOV 23 23:02:17 EST 2013)'
*
         A1 =    '/   ///  //    /'
         A2 =    '/   ///  //    /'
         A3 =    '  /    //////'
         A4 =    '  /    //////'
         A5 =    '/  ///    ///'
         A6 =    '/  ///    ///'
         A1 = A1 '///'
         A2 = A2 '///'
         A3 = A3 '    ///'
         A4 = A4 '    ///'
         A5 = A5 '    //    /'
         A6 = A6 '    //    /'
         A1 = A1 '///////'
         A2 = A2 '/// ////'
         A3 = A3 '  //    / ////'
         A4 = A4 '//    / ////'
         A5 = A5 '/// //    //'
         A6 = A6 '  /////    //'
         A1 = A1 '  /  /    /  /    /  /  /'
         A2 = A2 '  /  /    / /    // /'
         A3 = A3 '/    /    //    /  / /'
         A4 = A4 '/    /  //    ///'
         A5 = A5 '  /  // //  //'
         A6 = A6 '  /  //  //  /  /'
         A1 = A1 '/// ///  /'
         A2 = A2 '//////  /'
         A3 = A3 '  //  / //    /  /'
         A4 = A4 '  // ///    /  /'
         A5 = A5 '/    / ///    //'
         A6 = A6 '/    //  //    //'
         A1 = A1 '  /  /  /  //      /      /'
         A2 = A2 '/  /// /      /      /'
         A3 = A3 '////  /      //'
         A4 = A4 '  /  //  / /      //'
         A5 = A5 '  ///    /  /      /      /'
         A6 = A6 '  /  /  /    //      /      /'
*
         SEQ(" $('R' I) = CRACK($('A' I), '/')", .I, 1, 6)
*
         L = &DIGITS &UCASE ' -'
         BL = TABLE()
         I = 1
LDLUP    L LEN(1) . C REM . L                                :F(PROCESS)
         X = R1<I> '/' R2<I> '/' R3<I> '/' R4<I> '/' R5<I> '/' R6<I>
         BL<C> = X
         I = I + 1                                              :(LDLUP)
*
PROCESS  S = INPUT                                               :F(END)
         S = TRIMB(REPLACE(S, &LCASE, &UCASE))
         O = ARRAY(6)
LOOP     S LEN(1) . C REM . S                                    :F(OUT)
         X = CRACK(BL<C>, '/')
         SEQ(' O<I> = O<I> X<I>', .I)                            :(LOOP)
*
OUT      SEQ(' OUTPUT = O<I>', .I)                            :(PROCESS)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM UBAN
-TITLE UBAN
START
<<INCLUDES>>
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                  #     #  ######      #     #     #                  *
*                  #     #  #     #    # #    ##    #                  *
*                  #     #  #     #   #   #   # #   #                  *
*                  #     #  ######   #     #  #  #  #                  *
*                  #     #  #     #  #######  #   # #                  *
*                  #     #  #     #  #     #  #    ##                  *
*                   #####   ######   #     #  #     #                  *
*                                                                      *
* UBAN              UTF-8 LINE DRAW CHARACTER BANNER                   *
*                                                                      *
************************************************************************
*
* uban.lss
*
<<UBAN>>
*
* CE: .F.MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM UBAN
-LINE 86 "uban.lss"
-TITLE UBAN
START
-LINE 15 "uban.lss"
-INCLUDE 'CRACK.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'TRIMB.INC'
-STITL
-EJECT
*
************************************************************************
*                                                                      *
*                  #     #  ######      #     #     #                  *
*                  #     #  #     #    # #    ##    #                  *
*                  #     #  #     #   #   #   # #   #                  *
*                  #     #  ######   #     #  #  #  #                  *
*                  #     #  #     #  #######  #   # #                  *
*                  #     #  #     #  #     #  #    ##                  *
*                   #####   ######   #     #  #     #                  *
*                                                                      *
* UBAN              UTF-8 LINE DRAW CHARACTER BANNER                   *
*                                                                      *
************************************************************************
*
* uban.lss
*
-LINE 21 "uban.lss"
         TERMINAL = 'UBAN (SAT NOV 23 23:02:17 EST 2013)'
*
         A1 =    '/   ///  //    /'
         A2 =    '/   ///  //    /'
         A3 =    '  /    //////'
         A4 =    '  /    //////'
         A5 =    '/  ///    ///'
         A6 =    '/  ///    ///'
         A1 = A1 '///'
         A2 = A2 '///'
         A3 = A3 '    ///'
         A4 = A4 '    ///'
         A5 = A5 '    //    /'
         A6 = A6 '    //    /'
         A1 = A1 '///////'
         A2 = A2 '/// ////'
         A3 = A3 '  //    / ////'
         A4 = A4 '//    / ////'
         A5 = A5 '/// //    //'
         A6 = A6 '  /////    //'
         A1 = A1 '  /  /    /  /    /  /  /'
         A2 = A2 '  /  /    / /    // /'
         A3 = A3 '/    /    //    /  / /'
         A4 = A4 '/    /  //    ///'
         A5 = A5 '  /  // //  //'
         A6 = A6 '  /  //  //  /  /'
         A1 = A1 '/// ///  /'
         A2 = A2 '//////  /'
         A3 = A3 '  //  / //    /  /'
         A4 = A4 '  // ///    /  /'
         A5 = A5 '/    / ///    //'
         A6 = A6 '/    //  //    //'
         A1 = A1 '  /  /  /  //      /      /'
         A2 = A2 '/  /// /      /      /'
         A3 = A3 '////  /      //'
         A4 = A4 '  /  //  / /      //'
         A5 = A5 '  ///    /  /      /      /'
         A6 = A6 '  /  /  /    //      /      /'
*
         SEQ(" $('R' I) = CRACK($('A' I), '/')", .I, 1, 6)
*
         L = &DIGITS &UCASE ' -'
         BL = TABLE()
         I = 1
LDLUP    L LEN(1) . C REM . L                                :F(PROCESS)
         X = R1<I> '/' R2<I> '/' R3<I> '/' R4<I> '/' R5<I> '/' R6<I>
         BL<C> = X
         I = I + 1                                              :(LDLUP)
*
PROCESS  S = INPUT                                               :F(END)
         S = TRIMB(REPLACE(S, &LCASE, &UCASE))
         O = ARRAY(6)
LOOP     S LEN(1) . C REM . S                                    :F(OUT)
         X = CRACK(BL<C>, '/')
         SEQ(' O<I> = O<I> X<I>', .I)                            :(LOOP)
*
OUT      SEQ(' OUTPUT = O<I>', .I)                            :(PROCESS)
*
END START
*
* CE: .F.MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>uban</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Produces banners with line drawing characters in UTF-8. 13 of these fit
into 80 print columns (although each column is 3 characters). Allowed
characters are A..Z, 0..9, space and dash. Each character is formed
on a 6X6 grid. Each of the characters used is actually a 3 byte UTF-8
code.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="CRACK.html">CRACK</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="TRIMB.html">TRIMB</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;CRACK.INC&#39;
-INCLUDE &#39;SEQ.INC&#39;
-INCLUDE &#39;TRIMB.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;UBAN&raquo;&equiv;</b>
         TERMINAL = &#39;UBAN (SAT NOV 23 23:02:17 EST 2013)&#39;
<font color="#818181"><i>*</i></font>
         A1 =    &#39;/   ///  //    /&#39;
         A2 =    &#39;/   ///  //    /&#39;
         A3 =    &#39;  /    //////&#39;
         A4 =    &#39;  /    //////&#39;
         A5 =    &#39;/  ///    ///&#39;
         A6 =    &#39;/  ///    ///&#39;
         A1 = A1 &#39;///&#39;
         A2 = A2 &#39;///&#39;
         A3 = A3 &#39;    ///&#39;
         A4 = A4 &#39;    ///&#39;
         A5 = A5 &#39;    //    /&#39;
         A6 = A6 &#39;    //    /&#39;
         A1 = A1 &#39;///////&#39;
         A2 = A2 &#39;/// ////&#39;
         A3 = A3 &#39;  //    / ////&#39;
         A4 = A4 &#39;//    / ////&#39;
         A5 = A5 &#39;/// //    //&#39;
         A6 = A6 &#39;  /////    //&#39;
         A1 = A1 &#39;  /  /    /  /    /  /  /&#39;
         A2 = A2 &#39;  /  /    / /    // /&#39;
         A3 = A3 &#39;/    /    //    /  / /&#39;
         A4 = A4 &#39;/    /  //    ///&#39;
         A5 = A5 &#39;  /  // //  //&#39;
         A6 = A6 &#39;  /  //  //  /  /&#39;
         A1 = A1 &#39;/// ///  /&#39;
         A2 = A2 &#39;//////  /&#39;
         A3 = A3 &#39;  //  / //    /  /&#39;
         A4 = A4 &#39;  // ///    /  /&#39;
         A5 = A5 &#39;/    / ///    //&#39;
         A6 = A6 &#39;/    //  //    //&#39;
         A1 = A1 &#39;  /  /  /  //      /      /&#39;
         A2 = A2 &#39;/  /// /      /      /&#39;
         A3 = A3 &#39;////  /      //&#39;
         A4 = A4 &#39;  /  //  / /      //&#39;
         A5 = A5 &#39;  ///    /  /      /      /&#39;
         A6 = A6 &#39;  /  /  /    //      /      /&#39;
<font color="#818181"><i>*</i></font>
         SEQ(&quot; $(&#39;R&#39; I) = CRACK($(&#39;A&#39; I), &#39;/&#39;)&quot;, .I, 1, 6)
<font color="#818181"><i>*</i></font>
         L = &amp;DIGITS &amp;UCASE &#39; -&#39;
         BL = TABLE()
         I = 1
LDLUP    L LEN(1) . C REM . L                                <b>:F(PROCESS)</b>
         X = R1&lt;I&gt; &#39;/&#39; R2&lt;I&gt; &#39;/&#39; R3&lt;I&gt; &#39;/&#39; R4&lt;I&gt; &#39;/&#39; R5&lt;I&gt; &#39;/&#39; R6&lt;I&gt;
         BL&lt;C&gt; = X
         I = I + 1                                              <b>:(LDLUP)</b>
<font color="#818181"><i>*</i></font>
PROCESS  S = INPUT                                               <b>:F(END)</b>
         S = TRIMB(REPLACE(S, &amp;LCASE, &amp;UCASE))
         O = ARRAY(6)
LOOP     S LEN(1) . C REM . S                                    <b>:F(OUT)</b>
         X = CRACK(BL&lt;C&gt;, &#39;/&#39;)
         SEQ(&#39; O&lt;I&gt; = O&lt;I&gt; X&lt;I&gt;&#39;, .I)                            <b>:(LOOP)</b>
<font color="#818181"><i>*</i></font>
OUT      SEQ(&#39; OUTPUT = O&lt;I&gt;&#39;, .I)                            <b>:(PROCESS)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM UBAN
-TITLE UBAN
START
<b>&laquo;INCLUDES&raquo;</b>
-STITL
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                  #     #  ######      #     #     #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #    # #    ##    #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #   #   #   # #   #                  *</i></font>
<font color="#818181"><i>*                  #     #  ######   #     #  #  #  #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #######  #   # #                  *</i></font>
<font color="#818181"><i>*                  #     #  #     #  #     #  #    ##                  *</i></font>
<font color="#818181"><i>*                   #####   ######   #     #  #     #                  *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* UBAN              UTF-8 LINE DRAW CHARACTER BANNER                   *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* uban.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;UBAN&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .F.MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:31 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>UNIQUE - Generate unique name</h1>

Returns a string that can be used as a unique variable name.

If [[UNIQUE()]] is called with a non-null argument, all unique
variables are cleared, and the global variable [[UNIQUE_]] is set to
[[0]].

Gimpel generates unique variable names with the keyword
[[&amp;STCOUNT]].  However, in some implementations [[&amp;STCOUNT]]
is not updated if the keyword [[&amp;STLIMIT]] is set to [[-1]].

This function uses a global variable [[UNIQUE_]].

[[MAKE_UNIQUE(SUF)]] creates a [[UNIQUESUF()]] function that uses
its own global variable. This is preferred to using [[UNIQUE()]] if
the generated variables are cleared. This minimizes impact to other
modules using [[UNIQUE()]].

<h2>Uses</h2>
<a href="REPL.html">REPL</a><br>

<<INCLUDES>>=
-INCLUDE 'REPL.INC'
@

<<UNIQUE>>=
-MODULE UNIQUE
-PUBLIC MAKE_UNIQUE(), UNIQUE()
         DEFINE('MAKE_UNIQUE(SUF)S')
         MAKE_UNIQUE()
         OPSYN('UNIQUE', 'UNIQUE_')                        :(UNIQUE_END)
*
MAKE_UNIQUE
         S =
+ 'UNIQUE_SUF  UNIQUE_SUF_ = IDENT(I) UNIQUE_SUF_ + 1  :F(UNIQUECSUF);'
+ '            UNIQUE_SUF = "USUF" UNIQUE_SUF_ "_"          :(RETURN);'
+ 'UNIQUECSUF $("USUF" UNIQUE_SUF_ "_") = '
+ '           ?(UNIQUE_SUF_ = GT(UNIQUE_SUF_,0) UNIQUE_SUF_ - 1)'
+ '                                           :S(UNIQUECSUF)F(RETURN);'
         CODE(REPL(S, 'SUF', SUF))
         DEFINE('UNIQUE_' SUF '(I)')                           :(RETURN)
*
UNIQUE_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'UNIQUE.INC'
         &CODE = 1
         U1 = UNIQUE()
         IDENT($U1)                                              :F(END)
         $U1 = 1
         U2 = UNIQUE()
         IDENT($U2)                                              :F(END)
         $U2 = 2
         NE($U1, $U2)                                            :F(END)
         U3 = 'U3_'
         $U3 = 3
         UNIQUE('CLEAR')
         IDENT($U1)                                              :F(END)
         IDENT($U2)                                              :F(END)
         EQ($U3, 3)                                              :F(END)
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL UNIQUE
-EJECT
*
************************************************************************
*                                                                      *
*           #     #  #     #  ###   #####   #     #  #######           *
*           #     #  ##    #   #   #     #  #     #  #                 *
*           #     #  # #   #   #   #     #  #     #  #                 *
*           #     #  #  #  #   #   #     #  #     #  #####             *
*           #     #  #   # #   #   #   # #  #     #  #                 *
*           #     #  #    ##   #   #    #   #     #  #                 *
*            #####   #     #  ###   #### #   #####   #######           *
*                                                                      *
* UNIQUE                 GENERATE UNIQUE NAME                          *
*                                                                      *
************************************************************************
*
* UNIQUE.lss
*
<<UNIQUE>>
*
* CE: .MSNOBOL4;
@
-LINE 24 "UNIQUE.lss"
-INCLUDE 'REPL.INC'
-STITL UNIQUE
-EJECT
-LINE 73 "UNIQUE.lss"
*
************************************************************************
*                                                                      *
*           #     #  #     #  ###   #####   #     #  #######           *
*           #     #  ##    #   #   #     #  #     #  #                 *
*           #     #  # #   #   #   #     #  #     #  #                 *
*           #     #  #  #  #   #   #     #  #     #  #####             *
*           #     #  #   # #   #   #   # #  #     #  #                 *
*           #     #  #    ##   #   #    #   #     #  #                 *
*            #####   #     #  ###   #### #   #####   #######           *
*                                                                      *
* UNIQUE                 GENERATE UNIQUE NAME                          *
*                                                                      *
************************************************************************
*
* UNIQUE.lss
*
-LINE 28 "UNIQUE.lss"
-MODULE UNIQUE
-PUBLIC MAKE_UNIQUE(), UNIQUE()
         DEFINE('MAKE_UNIQUE(SUF)S')
         MAKE_UNIQUE()
         OPSYN('UNIQUE', 'UNIQUE_')                        :(UNIQUE_END)
*
MAKE_UNIQUE
         S =
+ 'UNIQUE_SUF  UNIQUE_SUF_ = IDENT(I) UNIQUE_SUF_ + 1  :F(UNIQUECSUF);'
+ '            UNIQUE_SUF = "USUF" UNIQUE_SUF_ "_"          :(RETURN);'
+ 'UNIQUECSUF $("USUF" UNIQUE_SUF_ "_") = '
+ '           ?(UNIQUE_SUF_ = GT(UNIQUE_SUF_,0) UNIQUE_SUF_ - 1)'
+ '                                           :S(UNIQUECSUF)F(RETURN);'
         CODE(REPL(S, 'SUF', SUF))
         DEFINE('UNIQUE_' SUF '(I)')                           :(RETURN)
*
UNIQUE_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>UNIQUE - Generate unique name</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Returns a string that can be used as a unique variable name.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
If <font face="Source Code Pro">UNIQUE()</font> is called with a non-null argument, all unique
variables are cleared, and the global variable <font face="Source Code Pro">UNIQUE_</font> is set to
<font face="Source Code Pro">0</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Gimpel generates unique variable names with the keyword
<font face="Source Code Pro">&amp;STCOUNT</font>.  However, in some implementations <font face="Source Code Pro">&amp;STCOUNT</font>
is not updated if the keyword <font face="Source Code Pro">&amp;STLIMIT</font> is set to <font face="Source Code Pro">-1</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
This function uses a global variable <font face="Source Code Pro">UNIQUE_</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">MAKE_UNIQUE(SUF)</font> creates a <font face="Source Code Pro">UNIQUESUF()</font> function that uses
its own global variable. This is preferred to using <font face="Source Code Pro">UNIQUE()</font> if
the generated variables are cleared. This minimizes impact to other
modules using <font face="Source Code Pro">UNIQUE()</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="REPL.html">REPL</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;REPL.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;UNIQUE&raquo;&equiv;</b>
-MODULE UNIQUE
-PUBLIC MAKE_UNIQUE(), UNIQUE()
         DEFINE(&#39;MAKE_UNIQUE(SUF)S&#39;)
         MAKE_UNIQUE()
         OPSYN(&#39;UNIQUE&#39;, &#39;UNIQUE_&#39;)                        <b>:(UNIQUE_END)</b>
<font color="#818181"><i>*</i></font>
MAKE_UNIQUE
         S =
+ &#39;UNIQUE_SUF  UNIQUE_SUF_ = IDENT(I) UNIQUE_SUF_ + 1  :F(UNIQUECSUF);&#39;
+ &#39;            UNIQUE_SUF = &quot;USUF&quot; UNIQUE_SUF_ &quot;_&quot;          :(RETURN);&#39;
+ &#39;UNIQUECSUF $(&quot;USUF&quot; UNIQUE_SUF_ &quot;_&quot;) = &#39;
+ &#39;           ?(UNIQUE_SUF_ = GT(UNIQUE_SUF_,0) UNIQUE_SUF_ - 1)&#39;
+ &#39;                                           :S(UNIQUECSUF)F(RETURN);&#39;
         CODE(REPL(S, &#39;SUF&#39;, SUF))
         DEFINE(&#39;UNIQUE_&#39; SUF &#39;(I)&#39;)                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
UNIQUE_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;UNIQUE.INC&#39;
         &amp;CODE = 1
         U1 = UNIQUE()
         IDENT($U1)                                              <b>:F(END)</b>
         $U1 = 1
         U2 = UNIQUE()
         IDENT($U2)                                              <b>:F(END)</b>
         $U2 = 2
         NE($U1, $U2)                                            <b>:F(END)</b>
         U3 = &#39;U3_&#39;
         $U3 = 3
         UNIQUE(&#39;CLEAR&#39;)
         IDENT($U1)                                              <b>:F(END)</b>
         IDENT($U2)                                              <b>:F(END)</b>
         EQ($U3, 3)                                              <b>:F(END)</b>
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL UNIQUE
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*           #     #  #     #  ###   #####   #     #  #######           *</i></font>
<font color="#818181"><i>*           #     #  ##    #   #   #     #  #     #  #                 *</i></font>
<font color="#818181"><i>*           #     #  # #   #   #   #     #  #     #  #                 *</i></font>
<font color="#818181"><i>*           #     #  #  #  #   #   #     #  #     #  #####             *</i></font>
<font color="#818181"><i>*           #     #  #   # #   #   #   # #  #     #  #                 *</i></font>
<font color="#818181"><i>*           #     #  #    ##   #   #    #   #     #  #                 *</i></font>
<font color="#818181"><i>*            #####   #     #  ###   #### #   #####   #######           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* UNIQUE                 GENERATE UNIQUE NAME                          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UNIQUE.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;UNIQUE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:32 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'UNIQUE.INC'
-LINE 51 "UNIQUE.lss"
         &CODE = 1
         U1 = UNIQUE()
         IDENT($U1)                                              :F(END)
         $U1 = 1
         U2 = UNIQUE()
         IDENT($U2)                                              :F(END)
         $U2 = 2
         NE($U1, $U2)                                            :F(END)
         U3 = 'U3_'
         $U3 = 3
         UNIQUE('CLEAR')
         IDENT($U1)                                              :F(END)
         IDENT($U2)                                              :F(END)
         EQ($U3, 3)                                              :F(END)
         &CODE = 0
END
<h1>upcase</h1>

Convert SNOBOL4 program to uppercase. Does not uppercase quoted
strings, or comments. If /L is used, converts to lowercase.

<h2>Uses</h2>
<a href="HOST.html">HOST</a><br>
<a href="SWAP.html">SWAP</a><br>

<<INCLUDES>>=
-INCLUDE 'HOST.INC'
-INCLUDE 'SWAP.INC'
@

<<UPCASE>>=
         TERMINAL = 'UPCASE (TUE OCT 23 16:16:46 EDT 2007)'
         DEFINE('TOUPPER(S)')
         Q = "'"
         QQ = '"'
         FROM = &LCASE
         TO = &UCASE
         ?(HOST(HOST_ARGN, HOST(HOST_FIRSTARG)) ('/L' | '/l'))
+           SWAP(.FROM, .TO)
*
TOP      R = INPUT                                               :F(END)
*
         S = ''
         R FENCE ANY('*#;|!')                                   :S(CMNT)
LOOP     R ARB . L (Q | QQ) $ DELIM ARB . M *DELIM REM . R      :F(DONE)
         S = S TOUPPER(L) DELIM M DELIM                          :(LOOP)
DONE     S = S TOUPPER(R)
*
         OUTPUT = S                                               :(TOP)
CMNT     OUTPUT = R                                               :(TOP)
*
TOUPPER  TOUPPER = REPLACE(S, FROM, TO)                        :(RETURN)
*
END START
@

<<>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM UPCASE
-TITLE UPCASE
START
<<INCLUDES>>
*
************************************************************************
*                                                                      *
*        #     #  ######    #####      #      #####   #######          *
*        #     #  #     #  #     #    # #    #     #  #                *
*        #     #  #     #  #         #   #   #        #                *
*        #     #  ######   #        #     #   #####   #####            *
*        #     #  #        #        #######        #  #                *
*        #     #  #        #     #  #     #  #     #  #                *
*         #####   #         #####   #     #   #####   #######          *
*                                                                      *
* UPCASE        CONVERTS NON-QUOTED TO UPPERCASE (SNOBOL SOURCE)       *
*                                                                      *
************************************************************************
*
* upcase.lss
*
<<UPCASE>>
*
* CE: .MSNOBOL4;
@
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-PROGRAM UPCASE
-LINE 45 "upcase.lss"
-TITLE UPCASE
START
-LINE 11 "upcase.lss"
-INCLUDE 'HOST.INC'
-INCLUDE 'SWAP.INC'
*
************************************************************************
*                                                                      *
*        #     #  ######    #####      #      #####   #######          *
*        #     #  #     #  #     #    # #    #     #  #                *
*        #     #  #     #  #         #   #   #        #                *
*        #     #  ######   #        #     #   #####   #####            *
*        #     #  #        #        #######        #  #                *
*        #     #  #        #     #  #     #  #     #  #                *
*         #####   #         #####   #     #   #####   #######          *
*                                                                      *
* UPCASE        CONVERTS NON-QUOTED TO UPPERCASE (SNOBOL SOURCE)       *
*                                                                      *
************************************************************************
*
* upcase.lss
*
-LINE 16 "upcase.lss"
         TERMINAL = 'UPCASE (TUE OCT 23 16:16:46 EDT 2007)'
         DEFINE('TOUPPER(S)')
         Q = "'"
         QQ = '"'
         FROM = &LCASE
         TO = &UCASE
         ?(HOST(HOST_ARGN, HOST(HOST_FIRSTARG)) ('/L' | '/l'))
+           SWAP(.FROM, .TO)
*
TOP      R = INPUT                                               :F(END)
*
         S = ''
         R FENCE ANY('*#;|!')                                   :S(CMNT)
LOOP     R ARB . L (Q | QQ) $ DELIM ARB . M *DELIM REM . R      :F(DONE)
         S = S TOUPPER(L) DELIM M DELIM                          :(LOOP)
DONE     S = S TOUPPER(R)
*
         OUTPUT = S                                               :(TOP)
CMNT     OUTPUT = R                                               :(TOP)
*
TOUPPER  TOUPPER = REPLACE(S, FROM, TO)                        :(RETURN)
*
END START
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>upcase</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Convert SNOBOL4 program to uppercase. Does not uppercase quoted
strings, or comments. If /L is used, converts to lowercase.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="HOST.html">HOST</a><br>
<a href="SWAP.html">SWAP</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;HOST.INC&#39;
-INCLUDE &#39;SWAP.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;UPCASE&raquo;&equiv;</b>
         TERMINAL = &#39;UPCASE (TUE OCT 23 16:16:46 EDT 2007)&#39;
         DEFINE(&#39;TOUPPER(S)&#39;)
         Q = &quot;&#39;&quot;
         QQ = &#39;&quot;&#39;
         FROM = &amp;LCASE
         TO = &amp;UCASE
         ?(HOST(HOST_ARGN, HOST(HOST_FIRSTARG)) (&#39;/L&#39; | &#39;/l&#39;))
+           SWAP(.FROM, .TO)
<font color="#818181"><i>*</i></font>
TOP      R = INPUT                                               <b>:F(END)</b>
<font color="#818181"><i>*</i></font>
         S = &#39;&#39;
         R FENCE ANY(&#39;*#;|!&#39;)                                   <b>:S(CMNT)</b>
LOOP     R ARB . L (Q | QQ) $ DELIM ARB . M *DELIM REM . R      <b>:F(DONE)</b>
         S = S TOUPPER(L) DELIM M DELIM                          <b>:(LOOP)</b>
DONE     S = S TOUPPER(R)
<font color="#818181"><i>*</i></font>
         OUTPUT = S                                               <b>:(TOP)</b>
CMNT     OUTPUT = R                                               <b>:(TOP)</b>
<font color="#818181"><i>*</i></font>
TOUPPER  TOUPPER = REPLACE(S, FROM, TO)                        <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
END START
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-PROGRAM UPCASE
-TITLE UPCASE
START
<b>&laquo;INCLUDES&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*        #     #  ######    #####      #      #####   #######          *</i></font>
<font color="#818181"><i>*        #     #  #     #  #     #    # #    #     #  #                *</i></font>
<font color="#818181"><i>*        #     #  #     #  #         #   #   #        #                *</i></font>
<font color="#818181"><i>*        #     #  ######   #        #     #   #####   #####            *</i></font>
<font color="#818181"><i>*        #     #  #        #        #######        #  #                *</i></font>
<font color="#818181"><i>*        #     #  #        #     #  #     #  #     #  #                *</i></font>
<font color="#818181"><i>*         #####   #         #####   #     #   #####   #######          *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* UPCASE        CONVERTS NON-QUOTED TO UPPERCASE (SNOBOL SOURCE)       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* upcase.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;UPCASE&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:32 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
<h1>UTF8 - UTF-8 encoded UNICODE handling</h1>

UTF-8 encoded UNICODE handling. This module is borked. Needs fixing
but I add it to the library anyway.

<h2>Uses</h2>

<<INCLUDES>>=
@

<<UTF8>>=
* PHIL BUDNE <PHIL@ULTIMATE.COM>
* SEPTEMBER 1996
* UPDATED FOR 4/5/6 BYTE RUNES JUNE 1997
*
* MOST OF THIS IS JUST AWFUL, BUT THIS IS JUST A PROOF OF CONCEPT,
* AND LIKE ALL SNOBOL THERE IS ALWAYS A SMALLER, FASTER AND MORE
* PERVERSE WAY TO DO ANYTHING.
*
* TODO
*
* UTFNOTANY
* UTFSPAN
* UTFBREAK
* UTFBREAKX
*
* PATTERN TO MATCH ONE UTF ENCODED RUNE
*
* SNOBOL4 LACKS CHAR(), SPITBOL CHAR() LOSES ON CHAR(0)!
*
         DEFINE("XCHAR(N)")                                    :(EXCHAR)
*
XCHAR    &ALPHABET ARB POS(N) LEN(1) . XCHAR        :S(RETURN)F(FRETURN)
*
EXCHAR
*
* HELPER FUNCTION TO PATTERN THAT MATCHES A RANGE OF BYTE VALUES.
* THE TRUE SNO-HEAD MIGHT IMPLEMENT THIS AS A FUNCTION THAT TAKES
* STRINGS OF SPAN('01') ARBNO('X') DIRECTLY!!
*
         DEFINE("RANGE(START,END)")                            :(ERANGE)
*
RANGE
*
* SPITBOL COMPILES ANY() INTO A BITMAP;
         &ALPHABET ARB (XCHAR(START) ARB XCHAR(END)) . RANGE :F(FRETURN)
* SPITBOL COMPILES TABLES ONCE
         RANGE = ANY(RANGE)                                    :(RETURN)
* FOR SNOBOL4; CREATE BIG PATTERN
*        GE(START, END)                                      :S(FRETURN)
*        RANGE = XCHAR(START)
*RANGE1  GE(STAT, END)                                        :S(RETURN)
*        START = START + 1
*        RANGE = RANGE | XCHAR(START)                          :(RANGE1)
*
ERANGE
*
* SINGLE BYTE:       0XXXXXXX  VALUES 0..0X7F
*
         UTF.T1 = RANGE(0, 127)
*
* TWO-BYTE LEADER:   110XXXXX  VALUES 0X80..0X7FF
*
         UTF.T2 = RANGE(192, 223)
*
* THREE-BYTE LEADER: 1110XXXX  VALUES 0X800..0XFFFF
*
         UTF.T3 = RANGE(224, 239)
*
* FOUR-BYTE LEADER:  11110XXX  VALUES 0X10000..0X1FFFFF
*
         UTF.T4 = RANGE(240, 247)
*
* FIVE-BYTE LEADER:  111110XX  VALUES 0X200000..0X3FFFFFF
*
         UTF.T5 = RANGE(248, 251)
*
* FIVE-BYTE LEADER:  1111110X  VALUES 0X4000000..0X7FFFFFFF
*
         UTF.T6 = RANGE(252, 253)
*
* SUBSEQUENT BYTE:   10XXXXXX
*
         UTF.TX = RANGE(128, 191)
*
         UTF.RUNE = FENCE
+           (UTF.T1 |
+            UTF.T2 UTF.TX |
+            UTF.T3 UTF.TX UTF.TX |
+            UTF.T4 UTF.TX UTF.TX UTF.TX |
+            UTF.T5 UTF.TX UTF.TX UTF.TX UTF.TX |
+            UTF.T6 UTF.TX UTF.TX UTF.TX UTF.TX UTF.TX)
*
         UTF.RUNE0 = POS(0) UTF.RUNE
*
* PATTERN TO MOVE TO NEXY SYNC CHAR;
*
*        UTF.SYNC = BREAKX(UTF.T1 UTF.T2 UTF.T3 UTF.T4 UTF.T5 UTF.T6)
*
* UTF ANALOG OF ARB
*
         UTFARB = ARBNO(UTF.RUNE)
*
* UTF ANALOG OF LEN
*
         DEFINE("UTFLEN(N)")                                  :(EUTFLEN)
*
UTFLEN   LT(N, 0)                                             :(FRETURN)
         UTFLEN =
UTFLEN2  EQ(N, 0)                                             :S(RETURN)
         UTFLEN = UTFLEN UTF.RUNE
         N = N - 1                                            :(UTFLEN2)
*
EUTFLEN
*
* UTF ANALOG FOR ANY(STR)
*
         DEFINE("UTFANY(STR)R")                               :(EUTFANY)
*
UTFANY   STR UTF.RUNE0 . UTFANY =                            :F(FRETURN)
UTFANY2  IDENT(STR)                                           :S(RETURN)
         STR UTF.RUNE0 . R =                                 :F(FRETURN)
         UTFANY = UTFANY | R                                  :(UTFANY2)
EUTFANY
*
* UTF ANALOG FOR CHAR(N)
*
         DEFINE("RUNE(N)")                                      :(ERUNE)
*
RUNE     LT(N, 0)                                            :S(FRETURN)
         GT(N, 127)                                            :S(RUNE2)
* SINGLE BYTE RUNE
         RUNE = XCHAR(N)                                       :(RETURN)
RUNE2    GT(N, 2047)                                           :S(RUNE3)
* TWO-BYTE RUNE
         RUNE = XCHAR(192 + (N / 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* THREE-BYTE RUNE
RUNE3    GT(N, 65535)                                          :S(RUNE4)
         RUNE = XCHAR(224 + N / 4096)
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* FOUR-BYTE RUNE
RUNE4    GT(N, 2097151)                                        :S(RUNE5)
         RUNE = XCHAR(240 + N / 262144)
+               XCHAR(128 + REMDR(N / 65536, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* FIVE-BYTE RUNE
RUNE5    GT(N, 67108863)                                       :S(RUNE6)
         RUNE = XCHAR(248 + N / 16777216)
+               XCHAR(128 + REMDR(N / 262144, 64))
+               XCHAR(128 + REMDR(N / 4096, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* SIX-BYTE RUNE
RUNE6    GT(N, 2147483647)                                   :S(FRETURN)
         RUNE = XCHAR(252 + N / 1073741824)
+               XCHAR(128 + REMDR(N / 16777216, 64))
+               XCHAR(128 + REMDR(N / 262144, 64))
+               XCHAR(128 + REMDR(N / 4096, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
*
ERUNE
*
* UTF ANALOG FOR SIZE(STR)
*
         DEFINE("UTFSIZE(STR)")                              :(EUTFSIZE)
*
UTFSIZE  STR UTF.RUNE =                                      :F(UTFSIZ2)
         UTFSIZE = UTFSIZE + 1                                :(UTFSIZE)
UTFSIZ2  IDENT(STR)                                 :S(RETURN)F(FRETURN)
*
EUTFSIZE
*
* UTF ANALOG FOR REPLACE()
*
         DEFINE("UTFREPLACE(IN,FROM,TO)T,R1,R2")          :(EUTFREPLACE)
*
UTFREPLACE
         T = TABLE()
* PEEL RUNES OFF INPUT AND OUTPUT LANGUAGES ONE AT A TIME
UTFREP1  FROM UTF.RUNE0 . R1 =                               :F(UTFREP2)
         TO UTF.RUNE0 . R2 =                                 :F(UTFREP2)
         T<R1> = R2                                           :(UTFREP1)
* BOTH INPUT AND OUTPUT LANGUAGES SHOULD NOW BE EMPTY
UTFREP2  DIFFER(FROM)                                        :S(FRETURN)
         DIFFER(TO)                                          :S(FRETURN)
* FREEZE TABLE FOR SNOBOL4+?
* PEEL RUNES INPUT ONE AT A TIME, FEED THRU TABLE
         UTFREPLACE =
UTFREP3  IN UTF.RUNE0 . R1 =                                 :F(UTFREP4)
         UTFREPLACE = UTFREPLACE (IDENT(T<R1>) R1, T<R1>)     :(UTFREP3)
UTFREP4  IDENT(IN)                                  :S(RETURN)F(FRETURN)
*
EUTFREPLACE
*
************************************************************************
*
* TESTS
*
*        &ANCHOR = 1
*        S = "Hello World!!"
*
*        OUTPUT = UTFREPLACE(S,&UCASE "!",&LCASE "?")
*
*L       S UTF.RUNE $ OUTPUT =                                     :S(L)
*
*        "HELLO WORLD!" UTFARB . OUTPUT RPOS(0)
*        "Hello World!" UTFARB UTFANY(&LCASE) . OUTPUT
*        "Hello World!" UTFANY(&UCASE) . OUTPUT
*
*        OUTPUT = RUNE(0)
*        OUTPUT = RUNE(127)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(128)
*        OUTPUT = RUNE(255)
*        OUTPUT = RUNE(2047)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(2048)
*        OUTPUT = RUNE(65535)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(65536)
*        OUTPUT = RUNE(2097151)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(2097152)
*        OUTPUT = RUNE(67108863)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(67108864)
*        OUTPUT = RUNE(2147483647)
*
*END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'UTF8.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-MODULE UTF8
-STITL UTF8
-EJECT
*
************************************************************************
*                                                                      *
*                   #     #  #######  #######   ###                    *
*                   #     #     #     #        #   #                   *
*                   #     #     #     #        #   #                   *
*                   #     #     #     #####     ###                    *
*                   #     #     #     #        #   #                   *
*                   #     #     #     #        #   #                   *
*                    #####      #     #         ###                    *
*                                                                      *
* UTF8                                                                 *
*                                                                      *
************************************************************************
*
* SNOBOL4 FUNCTIONS TO IMPLEMENT UTF-ENCODED UNICODE HANDLING
* UTF8.lss
*
<<UTF8>>
*
* CE: .MSNOBOL4;
@
-MODULE UTF8
-STITL UTF8
-EJECT
-LINE 249 "UTF8.lss"
*
************************************************************************
*                                                                      *
*                   #     #  #######  #######   ###                    *
*                   #     #     #     #        #   #                   *
*                   #     #     #     #        #   #                   *
*                   #     #     #     #####     ###                    *
*                   #     #     #     #        #   #                   *
*                   #     #     #     #        #   #                   *
*                    #####      #     #         ###                    *
*                                                                      *
* UTF8                                                                 *
*                                                                      *
************************************************************************
*
* SNOBOL4 FUNCTIONS TO IMPLEMENT UTF-ENCODED UNICODE HANDLING
* UTF8.lss
*
-LINE 12 "UTF8.lss"
* PHIL BUDNE <PHIL@ULTIMATE.COM>
* SEPTEMBER 1996
* UPDATED FOR 4/5/6 BYTE RUNES JUNE 1997
*
* MOST OF THIS IS JUST AWFUL, BUT THIS IS JUST A PROOF OF CONCEPT,
* AND LIKE ALL SNOBOL THERE IS ALWAYS A SMALLER, FASTER AND MORE
* PERVERSE WAY TO DO ANYTHING.
*
* TODO
*
* UTFNOTANY
* UTFSPAN
* UTFBREAK
* UTFBREAKX
*
* PATTERN TO MATCH ONE UTF ENCODED RUNE
*
* SNOBOL4 LACKS CHAR(), SPITBOL CHAR() LOSES ON CHAR(0)!
*
         DEFINE("XCHAR(N)")                                    :(EXCHAR)
*
XCHAR    &ALPHABET ARB POS(N) LEN(1) . XCHAR        :S(RETURN)F(FRETURN)
*
EXCHAR
*
* HELPER FUNCTION TO PATTERN THAT MATCHES A RANGE OF BYTE VALUES.
* THE TRUE SNO-HEAD MIGHT IMPLEMENT THIS AS A FUNCTION THAT TAKES
* STRINGS OF SPAN('01') ARBNO('X') DIRECTLY!!
*
         DEFINE("RANGE(START,END)")                            :(ERANGE)
*
RANGE
*
* SPITBOL COMPILES ANY() INTO A BITMAP;
         &ALPHABET ARB (XCHAR(START) ARB XCHAR(END)) . RANGE :F(FRETURN)
* SPITBOL COMPILES TABLES ONCE
         RANGE = ANY(RANGE)                                    :(RETURN)
* FOR SNOBOL4; CREATE BIG PATTERN
*        GE(START, END)                                      :S(FRETURN)
*        RANGE = XCHAR(START)
*RANGE1  GE(STAT, END)                                        :S(RETURN)
*        START = START + 1
*        RANGE = RANGE | XCHAR(START)                          :(RANGE1)
*
ERANGE
*
* SINGLE BYTE:       0XXXXXXX  VALUES 0..0X7F
*
         UTF.T1 = RANGE(0, 127)
*
* TWO-BYTE LEADER:   110XXXXX  VALUES 0X80..0X7FF
*
         UTF.T2 = RANGE(192, 223)
*
* THREE-BYTE LEADER: 1110XXXX  VALUES 0X800..0XFFFF
*
         UTF.T3 = RANGE(224, 239)
*
* FOUR-BYTE LEADER:  11110XXX  VALUES 0X10000..0X1FFFFF
*
         UTF.T4 = RANGE(240, 247)
*
* FIVE-BYTE LEADER:  111110XX  VALUES 0X200000..0X3FFFFFF
*
         UTF.T5 = RANGE(248, 251)
*
* FIVE-BYTE LEADER:  1111110X  VALUES 0X4000000..0X7FFFFFFF
*
         UTF.T6 = RANGE(252, 253)
*
* SUBSEQUENT BYTE:   10XXXXXX
*
         UTF.TX = RANGE(128, 191)
*
         UTF.RUNE = FENCE
+           (UTF.T1 |
+            UTF.T2 UTF.TX |
+            UTF.T3 UTF.TX UTF.TX |
+            UTF.T4 UTF.TX UTF.TX UTF.TX |
+            UTF.T5 UTF.TX UTF.TX UTF.TX UTF.TX |
+            UTF.T6 UTF.TX UTF.TX UTF.TX UTF.TX UTF.TX)
*
         UTF.RUNE0 = POS(0) UTF.RUNE
*
* PATTERN TO MOVE TO NEXY SYNC CHAR;
*
*        UTF.SYNC = BREAKX(UTF.T1 UTF.T2 UTF.T3 UTF.T4 UTF.T5 UTF.T6)
*
* UTF ANALOG OF ARB
*
         UTFARB = ARBNO(UTF.RUNE)
*
* UTF ANALOG OF LEN
*
         DEFINE("UTFLEN(N)")                                  :(EUTFLEN)
*
UTFLEN   LT(N, 0)                                             :(FRETURN)
         UTFLEN =
UTFLEN2  EQ(N, 0)                                             :S(RETURN)
         UTFLEN = UTFLEN UTF.RUNE
         N = N - 1                                            :(UTFLEN2)
*
EUTFLEN
*
* UTF ANALOG FOR ANY(STR)
*
         DEFINE("UTFANY(STR)R")                               :(EUTFANY)
*
UTFANY   STR UTF.RUNE0 . UTFANY =                            :F(FRETURN)
UTFANY2  IDENT(STR)                                           :S(RETURN)
         STR UTF.RUNE0 . R =                                 :F(FRETURN)
         UTFANY = UTFANY | R                                  :(UTFANY2)
EUTFANY
*
* UTF ANALOG FOR CHAR(N)
*
         DEFINE("RUNE(N)")                                      :(ERUNE)
*
RUNE     LT(N, 0)                                            :S(FRETURN)
         GT(N, 127)                                            :S(RUNE2)
* SINGLE BYTE RUNE
         RUNE = XCHAR(N)                                       :(RETURN)
RUNE2    GT(N, 2047)                                           :S(RUNE3)
* TWO-BYTE RUNE
         RUNE = XCHAR(192 + (N / 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* THREE-BYTE RUNE
RUNE3    GT(N, 65535)                                          :S(RUNE4)
         RUNE = XCHAR(224 + N / 4096)
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* FOUR-BYTE RUNE
RUNE4    GT(N, 2097151)                                        :S(RUNE5)
         RUNE = XCHAR(240 + N / 262144)
+               XCHAR(128 + REMDR(N / 65536, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* FIVE-BYTE RUNE
RUNE5    GT(N, 67108863)                                       :S(RUNE6)
         RUNE = XCHAR(248 + N / 16777216)
+               XCHAR(128 + REMDR(N / 262144, 64))
+               XCHAR(128 + REMDR(N / 4096, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
* SIX-BYTE RUNE
RUNE6    GT(N, 2147483647)                                   :S(FRETURN)
         RUNE = XCHAR(252 + N / 1073741824)
+               XCHAR(128 + REMDR(N / 16777216, 64))
+               XCHAR(128 + REMDR(N / 262144, 64))
+               XCHAR(128 + REMDR(N / 4096, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      :(RETURN)
*
ERUNE
*
* UTF ANALOG FOR SIZE(STR)
*
         DEFINE("UTFSIZE(STR)")                              :(EUTFSIZE)
*
UTFSIZE  STR UTF.RUNE =                                      :F(UTFSIZ2)
         UTFSIZE = UTFSIZE + 1                                :(UTFSIZE)
UTFSIZ2  IDENT(STR)                                 :S(RETURN)F(FRETURN)
*
EUTFSIZE
*
* UTF ANALOG FOR REPLACE()
*
         DEFINE("UTFREPLACE(IN,FROM,TO)T,R1,R2")          :(EUTFREPLACE)
*
UTFREPLACE
         T = TABLE()
* PEEL RUNES OFF INPUT AND OUTPUT LANGUAGES ONE AT A TIME
UTFREP1  FROM UTF.RUNE0 . R1 =                               :F(UTFREP2)
         TO UTF.RUNE0 . R2 =                                 :F(UTFREP2)
         T<R1> = R2                                           :(UTFREP1)
* BOTH INPUT AND OUTPUT LANGUAGES SHOULD NOW BE EMPTY
UTFREP2  DIFFER(FROM)                                        :S(FRETURN)
         DIFFER(TO)                                          :S(FRETURN)
* FREEZE TABLE FOR SNOBOL4+?
* PEEL RUNES INPUT ONE AT A TIME, FEED THRU TABLE
         UTFREPLACE =
UTFREP3  IN UTF.RUNE0 . R1 =                                 :F(UTFREP4)
         UTFREPLACE = UTFREPLACE (IDENT(T<R1>) R1, T<R1>)     :(UTFREP3)
UTFREP4  IDENT(IN)                                  :S(RETURN)F(FRETURN)
*
EUTFREPLACE
*
************************************************************************
*
* TESTS
*
*        &ANCHOR = 1
*        S = "Hello World!!"
*
*        OUTPUT = UTFREPLACE(S,&UCASE "!",&LCASE "?")
*
*L       S UTF.RUNE $ OUTPUT =                                     :S(L)
*
*        "HELLO WORLD!" UTFARB . OUTPUT RPOS(0)
*        "Hello World!" UTFARB UTFANY(&LCASE) . OUTPUT
*        "Hello World!" UTFANY(&UCASE) . OUTPUT
*
*        OUTPUT = RUNE(0)
*        OUTPUT = RUNE(127)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(128)
*        OUTPUT = RUNE(255)
*        OUTPUT = RUNE(2047)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(2048)
*        OUTPUT = RUNE(65535)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(65536)
*        OUTPUT = RUNE(2097151)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(2097152)
*        OUTPUT = RUNE(67108863)
*        OUTPUT = '-------'
*        OUTPUT = RUNE(67108864)
*        OUTPUT = RUNE(2147483647)
*
*END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>UTF8 - UTF-8 encoded UNICODE handling</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
UTF-8 encoded UNICODE handling. This module is borked. Needs fixing
but I add it to the library anyway.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;UTF8&raquo;&equiv;</b>
<font color="#818181"><i>* PHIL BUDNE &lt;PHIL@ULTIMATE.COM&gt;</i></font>
<font color="#818181"><i>* SEPTEMBER 1996</i></font>
<font color="#818181"><i>* UPDATED FOR 4/5/6 BYTE RUNES JUNE 1997</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MOST OF THIS IS JUST AWFUL, BUT THIS IS JUST A PROOF OF CONCEPT,</i></font>
<font color="#818181"><i>* AND LIKE ALL SNOBOL THERE IS ALWAYS A SMALLER, FASTER AND MORE</i></font>
<font color="#818181"><i>* PERVERSE WAY TO DO ANYTHING.</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TODO</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTFNOTANY</i></font>
<font color="#818181"><i>* UTFSPAN</i></font>
<font color="#818181"><i>* UTFBREAK</i></font>
<font color="#818181"><i>* UTFBREAKX</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PATTERN TO MATCH ONE UTF ENCODED RUNE</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SNOBOL4 LACKS CHAR(), SPITBOL CHAR() LOSES ON CHAR(0)!</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;XCHAR(N)&quot;)                                    <b>:(EXCHAR)</b>
<font color="#818181"><i>*</i></font>
XCHAR    &amp;ALPHABET ARB POS(N) LEN(1) . XCHAR        <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
EXCHAR
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* HELPER FUNCTION TO PATTERN THAT MATCHES A RANGE OF BYTE VALUES.</i></font>
<font color="#818181"><i>* THE TRUE SNO-HEAD MIGHT IMPLEMENT THIS AS A FUNCTION THAT TAKES</i></font>
<font color="#818181"><i>* STRINGS OF SPAN(&#39;01&#39;) ARBNO(&#39;X&#39;) DIRECTLY!!</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;RANGE(START,END)&quot;)                            <b>:(ERANGE)</b>
<font color="#818181"><i>*</i></font>
RANGE
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SPITBOL COMPILES ANY() INTO A BITMAP;</i></font>
         &amp;ALPHABET ARB (XCHAR(START) ARB XCHAR(END)) . RANGE <b>:F(FRETURN)</b>
<font color="#818181"><i>* SPITBOL COMPILES TABLES ONCE</i></font>
         RANGE = ANY(RANGE)                                    <b>:(RETURN)</b>
<font color="#818181"><i>* FOR SNOBOL4; CREATE BIG PATTERN</i></font>
<font color="#818181"><i>*        GE(START, END)                                      <b>:S(FRETURN)</b></i></font>
<font color="#818181"><i>*        RANGE = XCHAR(START)</i></font>
<font color="#818181"><i>*RANGE1  GE(STAT, END)                                        <b>:S(RETURN)</b></i></font>
<font color="#818181"><i>*        START = START + 1</i></font>
<font color="#818181"><i>*        RANGE = RANGE | XCHAR(START)                          <b>:(RANGE1)</b></i></font>
<font color="#818181"><i>*</i></font>
ERANGE
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SINGLE BYTE:       0XXXXXXX  VALUES 0..0X7F</i></font>
<font color="#818181"><i>*</i></font>
         UTF.T1 = RANGE(0, 127)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TWO-BYTE LEADER:   110XXXXX  VALUES 0X80..0X7FF</i></font>
<font color="#818181"><i>*</i></font>
         UTF.T2 = RANGE(192, 223)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* THREE-BYTE LEADER: 1110XXXX  VALUES 0X800..0XFFFF</i></font>
<font color="#818181"><i>*</i></font>
         UTF.T3 = RANGE(224, 239)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FOUR-BYTE LEADER:  11110XXX  VALUES 0X10000..0X1FFFFF</i></font>
<font color="#818181"><i>*</i></font>
         UTF.T4 = RANGE(240, 247)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIVE-BYTE LEADER:  111110XX  VALUES 0X200000..0X3FFFFFF</i></font>
<font color="#818181"><i>*</i></font>
         UTF.T5 = RANGE(248, 251)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FIVE-BYTE LEADER:  1111110X  VALUES 0X4000000..0X7FFFFFFF</i></font>
<font color="#818181"><i>*</i></font>
         UTF.T6 = RANGE(252, 253)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SUBSEQUENT BYTE:   10XXXXXX</i></font>
<font color="#818181"><i>*</i></font>
         UTF.TX = RANGE(128, 191)
<font color="#818181"><i>*</i></font>
         UTF.RUNE = FENCE
+           (UTF.T1 |
+            UTF.T2 UTF.TX |
+            UTF.T3 UTF.TX UTF.TX |
+            UTF.T4 UTF.TX UTF.TX UTF.TX |
+            UTF.T5 UTF.TX UTF.TX UTF.TX UTF.TX |
+            UTF.T6 UTF.TX UTF.TX UTF.TX UTF.TX UTF.TX)
<font color="#818181"><i>*</i></font>
         UTF.RUNE0 = POS(0) UTF.RUNE
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PATTERN TO MOVE TO NEXY SYNC CHAR;</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*        UTF.SYNC = BREAKX(UTF.T1 UTF.T2 UTF.T3 UTF.T4 UTF.T5 UTF.T6)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTF ANALOG OF ARB</i></font>
<font color="#818181"><i>*</i></font>
         UTFARB = ARBNO(UTF.RUNE)
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTF ANALOG OF LEN</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;UTFLEN(N)&quot;)                                  <b>:(EUTFLEN)</b>
<font color="#818181"><i>*</i></font>
UTFLEN   LT(N, 0)                                             <b>:(FRETURN)</b>
         UTFLEN =
UTFLEN2  EQ(N, 0)                                             <b>:S(RETURN)</b>
         UTFLEN = UTFLEN UTF.RUNE
         N = N - 1                                            <b>:(UTFLEN2)</b>
<font color="#818181"><i>*</i></font>
EUTFLEN
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTF ANALOG FOR ANY(STR)</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;UTFANY(STR)R&quot;)                               <b>:(EUTFANY)</b>
<font color="#818181"><i>*</i></font>
UTFANY   STR UTF.RUNE0 . UTFANY =                            <b>:F(FRETURN)</b>
UTFANY2  IDENT(STR)                                           <b>:S(RETURN)</b>
         STR UTF.RUNE0 . R =                                 <b>:F(FRETURN)</b>
         UTFANY = UTFANY | R                                  <b>:(UTFANY2)</b>
EUTFANY
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTF ANALOG FOR CHAR(N)</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;RUNE(N)&quot;)                                      <b>:(ERUNE)</b>
<font color="#818181"><i>*</i></font>
RUNE     LT(N, 0)                                            <b>:S(FRETURN)</b>
         GT(N, 127)                                            <b>:S(RUNE2)</b>
<font color="#818181"><i>* SINGLE BYTE RUNE</i></font>
         RUNE = XCHAR(N)                                       <b>:(RETURN)</b>
RUNE2    GT(N, 2047)                                           <b>:S(RUNE3)</b>
<font color="#818181"><i>* TWO-BYTE RUNE</i></font>
         RUNE = XCHAR(192 + (N / 64))
+               XCHAR(128 + REMDR(N, 64))                      <b>:(RETURN)</b>
<font color="#818181"><i>* THREE-BYTE RUNE</i></font>
RUNE3    GT(N, 65535)                                          <b>:S(RUNE4)</b>
         RUNE = XCHAR(224 + N / 4096)
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      <b>:(RETURN)</b>
<font color="#818181"><i>* FOUR-BYTE RUNE</i></font>
RUNE4    GT(N, 2097151)                                        <b>:S(RUNE5)</b>
         RUNE = XCHAR(240 + N / 262144)
+               XCHAR(128 + REMDR(N / 65536, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      <b>:(RETURN)</b>
<font color="#818181"><i>* FIVE-BYTE RUNE</i></font>
RUNE5    GT(N, 67108863)                                       <b>:S(RUNE6)</b>
         RUNE = XCHAR(248 + N / 16777216)
+               XCHAR(128 + REMDR(N / 262144, 64))
+               XCHAR(128 + REMDR(N / 4096, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      <b>:(RETURN)</b>
<font color="#818181"><i>* SIX-BYTE RUNE</i></font>
RUNE6    GT(N, 2147483647)                                   <b>:S(FRETURN)</b>
         RUNE = XCHAR(252 + N / 1073741824)
+               XCHAR(128 + REMDR(N / 16777216, 64))
+               XCHAR(128 + REMDR(N / 262144, 64))
+               XCHAR(128 + REMDR(N / 4096, 64))
+               XCHAR(128 + REMDR(N / 64, 64))
+               XCHAR(128 + REMDR(N, 64))                      <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
ERUNE
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTF ANALOG FOR SIZE(STR)</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;UTFSIZE(STR)&quot;)                              <b>:(EUTFSIZE)</b>
<font color="#818181"><i>*</i></font>
UTFSIZE  STR UTF.RUNE =                                      <b>:F(UTFSIZ2)</b>
         UTFSIZE = UTFSIZE + 1                                <b>:(UTFSIZE)</b>
UTFSIZ2  IDENT(STR)                                 <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
EUTFSIZE
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* UTF ANALOG FOR REPLACE()</i></font>
<font color="#818181"><i>*</i></font>
         DEFINE(&quot;UTFREPLACE(IN,FROM,TO)T,R1,R2&quot;)          <b>:(EUTFREPLACE)</b>
<font color="#818181"><i>*</i></font>
UTFREPLACE
         T = TABLE()
<font color="#818181"><i>* PEEL RUNES OFF INPUT AND OUTPUT LANGUAGES ONE AT A TIME</i></font>
UTFREP1  FROM UTF.RUNE0 . R1 =                               <b>:F(UTFREP2)</b>
         TO UTF.RUNE0 . R2 =                                 <b>:F(UTFREP2)</b>
         T&lt;R1&gt; = R2                                           <b>:(UTFREP1)</b>
<font color="#818181"><i>* BOTH INPUT AND OUTPUT LANGUAGES SHOULD NOW BE EMPTY</i></font>
UTFREP2  DIFFER(FROM)                                        <b>:S(FRETURN)</b>
         DIFFER(TO)                                          <b>:S(FRETURN)</b>
<font color="#818181"><i>* FREEZE TABLE FOR SNOBOL4+?</i></font>
<font color="#818181"><i>* PEEL RUNES INPUT ONE AT A TIME, FEED THRU TABLE</i></font>
         UTFREPLACE =
UTFREP3  IN UTF.RUNE0 . R1 =                                 <b>:F(UTFREP4)</b>
         UTFREPLACE = UTFREPLACE (IDENT(T&lt;R1&gt;) R1, T&lt;R1&gt;)     <b>:(UTFREP3)</b>
UTFREP4  IDENT(IN)                                  <b>:S(RETURN)F(FRETURN)</b>
<font color="#818181"><i>*</i></font>
EUTFREPLACE
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* TESTS</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*        &amp;ANCHOR = 1</i></font>
<font color="#818181"><i>*        S = &quot;Hello World!!&quot;</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*        OUTPUT = UTFREPLACE(S,&amp;UCASE &quot;!&quot;,&amp;LCASE &quot;?&quot;)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*L       S UTF.RUNE $ OUTPUT =                                     <b>:S(L)</b></i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*        &quot;HELLO WORLD!&quot; UTFARB . OUTPUT RPOS(0)</i></font>
<font color="#818181"><i>*        &quot;Hello World!&quot; UTFARB UTFANY(&amp;LCASE) . OUTPUT</i></font>
<font color="#818181"><i>*        &quot;Hello World!&quot; UTFANY(&amp;UCASE) . OUTPUT</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(0)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(127)</i></font>
<font color="#818181"><i>*        OUTPUT = &#39;-------&#39;</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(128)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(255)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(2047)</i></font>
<font color="#818181"><i>*        OUTPUT = &#39;-------&#39;</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(2048)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(65535)</i></font>
<font color="#818181"><i>*        OUTPUT = &#39;-------&#39;</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(65536)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(2097151)</i></font>
<font color="#818181"><i>*        OUTPUT = &#39;-------&#39;</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(2097152)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(67108863)</i></font>
<font color="#818181"><i>*        OUTPUT = &#39;-------&#39;</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(67108864)</i></font>
<font color="#818181"><i>*        OUTPUT = RUNE(2147483647)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*END</i></font>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;UTF8.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-MODULE UTF8
-STITL UTF8
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*                   #     #  #######  #######   ###                    *</i></font>
<font color="#818181"><i>*                   #     #     #     #        #   #                   *</i></font>
<font color="#818181"><i>*                   #     #     #     #        #   #                   *</i></font>
<font color="#818181"><i>*                   #     #     #     #####     ###                    *</i></font>
<font color="#818181"><i>*                   #     #     #     #        #   #                   *</i></font>
<font color="#818181"><i>*                   #     #     #     #        #   #                   *</i></font>
<font color="#818181"><i>*                    #####      #     #         ###                    *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* UTF8                                                                 *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SNOBOL4 FUNCTIONS TO IMPLEMENT UTF-ENCODED UNICODE HANDLING</i></font>
<font color="#818181"><i>* UTF8.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;UTF8&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:33 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'UTF8.INC'
-LINE 240 "UTF8.lss"
         &CODE = 1
         &CODE = 0
END
<h1>VDIFFER</h1>

[[VDIFFER(P1,P2)]] returns P1 if [[DIFFER(P1,P2)]]. Built into
CSNOBOL4, but not in SPITBOL.EXE.

<h2>Uses</h2>
<a href="SYSTEM.html">SYSTEM</a><br>

<<INCLUDES>>= 
-INCLUDE 'SYSTEM.INC'
@

<<VDIFFER>>=
-MODULE VDIFFER
         SYSTEM() 'CSNOBOL4'                             :S(VDIFFER_END)
-PUBLIC VDIFFER()
         DEFINE('VDIFFER(P1,P2)')                         :(VDIFFER_END)
*
VDIFFER  VDIFFER = DIFFER(P1, P2) P1                :F(FRETURN)S(RETURN)
*
VDIFFER_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'VDIFFER.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL VDIFFER
-EJECT
*
************************************************************************
*                                                                      *
*      #     #  ######   ###  #######  #######  #######  ######        *
*      #     #  #     #   #   #        #        #        #     #       *
*      #     #  #     #   #   #        #        #        #     #       *
*      #     #  #     #   #   #####    #####    #####    ######        *
*       #   #   #     #   #   #        #        #        #   #         *
*        # #    #     #   #   #        #        #        #    #        *
*         #     ######   ###  #        #        #######  #     #       *
*                                                                      *
* VDIFFER            RETURN FIRST ARG IF DIFFER                        *
*                                                                      *
************************************************************************
*
* VDIFFER.lss
*
<<VDIFFER>>
*
* CE: .MSNOBOL4;
@
-LINE 10 "VDIFFER.lss"
-INCLUDE 'SYSTEM.INC'
-STITL VDIFFER
-EJECT
-LINE 37 "VDIFFER.lss"
*
************************************************************************
*                                                                      *
*      #     #  ######   ###  #######  #######  #######  ######        *
*      #     #  #     #   #   #        #        #        #     #       *
*      #     #  #     #   #   #        #        #        #     #       *
*      #     #  #     #   #   #####    #####    #####    ######        *
*       #   #   #     #   #   #        #        #        #   #         *
*        # #    #     #   #   #        #        #        #    #        *
*         #     ######   ###  #        #        #######  #     #       *
*                                                                      *
* VDIFFER            RETURN FIRST ARG IF DIFFER                        *
*                                                                      *
************************************************************************
*
* VDIFFER.lss
*
-LINE 14 "VDIFFER.lss"
-MODULE VDIFFER
         SYSTEM() 'CSNOBOL4'                             :S(VDIFFER_END)
-PUBLIC VDIFFER()
         DEFINE('VDIFFER(P1,P2)')                         :(VDIFFER_END)
*
VDIFFER  VDIFFER = DIFFER(P1, P2) P1                :F(FRETURN)S(RETURN)
*
VDIFFER_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>VDIFFER</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<font face="Source Code Pro">VDIFFER(P1,P2)</font> returns P1 if <font face="Source Code Pro">DIFFER(P1,P2)</font>. Built into
CSNOBOL4, but not in SPITBOL.EXE.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
<a href="SYSTEM.html">SYSTEM</a><br>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
-INCLUDE &#39;SYSTEM.INC&#39;
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;VDIFFER&raquo;&equiv;</b>
-MODULE VDIFFER
         SYSTEM() &#39;CSNOBOL4&#39;                             <b>:S(VDIFFER_END)</b>
-PUBLIC VDIFFER()
         DEFINE(&#39;VDIFFER(P1,P2)&#39;)                         <b>:(VDIFFER_END)</b>
<font color="#818181"><i>*</i></font>
VDIFFER  VDIFFER = DIFFER(P1, P2) P1                <b>:F(FRETURN)S(RETURN)</b>
<font color="#818181"><i>*</i></font>
VDIFFER_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;VDIFFER.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
<b>&laquo;INCLUDES&raquo;</b>
-STITL VDIFFER
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*      #     #  ######   ###  #######  #######  #######  ######        *</i></font>
<font color="#818181"><i>*      #     #  #     #   #   #        #        #        #     #       *</i></font>
<font color="#818181"><i>*      #     #  #     #   #   #        #        #        #     #       *</i></font>
<font color="#818181"><i>*      #     #  #     #   #   #####    #####    #####    ######        *</i></font>
<font color="#818181"><i>*       #   #   #     #   #   #        #        #        #   #         *</i></font>
<font color="#818181"><i>*        # #    #     #   #   #        #        #        #    #        *</i></font>
<font color="#818181"><i>*         #     ######   ###  #        #        #######  #     #       *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* VDIFFER            RETURN FIRST ARG IF DIFFER                        *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* VDIFFER.lss</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;VDIFFER&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Thu Jun  5 20:00:46 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'VDIFFER.INC'
-LINE 28 "VDIFFER.lss"
         &CODE = 1
         &CODE = 0
END
<h1>WRAPPER - Create C code to wrap a function for LOAD()ing</h1>

Writes a C function to do parameter and result conversion to allow
an external function to be used with [[LOAD()]].

<h2>Uses</h2>

<<INCLUDES>>=
@

<<WRAPPER>>=
-MODULE WRAPPER
         WPMAXSTR = 1024
         WPSTRTYPE = 'STRING'
         WPSTRFREE = 'STRING_FREE'
         WPSTRTYP2 = 'STRING2'
         WPINTTYPE = 'INTEGER'
         WPLONGTYPE = 'LONG'
         WPREALTYPE = 'REAL'
         WPREDTYPE = 'PREDICATE'
         WPSPREDTYPE = 'SYSPRED'
         WPTYPES = WPLONGTYPE | WPINTTYPE | WPREALTYPE | WPSTRTYPE
         WPRTYPES = WPTYPES | WPREDTYPE | WPSPREDTYPE | WPSTRFREE |
+                   WPSTRTYP2 | ''
         WPNAME = ANY(&UCASE &LCASE '_')
+                 SPAN(&UCASE &LCASE '0123456789_')
         WPEND = ANY(',)')
         WP4SP = '    '
         WP8SP = '	'
*
* WRAPPER_STARTFILE(OUTPUT_NAME)
*
* OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VAR FOR C FILE
*
-PUBLIC WRAPPER_STARTFILE()
         DEFINE('WRAPPER_STARTFILE(FN)')        :(WRAPPER_STARTFILE_END)
*
WRAPPER_STARTFILE
         $FN = '/* Generated by WRAPPER on ' DATE() ' */'
         $FN =
         $FN = '#include "config.h"'
         $FN = '#include "h.h"'
         $FN = '#include "snotypes.h"'
         $FN = '#include "macros.h"'
         $FN = '#include "load.h"'
         $FN = '#include "equ.h"'
         $FN = '#include <string.h>'
         $FN =                                                 :(RETURN)
*
WRAPPER_STARTFILE_END
*
-PUBLIC WRAPPER_COBOL()
         DEFINE('WRAPPER_COBOL(FN)')                :(WRAPPER_COBOL_END)
*
WRAPPER_COBOL
         $FN = '#include <libcob.h>'                           :(RETURN)
*
WRAPPER_COBOL_END
*
* WRAPPER_PROTO(PROTOTYPE,OUTPUT_NAME)
*
* PROTOTYPE:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
*              C FUNCTION TO CALL IS THE LOWERCASE VERSION
*              OF THE FUNCTION NAME.
* OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
*
-PUBLIC WRAPPER_PROTO(), C_WRAPPER_PROTO(), COBOL_WRAPPER_PROTO()
-PUBLIC SCHEME_WRAPPER_PROTO()
         DEFINE('WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
         DEFINE('C_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'WRAPPER_PROTO')
         DEFINE('COBOL_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'WRAPPER_PROTO')
         DEFINE('SCHEME_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'WRAPPER_PROTO')                        :(WRAPPER_PROTO_END)
*
WRAPPER_PROTO
         $FN =
         $FN = '/* ' PROTO ' */'
         PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
         N = 0
         WPCOPY = 0
         TYPES = ARRAY('0:29')
         PROTO POS(0) ')' =                                  :S(WPEPARS)
WPLOOP   PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
         TYPES<N> = TYPE                                       :F(WPERR)
         N = N + 1
         WPCOPY = IDENT(TYPE, WPSTRTYPE) WPCOPY + 1
         IDENT(C, ')')                              :S(WPEPARS)F(WPLOOP)
WPERR    TERMINAL = 'ERROR IN PROTOTYPE: >' PROTO '<'         :(FRETURN)
WPEPARS  PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
         I = 0
         $FN = NAME '( LA_ALIST ) LA_DCL'
         $FN = '{'
         EQ(WPCOPY, 0)                                      :S(WPNOSTRS)
*
WPLOOP2  IDENT(TYPES<I>, WPSTRTYPE)                          :F(WPNEXT2)
         $FN = WP4SP 'char arg' I '[' WPMAXSTR '];'
WPNEXT2  I = I + 1
         LT(I, N)                                            :S(WPLOOP2)
*
         I = 0
WPCOPY                                           :($('WPCPY_' TYPES<I>))
WPCPY_STRING
         $FN = WP4SP
+              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
                                                              :(WPNCOPY)
WPCPY_LONG
WPCPY_INTEGER
WPCPY_REAL
WPCPY_
WPNCOPY  I = I + 1
         LT(I, N)                                             :S(WPCOPY)
*
WPNOSTRS CALL = REPLACE(NAME, &UCASE, &LCASE) '('
         I = 0
WPCALL   GE(I, N)                                            :S(WPECALL)
         CALL = GT(I, 0) CALL ','                :($('WPARG_' TYPES<I>))
WPARG_LONG
         CALL = CALL '(long)LA_INT(' I ')'                    :(WPNCALL)
WPARG_INTEGER
         CALL = CALL '(int)LA_INT(' I ')'                     :(WPNCALL)
WPARG_REAL
         CALL = CALL '(double)LA_REAL(' I ')'                 :(WPNCALL)
WPARG_STRING
         CALL = CALL 'arg' I
WPNCALL  I = I + 1                                             :(WPCALL)
WPECALL  CALL = CALL ')'                            :($('WPRET_' PROTO))
*
WPRET_STRING
         $FN = WP4SP 'RETSTR((char *)' CALL ');'               :(WPDONE)
WPRET_STRING2
         $FN = WP4SP 'RETSTR2((char *)' CALL ',' LEN ');'      :(WPDONE)
WPRET_STRING_FREE
         $FN = WP4SP 'RETSTR_FREE((char *)' CALL ');'          :(WPDONE)
WPRET_LONG
WPRET_INTEGER
         $FN = WP4SP 'RETINT(' CALL ');'                       :(WPDONE)
WPRET_REAL
         $FN = WP4SP 'RETREAL(' CALL ');'                      :(WPDONE)
WPRET_PREDICATE
         $FN = WP4SP 'if (' CALL ')'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
* SYSTEM CALL (< 0 FOR FAILURE)
WPRET_SYSPRED
         $FN = WP4SP 'if (' CALL ' >= 0)'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
WPRET_
         $FN = WP4SP CALL ';'
         $FN = WP4SP 'RETNULL;'
* END OF FUNCTION
WPDONE   $FN = '}'                                             :(RETURN)
*
WRAPPER_PROTO_END
*
* FWRAPPER
*
* MAKE WRAPPER FOR FORTRAN FUNCTION
*
* SIMILAR TO C WRAPPER, BUT:
*
*     - ALL PARAMETERS NEED TO BE COPIED
*     - STRINGS ARE PASSED AS TWO PARAMETERS
*     - STRING RETURN IS AN ADDED PARAMETER ON THE FRONT OF THE ARG
*       LIST
*
* FWRAPPER_PROTO(PROTO,FN,LEN)
*
* PROTO:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
*          FORTRAN FUNCTION TO CALL IS THE LOWERCASE VERSION
*          OF THE FUNCTION NAME WITH _ APPENDED.
* FN:      THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
*
-PUBLIC FWRAPPER_PROTO(), FORTRAN_WRAPPER_PROTO()
         DEFINE('FWRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
         DEFINE('FORTRAN_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'FWRAPPER_PROTO')                      :(FWRAPPER_PROTO_END)
*
FWRAPPER_PROTO
         $FN =
         $FN = '/* FORTRAN ' PROTO ' */'
         PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
         N = 0
         TYPES = ARRAY('0:29')
         PROTO POS(0) ')' =                                 :S(FWPEPARS)
FWPLOOP  PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
         TYPES<N> = TYPE                                       :F(WPERR)
         N = N + 1
         IDENT(C, ')')                            :S(FWPEPARS)F(FWPLOOP)
FWPEPARS WPCOPY = N
         PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
         I = 0
         $FN = NAME '( LA_ALIST ) LA_DCL'
         $FN = '{'
         $FN = IDENT(PROTO, WPREALTYPE)
+           WP4SP 'double ' REPLACE(NAME, &UCASE, &LCASE) '_();'
         $FN = IDENT(PROTO, WPSTRTYPE)
+           WP4SP 'char result[' WPMAXSTR '];' 
         EQ(WPCOPY, 0)                                     :S(FWPNOSTRS)
*
FWPLOOP2 $FN = IDENT(TYPES<I>, WPSTRTYPE)
+           WP4SP 'char arg' I '[' WPMAXSTR '];'            :S(FWPNEXT2)
         $FN = IDENT(TYPES<I>, WPLONGTYPE)
+           WP4SP 'long arg' I ';'                          :S(FWPNEXT2)
         $FN = IDENT(TYPES<I>, WPINTTYPE)
+           WP4SP 'int arg' I ';'                           :S(FWPNEXT2)
         $FN = IDENT(TYPES<I>, WPREALTYPE)
+           WP4SP 'double arg' I ';'                        :S(FWPNEXT2)
FWPNEXT2 I = I + 1
         LT(I, N)                                           :S(FWPLOOP2)
*
         I = 0
FWPCOPY                                         :($('FWPCPY_' TYPES<I>))
FWPCPY_STRING
         $FN = WP4SP
+              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
                                                             :(FWPNCOPY)
FWPCPY_LONG
         $FN = WP4SP 'arg' I ' = (long)LA_INT(' I ');'       :(FWPNCOPY)
FWPCPY_INTEGER
         $FN = WP4SP 'arg' I ' = (int)LA_INT(' I ');'        :(FWPNCOPY)
FWPCPY_REAL
         $FN = WP4SP 'arg' I ' = (double)LA_REAL(' I ');'    :(FWPNCOPY)
FWPCPY_
FWPNCOPY I = I + 1
         LT(I, N)                                            :S(FWPCOPY)
*
FWPNOSTRS
         CALL = REPLACE(NAME, &UCASE, &LCASE) '_('
         I = 0
FWPCALL  GE(I, N)                                           :S(FWPECALL)
         CALL = GT(I, 0) CALL ','               :($('FWPARG_' TYPES<I>))
FWPARG_LONG
FWPARG_INTEGER
FWPARG_REAL
         CALL = CALL '&arg' I                                :(FWPNCALL)
FWPARG_STRING
         CALL = CALL 'arg' I ', strlen(arg' I ')'
FWPNCALL I = I + 1                                            :(FWPCALL)
FWPECALL CALL = CALL ')'                           :($('FWPRET_' PROTO))
*
FWPRET_STRING
         LEN = 1024
FWPRET_STRING2
         CALL '()' = '(result, sizeof result)'             :S(FWPRETST2)
         CALL '(' = '(result, sizeof result,'
FWPRETST2
         CALL = CALL ', result'
         $FN = WP4SP 'RETSTR2((' CALL '), ' LEN ');'          :(FWPDONE)
FWPRET_LONG
FWPRET_INTEGER
         $FN = WP4SP 'RETINT(' CALL ');'                      :(FWPDONE)
FWPRET_REAL
         $FN = WP4SP 'RETREAL(' CALL ');'                     :(FWPDONE)
FWPRET_PREDICATE
         $FN = WP4SP 'if (' CALL ')'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
* SYSTEM CALL (< 0 FOR FAILURE)
FWPRET_SYSPRED
         $FN = WP4SP 'if (' CALL ' >= 0)'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
FWPRET_
         $FN = WP4SP CALL ';'
         $FN = WP4SP 'RETNULL;'
* END OF FUNCTION
FWPDONE  $FN = '}'                                             :(RETURN)
*
FWRAPPER_PROTO_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'WRAPPER.INC'
         &CODE = 1
         &CODE = 0
END
@

<<>>=
-STITL WRAPPER
-EJECT
*
************************************************************************
*                                                                      *
*    #     #  ######      #     ######   ######   #######  ######      *
*    #  #  #  #     #    # #    #     #  #     #  #        #     #     *
*    #  #  #  #     #   #   #   #     #  #     #  #        #     #     *
*    #  #  #  ######   #     #  ######   ######   #####    ######      *
*    #  #  #  #   #    #######  #        #        #        #   #       *
*    #  #  #  #    #   #     #  #        #        #        #    #      *
*     ## ##   #     #  #     #  #        #        #######  #     #     *
*                                                                      *
* WRAPPER   CREATE C CODE TO WRAP A FUNCTION FOR LOAD()'ING            *
*                                                                      *
* PHIL BUDNE, DECEMBER, 2001                                           *
*                                                                      *
************************************************************************
*
* WRAPPER.lss
*
* FMGW
*
*     STRING_FREE, FREE RETURNED STRING AFTER COPYING TO SNOBOL4
*     STRING2, REQUIRES LEN PARAMETER, COPY FIXED LENGTH
*     REMOVE HANDLE TYPE COMPLETELY
*
<<WRAPPER>>
*
* CE: .MSNOBOL4;
@
-STITL WRAPPER
-EJECT
*
-LINE 288 "WRAPPER.lss"
************************************************************************
*                                                                      *
*    #     #  ######      #     ######   ######   #######  ######      *
*    #  #  #  #     #    # #    #     #  #     #  #        #     #     *
*    #  #  #  #     #   #   #   #     #  #     #  #        #     #     *
*    #  #  #  ######   #     #  ######   ######   #####    ######      *
*    #  #  #  #   #    #######  #        #        #        #   #       *
*    #  #  #  #    #   #     #  #        #        #        #    #      *
*     ## ##   #     #  #     #  #        #        #######  #     #     *
*                                                                      *
* WRAPPER   CREATE C CODE TO WRAP A FUNCTION FOR LOAD()'ING            *
*                                                                      *
* PHIL BUDNE, DECEMBER, 2001                                           *
*                                                                      *
************************************************************************
*
* WRAPPER.lss
*
* FMGW
*
*     STRING_FREE, FREE RETURNED STRING AFTER COPYING TO SNOBOL4
*     STRING2, REQUIRES LEN PARAMETER, COPY FIXED LENGTH
*     REMOVE HANDLE TYPE COMPLETELY
*
-LINE 12 "WRAPPER.lss"
-MODULE WRAPPER
         WPMAXSTR = 1024
         WPSTRTYPE = 'STRING'
         WPSTRFREE = 'STRING_FREE'
         WPSTRTYP2 = 'STRING2'
         WPINTTYPE = 'INTEGER'
         WPLONGTYPE = 'LONG'
         WPREALTYPE = 'REAL'
         WPREDTYPE = 'PREDICATE'
         WPSPREDTYPE = 'SYSPRED'
         WPTYPES = WPLONGTYPE | WPINTTYPE | WPREALTYPE | WPSTRTYPE
         WPRTYPES = WPTYPES | WPREDTYPE | WPSPREDTYPE | WPSTRFREE |
+                   WPSTRTYP2 | ''
         WPNAME = ANY(&UCASE &LCASE '_')
+                 SPAN(&UCASE &LCASE '0123456789_')
         WPEND = ANY(',)')
         WP4SP = '    '
         WP8SP = '	'
*
* WRAPPER_STARTFILE(OUTPUT_NAME)
*
* OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VAR FOR C FILE
*
-PUBLIC WRAPPER_STARTFILE()
         DEFINE('WRAPPER_STARTFILE(FN)')        :(WRAPPER_STARTFILE_END)
*
WRAPPER_STARTFILE
         $FN = '/* Generated by WRAPPER on ' DATE() ' */'
         $FN =
         $FN = '#include "config.h"'
         $FN = '#include "h.h"'
         $FN = '#include "snotypes.h"'
         $FN = '#include "macros.h"'
         $FN = '#include "load.h"'
         $FN = '#include "equ.h"'
         $FN = '#include <string.h>'
         $FN =                                                 :(RETURN)
*
WRAPPER_STARTFILE_END
*
-PUBLIC WRAPPER_COBOL()
         DEFINE('WRAPPER_COBOL(FN)')                :(WRAPPER_COBOL_END)
*
WRAPPER_COBOL
         $FN = '#include <libcob.h>'                           :(RETURN)
*
WRAPPER_COBOL_END
*
* WRAPPER_PROTO(PROTOTYPE,OUTPUT_NAME)
*
* PROTOTYPE:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
*              C FUNCTION TO CALL IS THE LOWERCASE VERSION
*              OF THE FUNCTION NAME.
* OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
*
-PUBLIC WRAPPER_PROTO(), C_WRAPPER_PROTO(), COBOL_WRAPPER_PROTO()
-PUBLIC SCHEME_WRAPPER_PROTO()
         DEFINE('WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
         DEFINE('C_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'WRAPPER_PROTO')
         DEFINE('COBOL_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'WRAPPER_PROTO')
         DEFINE('SCHEME_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'WRAPPER_PROTO')                        :(WRAPPER_PROTO_END)
*
WRAPPER_PROTO
         $FN =
         $FN = '/* ' PROTO ' */'
         PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
         N = 0
         WPCOPY = 0
         TYPES = ARRAY('0:29')
         PROTO POS(0) ')' =                                  :S(WPEPARS)
WPLOOP   PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
         TYPES<N> = TYPE                                       :F(WPERR)
         N = N + 1
         WPCOPY = IDENT(TYPE, WPSTRTYPE) WPCOPY + 1
         IDENT(C, ')')                              :S(WPEPARS)F(WPLOOP)
WPERR    TERMINAL = 'ERROR IN PROTOTYPE: >' PROTO '<'         :(FRETURN)
WPEPARS  PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
         I = 0
         $FN = NAME '( LA_ALIST ) LA_DCL'
         $FN = '{'
         EQ(WPCOPY, 0)                                      :S(WPNOSTRS)
*
WPLOOP2  IDENT(TYPES<I>, WPSTRTYPE)                          :F(WPNEXT2)
         $FN = WP4SP 'char arg' I '[' WPMAXSTR '];'
WPNEXT2  I = I + 1
         LT(I, N)                                            :S(WPLOOP2)
*
         I = 0
WPCOPY                                           :($('WPCPY_' TYPES<I>))
WPCPY_STRING
         $FN = WP4SP
+              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
                                                              :(WPNCOPY)
WPCPY_LONG
WPCPY_INTEGER
WPCPY_REAL
WPCPY_
WPNCOPY  I = I + 1
         LT(I, N)                                             :S(WPCOPY)
*
WPNOSTRS CALL = REPLACE(NAME, &UCASE, &LCASE) '('
         I = 0
WPCALL   GE(I, N)                                            :S(WPECALL)
         CALL = GT(I, 0) CALL ','                :($('WPARG_' TYPES<I>))
WPARG_LONG
         CALL = CALL '(long)LA_INT(' I ')'                    :(WPNCALL)
WPARG_INTEGER
         CALL = CALL '(int)LA_INT(' I ')'                     :(WPNCALL)
WPARG_REAL
         CALL = CALL '(double)LA_REAL(' I ')'                 :(WPNCALL)
WPARG_STRING
         CALL = CALL 'arg' I
WPNCALL  I = I + 1                                             :(WPCALL)
WPECALL  CALL = CALL ')'                            :($('WPRET_' PROTO))
*
WPRET_STRING
         $FN = WP4SP 'RETSTR((char *)' CALL ');'               :(WPDONE)
WPRET_STRING2
         $FN = WP4SP 'RETSTR2((char *)' CALL ',' LEN ');'      :(WPDONE)
WPRET_STRING_FREE
         $FN = WP4SP 'RETSTR_FREE((char *)' CALL ');'          :(WPDONE)
WPRET_LONG
WPRET_INTEGER
         $FN = WP4SP 'RETINT(' CALL ');'                       :(WPDONE)
WPRET_REAL
         $FN = WP4SP 'RETREAL(' CALL ');'                      :(WPDONE)
WPRET_PREDICATE
         $FN = WP4SP 'if (' CALL ')'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
* SYSTEM CALL (< 0 FOR FAILURE)
WPRET_SYSPRED
         $FN = WP4SP 'if (' CALL ' >= 0)'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                                :(WPDONE)
WPRET_
         $FN = WP4SP CALL ';'
         $FN = WP4SP 'RETNULL;'
* END OF FUNCTION
WPDONE   $FN = '}'                                             :(RETURN)
*
WRAPPER_PROTO_END
*
* FWRAPPER
*
* MAKE WRAPPER FOR FORTRAN FUNCTION
*
* SIMILAR TO C WRAPPER, BUT:
*
*     - ALL PARAMETERS NEED TO BE COPIED
*     - STRINGS ARE PASSED AS TWO PARAMETERS
*     - STRING RETURN IS AN ADDED PARAMETER ON THE FRONT OF THE ARG
*       LIST
*
* FWRAPPER_PROTO(PROTO,FN,LEN)
*
* PROTO:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION
*          FORTRAN FUNCTION TO CALL IS THE LOWERCASE VERSION
*          OF THE FUNCTION NAME WITH _ APPENDED.
* FN:      THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE
*
-PUBLIC FWRAPPER_PROTO(), FORTRAN_WRAPPER_PROTO()
         DEFINE('FWRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL')
         DEFINE('FORTRAN_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL',
+           'FWRAPPER_PROTO')                      :(FWRAPPER_PROTO_END)
*
FWRAPPER_PROTO
         $FN =
         $FN = '/* FORTRAN ' PROTO ' */'
         PROTO POS(0) WPNAME . NAME '(' =                      :F(WPERR)
         N = 0
         TYPES = ARRAY('0:29')
         PROTO POS(0) ')' =                                 :S(FWPEPARS)
FWPLOOP  PROTO WPTYPES . TYPE WPEND . C =                      :F(WPERR)
         TYPES<N> = TYPE                                       :F(WPERR)
         N = N + 1
         IDENT(C, ')')                            :S(FWPEPARS)F(FWPLOOP)
FWPEPARS WPCOPY = N
         PROTO POS(0) WPRTYPES RPOS(0)                         :F(WPERR)
         I = 0
         $FN = NAME '( LA_ALIST ) LA_DCL'
         $FN = '{'
         $FN = IDENT(PROTO, WPREALTYPE)
+           WP4SP 'double ' REPLACE(NAME, &UCASE, &LCASE) '_();'
         $FN = IDENT(PROTO, WPSTRTYPE)
+           WP4SP 'char result[' WPMAXSTR '];'
         EQ(WPCOPY, 0)                                     :S(FWPNOSTRS)
*
FWPLOOP2 $FN = IDENT(TYPES<I>, WPSTRTYPE)
+           WP4SP 'char arg' I '[' WPMAXSTR '];'            :S(FWPNEXT2)
         $FN = IDENT(TYPES<I>, WPLONGTYPE)
+           WP4SP 'long arg' I ';'                          :S(FWPNEXT2)
         $FN = IDENT(TYPES<I>, WPINTTYPE)
+           WP4SP 'int arg' I ';'                           :S(FWPNEXT2)
         $FN = IDENT(TYPES<I>, WPREALTYPE)
+           WP4SP 'double arg' I ';'                        :S(FWPNEXT2)
FWPNEXT2 I = I + 1
         LT(I, N)                                           :S(FWPLOOP2)
*
         I = 0
FWPCOPY                                         :($('FWPCPY_' TYPES<I>))
FWPCPY_STRING
         $FN = WP4SP
+              'getstring(LA_PTR(' I '), arg' I ', sizeof(arg' I '));'
                                                             :(FWPNCOPY)
FWPCPY_LONG
         $FN = WP4SP 'arg' I ' = (long)LA_INT(' I ');'       :(FWPNCOPY)
FWPCPY_INTEGER
         $FN = WP4SP 'arg' I ' = (int)LA_INT(' I ');'        :(FWPNCOPY)
FWPCPY_REAL
         $FN = WP4SP 'arg' I ' = (double)LA_REAL(' I ');'    :(FWPNCOPY)
FWPCPY_
FWPNCOPY I = I + 1
         LT(I, N)                                            :S(FWPCOPY)
*
FWPNOSTRS
         CALL = REPLACE(NAME, &UCASE, &LCASE) '_('
         I = 0
FWPCALL  GE(I, N)                                           :S(FWPECALL)
         CALL = GT(I, 0) CALL ','               :($('FWPARG_' TYPES<I>))
FWPARG_LONG
FWPARG_INTEGER
FWPARG_REAL
         CALL = CALL '&arg' I                                :(FWPNCALL)
FWPARG_STRING
         CALL = CALL 'arg' I ', strlen(arg' I ')'
FWPNCALL I = I + 1                                            :(FWPCALL)
FWPECALL CALL = CALL ')'                           :($('FWPRET_' PROTO))
*
FWPRET_STRING
         LEN = 1024
FWPRET_STRING2
         CALL '()' = '(result, sizeof result)'             :S(FWPRETST2)
         CALL '(' = '(result, sizeof result,'
FWPRETST2
         CALL = CALL ', result'
         $FN = WP4SP 'RETSTR2((' CALL '), ' LEN ');'          :(FWPDONE)
FWPRET_LONG
FWPRET_INTEGER
         $FN = WP4SP 'RETINT(' CALL ');'                      :(FWPDONE)
FWPRET_REAL
         $FN = WP4SP 'RETREAL(' CALL ');'                     :(FWPDONE)
FWPRET_PREDICATE
         $FN = WP4SP 'if (' CALL ')'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
* SYSTEM CALL (< 0 FOR FAILURE)
FWPRET_SYSPRED
         $FN = WP4SP 'if (' CALL ' >= 0)'
         $FN = WP8SP 'RETNULL;'
         $FN = WP4SP 'RETFAIL;'                               :(FWPDONE)
FWPRET_
         $FN = WP4SP CALL ';'
         $FN = WP4SP 'RETNULL;'
* END OF FUNCTION
FWPDONE  $FN = '}'                                             :(RETURN)
*
FWRAPPER_PROTO_END
*
* CE: .MSNOBOL4;
<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type"
      content="text/html; charset=UTF-8">
<meta name="description"
      content="sweave generated">
</head><body><font face="Sorts Mill Goudy">
<p align="justify"><font face="Sorts Mill Goudy">
<h1>WRAPPER - Create C code to wrap a function for LOAD()ing</h1>
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
Writes a C function to do parameter and result conversion to allow
an external function to be used with <font face="Source Code Pro">LOAD()</font>.
</font></p>
<p align="justify"><font face="Sorts Mill Goudy">
<h2>Uses</h2>
</font></p>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;INCLUDES&raquo;&equiv;</b>
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;WRAPPER&raquo;&equiv;</b>
-MODULE WRAPPER
         WPMAXSTR = 1024
         WPSTRTYPE = &#39;STRING&#39;
         WPSTRFREE = &#39;STRING_FREE&#39;
         WPSTRTYP2 = &#39;STRING2&#39;
         WPINTTYPE = &#39;INTEGER&#39;
         WPLONGTYPE = &#39;LONG&#39;
         WPREALTYPE = &#39;REAL&#39;
         WPREDTYPE = &#39;PREDICATE&#39;
         WPSPREDTYPE = &#39;SYSPRED&#39;
         WPTYPES = WPLONGTYPE | WPINTTYPE | WPREALTYPE | WPSTRTYPE
         WPRTYPES = WPTYPES | WPREDTYPE | WPSPREDTYPE | WPSTRFREE |
+                   WPSTRTYP2 | &#39;&#39;
         WPNAME = ANY(&amp;UCASE &amp;LCASE &#39;_&#39;)
+                 SPAN(&amp;UCASE &amp;LCASE &#39;0123456789_&#39;)
         WPEND = ANY(&#39;,)&#39;)
         WP4SP = &#39;    &#39;
         WP8SP = &#39;	&#39;
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WRAPPER_STARTFILE(OUTPUT_NAME)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VAR FOR C FILE</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC WRAPPER_STARTFILE()
         DEFINE(&#39;WRAPPER_STARTFILE(FN)&#39;)        <b>:(WRAPPER_STARTFILE_END)</b>
<font color="#818181"><i>*</i></font>
WRAPPER_STARTFILE
         $FN = &#39;/* Generated by WRAPPER on &#39; DATE() &#39; */&#39;
         $FN =
         $FN = &#39;#include &quot;config.h&quot;&#39;
         $FN = &#39;#include &quot;h.h&quot;&#39;
         $FN = &#39;#include &quot;snotypes.h&quot;&#39;
         $FN = &#39;#include &quot;macros.h&quot;&#39;
         $FN = &#39;#include &quot;load.h&quot;&#39;
         $FN = &#39;#include &quot;equ.h&quot;&#39;
         $FN = &#39;#include &lt;string.h&gt;&#39;
         $FN =                                                 <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
WRAPPER_STARTFILE_END
<font color="#818181"><i>*</i></font>
-PUBLIC WRAPPER_COBOL()
         DEFINE(&#39;WRAPPER_COBOL(FN)&#39;)                <b>:(WRAPPER_COBOL_END)</b>
<font color="#818181"><i>*</i></font>
WRAPPER_COBOL
         $FN = &#39;#include &lt;libcob.h&gt;&#39;                           <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
WRAPPER_COBOL_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WRAPPER_PROTO(PROTOTYPE,OUTPUT_NAME)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PROTOTYPE:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION</i></font>
<font color="#818181"><i>*              C FUNCTION TO CALL IS THE LOWERCASE VERSION</i></font>
<font color="#818181"><i>*              OF THE FUNCTION NAME.</i></font>
<font color="#818181"><i>* OUTPUT_NAME: THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC WRAPPER_PROTO(), C_WRAPPER_PROTO(), COBOL_WRAPPER_PROTO()
-PUBLIC SCHEME_WRAPPER_PROTO()
         DEFINE(&#39;WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL&#39;)
         DEFINE(&#39;C_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL&#39;,
+           &#39;WRAPPER_PROTO&#39;)
         DEFINE(&#39;COBOL_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL&#39;,
+           &#39;WRAPPER_PROTO&#39;)
         DEFINE(&#39;SCHEME_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL&#39;,
+           &#39;WRAPPER_PROTO&#39;)                        <b>:(WRAPPER_PROTO_END)</b>
<font color="#818181"><i>*</i></font>
WRAPPER_PROTO
         $FN =
         $FN = &#39;/* &#39; PROTO &#39; */&#39;
         PROTO POS(0) WPNAME . NAME &#39;(&#39; =                      <b>:F(WPERR)</b>
         N = 0
         WPCOPY = 0
         TYPES = ARRAY(&#39;0:29&#39;)
         PROTO POS(0) &#39;)&#39; =                                  <b>:S(WPEPARS)</b>
WPLOOP   PROTO WPTYPES . TYPE WPEND . C =                      <b>:F(WPERR)</b>
         TYPES&lt;N&gt; = TYPE                                       <b>:F(WPERR)</b>
         N = N + 1
         WPCOPY = IDENT(TYPE, WPSTRTYPE) WPCOPY + 1
         IDENT(C, &#39;)&#39;)                              <b>:S(WPEPARS)F(WPLOOP)</b>
WPERR    TERMINAL = &#39;ERROR IN PROTOTYPE: &gt;&#39; PROTO &#39;&lt;&#39;         <b>:(FRETURN)</b>
WPEPARS  PROTO POS(0) WPRTYPES RPOS(0)                         <b>:F(WPERR)</b>
         I = 0
         $FN = NAME &#39;( LA_ALIST ) LA_DCL&#39;
         $FN = &#39;{&#39;
         EQ(WPCOPY, 0)                                      <b>:S(WPNOSTRS)</b>
<font color="#818181"><i>*</i></font>
WPLOOP2  IDENT(TYPES&lt;I&gt;, WPSTRTYPE)                          <b>:F(WPNEXT2)</b>
         $FN = WP4SP &#39;char arg&#39; I &#39;[&#39; WPMAXSTR &#39;];&#39;
WPNEXT2  I = I + 1
         LT(I, N)                                            <b>:S(WPLOOP2)</b>
<font color="#818181"><i>*</i></font>
         I = 0
WPCOPY                                           <b>:($(&#39;WPCPY_&#39; TYPES&lt;I&gt;))</b>
WPCPY_STRING
         $FN = WP4SP
+              &#39;getstring(LA_PTR(&#39; I &#39;), arg&#39; I &#39;, sizeof(arg&#39; I &#39;));&#39;
                                                              <b>:(WPNCOPY)</b>
WPCPY_LONG
WPCPY_INTEGER
WPCPY_REAL
WPCPY_
WPNCOPY  I = I + 1
         LT(I, N)                                             <b>:S(WPCOPY)</b>
<font color="#818181"><i>*</i></font>
WPNOSTRS CALL = REPLACE(NAME, &amp;UCASE, &amp;LCASE) &#39;(&#39;
         I = 0
WPCALL   GE(I, N)                                            <b>:S(WPECALL)</b>
         CALL = GT(I, 0) CALL &#39;,&#39;                <b>:($(&#39;WPARG_&#39; TYPES&lt;I&gt;))</b>
WPARG_LONG
         CALL = CALL &#39;(long)LA_INT(&#39; I &#39;)&#39;                    <b>:(WPNCALL)</b>
WPARG_INTEGER
         CALL = CALL &#39;(int)LA_INT(&#39; I &#39;)&#39;                     <b>:(WPNCALL)</b>
WPARG_REAL
         CALL = CALL &#39;(double)LA_REAL(&#39; I &#39;)&#39;                 <b>:(WPNCALL)</b>
WPARG_STRING
         CALL = CALL &#39;arg&#39; I
WPNCALL  I = I + 1                                             <b>:(WPCALL)</b>
WPECALL  CALL = CALL &#39;)&#39;                            <b>:($(&#39;WPRET_&#39; PROTO))</b>
<font color="#818181"><i>*</i></font>
WPRET_STRING
         $FN = WP4SP &#39;RETSTR((char *)&#39; CALL &#39;);&#39;               <b>:(WPDONE)</b>
WPRET_STRING2
         $FN = WP4SP &#39;RETSTR2((char *)&#39; CALL &#39;,&#39; LEN &#39;);&#39;      <b>:(WPDONE)</b>
WPRET_STRING_FREE
         $FN = WP4SP &#39;RETSTR_FREE((char *)&#39; CALL &#39;);&#39;          <b>:(WPDONE)</b>
WPRET_LONG
WPRET_INTEGER
         $FN = WP4SP &#39;RETINT(&#39; CALL &#39;);&#39;                       <b>:(WPDONE)</b>
WPRET_REAL
         $FN = WP4SP &#39;RETREAL(&#39; CALL &#39;);&#39;                      <b>:(WPDONE)</b>
WPRET_PREDICATE
         $FN = WP4SP &#39;if (&#39; CALL &#39;)&#39;
         $FN = WP8SP &#39;RETNULL;&#39;
         $FN = WP4SP &#39;RETFAIL;&#39;                                <b>:(WPDONE)</b>
<font color="#818181"><i>* SYSTEM CALL (&lt; 0 FOR FAILURE)</i></font>
WPRET_SYSPRED
         $FN = WP4SP &#39;if (&#39; CALL &#39; &gt;= 0)&#39;
         $FN = WP8SP &#39;RETNULL;&#39;
         $FN = WP4SP &#39;RETFAIL;&#39;                                <b>:(WPDONE)</b>
WPRET_
         $FN = WP4SP CALL &#39;;&#39;
         $FN = WP4SP &#39;RETNULL;&#39;
<font color="#818181"><i>* END OF FUNCTION</i></font>
WPDONE   $FN = &#39;}&#39;                                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
WRAPPER_PROTO_END
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FWRAPPER</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* MAKE WRAPPER FOR FORTRAN FUNCTION</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* SIMILAR TO C WRAPPER, BUT:</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*     - ALL PARAMETERS NEED TO BE COPIED</i></font>
<font color="#818181"><i>*     - STRINGS ARE PASSED AS TWO PARAMETERS</i></font>
<font color="#818181"><i>*     - STRING RETURN IS AN ADDED PARAMETER ON THE FRONT OF THE ARG</i></font>
<font color="#818181"><i>*       LIST</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FWRAPPER_PROTO(PROTO,FN,LEN)</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* PROTO:   A PROTOTYPE, AS PASSED TO SNOBOL LOAD() FUNCTION</i></font>
<font color="#818181"><i>*          FORTRAN FUNCTION TO CALL IS THE LOWERCASE VERSION</i></font>
<font color="#818181"><i>*          OF THE FUNCTION NAME WITH _ APPENDED.</i></font>
<font color="#818181"><i>* FN:      THE NAME (STRING) OF OUTPUT VARIABLE FOR C FILE</i></font>
<font color="#818181"><i>*</i></font>
-PUBLIC FWRAPPER_PROTO(), FORTRAN_WRAPPER_PROTO()
         DEFINE(&#39;FWRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL&#39;)
         DEFINE(&#39;FORTRAN_WRAPPER_PROTO(PROTO,FN,LEN)TYPES,I,N,C,CALL&#39;,
+           &#39;FWRAPPER_PROTO&#39;)                      <b>:(FWRAPPER_PROTO_END)</b>
<font color="#818181"><i>*</i></font>
FWRAPPER_PROTO
         $FN =
         $FN = &#39;/* FORTRAN &#39; PROTO &#39; */&#39;
         PROTO POS(0) WPNAME . NAME &#39;(&#39; =                      <b>:F(WPERR)</b>
         N = 0
         TYPES = ARRAY(&#39;0:29&#39;)
         PROTO POS(0) &#39;)&#39; =                                 <b>:S(FWPEPARS)</b>
FWPLOOP  PROTO WPTYPES . TYPE WPEND . C =                      <b>:F(WPERR)</b>
         TYPES&lt;N&gt; = TYPE                                       <b>:F(WPERR)</b>
         N = N + 1
         IDENT(C, &#39;)&#39;)                            <b>:S(FWPEPARS)F(FWPLOOP)</b>
FWPEPARS WPCOPY = N
         PROTO POS(0) WPRTYPES RPOS(0)                         <b>:F(WPERR)</b>
         I = 0
         $FN = NAME &#39;( LA_ALIST ) LA_DCL&#39;
         $FN = &#39;{&#39;
         $FN = IDENT(PROTO, WPREALTYPE)
+           WP4SP &#39;double &#39; REPLACE(NAME, &amp;UCASE, &amp;LCASE) &#39;_();&#39;
         $FN = IDENT(PROTO, WPSTRTYPE)
+           WP4SP &#39;char result[&#39; WPMAXSTR &#39;];&#39;
         EQ(WPCOPY, 0)                                     <b>:S(FWPNOSTRS)</b>
<font color="#818181"><i>*</i></font>
FWPLOOP2 $FN = IDENT(TYPES&lt;I&gt;, WPSTRTYPE)
+           WP4SP &#39;char arg&#39; I &#39;[&#39; WPMAXSTR &#39;];&#39;            <b>:S(FWPNEXT2)</b>
         $FN = IDENT(TYPES&lt;I&gt;, WPLONGTYPE)
+           WP4SP &#39;long arg&#39; I &#39;;&#39;                          <b>:S(FWPNEXT2)</b>
         $FN = IDENT(TYPES&lt;I&gt;, WPINTTYPE)
+           WP4SP &#39;int arg&#39; I &#39;;&#39;                           <b>:S(FWPNEXT2)</b>
         $FN = IDENT(TYPES&lt;I&gt;, WPREALTYPE)
+           WP4SP &#39;double arg&#39; I &#39;;&#39;                        <b>:S(FWPNEXT2)</b>
FWPNEXT2 I = I + 1
         LT(I, N)                                           <b>:S(FWPLOOP2)</b>
<font color="#818181"><i>*</i></font>
         I = 0
FWPCOPY                                         <b>:($(&#39;FWPCPY_&#39; TYPES&lt;I&gt;))</b>
FWPCPY_STRING
         $FN = WP4SP
+              &#39;getstring(LA_PTR(&#39; I &#39;), arg&#39; I &#39;, sizeof(arg&#39; I &#39;));&#39;
                                                             <b>:(FWPNCOPY)</b>
FWPCPY_LONG
         $FN = WP4SP &#39;arg&#39; I &#39; = (long)LA_INT(&#39; I &#39;);&#39;       <b>:(FWPNCOPY)</b>
FWPCPY_INTEGER
         $FN = WP4SP &#39;arg&#39; I &#39; = (int)LA_INT(&#39; I &#39;);&#39;        <b>:(FWPNCOPY)</b>
FWPCPY_REAL
         $FN = WP4SP &#39;arg&#39; I &#39; = (double)LA_REAL(&#39; I &#39;);&#39;    <b>:(FWPNCOPY)</b>
FWPCPY_
FWPNCOPY I = I + 1
         LT(I, N)                                            <b>:S(FWPCOPY)</b>
<font color="#818181"><i>*</i></font>
FWPNOSTRS
         CALL = REPLACE(NAME, &amp;UCASE, &amp;LCASE) &#39;_(&#39;
         I = 0
FWPCALL  GE(I, N)                                           <b>:S(FWPECALL)</b>
         CALL = GT(I, 0) CALL &#39;,&#39;               <b>:($(&#39;FWPARG_&#39; TYPES&lt;I&gt;))</b>
FWPARG_LONG
FWPARG_INTEGER
FWPARG_REAL
         CALL = CALL &#39;&amp;arg&#39; I                                <b>:(FWPNCALL)</b>
FWPARG_STRING
         CALL = CALL &#39;arg&#39; I &#39;, strlen(arg&#39; I &#39;)&#39;
FWPNCALL I = I + 1                                            <b>:(FWPCALL)</b>
FWPECALL CALL = CALL &#39;)&#39;                           <b>:($(&#39;FWPRET_&#39; PROTO))</b>
<font color="#818181"><i>*</i></font>
FWPRET_STRING
         LEN = 1024
FWPRET_STRING2
         CALL &#39;()&#39; = &#39;(result, sizeof result)&#39;             <b>:S(FWPRETST2)</b>
         CALL &#39;(&#39; = &#39;(result, sizeof result,&#39;
FWPRETST2
         CALL = CALL &#39;, result&#39;
         $FN = WP4SP &#39;RETSTR2((&#39; CALL &#39;), &#39; LEN &#39;);&#39;          <b>:(FWPDONE)</b>
FWPRET_LONG
FWPRET_INTEGER
         $FN = WP4SP &#39;RETINT(&#39; CALL &#39;);&#39;                      <b>:(FWPDONE)</b>
FWPRET_REAL
         $FN = WP4SP &#39;RETREAL(&#39; CALL &#39;);&#39;                     <b>:(FWPDONE)</b>
FWPRET_PREDICATE
         $FN = WP4SP &#39;if (&#39; CALL &#39;)&#39;
         $FN = WP8SP &#39;RETNULL;&#39;
         $FN = WP4SP &#39;RETFAIL;&#39;                               <b>:(FWPDONE)</b>
<font color="#818181"><i>* SYSTEM CALL (&lt; 0 FOR FAILURE)</i></font>
FWPRET_SYSPRED
         $FN = WP4SP &#39;if (&#39; CALL &#39; &gt;= 0)&#39;
         $FN = WP8SP &#39;RETNULL;&#39;
         $FN = WP4SP &#39;RETFAIL;&#39;                               <b>:(FWPDONE)</b>
FWPRET_
         $FN = WP4SP CALL &#39;;&#39;
         $FN = WP4SP &#39;RETNULL;&#39;
<font color="#818181"><i>* END OF FUNCTION</i></font>
FWPDONE  $FN = &#39;}&#39;                                             <b>:(RETURN)</b>
<font color="#818181"><i>*</i></font>
FWRAPPER_PROTO_END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;unit_test&raquo;&equiv;</b>
<font color="#818181"><i>#!/usr/bin/bash</i></font>
         exec &quot;snobol4&quot; &quot;-b&quot; &quot;$0&quot; &quot;$@&quot;
-INCLUDE &#39;WRAPPER.INC&#39;
         &amp;CODE = 1
         &amp;CODE = 0
END
<b>@</b>
</font></pre></div>
<div style="background-image: url(greenbar.gif)">
<pre><font face="Source Code Pro">
<b>&laquo;&raquo;&equiv;</b>
-STITL WRAPPER
-EJECT
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>*    #     #  ######      #     ######   ######   #######  ######      *</i></font>
<font color="#818181"><i>*    #  #  #  #     #    # #    #     #  #     #  #        #     #     *</i></font>
<font color="#818181"><i>*    #  #  #  #     #   #   #   #     #  #     #  #        #     #     *</i></font>
<font color="#818181"><i>*    #  #  #  ######   #     #  ######   ######   #####    ######      *</i></font>
<font color="#818181"><i>*    #  #  #  #   #    #######  #        #        #        #   #       *</i></font>
<font color="#818181"><i>*    #  #  #  #    #   #     #  #        #        #        #    #      *</i></font>
<font color="#818181"><i>*     ## ##   #     #  #     #  #        #        #######  #     #     *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* WRAPPER   CREATE C CODE TO WRAP A FUNCTION FOR LOAD()&#39;ING            *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>* PHIL BUDNE, DECEMBER, 2001                                           *</i></font>
<font color="#818181"><i>*                                                                      *</i></font>
<font color="#818181"><i>************************************************************************</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* WRAPPER.lss</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* FMGW</i></font>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>*     STRING_FREE, FREE RETURNED STRING AFTER COPYING TO SNOBOL4</i></font>
<font color="#818181"><i>*     STRING2, REQUIRES LEN PARAMETER, COPY FIXED LENGTH</i></font>
<font color="#818181"><i>*     REMOVE HANDLE TYPE COMPLETELY</i></font>
<font color="#818181"><i>*</i></font>
<b>&laquo;WRAPPER&raquo;</b>
<font color="#818181"><i>*</i></font>
<font color="#818181"><i>* CE: .MSNOBOL4;</i></font>
<b>@</b>
</font></pre></div>
<footer><hr><table width="100%" border="0">
<tr><td><p align=left>
Produced by <code>sweave</code>
</p></td><td><p align=center>
Sun Jun  8 20:38:06 EDT 2014</p></td><td><p align=right>
Return to <a href="index.html">index</a>
</p></td></table></footer>
</font></body></html>
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'WRAPPER.INC'
-LINE 279 "WRAPPER.lss"
         &CODE = 1
         &CODE = 0
END
