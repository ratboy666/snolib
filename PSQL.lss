<h1>PSQL - Interface to PostgreSQL</h1>

Interface to PostgreSQL. Uses <i>psql</i>. This is a crude
implementation because we want to be able to quickly modify the
API. [[SELECT]] results should be directly compatible with HTML
templating.  This is a thin layer on top of <i>psql</i>.

[[PSQL = SEND(PSQL_CLASS,'NEW')]] creates a new PSQL object.

[[SEND(PSQL,'OPEN')]] opens the connection to PSQL.  [[PIPE =
SEND(PSQL,'GET_PIPE')]] returns a pipe that can be written to with
[[$PIPE = 'sql statement;']].  After a command is written to the
pipe, [[SEND(PSQL,'OUTPUT')]] gathers the results and removes the
command echo. Results can be processed by function [[PSQL_RESULT()]]
which returns an [[ARRAY]] of [[TABLE]]s or [[NULL]] if no results
are available.  If there are no result rows, message 'OUTPUT' will
return [[NULL]].

If command output is not needed, [[SEND(PSQL,'DISCARD')]] can be
used. Either message 'OUTPUT' or 'DISCARD' must be used after a
command is issued, because data from <i>psql</i> must be read, and
we have to wait for the next prompt. Multiple line commands can be
issued. The command will be executed on receiving the ‘[[;]]’
command delimiter, or at the end of the line for ‘[[\]]’ commands
(for example, to establish a different database or user).

A [[TABLE]] can be passed to [[PSQL_INSERT()]] which will convert it
to [[(NAME,...) VALUES (VALUE,...)]] ready to be combined into an SQL
[[INSERT]] statement.

Function [[PSQL_INSERT()]] uses [[PSQL_ESCAPE()]] to escape and
quote SQL strings.  [[PSQL_INSERT()]] can also be used to display
the contents of a [[PSQL TABLE]].

[[SEND(PSQL,'CLOSE')]] closes the connection to <i>psql</i>.

{{
It would be useful to catch the error, so we should probably use
[[PSQL_OUTPUT()]] from [[PSQL_OPEN()]]. Not being done now, and
will probably never be done because this should use a socket level
interface.
}}

[[&ERRLIMIT]] is used to prevent error code 11 if (for example), the
PostgreSQL server is not running. If the server is not running, output
is sent back from the first result of reading [[PSQL_PIPE]] with the
error message (in [[PSQL_DISCARD]]). We throw the error message away.
After the error message, the next read causes an error because the
psql process is no longer running. Setting [[&ERRLIMIT]] converts
the error into a failure, which is propagated back to [[PSQL_OPEN()]]
and the calling program.

<h2>Uses</h2>
<a href="BRKREM.html">BRKREM</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="COUNT.html">COUNT</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="REPL.html">REPL</a><br>
<a href="SCOOP.html">SCOOP</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>
<a href="UNIQUE.html">UNIQUE</a><br>

<h2>See Also</h2>
<a href="HASH.html">HASH</a><br>
<a href="CSNOBOL4.html">CSNOBOL4</a><br>
<a href="BQ.html">BQ</a>

<<INCLUDES>>=
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'COUNT.INC'
-INCLUDE 'CSNOBOL4.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'SCOOP.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'UNIQUE.INC'
@

We use a [[PTY]] to communicate with <i>psql</i>. This shouldn't be
necessary, a simple bi-directional pipe should be sufficient. The
protocol is to allow the caller to write to the pipe. The final
thing written should activate the command. If a pipe is used for
communication, when the 'DISCARD' or 'OUTPUT' message is sent, an
echo command is used to generate a marker for the end of input.

If a [[PTY]] is used, the marker is generated by modifying the
<i>psql</i> prompts ([[PROMPT1]] and [[PROMPT2]]). Command echo has
to be stripped in the [[PSQL_OUTPUT()]] function as well.

{{
If pipes are used, this PSQL implementation fails with [[errno = 29]]
([[ESPIPE]], seek on pipe).  The interpreter was modified to display
errno in these cases. I suspect that this has to do with process
timing. Using the [[PTY]] appears reliable.
}}

For performance reasons using [[PTY]] may not be a desirable
solution. CSNOBOL4 now uses [[FFI]] to allow access to [[io_getfp()]]
which returns the [[FILE *]] (C library file pointer) associated with
a unit. Also [[fileno()]] is published which returns the underlying
[[fd]] (file descriptor) for a [[FILE *]]. These can be used to
generate alternate I/O routines later.

Pipes work, but the best solution would be to use a socket level
interface to PostgreSQL.

Performance is 500 to 1,000 SQL statements per second on my netbook
(1.6Ghz Atom) and 1,000 to 3,000 statements per second (1.4Ghz Intel
i3).  This is far from stellar. SQL commands are always parsed since
the interface is via the <i>psql</i> utility. A direct socket interface
would be helpful, but this current interface should be sufficient
for the near term. The <i>psql</i> process is started and can be left
open for a long duration (for the entire application execution).

<<PSQL>>=
-MODULE PSQL
%SET (USE_PTY,1)
*
* THESE THREE ARE FUNCTIONS -- SIMPLY EASIER THAT WAY.
*
-PUBLIC PSQL_INSERT(), PSQL_RESULT(), PSQL_ESCAPE()
         DEFINE('PSQL_INSERT(T)N,V,I')
         DEFINE('PSQL_RESULT(S)I,N,R,T,KEY,DAT')
         DEFINE('PSQL_ESCAPE(S)')
*
* CREATE CLASS PSQL_CLASS AND POPULATE ITS METHODS
*
-PUBLIC CLASS:PSQL_CLASS
         PSQL_CLASS = SEND(CLASS, 'NEW_CLASS', 'PSQL_CLASS')
         DEFINE('PSQL_OPEN()L')
-PUBLIC PSQL_CLASS:'OPEN'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'OPEN', 'PSQL_OPEN')
         DEFINE('PSQL_CLOSE()PID')
-PUBLIC PSQL_CLASS:'CLOSE'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'CLOSE', 'PSQL_CLOSE')
-PUBLIC PSQL_CLASS:'GET_PIPE'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'GET_PIPE', CODE(
+           ' SEND = |.PIPE :(RETURN)'))
         DEFINE('PSQL_DISCARD()L')
-PUBLIC PSQL_CLASS:'DISCARD'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'DISCARD', 'PSQL_DISCARD')
         DEFINE('PSQL_OUTPUT()L')
-PUBLIC PSQL_CLASS:'OUTPUT'
         SEND(PSQL_CLASS, 'ADD_METHOD', 'OUTPUT', 'PSQL_OUTPUT')
*
                                                             :(PSQL_END)
*
* CONVERT TABLE TO "(NAME, ...) VALUES (DATA, ...)" READY FOR SQL
* INSERT. USES PSQL_ESCAPE() TO ENSURE THAT VALUES ARE QUOTED CORRECTLY.
*
PSQL_INSERT
         T = CONVERT(T, 'ARRAY')
         SEQ(' N = N T<I, 1> ", "; '
+            ' V = V PSQL_ESCAPE(T<I, 2>) ", " ', .I)
         IDENT(N)                                            :S(FRETURN)
         N ', ' RPOS(0) =
         V ', ' RPOS(0) =
         PSQL_INSERT = '(' N ') VALUES (' V ')'                :(RETURN)
*
* CONVERT PSQL_OUTPUT() INTO ARRAY OF TABLES
*
PSQL_RESULT
         IDENT(S)                                            :S(FRETURN)
         S = S CHARS_NL
         N = COUNT(S, CHARS_NL CHARS_NL)
         EQ(N)                                               :S(FRETURN)
         PSQL_RESULT = ARRAY(N)
PSQL5    S POS(0) ARB . T CHARS_NL CHARS_NL REM . S           :F(RETURN)
         R = TABLE()
PSQL6    T POS(0) BREAK('|') . KEY '|'
+          BRKREM(CHARS_NL) . DAT (CHARS_NL | RPOS(0)) =       :F(PSQL7)
         R<KEY> = DAT                                           :(PSQL6)
PSQL7    I = I + 1
         PSQL_RESULT<I> = R                                     :(PSQL5)
*
* ESCAPE AND QUOTE AN SQL STRING
*
PSQL_ESCAPE
         PSQL_ESCAPE = "'" REPL(S, "'", "''") "'"              :(RETURN)
*
* DISCARD OUTPUT FROM LAST SQL COMMAND.
*
PSQL_DISCARD
%IF (USE_PTY)
         L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                  :S(RETURN)F(PSQL_DISCARD)
%ELSE
         $|.PIPE = '\echo *'                                 :F(FRETURN)
PSQL_D2  L = $|.PIPE
         L POS(0) '*' RPOS(0)                       :S(RETURN)F(PSQL_D2)
%ENDIF
*
* GATHER AND RETURN OUTPUT FROM SQL COMMAND. DISCARD COMMAND ECHO,
* RETURNING ONLY RESULTS.
*
PSQL_OUTPUT
%IF (USE_PTY)
PSQL2    L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                                  :S(PSQL3)
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
PSQL3    PSQL_OUTPUT CHARS_NL CHARS_NL RPOS(0) = CHARS_NL      :S(PSQL3)
PSQL4    PSQL_OUTPUT BREAK(CHARS_NL) CHARS_NL REM . PSQL_OUTPUT
+                                                            :F(FRETURN)
         PSQL_OUTPUT POS(0) '# '                      :S(PSQL4)F(RETURN)
%ELSE
         $|.PIPE = '\echo *'                                 :F(FRETURN)
PSQL2    L = $|.PIPE                                         :F(FRETURN)
         L POS(0) '*' RPOS(0)                                 :S(RETURN)
         PSQL_OUTPUT = PSQL_OUTPUT L CHARS_NL                   :(PSQL2)
%ENDIF
*
* OPEN PSQL COMMAND. SEND COMMANDS TO MAKE PSQL_OUTPUT() EASIER,
* PSQL_RESULT() FOR PARSING SELECT RESULTS AND BUILDING RESULT ARRAYS.
*
PSQL_OPEN
         |.UNIT = IO_FINDUNIT()                              :F(FRETURN)
         |.PIPE = UNIQUE()
%IF (USE_PTY)
         INPUT(|.PIPE, |.UNIT, 'U', '||/usr/bin/psql -q')    :F(FRETURN)
%ELSE
         INPUT(|.PIPE, |.UNIT, 'U', '|/usr/bin/psql -q')     :F(FRETURN)
%ENDIF
         OUTPUT(|.PIPE, |.UNIT)                              :F(FRETURN)
%IF (USE_PTY)
         $|.PIPE = "\set PROMPT1 '\n*\n'"                    :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\set PROMPT2 '# '"                       :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
%ENDIF
         $|.PIPE = "\pset pager off"                         :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\a"                                      :F(FRETURN)
         SELF('DISCARD')                                     :F(FRETURN)
         $|.PIPE = "\x on"                                   :F(FRETURN)
         SELF('DISCARD')                            :F(FRETURN)S(RETURN)
*
* CLOSE PSQL
*
PSQL_CLOSE
         $|.PIPE = '\q'                                      :F(FRETURN)
         ENDFILE(|.UNIT)                                     :F(FRETURN)
         DETACH(|.PIPE)                                      :F(FRETURN)
*
* ENDFILE() CLOSES PSQL. INDEED, WE SEND A QUIT COMMAND (\q) FIRST!
* BUT... THE CLOSE CODE IN THE INTERPRETER DOES NOT REAP THE ZOMBIE.
* WAIT() IS DEFINED IN CSNOBOL4, USE WAIT() TO REAP. THIS IS WRONG,
* WE MAY REAP THE WRONG PROCESS! SHOULD FIX THIS IN IO.C - THE CODE
* IS IN IO.C, BUT ISN'T WORKING (?)
*
         PID = WAIT()                               :S(RETURN)F(FRETURN)
*
PSQL_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'TIMER.INC'
-INCLUDE 'PSQL.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'DDT.INC'
*        DDT()
         &CODE = 1
*
* CREATE THE PSQL OBJECT
*
         PSQL = SEND(PSQL_CLASS, 'NEW')
*
* OPEN THE PSQL CONNECTION. NOTE THE &ERRLIMIT SETTING TO PREVENT
* PROBLEMS IF THE POSTGRESQL SERVER CANNOT BE REACHED.
*
         &ERRLIMIT = 1
         SEND(PSQL, 'OPEN')
*
* GET THE PIPE NAME CONNECTING TO PSQL
*
         P = SEND(PSQL, 'GET_PIPE')
*
* A SIMPLE PSQL COMMAND
*
         $P = "SELECT version();"                                :F(END)
         OUTPUT = SEND(PSQL, 'OUTPUT')                           :F(END)
*
* ANOTHER COMMAND
*
         $P = "SELECT 1 + 1;"                                    :F(END)
         OUTPUT = SEND(PSQL, 'OUTPUT')                           :F(END)
*
* CREATE THE WEATHER TABLE. DROP IT FIRST IN CASE IT EXISTS
*
         $P = "DROP TABLE weather;"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
         $P = "CREATE TABLE weather ("
         $P = "  city    VARCHAR(80),"
         $P = "  temp_lo INT,         -- low temperature"
         $P = "  temp_hi INT,         -- high temperature"
         $P = "  prcp    REAL,        -- precipitation"
         $P = "  date    DATE"
         $P = ");"
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* INSERT TWO ROWS INTO THE WEATHER TABLE
*
         $P = "INSERT INTO weather"                              :F(END)
         $P = PSQL_INSERT(
+           #("city=San Francisco,temp_lo=46,temp_hi=50,prcp=0.25,"
+           "date=1994-11-27")) ";"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
         $P = "INSERT INTO weather"                              :F(END)
         $P = PSQL_INSERT(
+           #"city=Hayward,temp_lo=37,temp_hi=55,date=1994-11-29")
+           ";"                                                  :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* SELECT FROM WEATHER TABLE, FOR A CITY THAT DOESN'T EXIST. WE EXPECT
* NO RESULTS FROM THIS
*
         $P = "SELECT * FROM weather"                            :F(END)
         $P = "WHERE city = 'xx';"                               :F(END)
         S = SEND(PSQL, 'OUTPUT')                                :F(END)
         IDENT(S)                                                :F(END)
*
* SELECT EVERYTHING FROM TABLE WEATHER. WE EXPECT TWO ROWS. NOTE THE
* USE OF PSQL_INSERT() TO FORMAT A ROW FOR DEBUG DISPLAY
*
         $P = "SELECT * FROM weather;"                           :F(END)
         R = PSQL_RESULT(SEND(PSQL, 'OUTPUT'))                   :F(END)
         EQ(PROTOTYPE(R), 2)                                     :F(END)
         OUTPUT = PSQL_INSERT(R<1>)                              :F(END)
         OUTPUT = PSQL_INSERT(R<2>)                              :F(END)
*
* USE 'AS' TO NAME A RESULT COLUMNS. RETRIEVE THE RESULT AND DISPLAY
*
         $P = 'SELECT 1 + 1 AS result;'                          :F(END)
         T = PSQL_RESULT(SEND(PSQL, 'OUTPUT'))                   :F(END)
         EQ(T<1><'result'>, 2)                                   :F(END)
         OUTPUT = T<1><'result'>
*
* SOME TIMING
*
* TIME SIMPLE SELECT AND RESULT ANALYSIS
*
         TIMER(" $P = 'SELECT 1 + 1 AS result;'; "
+              " T = PSQL_RESULT(SEND(PSQL, 'OUTPUT')) ")
*
* A SIMPLE SELECT, DISCARDING RESULTS
*
         TIMER(" $P = 'SELECT 1 + 1 AS result;'; "
+              " SEND(PSQL, 'DISCARD') ")
*
* A TABLE SELECT, AND RESULT ANALYSIS
*
         TIMER(" $P = 'SELECT * FROM weather;'; "
+              " R = PSQL_RESULT(SEND(PSQL, 'OUTPUT')) ")
*
* A TABLE SELECT, DISCARDING RESULTS
*
         TIMER(" $P = 'SELECT * FROM weather;'; "
+              " SEND(PSQL, 'DISCARD') ")
*
* DROP THE WEATHER TABLE
*
         $P = "DROP TABLE weather;"                              :F(END)
         SEND(PSQL, 'DISCARD')                                   :F(END)
*
* CLOSE PSQL, FREEING THE PIPE AND UNIT
*
         SEND(PSQL, 'CLOSE')                                     :F(END)
*
* SEE IF WE HAVE ANY ZOMBIES
*
         OUTPUT = BQ('ps ax | grep " Z "')
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL PSQL
-EJECT
*
************************************************************************
*                                                                      *
*                  ######    #####    #####   #                        *
*                  #     #  #     #  #     #  #                        *
*                  #     #  #        #     #  #                        *
*                  ######    #####   #     #  #                        *
*                  #              #  #   # #  #                        *
*                  #        #     #  #    #   #                        *
*                  #         #####    #### #  #######                  *
*                                                                      *
* PSQL                 INTERFACE TO POSTGRESQL                         *
*                                                                      *
************************************************************************
*
* PSQL.lss
*
<<PSQL>>
*
* CE: .F.MSNOBOL4;
@
