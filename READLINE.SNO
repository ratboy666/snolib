-MODULE READLINE
-STITL READLINE
-EJECT
-LINE 166 "READLINE.lss"
*
************************************************************************
*                                                                      *
*  ######   #######     #     ######   #        ###  #     #  #######  *
*  #     #  #          # #    #     #  #         #   ##    #  #        *
*  #     #  #         #   #   #     #  #         #   # #   #  #        *
*  ######   #####    #     #  #     #  #         #   #  #  #  #####    *
*  #   #    #        #######  #     #  #         #   #   # #  #        *
*  #    #   #        #     #  #     #  #         #   #    ##  #        *
*  #     #  #######  #     #  ######   #######  ###  #     #  #######  *
*                                                                      *
* READLINE                 READLINE FUNCTIONS                          *
*                                                                      *
* PHIL BUDNE <PHIL@ULTIMATE.COM>                                       *
* JANUARY 3, 2011                                                      *
*                                                                      *
************************************************************************
*
* READLINE.lss
*
-LINE 13 "READLINE.lss"
-SNOBOL SLOAD('BQ.INC')
-LINE 14 "READLINE.lss"
-SNOBOL SLOAD('DYNAMIC.INC')
-LINE 15 "READLINE.lss"
-SNOBOL SLOAD('WRAPPER.INC')
-LINE 16 "READLINE.lss"
-SNOBOL SLOAD('CRACK.INC')
-LINE 17 "READLINE.lss"
-SNOBOL SLOAD('SEQ.INC')
-LINE 18 "READLINE.lss"
-SNOBOL TERMINAL = 'READLINE (MON NOV 11 12:50:40 EST 2013)'
-LINE 19 "READLINE.lss"
-LINE 22 "READLINE.lss"
-EMBED C 'editline'
#line 26 "READLINE.lss"
-SNOBOL WRAPPER_STARTFILE(.EMBED)
#line 27 "READLINE.lss"

/* Adds some functions enhancing CSNOBOL4 READLINE().
 *
 * EDITLINE(PROMPT, LINE)STRING uses gnu readline to edit a line
 * RLAPPNAME(NAME) sets the appname for readline, allowing readline
 *     config to conditionally configure for application.
 * CLEAR_HISTORY() clears history
 * STIFLE_HISTORY(INTEGER) stifles history to (max) n items
 * READ_HISTORY(STRING)INTEGER reads history from fname
 * WRITE_HISTORY(STRING)INTEGER writes history to fname
 *
 * Base code generated by WRAPPER on 11/01/2013 15:30:10
 */

#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <readline/history.h>

static char *editline_s = NULL;

static int prehook(void)
{
    rl_insert_text(editline_s);
    rl_beg_of_line(0, 0);
    rl_redisplay();
    return 1;
}

/* EDITLINE(STRING,STRING)STRING_FREE
 *
 * First STRING is the prompt, second string is the initial value
 */
EDITLINE( LA_ALIST ) LA_DCL
{
    void *old = rl_pre_input_hook;
    char *result;
    char prompt[1024];
    char initial_line[1024];
    getstring(LA_PTR(0), prompt, sizeof(prompt));
    getstring(LA_PTR(1), initial_line, sizeof(initial_line));
    editline_s = initial_line;
    rl_pre_input_hook = prehook;
    result = readline(prompt);
    rl_pre_input_hook = old;
    RETSTR_FREE(result);
}

RLAPPNAME( LA_ALIST) LA_DCL
{
    static char rlapp[1024];
    getstring(LA_PTR(0), rlapp, sizeof(rlapp));
    rl_readline_name = rlapp;
    RETNULL;
}

CLEAR_HISTORY( LA_ALIST ) LA_DCL
{
    clear_history();
    RETNULL;
}

STIFLE_HISTORY( LA_ALIST ) LA_DCL
{
    stifle_history(LA_INT(0));
    RETNULL;
}

READ_HISTORY( LA_ALIST ) LA_DCL
{
    char *s;
    char fname[1024];
    getstring(LA_PTR(0), fname, sizeof(fname));
    if (strlen(fname) == 0)
	s = NULL;
    else
	s = fname;
    RETINT(read_history(s));
}

WRITE_HISTORY( LA_ALIST ) LA_DCL
{
    char *s;
    static char fname[1024];
    getstring(LA_PTR(0), fname, sizeof(fname));
    if (strlen(fname) == 0)
	s = NULL;
    else
	s = fname;
    RETINT(write_history(s));
}
-END
-LINE 122 "READLINE.lss"
-SNOBOL DYNAMIC_DEBUG = 1
-LINE 123 "READLINE.lss"
-SNOBOL COMPILE_DYNAMIC(editline) :F(ERROR) ;
-LINE 124 "READLINE.lss"
-SNOBOL LIBS = '-lreadline'
-LINE 125 "READLINE.lss"
-SNOBOL OBJECTS = editline ; OBJECTS '.c' = '.o'
-LINE 126 "READLINE.lss"
-SNOBOL LINK_DYNAMIC('./editline', OBJECTS, LIBS) :F(ERROR) ;
-LINE 127 "READLINE.lss"
-CMNT ERASE TEMPORARY FILES
-CMNT     WE DON'T NEED THE C BITS, OR THE OBJECT FILES ANYMORE.
-CMNT     ALL WE REQUIRE IS editline.so
-CMNT -SNOBOL A = CRACK(editline ' ' OBJECTS, ' ')
-CMNT -SNOBOL SEQ(' DELETE(A<K>) ', .K)
-LINE 136 "READLINE.lss"
-PUBLIC READLINE(), ADD_HISTORY(), HISTORY_EXPAND()
READLINE LOAD('READLINE(STRING)STRING')
         LOAD('ADD_HISTORY(STRING)STRING')
         LOAD('HISTORY_EXPAND(STRING)STRING')
*
-PUBLIC EDITLINE(), RLAPPNAME(), CLEAR_HISTORY(), STIFLE_HISTORY()
-PUBLIC READ_HISTORY(), WRITE_HISTORY()
         LOAD('EDITLINE(STRING,STRING)STRING', 'editline.so')
         LOAD('RLAPPNAME(STRING)', 'editline.so')
         LOAD('CLEAR_HISTORY()', 'editline.so')
         LOAD('STIFLE_HISTORY(INTEGER)', 'editline.so')
         LOAD('READ_HISTORY(STRING)INTEGER', 'editline.so')
         LOAD('WRITE_HISTORY(STRING)INTEGER', 'editline.so')
*
         CODE('READLINE')
*
* CE: .MSNOBOL4;
