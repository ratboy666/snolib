<h1>SESSION - CGI SESSION Support</h1>

CGI support functions for session handling.

Session handling. Session variables are stored in a table.  Scalar
string and numeric variables can be persisted. The table contains
control entries [[UUID]], [[EXPIRE_TIME]] and [[EXPIRE]]. [[UUID]] is
the unique identifier for this session (generated by [[uuid -v1]]). The
filename that the session is saved to is [[session_UUID.db]] in
directory [[SESSION_PERSIST_DIR]].

[[EXPIRE_TIME]] is the number of seconds for the expiration of
the session file. Default if not specified is 10 minutes (600)
[[EXPIRE_TIME]] can be something like 31536000 (one year) to
effectively create a permanent session file.

[[EXPIRE]] is the time after which the file should be expired. It is
in seconds after the Unix epoch (in UTC).

[[SESSION_TOUCH(SESSION)]] updates the [[EXPIRE]]
variable. [[SESSION_CREATE(EXPIRE_TIME)]] creates a new
session.  [[SESSION_PERSIST(SESSION)]] saves the session to
disk. [[SESSION_LOAD(UUID)]] loads the session from disk.

[[SESSION_TOUCH(SESSION)]] is called automatically from
[[SESSION_PERSIST(SESSION)]] and so normally doesn't need to be
called directly. [[SESSION_DELETE(SESSION)]] removes the session from
disk. [[SESSION_EXPIRE(SESSION)]] expires the session files in the
session file directory ([[SESSION_PERSIST_DIR]])

Only numbers and strings can be persisted. Other objects should be
serialized when stored into the SESSION table (arrays, tables, data).
This may be done with [[JSON]] (or other means, if appropriate).

Using [[apache]], under [[systemd]], [[/tmp/session_...]]
gets redirected to [[/tmp/systemd-private-09Kkk/tmp...]]  (for
example). This redirection happens with (eg) [[touch /tmp/afile]]
as well (if [[touch]] is launched from the [[CGI]] script). For this
reason [[SESSION_PERSIST_DIR]] is set to the directory we want the
persisted sessions to be stored in, and is [[/var/lib/SESSION/]]
by default.

[[SESSION_LOAD()]] sanitizes its incoming [[UUID]]. Character set
[[0-9 a-f]] and [['-']] is enforced. Single and double quotes are
stripped, spaces and tabs are removed.

After the session is created, the [[UUID]] is expected to always be
generated from the client. The server should only examine the session
files for expiry, and to load them based on client direction. A client
could attempt to load another clients session, by altering the [[UUID]]
sent. This may be a potential security issue. Possible mitigations
would be to store the client IP address within the session, and to
ensure that the client IP is the same after loading. This issue is
left to the calling program to resolve. Since [[uuid]] would only
partially validate the [[UUID]], we do not use [[uuid]] for validation.
If the session file exists, [[SESSION_LOAD()]] will load it, and an
additional validation should be made (like IP validation). This may
not be practical for very long-lived sessions (that would persist
across client machines, for example). That data should probably be
stored as cookies only, or be accessed from a more permanent database
store (and then put into a session).

<h2>See Also</h2>
<a href="JSON.html">JSON</a>

<h2>Uses</h2>
<a href="BQ.html">BQ</a><br>
<a href="NDBM.html">NDBM</a><br>
<a href="SEQ.html">SEQ</a><br>
<a href="CRACK.html">CRACK</a><br>
<a href="HASH.html">HASH</a><br>
<a href="TIME.html">TIME</a><br>
<a href="CHARS.html">CHARS</a><br>
<a href="REPL.html">REPL</a>

<<INCLUDES>>=
-INCLUDE 'BQ.INC'
-INCLUDE 'NDBM.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'HASH.INC'
-INCLUDE 'TIME.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'REPL.INC'
@

<<SESSION>>=
         DEFINE('SESSION_CREATE(EXPIRE_TIME)')
         DEFINE('SESSION_DELETE(SESSION)')
         DEFINE('SESSION_TOUCH(SESSION)')
         DEFINE('SESSION_PERSIST(SESSION)FILE,HANDLE,A,I')
         DEFINE('SESSION_LOAD(UUID)FILE,HANDLE,KEY,DATA,I')
         DEFINE('SESSION_EXPIRE()SESSION,TIME,UUID,L,I,S,P')
*
         SESSION_PERSIST_DIR = '/var/lib/SESSION/'
                                                          :(SESSION_END)
*
* CREATE NEW SESSION. GENERATE UUID FOR SESSION. DEFAULT SESSION
* EXPIRATION TO 10 MINUTES (UNLESS SPECIFIED).
*
SESSION_CREATE
         SESSION_CREATE = TABLE()
         SESSION_CREATE<'UUID'> = BQ('/usr/bin/uuid -v1')    :F(FRETURN)
         EXPIRE_TIME = IDENT(EXPIRE_TIME) 600
         SESSION_CREATE<'EXPIRE_TIME'> = EXPIRE_TIME           :(RETURN)
*
* TOUCH THE SESSION; SETS THE 'EXPIRE' TIME FOR NOW + EXPIRE_TIME.
*
SESSION_TOUCH
         IDENT(SESSION)                                      :S(FRETURN)
         SESSION<'EXPIRE'> = TV_SEC(GETTIMEOFDAY()) +
+                            SESSION<'EXPIRE_TIME'>            :(RETURN)
*
* PERSIST SESSION TO DISK. SCALAR VARIABLES ONLY. ARRAYS AND TABLES
* ARE NOT PERSISTED (ONLY AS THEY PRINT).
*
SESSION_PERSIST
         FILE = SESSION_PERSIST_DIR 'session_' SESSION<'UUID'>
         SESSION_DELETE(SESSION)
         SESSION_TOUCH(SESSION)                              :F(FRETURN)
         A = CONVERT(SESSION, 'ARRAY')                       :F(FRETURN)
         HANDLE = DBM_OPEN(FILE, 'CW', '0660')               :F(FRETURN)
         SEQ(' DBM_STORE('
+                 'HANDLE, A<I, 1>, VDIFFER(A<I, 2>), DBM_INSERT) ', .I)
         A<I>                                                :S(FRETURN)
         DBM_CLOSE(HANDLE)                          :S(RETURN)F(FRETURN)
*
* DELETE SESSION
*
SESSION_DELETE
         DELETE(SESSION_PERSIST_DIR 'session_' SESSION<'UUID'> '.db')
+                                                              :(RETURN)
*
* LOAD SESSION GIVEN UUID. USUALLY, THE UUID COMES FROM A COOKIE.
*
SESSION_LOAD
         UUID = REPL(UUID, ' ', '')
         UUID = REPL(UUID, CHARS_TAB, '')
         UUID = REPLACE(UUID, &UCASE, &LCASE)
         UUID POS(0) ANY('"' "'") REM . UUID
         UUID POS(0) SPAN(&DIGITS 'abcdef-') . UUID
*
         SESSION_LOAD = TABLE()
         FILE = SESSION_PERSIST_DIR 'session_' UUID
         HANDLE = DBM_OPEN(FILE, 'R')                        :F(FRETURN)
         KEY = DBM_FIRSTKEY(HANDLE)                    :F(SESSION_LOAD2)
         SEQ(' DATA = DBM_FETCH(HANDLE, KEY);'
+            ' SESSION_LOAD<KEY> = DATA;'
+            ' KEY = DBM_NEXTKEY(HANDLE) ', .I)
         DBM_CLOSE(HANDLE)                                   :F(FRETURN)
         IDENT(UUID, SESSION_LOAD<'UUID'>)          :S(RETURN)F(FRETURN)
SESSION_LOAD2
         DBM_CLOSE(HANDLE)                                    :(FRETURN)
*
* REMOVE EXPIRED SESSIONS FROM DISK.
*
SESSION_EXPIRE
         L = BQ('ls ' SESSION_PERSIST_DIR 'session_*.db 2>/dev/null')
+                                                             :F(RETURN)
         TIME = TV_SEC(GETTIMEOFDAY())
         L = CRACK(L, ' ')
         P = SESSION_PERSIST_DIR 'session_' BREAK('.') . UUID '.db'
SESSION_EXPIRE2
         I = I + 1
         S = L<I>                                             :F(RETURN)
         S P                                                  :F(RETURN)
         SESSION = SESSION_LOAD(UUID)                :F(SESSION_EXPIRE2)
         GE(SESSION<'EXPIRE'>, TIME)                 :S(SESSION_EXPIRE2)
         SESSION_DELETE(SESSION)                      :(SESSION_EXPIRE2)
*
SESSION_END
@

<<unit_test>>=
#!/usr/bin/bash
         exec "snobol4" "-b" "$0" "$@"
-INCLUDE 'SESSION.INC'
         &CODE = 1
* REMOVE ALL SESSIONS
         BQ('rm -f ' SESSION_PERSIST_DIR 'session_*.db')
* EXPIRE, EMPTY SESSIONS
         SESSION_EXPIRE()
* CREATE A 'PERMANENT' SESSION (1 YEAR EXPIRY)
         SESSION = SESSION_CREATE(31536000)
         UUID1 = SESSION<'UUID'>
         SESSION<'VAR'> = 'FIRST'
* PERSIST THE SESSION
         SESSION_PERSIST(SESSION)                                :F(END)
* EXPIRE, SHOULDN'T DO ANYTHING
         SESSION_EXPIRE()
* CREATE A SHORT-LIVED SESSION, 5 SECONDS. NOTE THAT THE UNIT TEST
* WILL TAKE AT LEAST THIS TIME TO RUN.
         SESSION = SESSION_CREATE(5)
         UUID2 = SESSION<'UUID'>
         SESSION<'VAR'> = 'SECOND'
         SESSION_PERSIST(SESSION)                                :F(END)
* LOAD AND CHECK FIRST SESSION
         SESS = SESSION_LOAD(UUID1)                              :F(END)
         IDENT(SESS<'VAR'>, 'FIRST')                             :F(END)
* LOAD AND CHECK SECOND SESSION
         SESS = SESSION_LOAD(UUID2)                              :F(END)
         IDENT(SESS<'VAR'>, 'SECOND')                            :F(END)
* WAIT LONGER THAN 5 SECONDS (EXPIRY TIME OF SECOND SESSION)
         SLEEP(6)
* EXPIRE, SHOULD REMOVE SECOND SESSION
         SESSION_EXPIRE()
* TRY LOADING SESSIONS, UUID2 SHOULD BE EXPIRED AND FAIL
         SESSION = SESSION_LOAD(UUID2)                           :S(END)
         SESSION = SESSION_LOAD(UUID1)                           :F(END)
* DELETE SESSION UUID1
         SESSION_DELETE(SESSION)
* SESSION UUID1 SHOULD NOW FAIL WHEN LOAD ATTEMPTED
         SESSION = SESSION_LOAD(UUID1)                           :S(END)
*
         &CODE = 0
END
@

<<>>=
<<INCLUDES>>
-STITL SESSION
-EJECT
*
************************************************************************
*                                                                      *
*       #####   #######   #####    #####   ###  #######  #     #       *
*      #     #  #        #     #  #     #   #   #     #  ##    #       *
*      #        #        #        #         #   #     #  # #   #       *
*       #####   #####     #####    #####    #   #     #  #  #  #       *
*            #  #              #        #   #   #     #  #   # #       *
*      #     #  #        #     #  #     #   #   #     #  #    ##       *
*       #####   #######   #####    #####   ###  #######  #     #       *
*                                                                      *
* SESSION               SESSION SUPPORT FOR CGI                        *
*                                                                      *
************************************************************************
*
* SESSION.lss
*
<<SESSION>>
*
* CE: .F.MSNOBOL4;
@
