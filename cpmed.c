/**********************************************************************
 *                                                                    *
 *                                                                    *
 *             #####   ######   #     #  #######  ######              *
 *            #     #  #     #  ##   ##  #        #     #             *
 *            #        #     #  # # # #  #        #     #             *
 *            #        ######   #  #  #  #####    #     #             *
 *            #        #        #     #  #        #     #             *
 *            #     #  #        #     #  #        #     #             *
 *             #####   #        #     #  #######  ######              *
 *                                                                    *
 * CPMED.C                 THE CPMED EDITOR                           *
 *                                                                    *
 * COPYRIGHT (C) 1982, 2000, 2005, 2009-2014 FRIDTJOF (FRED) WEIGEL   *
 * ALL RIGHTS RESERVED                                                *
 *                                                                    *
 *                                                                    *
 **********************************************************************/

/* AS MUCH AS POSSIBLE, ASCII-64 IS USED, WITH A LIMIT OF 72 CHARACTERS
 * PER LINE. HOWEVER, C REQUIRES LOWER CASE FOR BOTH LANGUAGE
 * CONSTRUCTS. AND LIBRARY CALLS. THIS IS ISOLATED INTO THE FIRST 100
 * OR SO LINES OF THE FILE. THIS CAN BE EDITED BY CPMED ON SUCH A
 * TERMINAL, IF THE .3 FLAG IS USED.
 *
 * ON AN 80X24 DISPLAY, 18 ROWS ARE DISPLAYED IN SCOPE MODE. THE FIRST
 * 18 LINES ARE THEREFORE DEDICATED TO A BANNER.
 */

/* #define LINUX */
/* #define HP_UX */
#define USE_MEMMOVE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#ifdef LINUX
#include <termios.h>
#include <sys/ioctl.h>
#endif

#ifdef HP_UX
/* FOR select() */
#include <sys/time.h>
#else
#include <sys/select.h>
#endif

#ifdef USE_MEMMOVE
#define IF_MM(X) X
#define NO_MM(X)
#else
#define IF_MM(X)
#define NO_MM(X) X
#endif

#ifdef LINUX
#define IF_LINUX(X) X
#define NO_LINUX(X)
#else
#define IF_LINUX(X)
#define NO_LINUX(X) X
#endif

#define VERSION "CPMED (WED AUG  6 12:10:10 EDT 2014)"

/* C KEYWORDS */
#define STATIC		static
#define INT		int
#define UNSIGNED	unsigned
#define CHAR		char
#define BEGIN		{
#define END		}
#define FOR		for
#define STRUCT		struct
#define UNION		union
#define TYPEDEF		typedef
#define ENUM		enum
#define VOID		void
#define RETURN		return
#define ELSE		else
#define IF		if
#define WHILE		while
#define CASE		case
#define DEFAULT		default
#define SWITCH		switch
#define DO		do
#define CONTINUE	continue
#define BREAK		break
#define GOTO		goto
#define SIZEOF		sizeof
#define ADDR(X)		(&X)
#define OR		||
#define AND		&&
#define BOR		|
#define BAND		&
#define BCOMP		~

/* DEFINE SOME SPECIAL CHARACTERS FOR MACROS */
#define CZ		"\x1a"
#define TA		"\x09"
#define NL		"\n"

/* LIBRARY FUNCTIONS */
#define PUTCHAR		putchar
#define SYSTEM		system
#define FCLOSE		fclose
#define FOPEN		fopen
#define FDSET		fd_set
#define TIMEVAL		timeval
#define FILENO		fileno
#define STDIN		stdin
#define ISATTY		isatty
#define TV_SEC		tv_sec
#define TV_USEC		tv_usec
#define SELECT		select
#define GETENV		getenv
#define FOPEN		fopen
#define MALLOC		malloc
#define FFLUSH		fflush
#define FEOF		feof
#define FGETC		fgetc
#define STDOUT		stdout
#define FPUTC		fputc
#define UNLINK		unlink
#define SLEEP		sleep
#define POPEN		popen
#define PCLOSE		pclose
#define FSCANF		fscanf
#define TEMPNAM		tempnam
#define MAIN		main
#define MEMMOVE		memmove
#ifdef LINUX
#define TERMIOS		termios
#define TCGETATTR	tcgetattr
#define TCSETATTR	tcsetattr
#define CFMAKERAW	cfmakeraw
#define IOCTL		ioctl
#define WINSIZE		winsize
#define WS_ROW		ws_row
#define WS_COL		ws_col
#endif

#define BARC		'|'

#define CLRBIT(V, B)	V &= ~B
#define SETBIT(V, B)	V |= B

/* APPLICATION DEFINES. #DEFINE MUST BE IN LOWER CASE, SO THESE ARE
 * INCLUDED IN THE TOP SECTION
 */
#define YES		1
#define NO		0
#define FOREVER		FOR (;;)
#define NOTHING
#define FEND		-1

#define CTL(C)		((C) - '@')
#define LC(C)		((C) + ' ')
#define RUBOUT		127
#define TILDE		126
#define CHCR		13
#define CHLF		10
#define CHBS		8
#define CHBELL		7
#define CHESC		27
#define CHTAB		9

#define BOOL		INT
#define PFILE		FILE *
#define CLOSED		NULL
/* MAX BUFFER = 8 MEGABYTES */
#define MAXBUF		(8 * 1024 * 1024)
#define MAXCMD		1024
#define MAXFN		256
#define XFILE		"$"

#define ILIM		20
#define MLIM		20
#define CLIM		50

#define ANRM		0
#define AREV		(1 << 8)
#define ABLD		(2 << 8)
#define ADIM		(4 << 8)

#define UTFACC		0 /* UTF-8 ACCEPT */
#define UTFREJ		1 /* UTF-8 REJECT */

#define MAXT		20 /* MAX HTABS */

/* FROM HERE ON, ONLY ASCII-64 IS USED */

STRUCT POSN BEGIN
    INT KEEPCP;
    INT KEEPLN;
END;

STATIC STRUCT UNDO_ST BEGIN
    INT POS;
    CHAR TYPE;
    CHAR CH;
    CHAR PAD1, PAD2;
END            *UNDO_P;
STATIC INT      UNDO_S;
STATIC INT      UNDO_E;
STATIC INT      UNDO_M;

/* BUFFER 1: PRIMARY EDIT BUFFER
 * BUFFER 2: HOLDS EDIT MACROS
 * BUFFER 3: AVAILABLE
 * BUFFER 4: AVAILABLE
 */
STATIC INT	CBUF;			/* EDIT BUFFER 1..4 */

STATIC CHAR	*EBUF1;			/* BUFFER 1 */
STATIC INT	SP1;
STATIC INT	CP1;
STATIC INT	MP1;
STATIC INT	BSIZE1;
STATIC INT	LN1;
STATIC INT	TN1;

STATIC CHAR	*EBUF2;			/* BUFFER 2 */
STATIC INT	SP2;
STATIC INT	CP2;
STATIC INT	MP2;
STATIC INT	BSIZE2;
STATIC INT	LN2;
STATIC INT	TN2;

STATIC CHAR	*EBUF3;			/* BUFFER 3 */
STATIC INT	SP3;
STATIC INT	CP3;
STATIC INT	MP3;
STATIC INT	BSIZE3;
STATIC INT	LN3;
STATIC INT	TN3;

STATIC CHAR	*EBUF4;			/* BUFFER 4 */
STATIC INT	SP4;
STATIC INT	CP4;
STATIC INT	MP4;
STATIC INT	BSIZE4;
STATIC INT	LN4;
STATIC INT	TN4;

STATIC CHAR	*EBUF;			/* EDIT BUFFER */
STATIC INT	SP;			/* SCOPE START POINT */
STATIC INT	CP;			/* CURRENT POINT */
STATIC INT	MP;			/* MAX POINT */
STATIC INT	BSIZE;			/* BUFFER SIZE */
STATIC INT	LN;			/* LINENUMBER */
STATIC INT	TN;			/* TOP NUMBER */

/* GATHER KEYSTROKES. CLEAR ON COMMAND ACCEPTED, NEED TO PREVENT
 * OVERFLOW OF KEYS BUFFER -- MOST KEYS ARE A SINGLE CHARACTER.
 * THESE ARE NOT THE "INTERESTING" ONES -- SOME WILL BE CONTROL
 * CODES, AND SOME WILL BE LONGER (POSSIBLY ESCAPE) SEQUENCES.
 * AS SOON AS A CODE IS NOT FOUND IN THE TABLE, IT IS EMITTED.
 * THIS TAKES CARE OF "PRINTABLE" AND "CONTROL" KEYS. AS LONG
 * AS THE CODE IS FOUND IN THE TABLE, WE WILL GATHER KEYS. AS
 * SOON AS (1) THE SEQUENCE IS NOT MATCHED OR (2) THE SEQUENCE
 * IS COMPLETELY MATCHED, WE ARE DONE.
 *
 * SO, THE QUESTION IS -- WHAT TO PUT INTO THE TABLE? THIS CAN
 * BE (1) A KEY SEQUENCE, (2) A FUNCTION, (3) A COMMAND TO 
 * INTERPRET. THE EMPTY KEY TRANSLATION TABLE SHOULD BEHAVE
 * THE SAME WAY THE EDITOR WORKS TODAY. A KEY SEQUENCES TAKES
 * THE SAME AS A KEY ENTRY FOR STORAGE. THIS CAN ALSO STORE
 * A POINTER. A COMMAND WOULD HAVE TO BE LIMITED IN LENGTH!
 * THIS CAN BE DONE BY FORCING COMMANDS LIKE .C/NAME/ (WHICH
 * IS 8 CHARACTERS). 10 * 4 = 40 BYTES. ONE WORD FOR TYPE.
 *
 * WE NEED TO REPRESENT THE COMMAND DECODE POSSIBILITIES
 * INTO THE TYPE FIELD -- IMMEDIATE, ETC. THIS TABLE TAKES
 * 10KB.
 *
 * 0..127/0..9 = v, 0..127 = string 0..127 = type
 * 0..127 key hhhh..,hh,hhhh..
 */
STATIC INT	KEYS[10];		/* KEYS FROM KEYBOARD */
STATIC STRUCT BEGIN			/* KEY TRANSLATION TABLE */
    INT	KEY[10];
    INT TYPE;
    INT VAL[10];
END KEYST[128] = BEGIN 0, END;

STATIC INT	LREF[10];		/* LINE MARKS */
STATIC INT	CREF[10];		/* CHARACTER MARKS */
STATIC CHAR	INNAM[MAXFN];		/* INPUT FILE NAME */
STATIC CHAR	OUTNAM[MAXFN];		/* OUTPUT FILE NAME */
STATIC CHAR	BAKNAM[MAXFN];		/* BACKUP FILE NAME */
STATIC CHAR	XFNAM[MAXFN];		/* TRANSFER FILE NAME */
STATIC PFILE	INFILE;			/* INPUT FILE */
STATIC PFILE	OUTFIL;			/* OUTPUT FILE */
STATIC PFILE	IDXFIL;			/* INDEX FILE */
STATIC CHAR	CMND[MAXCMD];		/* COMMAND */
STATIC CHAR	SHELF[MAXCMD];		/* STRING SHELF */
STATIC CHAR	AGAIN[MAXCMD];		/* REPEAT COMMAND */
STATIC CHAR	SSRCH[MAXCMD];		/* SEARCH STRING */
STATIC CHAR	SREPL[MAXCMD];		/* REPLACE STRING */
STATIC CHAR	SDELT[MAXCMD];		/* DELETE (JUXTAPOSE) STRING */
STATIC CHAR	SSHELL[MAXCMD];		/* SHELL COMMAND */
STATIC CHAR	SCMND;			/* SEARCH COMMAND */
STATIC CHAR	*CMDPTR;		/* COMMAND POINTER */
STATIC CHAR	SELEC;			/* COMMAND SELECTOR */
STATIC INT	NUM, N2, N3, N4;	/* COMMAND ARGUMENT STACK */
STATIC BOOL	SIGN;			/* YES IF SIGN ON ARG (0/-0) */
STATIC BOOL	ERROR;			/* ERROR RAISED */
STATIC INT	COL;			/* CURRENT COLUMN */
STATIC INT	STCOL;			/* START COLUMN */
STATIC BOOL	FEX;			/* EXECUTION FLAG */
STATIC BOOL	INMAC;			/* IN MACRO */
STATIC BOOL	SPRSLN;			/* SUPPRESS LINE NUMBER */
STATIC BOOL	CPM80;			/* CPM/80 FLAG */
STATIC INT	XPTAB;			/* TAB EXPANSION */
STATIC BOOL	FABEND;			/* ABEND FLAG */
STATIC BOOL	FONE;			/* SINGLE COMMAND FLAG */
STATIC BOOL	FSCOPE;			/* SCOPE FLAG */
STATIC BOOL	FUC;			/* UPPERCASE FLAG */
STATIC BOOL	FLN;			/* LINE NUMBERING FLAG */
STATIC BOOL	F8;			/* EIGHT BIT FLAG */
STATIC BOOL	IMMED;			/* IMMEDIATE COMMAND FLAG */
STATIC BOOL	LASTLF;			/* LAST CHAR WAS LF */
STATIC INT	ROWS, COLS;		/* SCOPE ROWS, COLUMNS */
STATIC INT	KEYBS;			/* KEY FOR BACKSPACE */
STATIC INT	KEYRUB;			/* KEY FOR RUBOUT */
STATIC BOOL	BRKNOW;			/* BREAK NOW (INTERRUPT) */
STATIC INT	CCOL, CLINE;		/* SCOPE CURSOR COLUMN, LINE */
STATIC INT	AUTOIN;			/* AUTOINDENT */
STATIC INT	IDELTA;			/* INDENT DELTA */
STATIC CHAR	MODE[16];		/* MAJOR MODE: FORTRAN COBOL C
					 * LISP SNOBOL4 TEXT SHELL
					 * ASSEMBLER PASCAL */
STATIC CHAR	DMODE[16];		/* DISPLAY MODE - YACC,  ETC */
STATIC INT	BROWS;			/* SCOPE BOTTOM ROWS */
STATIC FILE	*ISTK[ILIM];		/* INPUT SOURCE STACK */
STATIC INT	ISP;			/* ISTK POINTER */
STATIC CHAR	*CSTK[CLIM];		/* CALL STACK */
STATIC INT	CSP;			/* CSTK POINTER */
STATIC INT	BAR;			/* VERTICAL BAR (SCOPE) */
STATIC BOOL	EXEC;			/* EXEC FLAG */
STATIC CHAR	*MSTK[MLIM];		/* () BLOCK STACK */
STATIC INT	MSP;			/* MSTK POINTER */
STATIC INT	OFFLEV;			/* OFF LEVEL */
STATIC INT	RESULT;			/* RESULT (X) */
STATIC INT	RESLT2;			/* Y */
STATIC INT	RESLT3;			/* Z */
STATIC INT	RESLT4;			/* T */
STATIC INT	VARS[26];		/* A..Z VARIABLES */
STATIC FILE	*CINSRC;		/* INPUT SOURCE */
STATIC BOOL	CRSOFF;			/* CURSOR OFF (USE REAL
					 * CURSOR) */
STATIC INT	ATTRIB;			/* SCOPE ATTRIBUTE */
STATIC BOOL	CHAR64;			/* USE ASCII-64 */
STATIC BOOL	FASTUP;			/* FAST SCOPE UPDATE POSSIBLE */
STATIC INT	LINEST[256];		/* MAX 256 LINES FOR SCOPE */
STATIC BOOL	FLITL;			/* TRANSLATE ^L TO ^J */
STATIC BOOL	IACTIV;			/* INTERACTIVE */
STATIC INT	NBYTES;			/* WRITE COUNTER, FOR PADDING */
STATIC INT	CHANGE;			/* CHANGE COUNTER */
STATIC BOOL	SEEALL;			/* SEE ALL MODE (SCOPE) */
STATIC INT	ISNEWFILE;		/* EDITING A NEW FILE */
STATIC BOOL	UTF8;			/* UTF8 EDITING */
IF_LINUX(STATIC STRUCT TERMIOS TERM;)
STATIC INT	MBELL;			/* MARGIN BELL */
STATIC INT	HTABS[MAXT] = { 0, };	/* HTAB FOR ^W */
STATIC INT	SUBLVL;			/* SUBMIT LEVEL */
STATIC INT	PL;			/* PAGE LENGTH */
STATIC INT	MDSEL;

/* FORWARD DECLARATIONS */

STATIC VOID EXALL ();
STATIC VOID UPDATE();
STATIC VOID INSST2();
STATIC VOID CHARS ();
STATIC VOID PROMPT();
STATIC VOID REMOVE();
STATIC BOOL INSERT();
STATIC VOID INCIND();
STATIC VOID COPYA ();

STATIC STRUCT BEGIN
    CHAR E[12];
    CHAR T[12];
    CHAR T2[12];
END ELIST[128] = BEGIN 0, END;

/* .M? */
STATIC CHAR MDHELP[512] = BEGIN 0, END;

/* 1? .. 10? */
STATIC CHAR EDHELP[10][1024] = BEGIN 0, END;

STATIC CHAR HEX[] = "0123456789ABCDEF";

/* CLEAR UNDO */
STATIC VOID CLRUND()
BEGIN
    UNDO_S = 0;
    UNDO_E = 0;
END

/* ADD UNDO RECORD */
STATIC VOID ADDUND(T, C, P)
CHAR T;
CHAR C;
INT P;
BEGIN
    IF ((UNDO_M == 0) || (CBUF != 1))
	RETURN;
    UNDO_P[UNDO_E].TYPE = T;
    UNDO_P[UNDO_E].POS = P;
    UNDO_P[UNDO_E].CH = C;
    IF (++UNDO_E == UNDO_M)
	UNDO_E = 0;
    IF (UNDO_E == UNDO_S) BEGIN
	IF (++UNDO_S == UNDO_M)
	    UNDO_S = 0;
    END
END

/* LAST UNDO RECORD, RETURN TYPE; -1 IF EMPTY */
STATIC INT LSTUND(C, P)
CHAR *C;
INT *P;
BEGIN
    IF (UNDO_E == UNDO_S)
	RETURN -1;
    IF (--UNDO_E < 0)
	UNDO_E = UNDO_M - 1;
    *C = UNDO_P[UNDO_E].CH;
    *P = UNDO_P[UNDO_E].POS;
    RETURN UNDO_P[UNDO_E].TYPE;
END

/* PEEK AT LAST UNDO RECORD, RETURN TYPE; -1 IF EMPTY */
STATIC INT PEEKUN(C, P)
CHAR *C;
INT *P;
BEGIN
    INT I;
    IF (UNDO_E == UNDO_S)
	RETURN -1;
    I = UNDO_E;
    IF (--I < 0)
	I = UNDO_M - 1;
    *C = UNDO_P[I].CH;
    *P = UNDO_P[I].POS;
    RETURN UNDO_P[I].TYPE;
END

/* UNDO TAG (MARK) */
STATIC VOID TAGUND()
BEGIN
    CHAR C;
    INT T, P;
    IF ((SUBLVL + CSP + ISP + INMAC) == 0) BEGIN
	T = LSTUND(&C, &P);
	IF (T >= 0) BEGIN
	    ADDUND(T, C, P);
	    IF (T == 0)
		RETURN;
	END
	ADDUND(0, 0, CP);
    END
END

/* IS C UPPERCASE? */
STATIC BOOL ISUC(C)
INT C;
BEGIN
    RETURN ('A' <= C) AND (C <= 'Z');
END

/* IS C LOWERCASE? */
STATIC BOOL ISLC(C)
INT C;
BEGIN
    RETURN (LC('A') <= C) AND (C <= LC('Z'));
END

/* IS C CONTROL? */
STATIC BOOL ISCNTL(C)
INT C;
BEGIN
    RETURN (0 <= C) AND (C < ' ');
END

/* IS C NUMERIC? */
STATIC BOOL ISNUM(C)
INT C;
BEGIN
    RETURN ('0' <= C) AND (C <= '9');
END

/* IS C WHITESPACE? */
STATIC BOOL ISWHIT(C)
INT C;
BEGIN
    RETURN (C == ' ') OR (C == CHTAB);
END

/* LOWER CASE TO UPPER CASE */
STATIC INT TOUC(C)
INT C;
BEGIN
    RETURN ISLC(C) ? C - LC('A') + 'A' : C;
END

/* UPPER CASE TO LOWER CASE */
STATIC INT TOLC(C)
INT C;
BEGIN
    RETURN ISUC(C) ? C - 'A' + LC('A') : C;
END

/* IS CHARACTER ALPHA? */
STATIC BOOL ISALFA(C)
INT C;
BEGIN
    RETURN ('A' <= TOUC(C)) AND (TOUC(C) <= 'Z');
END

/* CONTROL CHARACTER TO CHARACTER (^A BECOMES A) */
STATIC INT CNTL2C(C)
INT C;
BEGIN
    RETURN C + '@';
END

/* ASCII NUMERIC TO NUMERIC ('0' TO 0) */
STATIC INT D2N(C)
INT C;
BEGIN
    RETURN C - '0';
END

/* APPLY F TO EACH CHAR OF STRING */
STATIC CHAR *STRF(S, F)
CHAR *S;
VOID (*F)();
BEGIN
    WHILE (*S) F(*S++);
    RETURN S;
END

STATIC VOID SNULL()
BEGIN
END

/* LENGTH OF STRING */
STATIC INT STRLEN(S)
CHAR *S;
BEGIN
    RETURN STRF(S, SNULL) - S;
END

/* COPY STRING */
STATIC CHAR *STRCPY(S, T)
CHAR *S, *T;
BEGIN
    CHAR *R = S;
    WHILE ((*S++ = *T++)) NOTHING;
    RETURN R;
END

/* CONCATENATE STRING */
STATIC CHAR *STRCAT(S, T)
CHAR *S, *T;
BEGIN
    CHAR *R = S;
    STRCPY(S + STRLEN(S), T);
    RETURN R;
END

/* CONCATENATE CHARACTER TO STRING */
STATIC CHAR *STRADD(S, C)
CHAR *S, C;
BEGIN
    INT I = STRLEN(S);
    S[I] = C;
    S[I + 1] = 0;
    RETURN S;
END

/* STRING TO NUMERIC (BASE 8, 10, 16) */
STATIC CHAR *ATOI(S, BASE, R)
CHAR *S;
INT BASE;
INT *R;
BEGIN
    INT I;
    FOR (*R = 0; *S; ++S) BEGIN
	FOR (I = 0; I < BASE; ++I)
	    IF (HEX[I] == TOUC(*S))
		BREAK;
	IF (I >= BASE)
	    RETURN S;
	*R = *R * BASE + I;
    END
    RETURN S;
END

/* COMPARE STRINGS */
STATIC INT STRCMP(S, T)
CHAR *S, *T;
BEGIN
    FOR (; *S; ++S, ++T)
	IF (*S != *T)
	    RETURN (INT)*S - (INT)*T;
    IF (*T)
	RETURN -1;
    RETURN 0;
END

/* COMPARE STRINGS, CASE INSENSITIVE */
STATIC INT STRICM(S, T)
CHAR *S, *T;
BEGIN
    FOR (; *S; ++S, ++T)
	IF (TOUC(*S) != TOUC(*T))
	    RETURN (INT)TOUC(*S) - (INT)TOUC(*T);
    IF (*T)
	RETURN -1;
    RETURN 0;
END

/* COMPARE STRINGS, CASE INSENSITIVE */
STATIC INT STRNIC(S, T, N)
CHAR *S, *T;
INT N;
BEGIN
    FOR (; N AND *S; ++S, ++T, --N)
	IF (TOUC(*S) != TOUC(*T))
	    RETURN (INT)TOUC(*S) - (INT)TOUC(*T);
    IF (N == 0)
	RETURN 0;
    IF (*T)
	RETURN -1;
    RETURN 0;
END

/* CONVERT INTEGER TO ASCII (BASE 8, 10, 16)
 * IF BASE IS NEGATIVE, SIGNED, ELSE UNSIGNED
 */
STATIC CHAR *ITOA(NUM, BASE)
INT NUM, BASE;
BEGIN
    STATIC CHAR BUF[40];
    UNSIGNED INT N = NUM, B;
    CHAR *S = BUF;
    INT ND;
    IF ((BASE < 0) && (NUM < 0)) BEGIN
	*S++ = '-';
	N = -NUM;
    END
    IF (BASE < 0) BASE = -BASE;
    IF (N == 0) BEGIN
	*S++ = '0';
	*S = 0;
	RETURN BUF;
    END
    FOR (B = N, ND = 0; B; B /= BASE) ++ND;
    FOR (B = 1; ND > 1; --ND) B *= BASE;
    WHILE (N) BEGIN
	FOR (ND = 0; N >= B; N -= B)
	    ++ND;
	*S++ = HEX[ND];
	B /= BASE;
    END
    WHILE (B >= 1) BEGIN
	*S++ = '0';
	B /= BASE;
    END
    *S = 0;
    RETURN BUF;
END

/* STRING TO LOWER CASE, FOR STRING CONSTANTS */
STATIC CHAR *S2L(S)
CHAR *S;
BEGIN
    STATIC CHAR BUF[MAXCMD];
    INT I;
    FOR (I = 0; S[I]; ++I)
	BUF[I] = TOLC(S[I]);
    BUF[I] = 0;
    RETURN BUF;
END

/* ZERO TO NINE */
STATIC BOOL N0TO9(N)
INT N;
BEGIN
    RETURN (0 <= N) AND (N <= 9);
END

/* FORMAT NUMBER, UP TO SIX DIGITS */
STATIC CHAR *FMTN(N)
INT N;
BEGIN
    RETURN ITOA(N, -10);
END

/* DECODE UTF8
 *
 * SET STATE TO UTFACC, AND THEN CALL WITH EACH BYTE IN THE
 * UTF-8 STRING. THIS FUNCTION WILL RETURN UTFREJ ON BAD
 * SEQUENCES, AND UTFACC ON COMPLETION OF A SEQUENCE. WHEN
 * THE SEQUENCE IS COMPLETE, CODEP WILL HAVE THE CODE POINT.
 */
STATIC UNSIGNED INT DECODE(STATE, CODEP, BYTE)
UNSIGNED INT *STATE;
UNSIGNED INT *CODEP;
UNSIGNED INT BYTE;
BEGIN
STATIC UNSIGNED CHAR UTF8D[] = BEGIN
    /* 00..7F */
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    /* 80..9F */
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,
    /* A0..BF */
    7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
    /* C0..DF */
    8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
    /* E0..EF */
    0XA,0X3,0X3,0X3,0X3,0X3,0X3,0X3,0X3,0X3,0X3,0X3,0X3,0X4,0X3,0X3,

    /* F0..FF */
    0XB,0X6,0X6,0X6,0X5,0X8,0X8,0X8,0X8,0X8,0X8,0X8,0X8,0X8,0X8,0X8,

    /* S0..S0 */
    0X0,0X1,0X2,0X3,0X5,0X8,0X7,0X1,0X1,0X1,0X4,0X6,0X1,0X1,0X1,0X1,
    /* S1..S2 */
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1,
    /* S3..S4 */
    1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,
    /* S5..S6 */
    1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1,
    /* S7..S8 */
    1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1
END;
    UNSIGNED INT TYPE = UTF8D[BYTE];
    *CODEP = (*STATE != UTFACC) ?
		(BYTE  & 0X3FU) | (*CODEP << 6) :
		(0XFF >> TYPE) & (BYTE);
    *STATE = UTF8D[256 + *STATE*16 + TYPE];
    RETURN *STATE;
END

/* RETURN MAXREP */
STATIC INT MAXREP()
BEGIN
    IF (BSIZE > 65535) RETURN BSIZE;
    RETURN 65535;
END

/* PRINT CHARACTER. DISPLAY CHARACTER, RECORDING IF THE LAST CHARACTER
 * WAS A LF (END OF LINE). THE LF INFORMATION IS USED WHEN A PROMPT
 * IS NEEDED OR ERROR IS ISSUED.
 */
STATIC VOID PC(C)
INT C;
BEGIN
    LASTLF = (C == CHLF);
    PUTCHAR(C);
END

/* SEND BELL TO TERMINAL */
STATIC VOID BELL()
BEGIN
    PC(CHBELL);
END

/* SCOPE - SEND ESC TO TERMINAL */
STATIC VOID ESC()
BEGIN
    PC(CHESC);
END

/* ISSUE A SCOPE COMMAND. SENDS CHARACTERS TO DISPLAY WITHOUT LOOKING
 * AT THEM, AS THEY WILL BE CONTROL SEQUENCES (AND ASSUMED TO BE VALID
 * VT100 SEQUENCES).
 */
STATIC VOID SCPCMD(S)
CHAR *S;
BEGIN
    ESC();
    PC('[');
    WHILE (*S) PC(*S++);
END

/* SEND SINGLE CHARACTER SCOPE COMMAND */
STATIC VOID SCPCMDC(C)
CHAR C;
BEGIN
    CHAR BUF[2];
    BUF[0] = C;
    BUF[1] = 0;
    SCPCMD(BUF);
END

/* SEND ONE ARGUMENT SCOPE COMMAND */
STATIC VOID SCPCMD1(N, S)
INT N;
CHAR S;
BEGIN
    CHAR BUF[40];
    SCPCMD(STRADD(STRCPY(BUF, FMTN(N)), S));
END

/* SEND TWO ARGUMENT SCOPE COMMAND */
STATIC VOID SCPCMD2(N, M, S)
INT N;
INT M;
CHAR S;
BEGIN
    CHAR BUF[40];
    STRCPY(BUF, FMTN(N));
    STRADD(BUF, ';');
    STRCAT(BUF, FMTN(M));
    STRADD(BUF, S);
    SCPCMD(BUF);
END

/* SCOPE POSITION CURSOR */
STATIC VOID GOTOYX(Y, X)
INT Y;
INT X;
BEGIN
    SCPCMD2(Y, X, 'H');
    COL = 0;
END

/* RETURN 0 IF NO KEY IS AVAILABLE TO BE READ (FROM KEYBOARD). IF THE
 * INPUT IS NOT A KEYBOARD, ALWAYS RETURN 0. IF A KEY IS READY, RETURN
 * NON-ZERO.
 */
STATIC BOOL READY()
BEGIN
    FDSET S;
    STRUCT TIMEVAL T;
    INT FD = FILENO(STDIN);
    IF (!ISATTY(FD)) RETURN NO;
    FD_ZERO(ADDR(S));
    FD_SET(FD, ADDR(S));
    T.TV_SEC = T.TV_USEC = 0;
    RETURN SELECT(FD + 1, ADDR(S), NULL, NULL, ADDR(T)) != 0;
END

/* READ A KEY. MAKE SURE THAT DISPLAY OUTPUT IS COMPLETE, AND THEN WAIT
 * FOR AND READ A KEY.
 */
STATIC INT CIN()
BEGIN
    INT C;
    FFLUSH(STDOUT);
    IF (FEOF(CINSRC)) BEGIN
AGAIN:	IF (ISP > 0) BEGIN
	    FCLOSE(CINSRC);
	    CINSRC = ISTK[--ISP];
	    IF (!IACTIV AND (ISP == 0))
		RETURN EOF;
	    RETURN CIN();
	END
    END
    C = FGETC(CINSRC);
    IF ((C == EOF) AND (ISP > 0))
	GOTO AGAIN;
    RETURN C;
END

/* CHARACTER TO FUNCTION. DISPLAY CONTROLS AS ^CHAR, [NN], IF EIGHT BIT
 * DISPLAY ENABLED, PASSES THROUGH. EXPAND TABS. UTF-8 AWARE.
 *
 * RETURNS NUMBER OF COLUMNS NEEDED. NOTE THAT NUMBER OF COLUMNS MAY BE
 * ZERO (IN CASE OF UTF8 SEQUENCES)
 *
 * USES COL AND STCOL (CURRENT COLUMN AND START COLUMN)
 */
STATIC INT COUTF(C, F, UTF8, CODEPOINT)
INT C;
VOID (*F)();
UNSIGNED INT *UTF8;
UNSIGNED INT *CODEPOINT;
BEGIN
    INT CC = COL;
    C = C BAND 0XFF;
    IF ((C == CHTAB) AND XPTAB) BEGIN
	DO
	    F(' ');
	WHILE ((++CC - STCOL) % XPTAB);
    END ELSE IF (C == 0) BEGIN
	GOTO HX;
    END ELSE IF ((C > 0X0) && (C <= 0X1F)) BEGIN
	GOTO CTL;
    END ELSE IF (F8) BEGIN
	F(C);
	DECODE(UTF8, CODEPOINT, C);
	IF (*UTF8 == UTFACC) BEGIN
	    ++CC;
	END ELSE IF (*UTF8 == UTFREJ) BEGIN
	    *UTF8 = UTFACC;
	    ++CC;
	END
    END ELSE IF (ISCNTL(C)) BEGIN
CTL:	F('^');
	F(CNTL2C(C));
	CC += 2;
    END ELSE IF ((C >= RUBOUT) OR (C == 0)) BEGIN
HX:	F('[');
	F(HEX[C >> 4]);
	F(HEX[C BAND 0X0F]);
	F(']');
	CC += 4;
    END ELSE IF (CHAR64 AND (C >= 96)) BEGIN
	F('[');
	F(C - 32);
	F(']');
	CC += 3;
    END ELSE BEGIN
	F(C);
	++CC;
    END
    RETURN CC - COL;
END

/* CHARACTER OUT */
STATIC VOID COUT(C)
INT C;
BEGIN
    STATIC UNSIGNED INT STATE = UTFACC, CODEPOINT = 0;
    COL += COUTF(C, PC, &STATE, &CODEPOINT);
END

/* PRINT STRING, TERMINATED BY 0 */
STATIC VOID SOUT(S)
CHAR *S;
BEGIN
    STRF(S, COUT);
END

STATIC VOID ROUT(S)
CHAR *S;
BEGIN
    STRF(S, PC);
END

/* RETURN TO FIRST COLUMN (CR) */
STATIC VOID CR()
BEGIN
    PC(CHCR);
    COL = 0;
END

/* DOWN ONE LINE */
STATIC VOID LF()
BEGIN
    PC(CHLF);
END

/* TO COLUMN ONE, AND ADVANCE LINE */
STATIC VOID CRLF()
BEGIN
    CR();
    LF();
END

/* COMPOSE AND PRINT ERROR MESSAGE */
STATIC VOID PERR(E)
INT E;
BEGIN
    IF (!LASTLF) CRLF();
    SOUT("BREAK \"");
    COUT(E);
    SOUT("\" AT ");
    IF (SELEC == 0) SELEC = '?';
    COUT(TOUC(SELEC));
    BELL();
    ERROR = YES;
END

/* POLL FOR A KEYBOARD BREAK. IF A BREAK HAS BEEN SIGNALED, THEN WE ARE
 * DONE; OTHERWISE, POLL THE KEYBOARD, AND IF A BREAK CHARACTER IS
 * ENTERED (DEL), ENTER BREAK CONDITION. ECHO BREAK ERROR MESSAGE TO THE
 * CONSOLE. TO BE CALLED ON MAJOR LOOPS.
 */
STATIC BOOL POLL()
BEGIN
    INT C;
    IF (BRKNOW) RETURN YES;
    IF (READY()) BEGIN
	C = FGETC(STDIN);
	IF ((C == RUBOUT) OR (C == CHBS)) BEGIN
	    /* BREAK REQUESTED, CLOSE UP ALL SOURCE FILES. */
	    WHILE (ISP > 0) BEGIN
		FCLOSE(CINSRC);
		CINSRC = ISTK[--ISP];
	    END
	    BRKNOW = YES;
	    PERR('B');
	    RETURN YES;
	END
    END
    RETURN NO;
END

/* OPEN FILE */
STATIC PFILE OPENF(F, M)
CHAR *F;
CHAR M;
BEGIN
    CHAR *MS;
    SWITCH (M) BEGIN
	CASE 'R': MS = S2L("RB");  BREAK;
	CASE 'W': MS = S2L("WB");  BREAK;
	CASE 'A': MS = S2L("AB+"); BREAK;
    END
    RETURN FOPEN(F, MS);
END

/* CLOSE FILE */
STATIC PFILE CLOSEF(F)
PFILE F;
BEGIN
    IF (F != CLOSED) FCLOSE(F);
    RETURN CLOSED;
END

/* GET ENVIRONMENT VARIABLE, AND SCALE (K, M) WITH DEFAULT */
STATIC INT GETBS(CHAR *E, INT D)
BEGIN
    INT I;
    CHAR *S;
    BOOL A = YES;
    A = YES;
    IF (D < 0) BEGIN
	A = NO;
	D = -D;
    END;
    I = D;
    S = GETENV(E);
    IF (S) BEGIN
	S = ATOI(S, 10, ADDR(I));
	IF ((*S == LC('M')) OR (*S == 'M')) I *= 1024 * 1024;
	ELSE IF ((*S == LC('K')) OR (*S == 'K')) I *= 1024;
    END
    IF (I <= 0)     I = D;
    IF (A == NO)
	RETURN I;
    IF (I < 2048)   I *= 1024;
    IF (I > MAXBUF) I = MAXBUF;
    RETURN I;
END
    
/* ALLOCATE EDIT BUFFER */
STATIC VOID ALLOC()
BEGIN
    INT I;
    BSIZE = GETBS("REGION", 512);
    /* ALLOCATE EDIT BUFFER, REDUCING SIZE ON FAILURE */
    WHILE (BSIZE AND
	   ((EBUF = MALLOC(BSIZE)) == NULL))
	--BSIZE;
    /* FILL EDIT BUFFER -- ENSURES THAT IT IS IN MEMORY */
    IF (EBUF)
	FOR (I = 0; I < BSIZE; ++I) EBUF[I] = 0XA5;
    /* ALLOCATE UNDO BUFFER */
    UNDO_M = GETBS("UNDO", -1024);
    UNDO_P = MALLOC(UNDO_M * SIZEOF (STRUCT UNDO_ST));
    IF (UNDO_P == NULL)
	UNDO_M = 0;
    /* ALLOCATE ALTERNATE BUFFER */
    BSIZE2 = GETBS("REGION2", 16);
    EBUF2 = MALLOC(BSIZE2);
    IF (EBUF2)
	EBUF2[0] = 0;
    ELSE
	BSIZE2 = 0;
    CP2 = MP2 = TN2 = SP2 = 0;
    LN2 = 1;
    /* ALLOCATE ALTERNATE BUFFER 3 */
    BSIZE3 = GETBS("REGION3", 16);
    EBUF3 = MALLOC(BSIZE3);
    IF (EBUF3)
	EBUF3[0] = 0;
    ELSE
	BSIZE3 = 0;
    CP3 = MP3 = TN3 = SP3 = 0;
    LN3 = 1;
    /* ALLOCATE ALTERNATE BUFFER 4 */
    BSIZE4 = GETBS("REGION4", 16);
    EBUF4 = MALLOC(BSIZE4);
    IF (EBUF4)
	EBUF4[0] = 0;
    ELSE
	BSIZE4 = 0;
    CP4 = MP4 = TN4 = SP4 = 0;
    LN4 = 1;
END

/* PRINT A LINE, UPPERCASING IF NEEDED. TERMINATE WITH CRLF */
STATIC VOID LOUT(S)
CHAR *S;
BEGIN
    WHILE (*S) COUT(FUC ? TOUC(*S++) : *S++) NOTHING;
    CRLF();
END

/* DISK ERROR -- FAILURE TO WRITE A FILE, POSSIBLY READ AS WELL */
STATIC VOID DERR()
BEGIN
    LOUT("DISK ERROR");
    ERROR = YES;
END

/* WRITE CHARACTER TO FILE */
STATIC BOOL FCOUT(C, F)
INT C;
PFILE F;
BEGIN
    IF (FPUTC(C, F) == EOF) BEGIN
	DERR();
	RETURN NO;
    END
    RETURN YES;
END

/* READ CHARACTER FROM FILE */
STATIC INT FCIN(F)
PFILE F;
BEGIN
    INT	C;
    IF (F == CLOSED)
	RETURN FEND;
    IF ((C = FGETC(F)) == EOF)
	RETURN FEND;
    RETURN C;
END

/* REMOVE TRANSFER FILE */
STATIC VOID RXFILE()
BEGIN
    UNLINK(XFILE);
END

/* COPY FILE */
STATIC BOOL FCOPY(FROM, TO)
PFILE FROM;
PFILE TO;
BEGIN
    INT	C;
    WHILE ((C = FCIN(FROM)) != FEND)
	IF (!FCOUT(C, TO))
	    RETURN NO;
    RETURN YES;
END

/* COPY FILE */
STATIC BOOL CPFILE(SRC, DST)
CHAR *SRC;
CHAR *DST;
BEGIN
    PFILE FSRC;
    PFILE FDST;
    BOOL OK = NO;
    FSRC = OPENF(SRC, 'R');
    FDST = OPENF(DST, 'W');
    IF ((FSRC == NULL) OR (FDST == NULL))
	RETURN NO;
    IF (!FCOPY(FSRC, FDST))
	GOTO ERROR;
    OK = YES;
ERROR:
    CLOSEF(FSRC);
    CLOSEF(FDST);
    RETURN OK;
END

/* UPDATE FILES (FILE, BACKUP) */
STATIC VOID UPDTFL()
BEGIN
    RXFILE();
    IF (BAKNAM[0]) BEGIN
	IF ((ISNEWFILE == NO) && !CPFILE(INNAM, BAKNAM))
	    LOUT("PROBLEM WRITING BACKUP");
	/* JUST IN CASE THE ORIGINAL FILE IS NOT WRITABLE, SAVE THE
	 * EDITED FILE IN TMP FOR RECOVERY. GENERALLY, THIS WILL
	 * HAPPEN IF YOU FORGET TO CHECK THE FILE OUT.
	 */
	IF (!CPFILE(OUTNAM, INNAM)) BEGIN
	    LOUT("PROBLEM WRITING FILE - SEE");
	    LOUT(OUTNAM);
	    LOUT("PRESS ANY KEY");
	    CIN();
	END ELSE
	    UNLINK(OUTNAM);
    END
END

/* SET UP OUTPUT AND BACKUP FILE NAMES.
 *
 * WE CREATE A UNIQUE /TMP FILE FOR THE OUTPUT. THIS ALLOWS MULTIPLE
 * COPIES OF THE EDITOR TO EDIT AT THE SAME TIME. NOTE, HOWEVER, THAT
 * THE NAME OF THE TRANSFER FILE IS ALWAYS "$" AND THIS WILL BE
 * SHARED BY MULTIPLE EDITORS RUNNING IN THE SAME DIRECTORY.
 */
STATIC VOID SNAMES(F, O)
CHAR *F;
CHAR *O;
BEGIN
    STRCPY(INNAM, F);
    IF (O == NULL) BEGIN
	STRCPY(OUTNAM, TEMPNAM(S2L("/TMP"), NULL));
	STRCPY(BAKNAM, F);
	STRCAT(BAKNAM, S2L(".BAK"));
    END ELSE BEGIN
	STRCPY(OUTNAM, O);
	BAKNAM[0] = 0;
    END
END

/* PREPARE CONSOLE FOR EDITING */
STATIC VOID PREPC()
BEGIN
    IF_LINUX(STRUCT TERMIOS T;)
    IF_LINUX(TCGETATTR(1, ADDR(TERM));)
    IF_LINUX(T = TERM;)
    IF_LINUX(CFMAKERAW(&T);)
    IF_LINUX(TCSETATTR(1, TCSANOW, &T);)
    NO_LINUX(SYSTEM(S2L("STTY -ECHO RAW"));)
    COL = 0;
END

/* RESTORE NORMAL CONSOLE AFTER EDIT */
STATIC VOID RESTC()
BEGIN
    IF_LINUX(TCSETATTR(1, TCSANOW, ADDR(TERM));)
    NO_LINUX(SYSTEM(S2L("STTY ECHO COOKED"));)
END

/* DETERMINE CONSOLE SIZE (ROWS, COLUMNS) */
STATIC VOID SIZEC()
BEGIN
    IF_LINUX(STRUCT WINSIZE W;)
    IF_LINUX(IOCTL(0, TIOCGWINSZ, (CHAR *)ADDR(W));)
    IF_LINUX(ROWS = W.WS_ROW;)
    IF_LINUX(COLS = W.WS_COL;)
    NO_LINUX(FILE *F = POPEN(S2L("STTY SIZE"), "\162");) /* LC('R') */
    NO_LINUX(IF (F) BEGIN)
	NO_LINUX(FSCANF(F, S2L("%D %D"), ADDR(ROWS), ADDR(COLS));)
	NO_LINUX(PCLOSE(F);)
    NO_LINUX(END)
END

/* DETERMINE MAJOR EDIT MODE */
STATIC BOOL ISMODE(M)
CHAR *M;
BEGIN
    RETURN STRCMP(MODE, M) == 0;
END

/* SHELL MODE? */
STATIC BOOL ISSHEL()
BEGIN
    RETURN ISMODE("SHELL");
END

/* PASCAL MODE? */
STATIC BOOL ISPASC()
BEGIN
    RETURN ISMODE("PASCAL");
END

/* FORTRAN MODE? */
STATIC BOOL ISFORT()
BEGIN
    RETURN ISMODE("FORTRAN");
END

/* COBOL MODE? */
STATIC BOOL ISCOBO()
BEGIN
    RETURN ISMODE("COBOL");
END

/* SNOBOL MODE? */
STATIC BOOL ISSNOB()
BEGIN
    RETURN ISMODE("SNOBOL4");
END

/* LISP MODE? */
STATIC BOOL ISLISP()
BEGIN
    RETURN ISMODE("LISP");
END

/* C MODE? */
STATIC BOOL ISC()
BEGIN
    RETURN ISMODE("C");
END

/* TEXT MODE? */
STATIC BOOL ISTEXT()
BEGIN
    RETURN ISMODE("TEXT");
END

/* ASSEMBLER MODE? */
STATIC BOOL ISASSE()
BEGIN
    RETURN ISMODE("ASSEMBLER");
END

/* CURSOR TO STATUS LINE */
STATIC VOID GOSTAT()
BEGIN
    GOTOYX(ROWS - BROWS + 1, 1);
END

/* MIN OF TWO INTEGERS */
STATIC INT MIN(A, B)
INT A, B;
BEGIN
    RETURN (A < B) ? A : B;
END

/* DISPLAY DIVIDER LINE */
STATIC VOID DIV2()
BEGIN
    CHAR S[81];
    INT I;
    GOSTAT();
    FOR (I = 0; I < 80; ++I)
	S[I] = '-';
    FOR (I = 0; I < 8; ++I)
	S[(I + 1) * 10 - 1] = '1' + I;
    IF (ISFORT()) BEGIN
	S[0] = 'C';
	S[5] = '+';
	S[6] = 'I';
    END ELSE IF (ISSNOB()) BEGIN
	S[0] = '+';
	S[9] = 'I';
	S[54] = 'I';
    END ELSE IF (ISPASC()) BEGIN
	FOR (I = 0; I < 26; ++I)
	    S[I * 3] = '.';
	FOR (I = 0; I < 7; ++I) /* PUT BACK NUMBERS */
	    S[(I + 1) * 10 - 1] = '1' + I;
    END ELSE IF (ISCOBO()) BEGIN
	S[6] = 'I';
	S[7] = 'A';
	S[11] = 'B';
    END ELSE IF (ISC()) BEGIN
	FOR (I = 0; I < 20; ++I)
	    S[I * 4] = '.';
    END
    S[63] = '+';
    S[71] = 'I';
    IF (!ISTEXT() AND (32 <= COLS))
	STRCPY(S + MIN(COLS, 80) - STRLEN(DMODE), DMODE);
    S[80] = 0;
    IF (COLS < 80)
	S[COLS] = 0;
    IF ((0 < BAR) AND (BAR <= 80))
	S[BAR - 1] = BARC;
    FOR (I = 0; S[I]; ++I)
	PC(S[I]);
    FOR (I = STRLEN(S); I < COLS; ++I)
	PC((I == (BAR - 1)) ? BARC :
	  ((I == 131) ? '!' : '-'));
    CRLF();
END

/* SET SCOPE ATTRIBUTE */
STATIC VOID SATTR()
BEGIN
    SCPCMD1(0, LC('M'));
    IF (ATTRIB BAND ABLD) SCPCMD1(1, LC('M'));
    IF (ATTRIB BAND ADIM) SCPCMD1(2, LC('M'));
    IF (ATTRIB BAND AREV) SCPCMD1(7, LC('M'));
END

/* SCOPE BOLD */
STATIC VOID BLD()
BEGIN
    SETBIT(ATTRIB, ABLD);
    SATTR();
END

/* SCOPE BOLD OFF */
STATIC VOID BLDOFF()
BEGIN
    CLRBIT(ATTRIB, ABLD);
    SATTR();
END

/* SCOPE DIM */
STATIC VOID DIM()
BEGIN
    SETBIT(ATTRIB, ADIM);
    SATTR();
END

/* SCOPE DIM OFF */
STATIC VOID DIMOFF()
BEGIN
    CLRBIT(ATTRIB, ADIM);
    SATTR();
END

/* SCOPE REVERSE */
STATIC VOID REV()
BEGIN
    SETBIT(ATTRIB, AREV);
    SATTR();
END

/* SCOPE REVERSE OFF */
STATIC VOID REVOFF()
BEGIN
    CLRBIT(ATTRIB, AREV);
    SATTR();
END

/* SCOPE NORMAL (NO EXTRA ATTRIBUTES) */
STATIC VOID NORMAL()
BEGIN
    ATTRIB = ANRM;
    SATTR();
END

/* SCOPE - SELECT REGION (TOP/BOTTOM LINE) */
STATIC VOID REGION(TOP, BTM)
INT TOP;
INT BTM;
BEGIN
    SCPCMD2(TOP, BTM, LC('R'));
END

/* SCOPE - REGION IS FULL SCREEN */
STATIC VOID RGNALL()
BEGIN
    REGION(1, ROWS);
END

/* SCOPE - REGION IS TOP DISPLAY */
STATIC VOID RGNTOP()
BEGIN
    REGION(1, ROWS - BROWS);
END

/* SCOPE - REGION IS BOTTOM (COMMAND SCROLL) */
STATIC VOID RGNBTM()
BEGIN
    REGION(ROWS - BROWS + 2, ROWS);
END

/* SCOPE - CLEAR SCREEN */
STATIC VOID CLS()
BEGIN
    SCPCMD1(2, 'J');
END

/* SCOPE - CLEAR TO END OF LINE */
STATIC VOID CLREOL()
BEGIN
    SCPCMDC('K');
END

/* SCOPE - CURSOR TO CP DETERMINED BY LAST FULL SCREEN UPDATE */
STATIC VOID GOCURS()
BEGIN
    GOTOYX(CLINE + 1, CCOL + 1);
END

/* SCOPE - CLEAR TO END OF SCREEN */
STATIC VOID CLREOS()
BEGIN
    GOCURS();
    CLREOL();
    IF (CLINE < (ROWS - BROWS - 1)) BEGIN
	SCPCMDC('B');
	SCPCMD1(ROWS- CLINE - BROWS - 1, 'L');
	SCPCMDC('A');
    END
    GOCURS();
END

/* SCOPE - CURSOR TO TOP LEFT */
STATIC VOID HOME()
BEGIN
    GOTOYX(1, 1);
END

/* EMPTY SCREEN, DIVIDER, SCROLL REGION */
STATIC VOID DIV()
BEGIN
    CLS();
    DIV2();
    RGNBTM();
END

/* REFRESH SCOPE MODE DISPLAY. USED AFTER COMMANDS THAT DISRUPT
 * DISPLAY.
 */
STATIC VOID RFRSHS()
BEGIN
    IF (FSCOPE) BEGIN
	SIZEC();
	DIV();
	UPDATE();
	LASTLF = YES;
    END
END

/* DISPLAY HELP */
STATIC VOID HELP()
BEGIN
    IF (!EXEC) RETURN;
    IF (NUM < 0) BEGIN
	NUM = -NUM;
	--NUM;
	COPYA(EDHELP[NUM] + STRLEN(EDHELP[NUM]));
	STRADD(EDHELP[NUM], 13);
	STRADD(EDHELP[NUM], 10);
	RETURN;
    END
    IF (NUM == 0) NUM = 1;
    --NUM;
    IF (NUM > 9) BEGIN
	PERR('?');
	RETURN;
    END
    IF (FSCOPE) BEGIN
	DIV();
	HOME();
    END
    ROUT(EDHELP[NUM]);
    IF (FSCOPE) CIN();
    RFRSHS();
END

/* BUMP NUMBER, -VE OR +VE TOWARDS ZERO */
STATIC VOID BUMP()
BEGIN
    IF (NUM < 0) ++NUM;
    ELSE	 --NUM;
END

/* IS CURRENT POINT AT BUFFER BEGINNING ? */
STATIC BOOL ATBEG()
BEGIN
    RETURN CP <= 0;
END

/* IS CURRENT POINT AT BUFFER END ? */
STATIC BOOL ATEND()
BEGIN
    RETURN CP >= MP;
END

/* IS CURRENT POINT STILL WITHIN THE EDIT BUFFER ? */
STATIC BOOL OK()
BEGIN
    IF (NUM < 0)      RETURN !ATBEG();
    ELSE IF (NUM > 0) RETURN !ATEND();
    RETURN NO;
END

/* IS CURRENT POINT PLUS OFFSET WITHIN EDIT BUFFER ? */
STATIC BOOL OK2(N)
INT N;
BEGIN
    BOOL R;
    CP += N;
    R = OK();
    IF ((NUM < 0) AND (CP == 0))
	R = YES;
    CP -= N;
    RETURN R;
END

/* SAVE CURRENT POINT (INCLUDING LINE NUMBER) */
STATIC VOID SAVPOS(P)
STRUCT POSN *P;
BEGIN
    P->KEEPCP = CP;
    P->KEEPLN = LN;
END

/* RESTORE CURRENT POINT (INCLUDING LINE NUMBER) */
STATIC VOID RSTPOS(P)
STRUCT POSN *P;
BEGIN
    CP = P->KEEPCP;
    LN = P->KEEPLN;
END

/* IS CHARACTER AN END-OF-STRING CHARACTER ? */
STATIC BOOL ISEOS(C)
INT C;
BEGIN
    RETURN (C == 0) OR (C == CTL('Z')) OR (C == CTL('D'));
END

/* EDITOR ABEND */
STATIC VOID ABEND()
BEGIN
    RESTC();
    FABEND = YES;
END

/* SUBMIT COMMANDS IN STRING, EXECUTE STRING. SAVES COMMAND ARG AND
 * SELECTOR AROUND THE COMMAND EXECUTED.
 */
STATIC VOID SUBMIT(S)
CHAR *S;
BEGIN
    CHAR *KC = CMDPTR;
    INT KN = NUM;
    CHAR KS = SELEC;
    CMDPTR = S;
    ++SUBLVL;
    EXALL();
    --SUBLVL;
    NUM = KN;
    CMDPTR = KC;
    SELEC = KS;
END

/* PRINT SPACE */
STATIC VOID SPACE()
BEGIN
    COUT(' ');
END

/* EAT CHARACTER, USED FOR COUTF */
STATIC VOID EAT(C)
INT C;
BEGIN
END

/* RETURN NUMBER OF DISPLAY COLUMNS NEEDED FOR CHARACTER */
STATIC INT PWIDTH(C)
INT C;
BEGIN
    STATIC UNSIGNED INT STATE = UTFACC, CODEP = 0;
    RETURN COUTF(C, EAT, &STATE, &CODEP);
END

/* BACK UP ONE COLUMN */
STATIC VOID BACKSP()
BEGIN
    IF (COL > 0) BEGIN
	--COL;
	PC(CHBS);
    END
END

/* PRINT NUMBER */
STATIC VOID NOUT(N)
INT N;
BEGIN
    SOUT(FMTN(N));
END

/* PRINT NUMBER, UP TO 5 DIGITS, RIGHT JUSTIFY */
STATIC VOID PADNUM(N)
INT N;
BEGIN
    IF (N >= 100000) BEGIN
	SOUT("#####");
	RETURN;
    END
    IF (N < 10)	   SPACE();
    IF (N < 100)   SPACE();
    IF (N < 1000)  SPACE();
    IF (N < 10000) SPACE();
    NOUT(N);
END

/* SKIP TO COLUMN STCOL */
STATIC VOID SKPCOL()
BEGIN
    CRLF();
    WHILE (COL < STCOL) SPACE();
END

/* BOUNCE POINT TO MATCHING BRACKET */
STATIC VOID BOUNCE()
BEGIN
    CHAR *SET1 = "([<\173"; /* BRACE AT END */
    CHAR *SET2 = ")]>\175";
    INT I, N;
    CHAR C, CT = 0, D;
    BOOL SS = NO;
    BOOL ISLSP = ISLISP();
    IF (!EXEC) RETURN;
    C = EBUF[CP];
    FOR (I = 0; I < STRLEN(SET1); ++I) BEGIN
	IF (C == SET1[I]) BEGIN
	    CT = SET2[I];
	    D = 1;
	    BREAK;
	END
	IF (C == SET2[I]) BEGIN
	    CT = SET1[I];
	    D = -1;
	    BREAK;
	END
    END
    IF (CT == 0) BEGIN
	PERR('?');
	IF (IMMED) CRLF();
	RETURN;
    END
    NUM = D;
    I = 0;
    N = 1;
    WHILE (OK2(I + D) AND (N != 0)) BEGIN
	I += D;
	IF ((EBUF[CP + I] == '"') OR
	    ((EBUF[CP + I] == '\'') AND !ISLSP)) BEGIN
	    SS = !SS;
	    CONTINUE;
	END
	IF (SS) CONTINUE;
	IF (EBUF[CP + I] == C) ++N;
	IF (EBUF[CP + I] == CT) --N;
    END
    IF (N == 0) BEGIN
	/* CP += I; */
	NUM = I;
	CHARS();
    END ELSE BEGIN
	PERR('#');
	IF (IMMED) CRLF();
    END
END

/* SCOPE - WIPE CHARACTERS FROM SCREEN */
STATIC VOID WIPE(N)
INT N;
BEGIN
    INT I;
    FOR (I = 0; I < N; ++I) BACKSP();
    FOR (I = 0; I < N; ++I) SPACE();
    FOR (I = 0; I < N; ++I) BACKSP();
END

/* ERASE LAST CHARACTER (CRT) */
/* FIXME - UTF8 */
STATIC VOID ERASCH(S, T)
CHAR *S, *T;
BEGIN
    INT N;
    IF ((*S == CHTAB) AND XPTAB) BEGIN
	FOR (N = 0; T != S; ++T) BEGIN
	    IF (*T == CHTAB)
		DO
		    ++N;
		WHILE (N % XPTAB);
	    ELSE IF (ISCNTL(*T))
		N += 2;
	    ELSE
		++N;
	END
	N = COL - STCOL - N;
	WIPE(N);
    END ELSE IF (ISCNTL(*S)) BEGIN
	WIPE(2);
    END ELSE IF ((*S == 0) OR ((*S BAND 0XFF) >= 127)) BEGIN
	WIPE(4);
    END ELSE IF (CHAR64 AND (*S >= 96)) BEGIN
	WIPE(3);
    END ELSE BEGIN
	WIPE(1);
    END
END

/* SCOPE MODE FAST UPDATE ATTEMPT */
STATIC VOID FAST(D)
INT D;
BEGIN
    FASTUP = YES;
    IF (LINEST[CLINE + 1] != 0XFFFFFFFF)
	LINEST[CLINE + 1] += D;
END

/* GET COMMAND, WITH EDITING. RETURNS NO ON EOF OR ABEND */
STATIC BOOL GETCMD()
BEGIN
    INT I, N, M;
    CHAR C;
    FASTUP = NO;
    N = 0;
    CMDPTR = CMND;
    PROMPT();
    STCOL = COL;
    IMMED = NO;
    FOREVER BEGIN
/* FIXME -- INPUT MAPPING, FAST(0), FAST(-1), IMM IS ASSUMED */
	C = CIN();
	IF (C == EOF) BEGIN
	    RETURN NO;
	END
	IF (C == KEYBS) BEGIN
	    /* FIXME - UTF8 */
	    IF (N > 0) BEGIN
		--N;
		ERASCH(CMND + N, CMND);
	    END
	    CONTINUE;
	END
	IF (C == KEYRUB) BEGIN
	    /* FIXME - UTF8 */
            IF (N > 0)
		COUT(CMND[--N]);
	    CONTINUE;
	END
	SWITCH (C) BEGIN
/* FIXME: HOME AND END NOT WORKING - MAYBE F1 AS WELL */
/* ANSI TERMINAL VS. VT100
 * ESC [H ESC [F
 */
	    CASE CHESC:
		C = CIN();
		IF (C == 'O') BEGIN
		    C = CIN();
		    IF (C == 'H') BEGIN
			STRCPY(CMND, "0L");
			FAST(0);
			GOTO IMM;
		    END ELSE IF (C == 'F') BEGIN
			STRCPY(CMND, "L-C");
			FAST(0);
			GOTO IMM;
		    END ELSE IF (C == 'P') BEGIN
			STRCPY(CMND, "?");
			GOTO IMM;
		    END
		    CONTINUE;
		END
		IF (C != '[') CONTINUE;
		SWITCH (C = CIN()) BEGIN
		    CASE '1':
			IF (CIN() != ';') BREAK;
			IF (CIN() != '5') BREAK;
			C = CIN();
			IF (C == 'C')
			    /* CTRL-RIGHT ARROW */
STRCPY(CMND, "($" NL CZ "$ " CZ "$" TA CZ "=OR OR NOT" CZ ">C<)"
             "($" NL CZ "$ " CZ "$" TA CZ "=OR OR" CZ ">C<)");
			ELSE IF (C == 'D')
			    /* CTRL-LEFT ARROW */
STRCPY(CMND, "($" NL CZ "$ " CZ "$" TA CZ "=OR OR NOT" CZ ">-C<)"
             "($" NL CZ "$ " CZ "$" TA CZ "=OR OR" CZ ">-C<)"
             "($" NL CZ "$ " CZ "$" TA CZ "=OR OR NOT" CZ ">-C<)C");
			FAST(0);
			BREAK;
		    /* FIXME:
		     *
		     * -L AND L SHOULD ATTEMPT TO KEEP THE CURSOR AT THE
		     * CURRENT COLUMN! WE COULD USE MACROS HERE
		     *
		     * WE NEED TO COUNT THE NUMBER OF CHARACTERS BACK
		     * TO THE PREVIOUS NEWLINE. ACCESS TO THE MARKS
		     * (LINE/CHARACTER) WOULD HELP.
		     */
		    CASE 'A': STRCPY(CMND, "-L");
/*			      IF (CLINE != 0) BEGIN
 *				  --CLINE;
 *				  FASTUP = YES;
 *			      END
 */
			      BREAK;
		    CASE 'B': STRCPY(CMND, "L");
/*			      FASTUP = YES;
 */
			      BREAK;
		    CASE 'C': STRCPY(CMND, "C");
			      FAST(0);
			      BREAK;
		    CASE 'D': STRCPY(CMND, "-C");
			      FAST(0);
			      BREAK;
		    CASE 'H': STRCPY(CMND, "0L");
			      FAST(0);
			      BREAK;
		    CASE 'F': STRCPY(CMND, "L-C");
			      FAST(0);
			      BREAK;
		    DEFAULT:
			      M = 0;
			      WHILE (ISNUM(C)) BEGIN
				  M = M * 10 + C - '0';
				  C = CIN();
			      END
			      SWITCH (M) BEGIN
				  CASE 5: STRCPY(CMND, "-P"); BREAK;
				  CASE 6: STRCPY(CMND, "P"); BREAK;
				  CASE 2: STRCPY(CMND, S2L("-I"));
					  BREAK;
				  CASE 1: STRCPY(CMND, "0L");
					  FAST(0);
					  BREAK;
				  CASE 4: STRCPY(CMND, "L-C");
					  FAST(0);
					  BREAK;
				  CASE 3: STRCPY(CMND, "D");
					  FAST(-1);
					  BREAK;
			      END
			BREAK;
		END
IMM:		CR();
		IMMED = YES;
		RETURN YES;
	    CASE CTL('K'):
		IMMED = YES;
		STRCPY(CMND, S2L("-I"));
		RETURN YES;
	    CASE CTL('B'):
		IMMED = YES;
		STRCPY(CMND, ",");
		RETURN YES;
	    CASE CTL('T'):
		INCIND(IDELTA);
		IMMED = YES;
		STRCPY(CMND, "0C");
		FAST(0);
		RETURN YES;
	    CASE CTL('G'):
		INCIND(-IDELTA);
		IMMED = YES;
		STRCPY(CMND, "0C");
		FAST(0);
		RETURN YES;
/*	    CASE CTL('L'):
 */
	    CASE CTL('V'):
		IF (FSCOPE) BEGIN
		    SIZEC();
		    DIV();
		    UPDATE();
		    LASTLF = YES;
		    PROMPT();
		    FOR (I = 0; I < N; ++I)
			COUT(CMND[I]);
		END
		F8 = NO;
		BREAK;
	    CASE CTL('C'):
		IF (N == 0) BEGIN
		    ABEND();
		    RETURN NO;
		END
		BREAK;
	    CASE CTL('E'):
		SKPCOL();
		BREAK;
	    CASE CTL('A'):
		STRCPY(CMND, AGAIN);
		RETURN YES;
	    CASE CTL('J'):
	    CASE CTL('M'):
		CMND[N] = 0;
		IF ((CSP == 0) AND (ISP == 0))
		    STRCPY(AGAIN, CMND);
		IF (IACTIV)
		    CRLF();
		STCOL = 0;
		RETURN YES;
	    CASE CTL('R'):
		COUT('#');
		SKPCOL();
		FOR (I = 0; I < N; ++I)
		    COUT(CMND[I]);
		BREAK;
	    CASE CTL('U'):
		N = 0;
		SKPCOL();
		BREAK;
	    CASE CTL('X'):
		WHILE (N > 0) BEGIN
		    --N;
		    ERASCH(CMND + N, CMND);
		END
		CR();
		WHILE (COL < STCOL) SPACE();
		BREAK;
	    CASE CTL('F'):
		FOR (I = 0; SHELF[I]; ++I) BEGIN
		    COUT(SHELF[I]);
		    CMND[N++] = SHELF[I];
		END
		BREAK;
	    CASE CTL('P'):
		C = CIN();
		/* AND FALL THROUGH */
	    DEFAULT:
		IF (IACTIV)
		    COUT(C);
		CMND[N++] = C;
		IF (N == (MAXCMD - 1)) BEGIN
		    CMND[N] = 0;
		    STCOL = 0;
		    RETURN YES;
		END
		BREAK;
	END
    END
    RETURN YES;
END

/* CLEAR EDIT BUFFER */
STATIC VOID CLRBUF()
BEGIN
    EBUF[CP = MP = TN = 0] = 0;
    LN = 1;
    SPRSLN = NO;
    CHANGE = 0;
END

/* OPEN INPUT AND OUTPUT FILES */
STATIC VOID PREPF()
BEGIN
    INFILE = OPENF(INNAM, 'R');
    CPM80 = NO;
    OUTFIL = OPENF(OUTNAM, 'W');
    NBYTES = 0;
    IDXFIL = NULL;
END

/* INITIALIZE EDITOR, DEFAULT STATE */
STATIC VOID INIT()
BEGIN
    INT I;
    FOR (I = 0; I < 256; ++I)
	LINEST[I] = 0XFFFFFFFF;
    CBUF = 1;
    SEEALL = NO;
    PL = 16;
    MBELL = 0;
    UTF8 = NO;
    CHANGE = 0;
    FLN = YES;
    FSCOPE = 0; /* 0, 1, 2 */
    FUC = NO;
    FEX = NO;
    INMAC = NO;
    FONE = NO;
    XPTAB = 8;
    SUBLVL = 0;
    F8 = NO;
    CHAR64 = NO;
    AUTOIN = NO;
    FLITL = YES;
    IDELTA = 4;
    LASTLF = YES;
    IMMED = NO;
    FASTUP = NO;
    ATTRIB = 0;
    CRSOFF = NO;
    ROWS = 24;
    COLS = 80;
    KEYBS = CHBS;
    KEYRUB = RUBOUT;
    STRCPY(DMODE, STRCPY(MODE, "TEXT"));
    STRCPY(XFNAM, XFILE);
    MDSEL = 0;
    BROWS = 6;
    EXEC = YES;
    MSP = 0;
    ISP = 0;
    CSP = 0;
    BAR = 0;
    OFFLEV = 0;
    RESULT = 1;
    SHELF[0] = 0;
    AGAIN[0] = 0;
    SSRCH[0] = 0;
    SREPL[0] = 0;
    SDELT[0] = 0;
    STRCPY(SSHELL, S2L("SH"));
    SCMND = 0;
    ALLOC();
    CLRBUF();
    CLRUND();
    IF (EBUF == NULL) BEGIN
	LOUT("NO EDIT BUFFER");
	ABEND();
	RETURN;
    END
    IF (UNDO_P == NULL)
	LOUT("NO UNDO BUFFER");
    IF (EBUF2 == NULL)
	LOUT("NO SECONDARY BUFFER");
    PREPF();
    ISNEWFILE = NO;
    IF (INFILE == CLOSED) BEGIN
	ISNEWFILE = YES;
	LOUT("NEW FILE");
    END
END

/* PRINT LINE NUMBER (FOR PROMPT) */
STATIC VOID PLNNS()
BEGIN
    IF (FLN) BEGIN
	IF (ATEND())
	    SOUT("     ");
	ELSE
	    PADNUM(LN);
	SOUT(": ");
    END
END

/* PRINT LINE NUMBER, NOT FOR PROMPT */
STATIC VOID LOUTN()
BEGIN
    IF (FLN) BEGIN
	PLNNS();
	SPACE();
    END
END

/* FORCE DISPLAY OF LINE NUMBER */
STATIC VOID FORCELINENUMBER()
BEGIN
    ++MP;
    LOUTN();
    --MP;
END

/* COMPUTE TAB AND SPACE INDENTATION. NOTE THAT INSERT AND REMOVE
 * CHARACTER ENSURE THAT A ZERO BYTE TERMINATES THE EDIT BUFFER,
 * SO WE DON'T NEED SPECIAL HANDLING FOR CP >= MP CONDITION.
 */
STATIC CHAR *TABSPC(S, N)
CHAR *S;
INT *N;
BEGIN
    *N = 0;
    FOR (; *S; ++S) BEGIN
	IF (*S == ' ')
	    ++*N;
	ELSE IF ((*S == CHTAB) AND XPTAB) BEGIN
	    DO
		++*N;
	    WHILE (*N % XPTAB);
	END ELSE
	    BREAK;
    END
    RETURN S;
END

/* INCREASE AUTOMATIC INDENT BY D */
STATIC VOID INCIND(D)
INT D;
BEGIN
    INT N, I;
    CHAR *S, *T;
    TAGUND();
    SUBMIT("0L");
    T = TABSPC((S = EBUF + CP), ADDR(N));
    CP += (I = T - S);
    N += D; /* IDELTA */
    WHILE (I--)
	SUBMIT("-D");
    WHILE (N > 0) BEGIN
	IF ((XPTAB > 1) AND (N >= XPTAB)) BEGIN
	    INSERT(CHTAB, YES);
	    N -= XPTAB;
	END ELSE BEGIN
	    INSERT(' ', YES);
	    --N;
	END
    END
END

/* INDENT/OUTDENT NUM LEVELS */
STATIC VOID DOIND()
BEGIN
    INT N = IDELTA;
    IF (N <= 0)
	RETURN;
    IF (NUM < 0) BEGIN
	N = -N;
	NUM = -NUM;
    END
    IF (NUM == 0)
	RETURN;
    WHILE (NUM--)
	INCIND(N);
END

/* INSERT INDICATOR */
STATIC VOID INSIND()
BEGIN
/*  STATIC CHAR KEEP[16]; */
/*  STRCPY(KEEP, DMODE); */
/*  STRCPY(DMODE, "INSERT"); */
    UPDATE();
    DIV2();
    GOSTAT();
    SOUT("INSERT");
    RGNTOP();
    GOCURS();
/*  STRCPY(DMODE, KEEP); */
END

/* TURN OFF INSERT INDICATOR */
STATIC VOID INSOFF()
BEGIN
    HOME();
    RGNBTM();
    UPDATE();
    DIV2();
END

/* BULK INPUT */
STATIC VOID INPUT1()
BEGIN
    CHAR *S, *T, *U, C;
    INT I;
    IF (INMAC)
	RETURN;
    S = EBUF + CP;
    T = S;
    IF (FSCOPE == 1) BEGIN
	INSIND();
	RGNTOP();
	CLREOS();
    END
    IF (FSCOPE != 1)
	FORCELINENUMBER();
    STCOL = COL;
    IF (FSCOPE == 1) BEGIN
	STCOL = 0;
	COL = CCOL;
    END
    FOREVER BEGIN
	C = CIN();
	IF (MBELL AND ((COL - STCOL) >= MBELL)) BELL();
	IF ((C == CTL('Z')) OR (C == CTL('D')) OR (C == CTL('K'))) BEGIN
	    CRLF();
	    BREAK;
	END ELSE IF (C == KEYBS) BEGIN
	    IF (T != S) BEGIN
		/* FIXME - UTF8 */
		ERASCH(--T, S);
		--CP;
		REMOVE(YES);
	    END
	END ELSE IF (C == KEYRUB) BEGIN
	    IF (T != S) BEGIN
		/* UTF8 */
		--T;
		COUT(EBUF[--CP]);
		REMOVE(YES);
	    END
	END ELSE IF (C == CTL('R')) BEGIN
	    COUT('#');
	    SKPCOL();
	    FOR (U = S; U < T; ++U)
		COUT(*U);
	END ELSE IF (C == CTL('E')) BEGIN
	    SKPCOL();
	END ELSE IF (C == CTL('W')) BEGIN
	    FOR (I = 0; (I < MAXT) AND HTABS[I]; ++I)
		IF (HTABS[I] > COL) BEGIN
		    WHILE ((COL - STCOL + 1) < HTABS[I]) BEGIN
			COUT(' ');
			INSERT(' ', YES);
			++T;
		    END
		    BREAK;
		END
	END ELSE IF (C == CTL('T')) BEGIN
	    NOTHING;
	END ELSE IF (C == CTL('G')) BEGIN
	    NOTHING;
	END ELSE IF (C == CTL('M')) BEGIN
	    TAGUND();
	    IF (!INSERT(CHLF, YES))
		BREAK;
	    CRLF();
	    IF (FSCOPE != 1) FORCELINENUMBER();
	    STCOL = COL;
	    S = EBUF + CP;
	    T = S;
	END ELSE IF (C == CTL('U')) BEGIN
	    SKPCOL();
RMLINE:	    I = 0;
	    IF (T != S)
		FOR (U = T; U < (EBUF + MP); ++U)
		    S[I++] = *U;
	    CP -= (T - S);
	    MP -= (T - S);
	    T = S;
	    EBUF[MP] = 0;
	END ELSE IF (C == CTL('X')) BEGIN
	    IF (T != S)
		FOR (U = T - 1; U >= S; --U)
		    ERASCH(U, S);
	    GOTO RMLINE;
	END ELSE IF (C == CTL('P')) BEGIN
	    C = CIN();
	    GOTO INSERT;
	END ELSE BEGIN
INSERT:	    COUT(C);
	    ++T;
	    IF (!INSERT(C, YES))
		BREAK;
	END
    END
    STCOL = 0;
    IF (FSCOPE == 1)
	INSOFF();
END

/* "HIGH IMPACT" FULL-SCREEN INPUT */
STATIC VOID INPUT2()
BEGIN
    CHAR *S = EBUF + CP;
    CHAR *T = S;
    CHAR C;
    INT N, M;
    IF (!FSCOPE) BEGIN
	INPUT1();
	RETURN;
    END
    INSIND();
    CRSOFF = YES;
    FASTUP = NO;
    UPDATE();
    GOCURS();
    WHILE (((C = CIN()) != CTL('Z')) AND (C != CTL('D')) AND
           (C != CTL('K'))) BEGIN
	/* LOOK FOR INS KEY TO STOP INSERT AS WELL.
	 * WE COULD ALSO HANDLE OTHER KEYS HERE, BUT KEEP IT
	 * SIMPLE!
	 */
	IF (C == CHESC) BEGIN
	    IF (CIN() != '[') CONTINUE;
	    IF (CIN() != '2') CONTINUE;
	    IF (CIN() != TILDE) CONTINUE;
	    BREAK;
	END
	IF (C == CTL('M')) BEGIN
	    TAGUND();
	    IF (AUTOIN) BEGIN
		FOR (N = CP; N; --N) BEGIN
		    IF (EBUF[N - 1] == CHLF)
			BREAK;
		END /* NOW N POINTS TO WHITESPACE TO DUPLICATE */
		M = CP;
		INSERT(CHLF, YES);
		++T;
		WHILE ((N < M) AND ISWHIT(EBUF[N])) BEGIN
		    INSERT(EBUF[N++], YES);
		    ++T;
		END
		GOTO BTM;
	    END
	    C = CHLF;
	    GOTO INSERT;
	END ELSE IF ((C == KEYBS) OR (C == KEYRUB)) BEGIN
	    IF (S != T) BEGIN
		/* FIXME - UTF8 */
		--CP;
		IF (EBUF[CP] == CHLF) --LN;
		REMOVE(YES);
		--T;
		FAST(-1);
	    END
	END ELSE IF ((C == CTL('X')) OR (C == CTL('U'))) BEGIN
	    WHILE ((S != T) AND (EBUF[CP - 1] != CHLF)) BEGIN
		/* FIXME - UTF8 */
		--CP;
		REMOVE(YES);
		--T;
	    END
	END ELSE IF ((C == CTL('R')) OR (C == CTL('E'))) BEGIN
	    NOTHING; /* RETYPE, LOGICAL LINE NOT NEEDED */
	END ELSE IF (C == CTL('T')) BEGIN
	    INCIND(IDELTA);
	END ELSE IF (C == CTL('G')) BEGIN
	    INCIND(-IDELTA);
	END ELSE IF (C == CTL('W')) BEGIN
	    FOR (N = 0; (N < MAXT) AND HTABS[N]; ++N)
		IF (HTABS[N] > (CCOL + 1)) BEGIN
		    WHILE ((CCOL + 1) < HTABS[N]) BEGIN
			INSERT(' ', YES);
			++T;
			FAST(1);
			UPDATE();
			GOCURS();
		    END
		GOTO BTM2;
		END
	END ELSE IF (C == CTL('P')) BEGIN
	    C = CIN();
	    GOTO INSERT;
	END ELSE BEGIN
INSERT:	    INSERT(C, YES);
	    ++T;
	    IF (C != CHLF) BEGIN
		FAST(1);
	    END
	END
BTM:	UPDATE();
	GOCURS();
BTM2:	IF (MBELL AND (CCOL >= MBELL)) BELL();
    END
    INSOFF();
    CRSOFF = NO;
END

/* INSERT CHARACTER INTO EDIT BUFFER */
STATIC BOOL INSERT(C, U)
INT C;
BOOL U;
BEGIN
    NO_MM(INT I;)
    IF (MP >= (BSIZE - 1)) BEGIN
	PERR('>');
	RETURN NO;
    END
    IF (U)
	ADDUND(2, 0, CP);
    IF (CBUF == 1) ++CHANGE;
    IF_MM(MEMMOVE(EBUF + CP + 1, EBUF + CP, MP - CP);)
    NO_MM(FOR (I = MP; I > CP; --I))
	NO_MM(EBUF[I] = EBUF[I - 1];)
    IF (FUC OR ISUC(SELEC))
	C = TOUC(C);
    EBUF[CP++] = C;
    EBUF[++MP] = 0;
    IF (C == CHLF)
	++LN;
    RETURN YES;
END

/* REMOVE CHARACTER FROM EDIT BUFFER */
STATIC VOID REMOVE(U)
BOOL U;
BEGIN
    NO_MM(INT I;)
    IF (ATEND())
	RETURN;
    IF (U)
	ADDUND(1, EBUF[CP], CP);
    IF (CBUF == 1) ++CHANGE;
    --MP;
    IF_MM(MEMMOVE(EBUF + CP, EBUF + CP + 1, MP - CP);)
    NO_MM(FOR (I = CP; I < MP; ++I))
	NO_MM(EBUF[I] = EBUF[I+1];)
    EBUF[MP] = 0;
    IF (UTF8 AND ((EBUF[CP] & 0XC0) == 0X80))
	REMOVE(U);
END

/* ISSUE PROMPT FOR NEW COMMAND */
STATIC VOID PROMPT()
BEGIN
    IF (!IACTIV)
	RETURN;
    IF (!LASTLF AND !IMMED)
	CRLF();
    IF (!SPRSLN)
	PLNNS();
    SPRSLN = NO;
    COUT('*');
END

/* TRANSFER TO FILE (X) */
STATIC VOID TRANSF()
BEGIN
    INT I, C;
    PFILE F;
    IF (!EXEC) RETURN;
    IF (NUM < 0) BEGIN
	PERR('?');
	RETURN;
    END
    IF (NUM == 0) BEGIN
	UNLINK(XFNAM);
	RETURN;
    END
    IF ((F = OPENF(XFNAM, 'A')) == CLOSED) BEGIN
	PERR('O');
	RETURN;
    END
    FOR (I = CP; (I != MP) AND NUM; ++I) BEGIN
	C = EBUF[I];
	IF (!FCOUT(C, F))
	    RETURN;
	IF (C == CHLF)
	    BUMP();
    END
    CLOSEF(F);
END

/* COMPUTE HALF */
STATIC INT CHALF()
BEGIN
    IF (NUM == 0) BEGIN
	NUM = MAXREP();
	RETURN BSIZE / 2;
    END
    RETURN 0;
END

/* WRITE LINES (W) */
STATIC VOID WRITE()
BEGIN
    INT C, I, J, K, HALF;
    INT PAGECN = -1;
    IF (!EXEC) RETURN;
    IF (CBUF != 1) BEGIN PERR('Z'); RETURN; END
    CLRUND();
    IF (NUM < 0) BEGIN
	PAGECN = -NUM;
	NUM = MAXREP();
    END
    HALF = CHALF();
    FOR (I = 0; (I != MP) AND NUM; ++I) BEGIN
	C = EBUF[I];
	IF (CPM80 AND (C == CHLF)) BEGIN
	    ++NBYTES;
	    IF (!FCOUT(CHCR, OUTFIL))
	    RETURN;
	END
	++NBYTES;
	IF (!FCOUT(C, OUTFIL))
	    RETURN;
	IF (C == CHLF) BEGIN
	    ++TN;
	    BUMP();
	END
	IF (I == CP)
	    CP = 0;
	IF (HALF AND (I >= HALF) AND (C == CHLF))
	    BREAK;
	IF ((C == CTL('L')) AND (PAGECN > 0))
	    IF (--PAGECN == 0) BEGIN
		++I;
		BREAK;
	    END
    END
    FOR (K = 0, J = I; J < MP; ++J)
	EBUF[K++] = EBUF[J];
    MP -= I;
    IF (CP >= MP)
	CP = 0;
    IF (ATBEG())
	LN = TN + 1;
    EBUF[MP] = 0;
END

/* SKIP ARGUMENT IN COMMAND */
STATIC VOID SKPARG()
BEGIN
    WHILE (!ISEOS(*CMDPTR))
	++CMDPTR;
    IF (*CMDPTR != 0)
	++CMDPTR;
END

/* COPY ARG */
STATIC VOID COPYA(S)
CHAR *S;
BEGIN
    IF (EXEC) BEGIN
	WHILE (!ISEOS(*CMDPTR))
	    *S++ = *CMDPTR++;
	*S = 0;
    END
    SKPARG();
END

/* COPY ARG, WITH TERMINATOR */
STATIC VOID COPYA2(S)
CHAR *S;
BEGIN
    IF (EXEC) BEGIN
	WHILE (!ISEOS(*CMDPTR))
	    *S++ = *CMDPTR++;
	*S++ = *CMDPTR++;
	*S = 0;
    END ELSE
        SKPARG();
END

/* COPY CHARACTERS TO SHELF
 *
 * IF 0* THEN COPY ARGUMENT TO SHELF
 * IF +V THEN COPY BUFFER CHARACTERS TO SHELF
 * IF -V THEN COPY TO CHAR TO SHELF
 * SHELF CAN BE RETRIEVED BY ^F
 */
STATIC VOID TOSHLF()
BEGIN
    INT I;
    CHAR C;
    IF (NUM == 0)
	COPYA(SHELF);
    ELSE IF (NUM > 0) BEGIN
	IF (NUM >= MAXCMD) NUM = MAXCMD - 1;
	FOR (I = 0; EBUF[CP + I] AND NUM; ++I, --NUM)
	    SHELF[I] = EBUF[CP + I];
	SHELF[I] = 0;
    END ELSE IF (NUM == -1) BEGIN
	COPYA(SHELF);
	C = SHELF[0];
	FOR (I = 0; EBUF[CP + I] AND (EBUF[CP + I] != C); ++I)
	    SHELF[I] = EBUF[CP + I];
	SHELF[I] = 0;
    END ELSE
	PERR('?');
END

/* UPPER CASE STRING */
STATIC VOID UCSTR(S)
CHAR *S;
BEGIN
    FOR (; *S; ++S)
	*S = TOUC(*S);
END

/* OPEN FILE IN LOCAL DIRECTORY OR CELIB */
STATIC PFILE RDPATH(FN)
CHAR *FN;
BEGIN
    PFILE F;
    CHAR *S;
    CHAR FNAME[MAXFN];
    IF ((F = OPENF(FN, 'R')) == CLOSED) BEGIN
	S = GETENV("CELIB");
	IF (S != NULL) BEGIN
	    STRCPY(FNAME, S);
	    STRADD(FNAME, '/');
	    STRCAT(FNAME, FN);
	    F = OPENF(FNAME, 'R');
	END
    END
    RETURN F;
END

/* SOURCE IN COMMAND FILE */
STATIC VOID SOURCE()
BEGIN
    CHAR FNAME[MAXFN];
    FILE *F;
    COPYA(FNAME);
    IF (!EXEC) RETURN;
    IF (ISP >= ILIM) BEGIN
	PERR('#');
	RETURN;
    END
    F = RDPATH(FNAME);
    IF (F == CLOSED) BEGIN
	IF (STRCMP(FNAME, S2L(".CPMEDRC")))
	    PERR('?');
	RETURN;
    END
    ISTK[ISP++] = CINSRC;
    CINSRC = F;
    CMND[0] = 0;
    CMDPTR = CMND;
END

/* READ FILE (R) */
STATIC VOID READ()
BEGIN
    CHAR FNAME[MAXFN];
    PFILE F;
    INT C;
    COPYA(FNAME);
    IF (!EXEC) RETURN;
    IF (FNAME[0] == 0)
	STRCPY(FNAME, XFNAM);
    F = RDPATH(FNAME);
    IF (F == CLOSED) BEGIN
	PERR('O');
	RETURN;
    END
    WHILE ((C = FCIN(F)) != FEND) BEGIN
	IF (CPM80) BEGIN
	    IF (C == CHCR)
		NOTHING;
	    ELSE IF (C == CTL('Z'))
		BREAK;
	END ELSE BEGIN
	    IF (!INSERT(C, YES))
		BREAK;
	END
    END
    CLOSEF(F);
END

/* MODE SPECIFIC SETTINGS
 *
 * SETS AUTOINDENT, TAB EXPANSION, ^W TABULATION TO THE PREFERRED
 * SETTINGS FOR THE LANGUAGE MODE.
 */
STATIC VOID MDSPEC()
BEGIN
    SUBMIT("-.B 3.A .A 8.T -U");
    IF (ISC()) BEGIN
	SUBMIT("4.A");
    END ELSE IF (ISTEXT()) BEGIN
	SUBMIT("8.A");
    END ELSE IF (ISFORT()) BEGIN
	SUBMIT("72.B -.A -.T -.H 7.H");
    END ELSE IF (ISCOBO()) BEGIN
	SUBMIT("72.B -.A -.T -.H 8.H 12.H");
    END ELSE IF (ISSNOB()) BEGIN
	SUBMIT("72.B -.A -.T -.H 10.H 55.H");
    END ELSE IF (ISLISP() OR ISSHEL()) BEGIN
	SUBMIT("2.A");
    END ELSE IF (ISASSE()) BEGIN
	SUBMIT("72.B");
    END
END

/* SET TRANSFER FILE */
STATIC VOID SETXFN()
BEGIN
    COPYA(XFNAM);
    IF (XFNAM[0] == 0)
	STRCPY(XFNAM, XFILE);
END

/* FIXME: SHOULD ALSO SET IDX BIAS HERE - INITIALLY ZERO, BUT ON
 * INSERTION OF LF, DELETION OF LF, ADJUST. BIAS ASSUMES THAT MOTION
 * IN FILE IS FORWARD.
 *
 * INSERT, FORWARD K, FORWARD D CAN ADJUST BIAS. NEED TO READ NEXT
 * NUMBER FROM IDXFILE, APPLY ANY BIAS, AND TRANSFER TO THAT LINE
 * (BIAS IDX READ AS ARGUMENT). FEATURE INTERACTION WITH TOP LINE
 * OF CURRENT BUFFER -- THAT PLAYS INTO THE BIAS AS WELL... NEED
 * TO TEST THOSE CASES AS WELL. WOULD ALLOW PRE-INDEXING TARGET
 * LINES, NOTE THAT WRITE/APPEND COME INTO PLAY AS WELL.
 */
STATIC VOID SETIDX()
BEGIN
    CHAR FNAME[MAXFN];
    COPYA(FNAME);
    IF (IDXFIL) BEGIN
	CLOSEF(IDXFIL);
	IDXFIL = NULL;
    END
    IF (FNAME[0] == 0)
	RETURN;
    IDXFIL = OPENF(FNAME, 'R');
END

/* SET EDIT MODE (.M) */
STATIC VOID SETMDE()
BEGIN
    CHAR M[MAXFN];
    INT I;
    COPYA(M);
    IF (!EXEC) RETURN;
    UCSTR(M);
    M[15] = 0;
    IF (STRCMP(M, "?") == 0) BEGIN
	ROUT(MDHELP);
	RETURN;
    END
    ++MDSEL;
    IF (M[0] == 0)
	STRCPY(M, "TEXT");
    /* LOOK FOR LANGUAGE */
    FOR (I = 0; I < 128; ++I) BEGIN
	IF (ELIST[I].T[0])
	IF (STRICM(M, ELIST[I].T2) == 0) BEGIN
	    STRCPY(MODE, ELIST[I].T);
	    STRCPY(DMODE, ELIST[I].T2);
	    MDSPEC();
	    RFRSHS();
	    RETURN;
	END
    END
    /* NOW, BY EXTENSION */
    FOR (I = 0; I < 128; ++I) BEGIN
	IF (ELIST[I].T[0])
	IF (STRICM(M, ELIST[I].E) == 0) BEGIN
	    STRCPY(MODE, ELIST[I].T);
	    STRCPY(DMODE, ELIST[I].T2);
	    MDSPEC();
	    RFRSHS();
	    RETURN;
	END
    END
    PERR('?');
END

/* SELECT BUFFER 1, 2 OR 3 */
STATIC VOID SELBUF()
BEGIN
    IF (NUM == CBUF)
	RETURN;
    IF (CBUF == 1) BEGIN
	EBUF1  = EBUF;
	SP1    = SP;
	CP1    = CP;
	MP1    = MP;
	BSIZE1 = BSIZE;
	LN1    = LN;
	TN1    = TN;
    END ELSE IF (CBUF == 2) BEGIN
	EBUF2  = EBUF;
	SP2    = SP;
	CP2    = CP;
	MP2    = MP;
	BSIZE2 = BSIZE;
	LN2    = LN;
	TN2    = TN;
    END ELSE IF (CBUF == 3) BEGIN
	EBUF3  = EBUF;
	SP3    = SP;
	CP3    = CP;
	MP3    = MP;
	BSIZE3 = BSIZE;
	LN3    = LN;
	TN3    = TN;
    END ELSE IF (CBUF == 4) BEGIN
	EBUF4  = EBUF;
	SP4    = SP;
	CP4    = CP;
	MP4    = MP;
	BSIZE4 = BSIZE;
	LN4    = LN;
	TN4    = TN;
    END
    IF (NUM == 1) BEGIN
	CBUF   = 1;
	EBUF   = EBUF1;
	SP     = SP1;
	CP     = CP1;
	MP     = MP1;
	BSIZE  = BSIZE1;
	LN     = LN1;
	TN     = TN1;
    END ELSE IF (NUM == 2) BEGIN
	IF (EBUF2 == NULL) BEGIN
	    PERR('?');
	    RETURN;
	END
	CBUF   = 2;
	EBUF   = EBUF2;
	SP     = SP2;
	CP     = CP2;
	MP     = MP2;
	BSIZE  = BSIZE2;
	LN     = LN2;
	TN     = TN2;
    END ELSE IF (NUM == 3) BEGIN
	IF (EBUF == NULL) BEGIN
	    PERR('?');
	    RETURN;
	END
	CBUF   = 3;
	EBUF   = EBUF3;
	SP     = SP3;
	CP     = CP3;
	MP     = MP3;
	BSIZE  = BSIZE3;
	LN     = LN3;
	TN     = TN3;
    END ELSE IF (NUM == 4) BEGIN
	IF (EBUF == NULL) BEGIN
	    PERR('?');
	    RETURN;
	END
	CBUF   = 4;
	EBUF   = EBUF4;
	SP     = SP4;
	CP     = CP4;
	MP     = MP4;
	BSIZE  = BSIZE4;
	LN     = LN4;
	TN     = TN4;
    END ELSE
    	PERR('?');
END

/* APPEND LINES (A) */
STATIC VOID APPEND()
BEGIN
    INT C, HALF;
    INT STATE = 0;
    INT PAGECN = -1;
    CHAR FT[MAXCMD];
    INT NFT = 0;
    IF (!EXEC) RETURN;
    IF (CBUF != 1) BEGIN PERR('Z'); RETURN; END
    FT[0] = 0;
    CLRUND();
    IF (NUM < 0) BEGIN
	PAGECN = -NUM;
	NUM = MAXREP();
    END
    HALF = CHALF();
    WHILE (NUM) BEGIN
	IF (MP >= BSIZE) BEGIN
	    PERR('>');
	    BREAK;
	END
	C = FCIN(INFILE);
	IF (C == FEND) BEGIN
	    INFILE = CLOSEF(INFILE);
	    BREAK;
	END
	/* FIND CE LINES AND SUBMIT THEM
	 * THIS ALLOWS AUTOMATIC MODE FOR FILES WITH NO EXTENSION
	 * (SCRIPTS THAT ARE EXECUTABLE, FOR EXAMPLE) USES A STATE
	 * MACHINE TO IDENTIFY " C E:" WHICH TAKES A SWITCH AND A
	 * CHARACTER COMPARE PER CHARACTER, AND SHOULDN'T IMPACT
	 * APPEND() TIME.
	 */
	SWITCH (STATE) BEGIN
	    CASE 0: IF (C == ' ') STATE = 1; BREAK;
	    CASE 1: STATE = ((C == LC('C')) || (C == 'C')) ? 2 : 0;
		    BREAK;
	    CASE 2: STATE = ((C == LC('E')) || (C == 'E')) ? 3 : 0;
		    BREAK;
	    CASE 3: STATE = (C == ':')                     ? 4 : 0;
		    BREAK;
	    CASE 4:
		IF (C == CHLF) BEGIN
		    STATE = 0;
		    NFT = 0;
		END ELSE IF (C != ';') BEGIN
		    IF (NFT < MAXCMD) BEGIN
			FT[NFT++] = (C == ';') ? CTL('Z') : C;
		    END
		END ELSE BEGIN /* ';' */
		    STATE = 0;
		    FT[NFT] = 0;
		    SUBMIT(FT);
		    NFT = 0;
		END
		BREAK;
	END
	/* CONSIDER IF CPM80 IS ON, CR SHOULD BE IGNORED (AND WE WANT
	 * TO PAD FILE WITH ^Z TO 128 BYTE BOUNDARY). AUTOMATIC
	 * DETECTION OF CR TO SET THE MODE ON READING MEANS THAT WE
	 * CANNOT EDIT FILES WITH ^M CHARACTERS -- BASICALLY, LOSE THE
	 * ABILITY TO DO BINARY EDITS.
	 */
	IF ((C == CHCR) AND CPM80)
	    NOTHING;
	ELSE IF ((C == CTL('Z')) AND CPM80) BEGIN
	    INFILE = CLOSEF(INFILE);
	    BREAK;
	END ELSE BEGIN
	    IF (FUC OR (SELEC == 'A'))
		EBUF[MP++] = TOUC(C);
	    ELSE
		EBUF[MP++] = C;
	END
	IF ((C == CTL('L')) AND (PAGECN > 0))
	    IF (--PAGECN == 0)
		BREAK;
	IF (C == CHLF) BEGIN
	    BUMP();
	    IF (HALF AND (MP >= HALF))
		BREAK;
	END
    END
    EBUF[MP] = 0;
END

/* TYPE BETWEEN TWO BUFFER POSITIONS */
STATIC VOID TYPBET(N, M)
INT N, M;
BEGIN
    INT I;
    SPRSLN = YES;
    IF (ATBEG() OR (EBUF[CP - 1] == CHLF))
	LOUTN();
    STCOL = COL;
    FOR (I = N; I < M; ++I)
	IF (EBUF[I] == CHLF) BEGIN
	    SPRSLN = NO;
	    CRLF();
	    BREAK;
	END ELSE BEGIN
	    IF (CHAR64)
		COUT(EBUF[I]);
	    ELSE IF (FUC)
		COUT(TOUC(EBUF[I]));
	    ELSE
		COUT(EBUF[I]);
	END
    STCOL = 0;
END

/* TYPE TEXT (T) */
STATIC VOID TYPE()
BEGIN
    INT I;
    STRUCT POSN POS;
    IF (!EXEC) RETURN;
    SAVPOS(ADDR(POS));
    IF (NUM == 0) BEGIN
	SUBMIT("0L");
	IF (CP != POS.KEEPCP)
	    TYPBET(CP, POS.KEEPCP);
    END ELSE IF (NUM < 0) BEGIN
	I = 0;
	FOR (; OK(); BUMP()) BEGIN
	    SUBMIT("-L");
	    ++I;
	END
	FOR (; I; --I) BEGIN
	    TYPBET(CP, MP);
	    SUBMIT("L");
	END
	IF (CP != POS.KEEPCP)
	    TYPBET(CP, POS.KEEPCP);
    END ELSE BEGIN
	FOR (; OK(); BUMP()) BEGIN
	    TYPBET(CP, MP);
	    SUBMIT("L");
	END
    END
    RSTPOS(ADDR(POS));
END

/* SKIP WHITESPACE IN COMMAND */
STATIC VOID SKIPWH()
BEGIN
    WHILE (ISWHIT(*CMDPTR))
	++CMDPTR;
END

/* READ NEXT NUMBER FROM INDEX FILE */
STATIC INT RDIDX()
BEGIN
    INT C, N, S, K;
    S = 1;
    N = 0;
    K = 0;
    WHILE ((C = FCIN(IDXFIL)) != EOF) BEGIN
	++K;
	IF (ISNUM(C))
	    N = N * 10 + D2N(C);
	ELSE IF (C == '-')
	    S = -1;
	ELSE IF (C == '+')
	    S = 1;
	ELSE IF (C == 10)
	    RETURN N * S;
	ELSE IF ((C == ' ') OR (C == 9))
	    NOTHING;
	ELSE BEGIN
	    K = 0;
	    BREAK;
	END
    END
    IF (K == 0)
	PERR('&');
    RETURN N * S;
END

/* PARSE NEXT COMMAND */
STATIC INT PARSE()
BEGIN
    BOOL THRUTO = NO;
    BOOL LINREF = NO;
    INT  N;
    N4 = N3;
    N3 = N2;
    N2 = NUM;
    NUM = 1;
    SIGN = NO;
    SKIPWH();
    IF (*CMDPTR == '-') BEGIN		/* - */
	SIGN = YES;
	++CMDPTR;
    END ELSE IF (*CMDPTR == '+') BEGIN	/* + */
	++CMDPTR;
    END ELSE IF (*CMDPTR == ':') BEGIN	/* LINE */
	THRUTO = YES;
	++CMDPTR;
    END ELSE IF (*CMDPTR == '@') BEGIN	/* REF */
	LINREF = YES;
	++CMDPTR;
    END ELSE IF (*CMDPTR == '^') BEGIN	/* USE RESULT */
	NUM = RESULT;
	++CMDPTR;
    END
    SKIPWH();
    IF (ISNUM(*CMDPTR))			/* NUMBER */
	CMDPTR = ATOI(CMDPTR, 10, ADDR(NUM));
    ELSE IF (*CMDPTR == '#') BEGIN	/* MAX */
	NUM = MAXREP();
	++CMDPTR;
    END ELSE IF (*CMDPTR == '&') BEGIN	/* FROM .N INDEX */
	NUM = RDIDX();
	++CMDPTR;
	IF (ERROR)
	    RETURN 9999; /* ERROR IN PARSE */
    END
    IF (SIGN)
	NUM = -NUM;
    ELSE IF (THRUTO)
	NUM = NUM - LN + 1;
    ELSE IF (LINREF) BEGIN
	IF (N0TO9(NUM))
	    NUM = LREF[NUM] - LN + 1;
	ELSE
	    NUM = 0;			/* SHOULD BE ERROR */
    END
    SKIPWH();				/* +/- NUMBER */
    IF ((*CMDPTR == '-') OR (*CMDPTR == '+')) BEGIN
	SIGN = *CMDPTR == '-';
	++CMDPTR;
	SKIPWH();
	CMDPTR = ATOI(CMDPTR, 10, ADDR(N));
	IF (SIGN)
	    N = -N;
	NUM += N;
    END
    SKIPWH();			/* COMMAND */
    IF ((SELEC = *CMDPTR) != 0)
	++CMDPTR;
    /* '.' COMMANDS. THE DOT IS FOLLOWED BY ANOTHER COMMAND SELECTOR,
     * EXTENDING THE SET OF COMMANDS. WE WILL RETURN "INT" TYPES
     * (1000, 1001...) TO REPRESENT THE NEW COMMANDS.
     */
    IF (SELEC == '.') BEGIN
	IF ((SELEC = *CMDPTR) != 0)
	    ++CMDPTR;
	SWITCH (TOUC(SELEC)) BEGIN
/* KOPQUW */
	    CASE 'D': RETURN 1000;
	    CASE 'T': RETURN 1001;
	    CASE '8': RETURN 1002;
	    CASE 'Y': RETURN 1003;
	    CASE 'S': RETURN 1004;
	    CASE 'A': RETURN 1005;
	    CASE 'I': RETURN 1006;
	    CASE 'M': RETURN 1007;
	    CASE '.': RETURN 1008;
	    CASE '@': RETURN 1009;
	    CASE 'G': RETURN 1010;
	    CASE '!': RETURN 1011;
	    CASE '3': RETURN 1012;
	    CASE 'L': RETURN 1013;
	    CASE 'E': RETURN 1014;
	    CASE 'F': RETURN 1015;
	    CASE 'B': RETURN 1016;
	    CASE 'H': RETURN 1017;
	    CASE 'X': RETURN 1018;
	    CASE 'Z': RETURN 1019;
	    CASE 'C': RETURN 1020;
	    CASE 'R': RETURN 1021;
	    CASE 'N': RETURN 1022;
	    CASE 'V': RETURN 1023;
	    CASE 'J': RETURN 1024;
	    DEFAULT:  RETURN 9999;
	END
    END
    RETURN TOUC(SELEC);
END

/* CHECK IF E ETC IS SEPARATE */
STATIC INT ONLY()
BEGIN
    IF (FONE OR (CMND[1] == 0))
	RETURN YES;
    PERR('?');
    RETURN NO;
END

/* ISSUE YES/NO FOR E ETC */
STATIC INT YESNO()
BEGIN
    CHAR A;
    IF (FONE) RETURN YES;
    COUT(TOUC(SELEC));
    SOUT("-(Y/N)?");
    COUT(A = CIN());
    CRLF();
    RETURN TOUC(A) == 'Y';
END

/* MACRO COMMAND (M) */
STATIC VOID MACRO()
BEGIN
    INT	KN;
    CHAR *KC;
    IF (INMAC) BEGIN
	PERR('?');
	RETURN;
    END
    /* M IS THE SAME AS 1M */
    IF (NUM == 0)
	NUM = 1;
    ELSE IF (NUM < 0) BEGIN
	PERR('?');
	RETURN;
    END
    IF (*CMDPTR == 0)
	RETURN;
    INMAC = YES;
    KC = CMDPTR;
    IF (!EXEC) NUM = 1;
    TAGUND();
    FOR (; !ERROR AND NUM; BUMP()) BEGIN
	KN = NUM;
	CMDPTR = KC;
	EXALL();
	NUM = KN;
	POLL();
    END
    INMAC = NO;
END

/* END EDIT */
STATIC VOID ENDED()
BEGIN
    SUBMIT("#W");
    IF (INFILE != CLOSED) BEGIN
	IF (!FCOPY(INFILE, OUTFIL))
	    RETURN;
	INFILE = CLOSEF(INFILE);
    END
    IF (CPM80) BEGIN
	DO BEGIN
	    ++NBYTES;
	    FCOUT(CTL('Z'), OUTFIL);
	END WHILE (NBYTES & 0X7F);
    END
    OUTFIL = CLOSEF(OUTFIL);
END

/* FIND STRING IN BUFFER */
STATIC INT FINDST(T)
CHAR *T;
BEGIN
    INT I;
    CHAR *S;
    IF (ISEOS(*T))
	RETURN YES;
    WHILE (!ATEND()) BEGIN
	IF (EBUF[I = CP] != *T)
	    SUBMIT("C");
	ELSE BEGIN
	    FOR (S = T; !ISEOS(*S); ++S, ++I)
		IF (*S != EBUF[I])
		    BREAK;
	    IF (ISEOS(*S)) BEGIN
		SUBMIT("1#");
		WHILE ((CP < I) AND !ATEND())
		    SUBMIT("C");
		RETURN YES;
	    END ELSE
		SUBMIT("C");
	END
    END
    RETURN NO;
END

/* DETERMINE ARGUMENT LENGTH */
STATIC INT ARGLEN(S)
CHAR *S;
BEGIN
    INT	N;
    FOR (N = 0; !ISEOS(S[N]); ++N)
	NOTHING;
    RETURN N;
END

/* REPLACE (SUBSTITUTE/JUXTAPOSE) */
STATIC VOID DOREPL(SEARCH, REPLAC)
CHAR *SEARCH;
CHAR *REPLAC;
BEGIN
    INT	I, N;
    TAGUND();
    N = ARGLEN(SEARCH);
    FOR (I = 0; I < N; ++I) SUBMIT("-D");
    INSST2(REPLAC);
END

/* DELETION PART OF JUXTAPOSE */
STATIC VOID JUXTAP(DELETE)
CHAR *DELETE;
BEGIN
    BOOL K8 = UTF8;
    INT	I = CP;
    INT L = LREF[1];
    INT C = CREF[1];
    UTF8 = NO;
    IF (FINDST(DELETE)) BEGIN
	TAGUND();
	SUBMIT(".@");
	WHILE (CP > I)
	    SUBMIT("-D");
	LREF[1] = L;
	CREF[1] = C;
    END
    UTF8 = K8;
END

/* ISSUE SHELL COMMAND */
STATIC VOID SHELL()
BEGIN
    IF (ISEOS(*CMDPTR))	SKPARG();
    ELSE		COPYA(SSHELL);
    IF (!EXEC) RETURN;
    RESTC();
    SYSTEM(SSHELL);
    PREPC();
END

/* QUOTE STRING FOR BASH -- USED BY SCAN() */
STATIC CHAR *QAPPEND(D, S)
CHAR *D, *S;
BEGIN
    CHAR T = *S++;
    *D++ = '$';
    *D++ = '\'';
    *D++ = '\\';
    *D++ = T;
    FOR(; *S AND (*S != T); ++S) BEGIN
	SWITCH (*S) BEGIN
	CASE '\'':
	CASE '"':
	CASE '\\': *D++ = '\\';
	DEFAULT:   *D++ = *S;
	END
    END
    *D++ = '\\';
    *D++ = T;
    *D++ = '\'';
    *D = 0;
    RETURN S;
END

/* ALTER LINES WITH PATTERN
 * SHORTHAND FOR .!SCAN FOLLOWED BY .N WITH ARG QUOTING
 */
STATIC VOID SCAN()
BEGIN
    CHAR T[MAXCMD];
    CHAR CMD[MAXCMD + MAXCMD];
    CHAR *S, *D;
    INT Q = 0;
    BOOL EQ = NO;
    COPYA(T);
    IF (!EXEC) RETURN;
    IF (T[0] == 0)
	RETURN;
    FOR (S = T; *S; ++S) BEGIN
	SWITCH (*S) BEGIN
	CASE '\'':
	    IF (Q == 0)
		Q = 1;
	    ELSE IF (Q == 1)
		Q = 0;
	    BREAK;
	CASE '\"':
	    IF (Q == 0)
		Q = 2;
	    ELSE IF (Q == 2)
		Q = 0;
	    BREAK;
	CASE '=':
	    IF (Q == 0)
		EQ = YES;
	    BREAK;
	END
    END
    IF ((NUM == 0) && !EQ)
	STRCPY(CMD, "B-#");
    ELSE IF (NUM > 0)
	STRCPY(CMD, FMTN(EQ ? NUM : -NUM));
    ELSE
	RETURN;
    STRCAT(CMD, S2L(".!SCAN "));
    IF (!EQ)
	STRCAT(CMD, "/G ");
    D = CMD + STRLEN(CMD);
    FOR (S = T; *S; ++S) BEGIN
	IF ((*S == '"') OR (*S == '\'')) BEGIN
	    /* EXPAND '..' AND ".." BY GENERATING $'..'. YES, THIS
	     * IS BASH SPECIFIC, BUT ALLOWS US TO HAVE INTERNAL
	     * QUOTES QUOTED. ALL LITERAL STRINGS WILL HAVE THIS
	     * PATTERN
	     */
	    S = QAPPEND(D, S);
	    D = CMD + STRLEN(CMD);
	END ELSE IF ((*S == '(') OR (*S == ')') OR (*S == '|') OR
	             (*S == '<') OR (*S == '>') OR (*S == '&') OR
	             (*S == '&') OR (*S == '#')
	) BEGIN
	    /* WE WILL NEED TO QUOTE (, ) AND OTHER CHARACTERS
	     * OF IMPORTANCE TO BASH. THIS INCLUDES ( ) | < > & ; $
	     * AND MAYBE MORE
	     */
	    *D++ = '\\';
	    *D++ = *S;
	    *D = 0;
	END ELSE BEGIN
	    *D++ = *S;
	    *D = 0;
	END
    END
    SUBMIT(CMD);
    IF (!EQ)
	SUBMIT(".N$");
END

/* FILTER LINES THROUGH SHELL COMMAND */
STATIC VOID FILTER()
BEGIN
    BOOL NORM = YES;
    CHAR T[MAXCMD], F[80];
    IF (ISEOS(*CMDPTR)) SKPARG();
    ELSE		COPYA(SSHELL);
    IF (!EXEC) RETURN;
    IF (NUM == 0) BEGIN
	PERR('?');
	RETURN;
    END
    TAGUND();
    IF (NUM < 0) BEGIN
	NORM = NO;
	NUM = -NUM;
    END
    STRCPY(T, "0L0X");
    STRCAT(T, FMTN(NUM));
    STRADD(T, 'X');
    IF (NORM) BEGIN
	STRCAT(T, FMTN(NUM));
	STRADD(T, 'K');
    END
    SUBMIT(T);
    RESTC();
    /* SAVE ORIGINAL CLIP (FOR ERROR) */
    STRCPY(F, S2L("/TMP/$$"));
    if (!CPFILE("$", F)) BEGIN
	LOUT("CANNOT COPY $ TO TMP");
	LOUT("TRY R TO RETRIEVE");
	RETURN;
    END
    STRCPY(T, "(");
    STRCAT(T, SSHELL);
    STRCAT(T, S2L(") <$ >/TMP/$; CP /TMP/$ $"));
    SYSTEM(T);
    PREPC();
    STRCPY(T, S2L("R"));
    IF (NORM)
	SUBMIT(T);
END

/* CONVERT ^L TO ^J */
STATIC VOID LTOJ(S)
CHAR *S;
BEGIN
    FOR (; *S; ++S)
	IF (*S == CTL('L'))
	    *S = CTL('J');
END

/* SET EXTENSION/TYPE ENTRY */
STATIC VOID SETEXT()
BEGIN
    IF (NUM < 0) BEGIN
        COPYA(MDHELP + STRLEN(MDHELP));
	STRADD(MDHELP, 13);
	STRADD(MDHELP, 10);
        RETURN;
    END
    IF ((NUM <= 0) OR (NUM > 64)) BEGIN
	PERR('?');
	RETURN;
    END
    --NUM;
    IF (*CMDPTR == 0) BEGIN
	PERR('?');
	RETURN;
    END
    COPYA(ELIST[NUM].E);
    IF (*CMDPTR == 0) BEGIN
	PERR('?');
	RETURN;
    END
    COPYA(ELIST[NUM].T);
    IF (*CMDPTR == 0) BEGIN
	PERR('?');
	RETURN;
    END
    COPYA(ELIST[NUM].T2);
END

/* SEARCH COMMAND (FIND, SUBSTITUTE, JUXTAPOSE) */
STATIC VOID SEARCH()
BEGIN
    STRUCT POSN POS;
    CHAR COMMAND;
    IF (NUM <= 0) BEGIN
	PERR('?');
	RETURN;
    END
    SAVPOS(ADDR(POS));
    COMMAND = TOUC(SELEC);
    IF (COMMAND != '/') BEGIN
	COPYA(SSRCH);
	/* S^ZSTRING^Z MAY NOT MAKE SENSE, BECAUSE THAT IS THE SAME AS
	 * ISTRING^Z F^Z ALSO DOESN'T REALLY MAKE SENSE EITHER. BUT,
	 * J^ZSTRING^ZSTRING2^Z DOES WORK -- INSERT STRING AND DELETE
	 * TO STRING2. INDEED, THAT IS A VERY USEFUL COMMAND.
	 *
	 * SO, WE ALLOW A NULL MATCH STRING
	 */
/*	IF (*SEARCH == 0) BEGIN
 *	    PERR('?');
 *	    RETURN;
 *	END
 */
	IF ((COMMAND == 'S') OR (COMMAND == 'J')) BEGIN
	    IF (*CMDPTR == 0) BEGIN
		PERR('?');
		RETURN;
	    END
	    COPYA2(SREPL);
	END
	IF (COMMAND == 'J') BEGIN
	    IF (*CMDPTR == 0) BEGIN
		PERR('?');
		RETURN;
	    END
	    COPYA(SDELT);
	END
	IF (EXEC) BEGIN
	    SCMND = COMMAND;
	    /* ^L COMPLIANCE WITH ED */
	    IF (FLITL) BEGIN
		LTOJ(SSRCH);
		LTOJ(SREPL);
		LTOJ(SDELT);
	    END
	    /* CASE COMPLIANCE WITH ED */
	    IF (ISUC(SELEC)) BEGIN
		UCSTR(SSRCH);
		UCSTR(SREPL);
		UCSTR(SDELT);
	    END
	END
    END
    IF (!EXEC) RETURN;
    IF (SCMND == 0) BEGIN
	PERR('?');
	RETURN;
    END

TOP:
    FOR (; OK() AND FINDST(SSRCH); BUMP()) BEGIN
	IF (POLL()) RETURN;
	IF ((COMMAND == 'S') OR (COMMAND == 'J')) BEGIN
	    DOREPL(SSRCH, SREPL);
	    IF (ERROR)
		RETURN;
	END
	IF (COMMAND == 'J')
	    JUXTAP(SDELT);
	IF ((COMMAND == 'S') OR (COMMAND == 'J'))
	    SAVPOS(ADDR(POS));
    END
    IF ((COMMAND == 'N') AND (NUM != 0)) BEGIN
	IF (INFILE == CLOSED) BEGIN
	    PERR('#');
	    RETURN;
	END
	SUBMIT("#W");
	IF (ERROR) RETURN;
	SUBMIT(S2L("0A"));
	IF (ERROR) RETURN;
	SAVPOS(ADDR(POS));
	GOTO TOP;
    END
    IF (NUM != 0) BEGIN
	RSTPOS(ADDR(POS));
	PERR('#');
    END
END

/* MOVE AND TYPE */
STATIC VOID MTYPE()
BEGIN
    IF (!EXEC) RETURN;
    FOR (; NUM; BUMP())
	SUBMIT((NUM < 0) ? "-L" : "L");
    IF (FSCOPE != 1)
	SUBMIT("T");
END

/* BEGIN/END OF BUFFER */
STATIC VOID CBEGIN()
BEGIN
    IF (!EXEC) RETURN;
    SUBMIT((NUM < 0) ? "#C" : "-#C");
    /* THIS WILL SILENTLY ERROR, SO CLEAR ERROR */
    ERROR = NO;
END

/* MOVE BY CHARACTERS */
STATIC VOID CHARS()
BEGIN
    IF (!EXEC) RETURN;
    IF (!OK()) BEGIN
	ERROR = YES; /* SILENT ERROR */
	RETURN;
    END
    FOR (; OK() AND NUM; BUMP()) BEGIN
	IF (NUM < 0) BEGIN
	    IF (UTF8)
		WHILE ((CP > 0) AND ((EBUF[CP - 1] & 0XC0) == 0X80))
		    --CP;
	    IF (CP AND (EBUF[--CP] == CHLF))
		--LN;
	END ELSE BEGIN
	    IF (UTF8)
		WHILE ((EBUF[CP + 1] & 0XC0) == 0X80)
		    ++CP;
	    IF (EBUF[CP++] == CHLF)
		++LN;
	END
    END
END

/* UNDO */
STATIC VOID UNDO()
BEGIN
    CHAR C;
    INT P;
    INT T;
    INT K = UTF8;
    IF (PEEKUN(&C, &P) == 0)
	LSTUND(&C, &P);
    DO BEGIN
	T = LSTUND(&C, &P);
	IF (T < 0)
	    BREAK;
	UTF8 = NO;
	NUM = P - CP;
	CHARS();
	IF (T == 1)
	    INSERT(C, NO);
	ELSE IF (T == 2)
	    REMOVE(NO);
	UTF8 = K;
    END WHILE (T > 0);
END

/* DELETE CHARACTERS */
STATIC VOID DELETE()
BEGIN
    IF (!EXEC) RETURN;
    TAGUND();
    FOR (; NUM; BUMP()) BEGIN
	IF (NUM < 0) BEGIN
	    IF (ATBEG())
		BREAK;
	    SUBMIT("-C");
	END ELSE BEGIN
	    IF (ATEND())
		BREAK;
	END
	REMOVE(YES);
    END
END

/* END OR H (RE-EDIT) */
STATIC VOID CEND()
BEGIN
    IF (!EXEC) RETURN;
    IF (CBUF != 1) BEGIN PERR('Z'); RETURN; END
    IF (ONLY()) BEGIN
	ENDED();
	UPDTFL();
	IF (TOUC(SELEC) == 'H') BEGIN
	    ISNEWFILE = NO;
	    IF (BAKNAM[0] == 0) BEGIN
		/* FLIP IN AND OUT FILES IF EXPLICITLY GIVEN */
		STRCPY(BAKNAM, INNAM);
		STRCPY(INNAM, OUTNAM);
		STRCPY(OUTNAM, BAKNAM);
		BAKNAM[0] = 0;
	    END
	    PREPF();
	    CLRBUF();
	END ELSE
	    FEX = YES;
    END
END

/* INSERT STRING INTO BUFFER */
STATIC CHAR *INSST(S)
CHAR *S;
BEGIN
    IF (!EXEC) RETURN NULL;
    WHILE (!ISEOS(*S))
	IF (!INSERT(*S++, YES))
	    BREAK;
    RETURN S;
END

/* INSERT STRING AND ADD NEWLINE IF NOT ^Z/^D */
STATIC VOID INSST2(S)
CHAR *S;
BEGIN
    IF (!EXEC) RETURN;
    S = INSST(S);
    IF (!*S)
	INSERT(CHLF, YES);
END

/* INPUT COMMAND */
STATIC VOID INPUT()
BEGIN
    TAGUND();
    IF (*CMDPTR == 0) BEGIN
	IF (!EXEC) RETURN;
	IF (NUM < 0)
	    INPUT2();
	ELSE
	    INPUT1();
    END ELSE BEGIN
	INSST2(CMDPTR);
	SKPARG();
    END
END

/* KILL LINES
 *
 * FIXME - SHOULD DO THIS MORE LIKE LINE KILL IN INPUT, AT LEAST IN
 *         FORWARD DIRECTION. RIGHT NOW, TAKE N^2 TIME
 */
STATIC VOID KILL()
BEGIN
    IF (!EXEC) RETURN;
    TAGUND();
    IF (NUM <= 0) BEGIN
	WHILE (OK()) BEGIN
	    IF (EBUF[CP-1] == CHLF) BEGIN
		TAGUND();
		BUMP();
	    END
	    SUBMIT("-D");
	END
	WHILE (!ATBEG() AND (EBUF[CP-1] != CHLF))
	    SUBMIT("-D");
    END ELSE BEGIN
	WHILE (OK()) BEGIN
	    IF (EBUF[CP] == CHLF) BEGIN
		TAGUND();
		BUMP();
	    END
	    SUBMIT("D");
	END
    END
END

/* MOVE BY LINES */
STATIC VOID LINE()
BEGIN
    IF (!EXEC) RETURN;
    IF (NUM < 0)
	SUBMIT("0L");
    IF ((NUM == 0) AND (EBUF[CP-1] != CHLF))
	NUM = -1;
    FOR (; OK(); BUMP())
	DO
	    SUBMIT(NUM < 0 ? "-C" : "C");
	WHILE (OK() AND (EBUF[CP-1] != CHLF));
END

/* RESTORE ORIGINAL FILE */
STATIC VOID ORIGNL()
BEGIN
    IF (!EXEC) RETURN;
    IF (CBUF != 1) BEGIN PERR('Z'); RETURN; END
    IF (ONLY() AND YESNO()) BEGIN
	INFILE = CLOSEF(INFILE);
	OUTFIL = CLOSEF(OUTFIL);
	PREPF();
	CLRBUF();
    END	
END

/* PAGE UP OR DOWN */
STATIC VOID PAGE()
BEGIN
    CHAR BUF[20];
    IF (!EXEC) RETURN;
    STRCPY(BUF, (NUM < 0) ? "-" : "");
    STRCAT(BUF, FMTN(PL));
    STRADD(BUF, 'L');
    IF (NUM < 0) BEGIN
	WHILE (!ATBEG() AND (NUM < 0)) BEGIN
	    SUBMIT(BUF);
	    ++NUM;
	END
    END ELSE IF (NUM > 0) BEGIN
	WHILE (!ATEND() AND (NUM > 0)) BEGIN
	    SUBMIT(BUF);
	    --NUM;
	END
    END
    IF (FSCOPE == 2) BEGIN
	SP = CP;
	UPDATE();
    END
    IF (FSCOPE)
	RETURN;
    STRCPY(BUF, FMTN(PL));
    STRADD(BUF, 'T');
    SUBMIT(BUF);
END

/* QUIT EDIT, NO SAVE */
STATIC VOID QUIT()
BEGIN
    IF (!EXEC) RETURN;
    IF (CBUF != 1) BEGIN PERR('Z'); RETURN; END
    IF (ONLY() AND YESNO()) BEGIN
	INFILE = CLOSEF(INFILE);
	OUTFIL = CLOSEF(OUTFIL);
	RXFILE();
	UNLINK(OUTNAM);
	FEX = YES;
    END
END

/* GOTO LINE */
STATIC VOID CGOTO()
BEGIN
    IF (NUM < 0) BEGIN
	PERR('?');
	RETURN;
    END
    NUM -= TN;
    IF (NUM <= 0)
	NUM = 1;
    --NUM;
    SUBMIT("B");
    FOR (; OK(); BUMP())
	SUBMIT("L");
END

/* MOVE TO CHARACTER MARK */
STATIC VOID CMARK()
BEGIN
    IF (!EXEC) RETURN;
    IF (N0TO9(NUM)) BEGIN
	IF (CREF[NUM] <= MP) BEGIN
	    SUBMIT("B");
	    NUM = CREF[NUM];
	    CHARS();
	END ELSE
	    PERR('#');
    END ELSE
	PERR('?');
END

/* MOVE TO LINE MARK */
STATIC VOID LMARK()
BEGIN
    IF (N0TO9(NUM)) BEGIN
	NUM = LREF[NUM];
	CGOTO();
    END ELSE
	PERR('?');
END

/* NUMBER TO BOOLEAN */
STATIC BOOL NUM2B()
BEGIN
    RETURN NUM >= 0;
END

/* PRINT FLAG VALUE/NAME */
STATIC VOID PFLAG(F, S)
BOOL F;
CHAR *S;
BEGIN
    COUT(F ? '+' : '-');
    SOUT(S);
END

/* VERIFY - LINE NUMBERING, FLAGS, MEMORY LEFT */
STATIC VOID VERIFY()
BEGIN
    IF (!EXEC) RETURN;
    IF (NUM == 0) BEGIN
	BOOL OLDFLN = FLN;
	NOUT(BSIZE - MP);
	COUT('/');
	NOUT(BSIZE);
	SOUT(" BUF ");
	NOUT(CBUF);
	SPACE();
	FLN = YES;
	FORCELINENUMBER();
	FLN = OLDFLN;
	CRLF();
    END ELSE IF (NUM == 2) BEGIN
	/* OUTPUT THE STATUS OF ALL THE FLAGS:
	 *
	 *	U	UPPERCASE
	 *	V	LINE NUMBER VERIFY
	 *	.S	SCOPE MODE
	 *	.Y	"YES"
	 *	.D	EIGHT BIT OUTPUT
	 *	.8	CR/LF INSTEAD OF JUST LF, ^Z PAD
	 *	.3	ASCII-64 OUTPUT
	 *	.L	TRANSLATE ^L TO NEWLINE
	 *	.E	SEEALL MODE
	 *	.F	UTF8 EDIT MODE
	 *	.A	AUTOINDENT
	 *	.T	TAB EXPANSION
	 */
	PFLAG(FUC,    "U");
	PFLAG(FLN,    "V");
	IF (FSCOPE == 0)
	    SOUT("-.S");
	ELSE
	    BEGIN NOUT(FSCOPE); SOUT(".S"); END
	PFLAG(FONE,   ".Y");
	PFLAG(F8,     ".D");
	PFLAG(CPM80,  ".8");
	PFLAG(CHAR64, ".3");
	PFLAG(FLITL,  ".L");
	PFLAG(SEEALL, ".E");
	PFLAG(UTF8,   ".F");
	IF (AUTOIN == NO)
	    SOUT("-.A");
	ELSE
	    BEGIN NOUT(IDELTA); SOUT(".A"); END
	IF (MBELL <= 0)
	    SOUT("-.B");
	ELSE
	    BEGIN NOUT(MBELL); SOUT(".B"); END
	IF (XPTAB == 0)
	    LOUT("-.T");
	ELSE
	    BEGIN NOUT(XPTAB); LOUT(".T"); END
    END ELSE IF (NUM == 3) BEGIN
    	IF (CHANGE) SOUT("BUFFER CHANGED");
    	ELSE	    SOUT("NO CHANGE");
    	CRLF();
    END ELSE IF (NUM == 4) BEGIN
	SOUT("   INPUT: "); LOUT(INNAM);
	SOUT("  OUTPUT: "); LOUT(OUTNAM);
	SOUT("    BACK: "); LOUT(BAKNAM);
	SOUT("TRANSFER: "); LOUT(XFNAM);
    END ELSE IF (NUM == 5) BEGIN
	LOUT(VERSION);
    END ELSE
	FLN = NUM2B();
END

/* SIMPLE FLAG */
STATIC VOID SFLAG(F)
BOOL *F;
BEGIN
    IF (!EXEC) RETURN;
    *F = NUM2B();
END

/* AUTOINDENT FLAG/AMOUNT */
STATIC VOID AI()
BEGIN
    IF (!EXEC) RETURN;
    IF (NUM <= 1)
	SFLAG(&AUTOIN);
    ELSE
	IDELTA = NUM;
END

/* SET LINE/CHARACTER MARK */
STATIC VOID SETMRK()
BEGIN
    IF (!EXEC) RETURN;
    IF (N0TO9(NUM)) BEGIN
	LREF[NUM] = LN;
	CREF[NUM] = CP;
    END ELSE
	PERR('?');
END

/* TAB EXPANSION (AND AMOUNT) */
STATIC VOID TAB()
BEGIN
    IF (!EXEC) RETURN;
    IF (NUM <= 0)
	XPTAB = 0;
    ELSE IF (NUM == 1)
	XPTAB = 8;
    ELSE
	XPTAB = NUM;
END

/* PRINT TABS */
STATIC VOID PRTABS()
BEGIN
    INT I;
    SOUT("TAB: ");
    FOR (I = 0; I < MAXT; ++I) BEGIN
	IF (HTABS[I] < 10)
	    COUT(' ');
	NOUT(HTABS[I]);
	COUT(' ');
    END;
    CRLF();
END

/* HORIZONTAL TABULATION */
STATIC VOID HTAB()
BEGIN
    INT I, J;
    IF(!EXEC) RETURN;
    IF (NUM < 0) BEGIN
	FOR (I = 0; I < MAXT; ++I)
	    HTABS[I] = 0;
	RETURN;
    END
    IF (NUM <= 1) BEGIN
	PRTABS();
	RETURN;
    END
    FOR (I = 0; I < MAXT; ++I) BEGIN
	IF (HTABS[I] == NUM) BEGIN
	    FOR (J = I; J < (MAXT - 1); ++J)
		HTABS[J] = HTABS[J + 1];
	    HTABS[MAXT - 1] = 0;
	    RETURN;
	END
    END
    FOR (I = 0; I < MAXT; ++I) BEGIN
	IF ((HTABS[I] == 0) OR (HTABS[I] > NUM)) BEGIN
	    FOR (J = MAXT - 1; J > I; --J)
		HTABS[J] = HTABS[J - 1];
	    HTABS[I] = NUM;
	    RETURN;
	END
    END
END

/* SET MARGIN BELL */
STATIC VOID MGNBEL()
BEGIN
    IF (!EXEC) RETURN;
    IF (NUM <= 0)
	MBELL = 0;
    ELSE
	MBELL = NUM;
END

/* INSERT CHARACTER BY VALUE */
STATIC VOID ICHAR()
BEGIN
    IF (!EXEC) RETURN;
    TAGUND();
    IF (NUM >= 0)
	INSERT(NUM BAND 0XFF, YES);
END

/* SLEEP FOR NUMBER SECONDS */
STATIC VOID CSLEEP()
BEGIN
    INT I;
    IF (!EXEC) RETURN;
    IF (NUM <= 0)
	PERR('?');
    ELSE
	FOR (I = 0; I < NUM; ++I) BEGIN
	    IF (POLL())
		RETURN;
	    SLEEP(1);
	END
END

/* SET SCOPE BAR TO ABSOLUTE COLUMN */
STATIC VOID ABAR()
BEGIN
    IF (!EXEC) RETURN;
    BAR = NUM;
    RFRSHS();
END

/* RELATIVE SCOPE BAR MOVE */
STATIC VOID RBAR()
BEGIN
    IF (!EXEC) RETURN;
    BAR += NUM;
    RFRSHS();
END

/* SCOPE DISPLAY VERTICAL BAR */
STATIC VOID VBAR()
BEGIN
    DIM();
    PC(BARC);
    ++COL;
    DIMOFF();
END

/* SCOPE REFRESH, ADJUST SP (START POINT) */
STATIC VOID RESTSP()
BEGIN
    INT I;
    /* IF CP IS BEFORE SP, OR CP IS MORE THAN ONE SCREEN LOWER THAN
     * SP, RESET SP TO CP
     */
    IF ((CP < SP) OR (CP > (SP + (ROWS * COLS)))) BEGIN
	SP = CP;
    END
    /* BACK UP SP UNTIL LINE BEGIN. IF LINE BEGIN IS NOT WITHIN ONE
     * SCREEN LINE, DON'T BACK IT UP (LONG LINE)
     */
    IF ((SP > 0) AND (EBUF[SP - 1] != CHLF)) BEGIN
	FOR (I = 1; (I < COLS) AND ((SP - I) > 0); ++I) BEGIN
	    IF (EBUF[SP - I] == CHLF) BEGIN
		SP -= I - 1;
		BREAK;
	    END
	END
    END
END

/* BOLDING - FORTRAN, SHELL, SNOBOL */
STATIC VOID SCNBLD(CC, C)
INT CC;
CHAR C;
BEGIN
    IF ((CC == 6) && (C == '*') && ISCOBO()) BEGIN
	BLD();
    END ELSE IF (CC == 0) BEGIN
	IF (ISFORT()) BEGIN
	    IF ((C == 'C') OR (C == LC('C')) OR (C == '*') OR
		(C == '!'))
		BLD();
	END ELSE IF (!ISC() AND ((C == '#') OR (C == ';')
	/* ANDRITZ FILES USE * AND ^ AS COMMENT INDICATORS */
/*			       OR (C == '*') OR (C == '^') */
							  )) BEGIN
	    IF (!ISTEXT())
		BLD();
	END ELSE IF (ISSNOB()) BEGIN
	    IF (C == '*')
		BLD();
	END
    END ELSE IF (CC == 72) BEGIN
	IF (ISFORT()) BEGIN
	    BLD();
	END
    END
END

/* LMTSCN UPDATES FROM THE LAST CURSOR LINE TO THE FIRST LINE
 * THAT MATCHES THE PREVIOUS UPDATESCREEN. ACTUALLY, THIS VERSION
 * ONLY UPDATES ONE LINE.
 *
 * AS LONG AS THE CURSOR STAYS ON THE SAME LINE, WE JUST REDRAW THE
 * SINGLE LINE. THIS APPLIES FOR -I, IMMEDIATE DELETE, HOME/END AND
 * LEFT/RIGHT CURSOR. THIS MEANS THAT -I ONLY REDRAWS THE FULL SCREEN
 * ON NEWLINE. AT WORST, WE DRAW AN EXTRA LINE. ON INPUT2() INSERT,
 * THE NEXT LINE BEGIN IS ADJUSTED BY ONE TO ALLOW THIS OPTIMIZATION.
 * IF THE LINE SPLITS, WE DO THE NORMAL FULL UPDATE. ON IMMEDIATE
 * DELETE, THE NEXT LINE BEGIN IS DECREMENTED TO ALLOW THE SAME
 * OPTIMIZATION.
 *
 * NORMAL "I" FULL SCREEN INSERTION DOESN'T UPDATE PER CHARACTER --
 * TYPED IN CHARACTERS ARE DIRECTLY DISPLAYED ON-SCREEN.
 *
 * NOTE THAT THIS OPTIMIZATION IS MOOT ONCE WE DO SCREEN DELTA FOR
 * UPDATE.
 */
STATIC BOOL LMTSCN()
BEGIN
    INT KLLF = LASTLF;
    INT I, N, LINES, CC, SCROLL;
    CHAR C;
    BOOL FNDCP, R;

    CC = SCROLL = 0;
    FASTUP = NO;
    FNDCP = R = NO;
    GOTOYX(CLINE + 1, 1);
    NORMAL();

    FOR (I = LINEST[LINES = CLINE]; I < MP; ++I) BEGIN

	IF (I == CP) BEGIN
	    IF (!CRSOFF) REV();
	    CLINE = LINES;
	    CCOL = CC;
	    FNDCP = YES;
	END

	C = EBUF[I];

	IF (C == CHLF) BEGIN
	    BLDOFF();
	    IF (CC < COLS) BEGIN
		IF ((CC <= (BAR - 1)) AND (BAR <= COLS)) BEGIN
		    WHILE (CC < (BAR - 1)) BEGIN
			SPACE();
			++CC;
		    END
		    VBAR();
		END
		CLREOL();
	    END
	    IF (FNDCP AND (I == CP) AND (CP != MP)) BEGIN
		SPACE();
	    END
	    R = FNDCP AND (LINEST[++LINES] == I+1);
	    BREAK;
	END

	SCNBLD(CC, C);

	N = PWIDTH(C);
	IF ((CC + N) > COLS) BEGIN
	    BREAK;
	END

	IF (XPTAB AND (C == CHTAB) AND (BAR > 0)) BEGIN
	    INT TC;
	    FOR (TC = 0; TC < N; ++TC) BEGIN
		IF ((BAR - 1) == (CC + TC)) BEGIN
		    VBAR();
		END ELSE
		    SPACE();
	    END
	END ELSE IF ((C == ' ') AND ((BAR - 1) == CC)) BEGIN
	    VBAR();
	END ELSE
	    COUT(C);

	IF (FNDCP AND (I == CP)) BEGIN
	    IF (UTF8) BEGIN
		WHILE ((EBUF[I + 1] & 0XC0) == 0X80) BEGIN
		    COUT(EBUF[++I]);
		END
	    END
	    REVOFF();
	END

	CC += N;
    END

    NORMAL();
    GOTOYX(ROWS, 1);
    LASTLF = KLLF;
    RETURN R;
END

/* REDRAWS SCREEN EVERY COMMAND */
STATIC VOID UPDATE()
BEGIN
    INT KLLF = LASTLF;
    INT I, LINES, CC, N, SCROLL = 0;
    CHAR C;
    BOOL FNDCP;

    IF (FASTUP)
	IF (!SEEALL AND LMTSCN()) BEGIN
	    /* BELL IF LMTSCN SAYS SCREEN IS OK */
/*	    BELL(); */
	    RETURN;
	END

    SCPCMD(S2L("?25L"));
    SCPCMD(S2L("?7L"));
TOP:
    NORMAL();
    CC = 0;
    FNDCP = NO;
    STCOL = 0;
    HOME();
    RESTSP();
    LINEST[LINES = 0] = SP;
    FOR (I = SP; I != MP; ++I) BEGIN

	IF (I == CP) BEGIN
	    IF (!CRSOFF) REV();
	    CLINE = LINES;
	    CCOL = CC;
	    FNDCP = YES;
	END

	C = EBUF[I];

	IF (C == CHLF) BEGIN
	    /* ERASE TO END OF LINE IF CURSOR HAS WRITTEN LAST COLUMN:
	     * XTERM - CURSOR ON LAST COLUMN, LAST CHARACTER ERASED
	     * XFCE TERMINAL - CURSOR AFTER LAST, LAST CHARACTER KEPT
	     * SO, WE ONLY ISSUE ERASE TO END OF LINE IF WE AREN'T YET
	     * AT THE LAST COLUMN
	     */
	    BLDOFF();
	    IF (CC < COLS) BEGIN
		IF (SEEALL) BEGIN
		    DIM();
		    COUT('<');
		    DIMOFF();
		    ++CC;
		END
		IF ((CC <= (BAR - 1)) AND (BAR <= COLS)) BEGIN
		    /* FILL IN BAR OVER EMPTY LINES */
		    WHILE (CC < (BAR - 1)) BEGIN
			SPACE();
			++CC;
		    END
		    VBAR();
		END
		CLREOL();
	    END
	    /* ON END OF LINE - HIGHLIGHT AS SPACE */
	    IF (FNDCP AND (I == CP) AND (CP != MP)) BEGIN
		IF (!SEEALL) SPACE();
	    END
	    LINEST[++LINES] = I + 1;
	    IF (LINES >= (ROWS - BROWS))
		BREAK;
	    CRLF();
	    CC = 0;
	    NORMAL();
	    CONTINUE;
	END

	SCNBLD(CC, C);

	/* FIND PRINT WIDTH, GO TO NEXT LINE IF WE MUST */
	N = PWIDTH(C);
	IF ((CC + N) > COLS) BEGIN
	    IF (N > 1) CLREOL();
	    CC = 0;
	    LINEST[++LINES] = I;
	    IF (LINES >= (ROWS - BROWS))
		BREAK;
	    CRLF();
	    N = PWIDTH(C); /* IN CASE OF TAB */
	END

	/* PRINT CHARACTER, AND VERTICAL BAR */
	IF (XPTAB AND (C == CHTAB) AND (BAR > 0)) BEGIN
	    INT TC;
	    FOR (TC = 0; TC < N; ++TC) BEGIN
		IF ((BAR - 1) == (CC + TC)) BEGIN
		    VBAR();
		END ELSE
		    SPACE();
	    END
	END ELSE IF ((C == ' ') AND ((BAR - 1) == CC)) BEGIN
	    VBAR();
	END ELSE BEGIN
	    IF (SEEALL AND (C == ' ')) BEGIN
		DIM();
		COUT('.');
		DIMOFF();
	    END ELSE
		COUT(C);
	END

	/* IF THIS WAS REVERSED (CP) THEN TURN OFF REVERSE */
	IF (FNDCP AND (I == CP)) BEGIN
	    IF (UTF8) BEGIN
	        WHILE ((EBUF[I + 1] & 0XC0) == 0X80) BEGIN
		    COUT(EBUF[++I]);
	        END
	    END
	    REVOFF();
	END

	/* ADVANCE BY CHARACTER WIDTH [XX], TAB, ^C, ETC. */
	CC += N;
    END

    IF (!FNDCP AND (I == MP) AND (LINES <= (ROWS - BROWS))) BEGIN
	GOTO HILITE;
    END
    IF (!FNDCP) BEGIN
	/* FIXME - TRULY HORRIBLE, WE HAVE JUST DRAWN THE ENTIRE SCREEN
	 * FOR NOTHING - AND WE ARE GOING TO ADVANCE A LINE AND DO IT
	 * AGAIN!
	 *
	 * ALL THIS TO SIMULATE A SCROLL!
	 *
	 * TO IMPROVE THIS, KEEP TRACK OF EBUF LOCATION FOR THE
	 * LAST LINE, SCROLL THE SCREEN BY ISSUING CRLF AND THEN ADD
	 * ONE MORE LINE. CCOL/CROW IS WELL BEHAVED 0..N
	 */
	IF (SP != CP) BEGIN
/*	    SP = CP;
 *	    GOTO TOP;
 */
	    WHILE ((SP != CP) AND (EBUF[SP] != CHLF))
		++SP;
	    IF (SP != CP)
		++SP;
/*	    IF (++SCROLL > (ROWS - BROWS))
 *	    IF (++SCROLL > 1)
 */
	    IF (++SCROLL >= 17)
		SP = CP;
	    GOTO TOP;

	END
	IF (CP == MP) BEGIN
	    LINES = 0;
	    HOME();
	END
    END
HILITE:
    IF (!FNDCP) BEGIN
	IF (!CRSOFF) REV();
	SPACE();
	REVOFF();
	CLREOL();
	CLINE = LINES;
	CCOL = CC;
    END
    IF (LINES < (ROWS - BROWS))
	LINEST[LINES] = I;
    WHILE (LINES < (ROWS - BROWS)) BEGIN
	LINEST[++LINES] = 0XFFFFFFFF;
	CLREOL();
	IF (LINES != (ROWS - BROWS)) /* DON'T CRLF ON LAST LINE */
	    CRLF();
    END
    NORMAL();
    SCPCMD(S2L("?7H"));
    SCPCMD(S2L("?25H"));
    GOTOYX(ROWS, 1);
    LASTLF = KLLF;
END

/* FULL SCREEN SCOPE MODE, ON/OFF, HOLD, NUMBER OF COMMAND LINES */
STATIC VOID SCOPE()
BEGIN
    IF (!EXEC) RETURN;
    CRSOFF = NO;
    IF ((3 <= NUM) AND (NUM <= 22))
	BROWS = NUM;
    IF (FSCOPE AND (NUM == 1)) BEGIN
	SIZEC();
	/* RESET SCOPE */
	IF (FSCOPE) BEGIN
	    ESC();
	    PC(LC('C'));
	END
	DIV();
	FASTUP = NO;
	UPDATE();
	RETURN;
    END
    IF ((FSCOPE == 2) AND (NUM == 0))
	NUM = 1;
    FSCOPE = NUM2B();
    IF (FSCOPE AND (NUM <= 2))
	FSCOPE = NUM;
    IF (FSCOPE) BEGIN
	SIZEC();
	DIV();
	KEYBS = RUBOUT;
	KEYRUB = CHBS;
	SP = CP;
	FASTUP = NO;
	IF (FSCOPE == 2)
	    UPDATE();
	PL = ROWS - BROWS;
    END ELSE BEGIN
	SIZEC();
	CLS();
	RGNALL();
	KEYBS = CHBS;
	KEYRUB = RUBOUT;
	PL = 16;
	BROWS = 6;
    END
END

/* START PROGRAM BLOCK */
STATIC VOID STARTB()
BEGIN
    IF (POLL()) RETURN;
    IF (MSP >= MLIM) BEGIN
	PERR('S');
	RETURN;
    END
    MSTK[MSP] = CMDPTR;
    ++MSP;
END

/* END PROGRAM BLOCK */
STATIC VOID ENDB()
BEGIN
    IF (POLL()) RETURN;
    IF (MSP <= 0) BEGIN
	PERR('S');
	RETURN;
    END
    IF (!EXEC) BEGIN
	IF (OFFLEV == MSP)
	    EXEC = YES;
    END
    --MSP;
END

/* INVERT EXECUTION FLAG */
STATIC VOID INVERT()
BEGIN
    IF (POLL()) RETURN;
    IF (!EXEC AND (OFFLEV < MSP)) RETURN;
    EXEC = !EXEC;
    IF (!EXEC) OFFLEV = MSP;
END

/* POP RESULT REGISTERS */
STATIC VOID POPR()
BEGIN
    RESULT = RESLT2;
    RESLT2 = RESLT3;
    RESLT3 = RESLT4;
END

/* PUSH RESULT REGISTERS */
STATIC VOID PUSHR()
BEGIN
    RESLT4 = RESLT3;
    RESLT3 = RESLT2;
    RESLT2 = RESULT;
END

/* ASSIGN RESULT TO EXECUTION FLAG */
STATIC VOID ASSIGN()
BEGIN
    IF (POLL()) RETURN;
    IF (!EXEC) RETURN;
    EXEC = (RESULT != 0);
    IF (!EXEC) OFFLEV = MSP;
    POPR();
END

/* BRANCH BACK TO PREVIOUS BLOCK BEGIN */
STATIC VOID BRANCH()
BEGIN
    IF (POLL()) RETURN;
    IF (!EXEC) RETURN;
    IF (MSP > 0) CMDPTR = MSTK[MSP - 1];
END

/* TEST STRING AT CP - SHOULD DO PATTERNS, ETC. */
STATIC VOID STEST()
BEGIN
    INT I;
    CHAR *S = CMDPTR;
    IF (POLL()) RETURN;
    SKPARG();
    IF (!EXEC) RETURN;
    PUSHR();
    RESULT = 0; /* ASSUME FAIL */
    FOR (I = 0; !ISEOS(S[I]); ++I) BEGIN
	IF (S[I] != EBUF[CP + I])
	    RETURN;
    END
    RESULT = 1; /* SUCCESS */
END

/* FIND INTERNAL VARIABLE BY NAME */
STATIC INT *IVAR(S2)
CHAR *S2;
BEGIN
    STATIC INT R;
    INT I;
    STATIC STRUCT BEGIN
	CHAR *S;
	INT *P;
    END IVL[] = BEGIN
	BEGIN "CP",	ADDR(CP)	END,
	BEGIN "MP",	ADDR(MP)	END,
	BEGIN "LN",	ADDR(LN)	END,
	BEGIN "TOP",	ADDR(TN)	END,
	BEGIN "N",	ADDR(NUM)	END,
	BEGIN "N2",	ADDR(N2)	END,
	BEGIN "N3",	ADDR(N3)	END,
	BEGIN "N4",	ADDR(N4)	END,
	BEGIN "KEYBS",	ADDR(KEYBS)	END,
	BEGIN "KEYRUB",	ADDR(KEYRUB)	END,
	BEGIN "ROWS",	ADDR(ROWS)	END,
	BEGIN "COLS",	ADDR(COLS)	END,
	BEGIN "BROWS",	ADDR(BROWS)	END,
	BEGIN "CCOL",	ADDR(CCOL)	END,
	BEGIN "CROW",	ADDR(CLINE)	END,
	BEGIN "SP",	ADDR(SP)	END,
	BEGIN "X",	ADDR(RESULT)	END,
	BEGIN "Y",	ADDR(RESLT2)	END,
	BEGIN "Z",	ADDR(RESLT3)	END,
	BEGIN "T",	ADDR(RESLT4)	END,
	BEGIN "L0",	ADDR(LREF[0])	END,
	BEGIN "L1",	ADDR(LREF[1])	END,
	BEGIN "L2",	ADDR(LREF[2])	END,
	BEGIN "L3",	ADDR(LREF[3])	END,
	BEGIN "L4",	ADDR(LREF[4])	END,
	BEGIN "L5",	ADDR(LREF[5])	END,
	BEGIN "L6",	ADDR(LREF[6])	END,
	BEGIN "L7",	ADDR(LREF[7])	END,
	BEGIN "L8",	ADDR(LREF[8])	END,
	BEGIN "L9",	ADDR(LREF[9])	END,
	BEGIN "C0",	ADDR(CREF[0])	END,
	BEGIN "C1",	ADDR(CREF[1])	END,
	BEGIN "C2",	ADDR(CREF[2])	END,
	BEGIN "C3",	ADDR(CREF[3])	END,
	BEGIN "C4",	ADDR(CREF[4])	END,
	BEGIN "C5",	ADDR(CREF[5])	END,
	BEGIN "C6",	ADDR(CREF[6])	END,
	BEGIN "C7",	ADDR(CREF[7])	END,
	BEGIN "C8",	ADDR(CREF[8])	END,
	BEGIN "C9",	ADDR(CREF[9])	END,
	BEGIN "PL",	ADDR(PL)	END,
	BEGIN NULL,	NULL		END
    END;

    FOR (I = 0; IVL[I].S; ++I)
	IF (STRICM(IVL[I].S, S2) == 0)
	    RETURN IVL[I].P;
    PERR('?');
    RETURN ADDR(R);
END

/* EVALUATE RPN EXPRESSION */
STATIC VOID EXPR()
BEGIN
    CHAR *S = CMDPTR;
    CHAR *S2;
    INT N;
    SKPARG();
    IF (!EXEC) RETURN;
    WHILE (!ISEOS(*S)) BEGIN
	IF (ERROR)
	    RETURN;
	IF (ISNUM(*S)) BEGIN /* DECIMAL CONSTANT */
	    PUSHR();
	    S = ATOI(S, 10, ADDR(RESULT));
	    CONTINUE;
	/* HP, OP, OR MUST BE TESTED BEFORE H AND O CONSTANTS */
	END ELSE IF (STRNIC(S, "HP", 2) == 0) BEGIN
	    LOUT(ITOA(RESULT, 16));
	    ++S;
	END ELSE IF (STRNIC(S, "OP", 2) == 0) BEGIN
	    LOUT(ITOA(RESULT, 8));
	    ++S;
	END ELSE IF (TOUC(*S) == 'H') BEGIN /* HEX CONSTANT */
	    PUSHR();
	    ++S;
	    S = ATOI(S, 16, ADDR(RESULT));
	    CONTINUE;
	END ELSE IF (STRNIC(S, "OR", 2) == 0) BEGIN
	    N = RESLT2 BOR RESULT;
	    POPR();
	    RESULT = N;
	    ++S;
	END ELSE IF (TOUC(*S) == 'O') BEGIN /* OCTAL CONSTANT */
	    PUSHR();
	    ++S;
	    S = ATOI(S, 8, ADDR(RESULT));
	    CONTINUE;
	END ELSE IF (*S == '[') BEGIN /* INTERNAL VARIABLE */
	    PUSHR();
	    S2 = ++S;
	    WHILE (!ISEOS(*S) AND (*S != ']')) ++S;
	    IF (*S == ']') BEGIN
		*S = 0;
		RESULT = *IVAR(S2);
		*S = ']';
		++S;
	    END
	    CONTINUE;
	END ELSE IF (*S == '$') BEGIN /* LOAD VARIABLE */
	    ++S;
	    IF (ISALFA(*S)) BEGIN
		PUSHR();
		RESULT = VARS[TOUC(*S) - 'A'];
	    END ELSE
		CONTINUE;
	END ELSE IF (*S == '>') BEGIN /* STORE VARIABLE OR INTERNAL */
	    ++S;
	    IF (*S == '[') BEGIN
		S2 = ++S;
		WHILE (!ISEOS(*S) AND (*S != ']')) ++S;
		IF (*S == ']') BEGIN
		    *S = 0;
		    *IVAR(S2) = RESULT;
		    *S = ']';
		    ++S;
		END
		CONTINUE;
	    END ELSE IF (ISALFA(*S)) BEGIN
		VARS[TOUC(*S) - 'A'] = RESULT;
	    END
	    POPR();
	END ELSE IF (*S == '?') BEGIN /* CHARACTER FROM BUFFER */
	    PUSHR();
	    RESULT = EBUF[CP] BAND 0XFF;
	END ELSE IF (*S == '#') BEGIN /* NUMBER FROM BUFFER */
	    PUSHR();
	    RESULT = 0;
	    FOR (N = 0; ISNUM(EBUF[CP + N]); ++N) BEGIN
		RESULT = RESULT * 10 + D2N(EBUF[CP + N]);
	    END
	END ELSE IF (*S == '+') BEGIN /* ADD */
	    N = RESLT2 + RESULT;
	    POPR();
	    RESULT = N;
	END ELSE IF (*S == '-') BEGIN /* SUBTRACT */
	    N = RESLT2 - RESULT;
	    POPR();
	    RESULT = N;
	END ELSE IF (*S == '*') BEGIN /* MULTIPLY */
	    N = RESLT2 * RESULT;
	    POPR();
	    RESULT = N;
	END ELSE IF (*S == '/') BEGIN /* DIVIDE */
	    N = RESLT2 / RESULT;
	    POPR();
	    RESULT = N;
	END ELSE IF (STRNIC(S, "SHL", 3) == 0) BEGIN
	    N = RESLT2 << RESULT;
	    POPR();
	    RESULT = N;
	    S += 2;
	END ELSE IF (STRNIC(S, "SHR", 3) == 0) BEGIN
	    N = RESLT2 >> RESULT;
	    POPR();
	    RESULT = N;
	    S += 2;
	END ELSE IF (STRNIC(S, "AND", 3) == 0) BEGIN
	    N = RESLT2 BAND RESULT;
	    POPR();
	    RESULT = N;
	    S += 2;
	END ELSE IF (*S == '=') BEGIN /* EQUAL */
	    N = RESLT2 == RESULT;
	    POPR();
	    RESULT = N;
	END ELSE IF (*S == '<') BEGIN /* LESS */
	    N = RESLT2 < RESULT;
	    POPR();
	    RESULT = N;
	END ELSE IF (STRNIC(S, "SWAP", 4) == 0) BEGIN
	    N = RESLT2;
	    RESLT2 = RESULT;
	    RESULT = N;
	    S += 3;
	END ELSE IF (STRNIC(S, "NOT", 3) == 0) BEGIN
	    RESULT = !RESULT;
	    S += 2;
	END ELSE IF (STRNIC(S, "NEG", 3) == 0) BEGIN
	    RESULT = -RESULT;
	    S += 2;
	END ELSE IF (STRNIC(S, "COMP", 4) == 0) BEGIN
	    RESULT = BCOMP RESULT;
	    S += 3;
	END ELSE IF (STRNIC(S, "DUP", 3) == 0) BEGIN
	    PUSHR();
	    S += 2;
	END ELSE IF (STRNIC(S, "ROLL", 4) == 0) BEGIN
	    N = RESULT;
	    POPR();
	    RESLT4 = N;
	    S += 3;
	END ELSE IF (STRNIC(S, "P", 1) == 0) BEGIN
	    LOUT(ITOA(RESULT, -10));
	END ELSE IF (ISWHIT(*S)) BEGIN
	    NOTHING;
	END ELSE BEGIN
	    PERR('?');
	    RETURN;
	END
	++S;
    END
END

/* SEARCH FOR AND CALL MACRO IN BUFFER 2 */
STATIC VOID CALL()
BEGIN
    CHAR *X;
    INT L = LREF[1];
    INT C = CREF[1];
    IF (!EXEC) BEGIN
	SKPARG();
	RETURN;
    END
    IF (CSP >= CLIM) BEGIN
	PERR('C');
	RETURN;
    END
    SUBMIT("2.ZB");
    IF (ERROR) BEGIN
CALL2:	SUBMIT(".Z");
	RETURN;
    END
    NUM = 1;
    SELEC = LC('F');
    SEARCH();
    LREF[1] = L;
    CREF[1] = C;
    X = EBUF + CP;
    IF (ERROR)
	GOTO CALL2;
    SUBMIT(".Z");
    CSTK[CSP++] = CMDPTR;
    CMDPTR = X;
END

/* RETURN FROM CALLED MACRO */
STATIC VOID RET()
BEGIN
    IF (!EXEC) RETURN;
    IF (CSP == 0) BEGIN
	PERR('R');
	RETURN;
    END
    CMDPTR = CSTK[--CSP];
    END

/* EXECUTE ONE PARSED COMMAND */
STATIC VOID EXCMD()
BEGIN
    SWITCH (PARSE()) BEGIN

	/* BASIC COMMANDS */
	CASE 0:		MTYPE();	BREAK;
	CASE 'A':	APPEND();	BREAK;
	CASE 'B':	CBEGIN();	BREAK;
	CASE 'C':	CHARS();	BREAK;
	CASE 'D':	DELETE();	BREAK;
	CASE 'H':
	CASE 'E':	CEND();		BREAK;
	CASE 'I':	INPUT();	BREAK;
	CASE 'K':	KILL();		BREAK;
	CASE 'L':	LINE();		BREAK;
	CASE 'M':	MACRO();	BREAK;
	CASE 'O':	ORIGNL();	BREAK;
	CASE 'P':	PAGE();		BREAK;
	CASE 'Q':	QUIT();		BREAK;
	CASE 'R':	READ();		BREAK;
	CASE '/':
	CASE 'F':
	CASE 'N':
	CASE 'J':
	CASE 'S':	SEARCH();	BREAK;
	CASE 'T':	TYPE();		BREAK;
	CASE 'U':	SFLAG(&FUC);	BREAK;
	CASE 'V':	VERIFY();	BREAK;
	CASE 'W':	WRITE();	BREAK;
	CASE 'X':	TRANSF();	BREAK;
	CASE 'Y':	UNDO();		BREAK;
	CASE 'Z':	CSLEEP();	BREAK;
	CASE ':':	CGOTO();	BREAK;
	CASE CTL('J'):
	CASE CTL('M'):
	CASE CTL('D'):
	CASE CTL('Z'):	NOTHING		BREAK;

	/* EXTRA COMMANDS */
	CASE 1006:	ICHAR();	BREAK; /* .I */

	/* ADDITIONAL FLAGS */
	CASE 1003:	SFLAG(&FONE);	BREAK; /* .Y */
	CASE 1001:	TAB();		BREAK; /* .T */
	CASE 1002:	SFLAG(&CPM80);	BREAK; /* .8 */
	CASE 1005:	AI();		BREAK; /* .A */
	CASE 1012:	SFLAG(&CHAR64);	BREAK; /* .3 */
	CASE 1013:	SFLAG(&FLITL);	BREAK; /* .L */
	CASE 1014:	SFLAG(&SEEALL);	BREAK; /* .E */
	CASE 1015:	SFLAG(&UTF8);          /* .F (FALL THRU) */
	CASE 1000:	SFLAG(&F8);	BREAK; /* .D */
	CASE 1016:	MGNBEL();	BREAK; /* .B */
	CASE 1017:	HTAB();		BREAK; /* .H */

	/* CHARACTER AND LINE MARKS */
	CASE '@':	LMARK();	BREAK;
	CASE 1009:	CMARK();	BREAK; /* .@ */
	CASE '#':	SETMRK();	BREAK;
	CASE 1018:	SETXFN();	BREAK; /* .X */

	CASE '*':	TOSHLF();	BREAK;

	/* SCOPE MODE */
	CASE 1004:	SCOPE();	BREAK; /* .S */
	CASE 'G':	RBAR();		BREAK;
	CASE 1010:	ABAR();		BREAK; /* .G */
	CASE 1007:	SETMDE();	BREAK; /* .M */
	CASE ',':	BOUNCE();	BREAK;
	CASE '%':	DOIND();	BREAK;

	/* COMMAND IGNORE */
	CASE '\'':
	CASE '\\':
	CASE '"':	NOTHING		BREAK;

	/* HELP, SHELL, SOURCE */
	CASE '?':	HELP();		BREAK;
	CASE '!':	SHELL();	BREAK;
	CASE 1011:	FILTER();	BREAK; /* .! */
	CASE 1008:	SOURCE();	BREAK; /* .. */
	CASE 1022:	SETIDX();	BREAK; /* .N */
	CASE 1023:	SCAN();		BREAK; /* .V */
	CASE 1024:      SETEXT();       BREAK; /* .J */

	/* PROGRAMMING */
	CASE '(':	STARTB();	BREAK;
	CASE ')':	ENDB();		BREAK;
	CASE '_':	INVERT();	BREAK;
	CASE '>':	ASSIGN();	BREAK;
	CASE '<':	BRANCH();	BREAK;
	CASE '$':	STEST();	BREAK;
	CASE '=':	EXPR();		BREAK;
	CASE 1019:	SELBUF();	BREAK; /* .Z */
	CASE 1020:	CALL();		BREAK; /* .C */
	CASE 1021:	RET();		BREAK; /* .R */

	CASE 9999:			BREAK;
	DEFAULT:	PERR('?');	BREAK;
    END
END

/* EXECUTE ALL COMMANDS */
STATIC VOID EXALL()
BEGIN
    DO
	EXCMD();
    WHILE (!ISEOS(*CMDPTR) AND !ERROR);
END

/* FIND EXTENSION, SET MODE AND DMODE (DISPLAY MODE) */
STATIC VOID EXT(F, E, M, M2)
CHAR *F, *E, *M, *M2;
BEGIN
    IF (STRLEN(E) > STRLEN(F))
	RETURN;
    IF (STRICM(F + STRLEN(F) - STRLEN(E), E) == 0) BEGIN
	STRCPY(MODE, M);
	STRCPY(DMODE, M2);
    END
END

/* FIND EXTENSION, SET EDIT MODE ACCORDINGLY */
STATIC VOID EXTSEL(F)
CHAR *F;
BEGIN
    INT I;
    FOR (I = 0; I < 128; ++I)
	IF (ELIST[I].E[0])
	EXT(F, ELIST[I].E, ELIST[I].T, ELIST[I].T2);
    MDSPEC();
END

/* READ COMMAND LINE AND EXECUTE */
STATIC BOOL RDEXEC()
BEGIN
    ERROR = NO;
    IF (FSCOPE == 1)
	UPDATE();
    BRKNOW = NO;
    IF (!GETCMD()) RETURN NO;
    IF (CMND[0] == CHTAB) BEGIN
	/* <TAB>TEXT<CR> - INSERT LINE ABOVE */
	SUBMIT("0L");
	SELEC = LC('I');
	INSST2(CMND + 1);
	RETURN YES;
    END
    DO
	EXALL();
    WHILE (*CMDPTR AND !ERROR);
    EXEC = YES;
    MSP = 0;
    RETURN YES;
END

/* SUBMIT AND EXEC (FOR STARTUP) */
STATIC VOID SUBEX(S)
CHAR *S;
BEGIN
    SUBMIT(S);
    WHILE (CINSRC != STDIN) BEGIN
	IF (!RDEXEC()) BREAK;
    END
END

/* CPMED MAIN FUNCTION - EDIT FILE, WITH INITIAL COMMANDS */
STATIC INT CPMED(F, O, IC)
CHAR *F;
CHAR *O;
CHAR *IC;
BEGIN
    CHAR BUF[40];
    /* PREPC(); */
    SNAMES(F, O);
    INIT();
    IF (FABEND) RETURN NO;
    IACTIV = NO;
    STRCPY(BUF, S2L("...CPMEDRC"));
    SUBEX(BUF);
    IF (IC != NULL) BEGIN
	CMDPTR = IC;
	DO
	    EXALL();
	WHILE (*CMDPTR AND !ERROR);
    END
    IF (MDSEL == 0) EXTSEL(F);
    IACTIV = YES;
    WHILE (!FEX) BEGIN
	RDEXEC();
	IF (FABEND) BREAK;
    END
    /* RESET SCOPE */
    IF (FSCOPE) BEGIN
	ESC();
	PC(LC('C'));
    END
    RESTC();
    RETURN TOUC(SELEC) == 'E';
END

/* ENTER EDITOR. ENSURE THAT AT LEAST A FILENAME IS SPECIFIED. PASS THE
 * FILENAME AND OPTIONAL INITIAL EDIT COMMANDS TO EDITOR.
 */
INT MAIN(AC, AV)
INT AC;
CHAR **AV;
BEGIN
    CHAR S[MAXCMD], *FNOUT = NULL;
    INT I;
    S[0] = 0;
    CINSRC = STDIN;
    PREPC();
    LOUT(VERSION);
    IF ((AC < 2) || (STRICM(AV[1], "-E") == 0)) BEGIN
    	/* NO ARGS, OR JUST -E ... */
	LOUT("NO FILE");
	RESTC();
	RETURN 1;
    END
    IF ((AC > 2) AND STRICM(AV[2], "-E")) BEGIN
	/* IN OUT ... */
	FNOUT = AV[2];
    END
    FOR (I = 2; (I + 1) < AC; ++I)
	/* LOOK FOR -E CMDS */
    	IF (STRICM(AV[I], "-E") == 0) BEGIN
	    STRCAT(S, AV[++I]);
	    STRADD(S, CTL('Z'));
	END
    CPMED(AV[1], FNOUT, S[0] == 0 ? NULL : S);
    RETURN 0;
END

/* CE: .MC; */
