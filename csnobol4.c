#line 42 "CSNOBOL4.lss"
/* Generated by WRAPPER on 06/16/2014 04:53:18 */

#include "config.h"
#include "h.h"
#include "snotypes.h"
#include "macros.h"
#include "load.h"
#include "equ.h"
#include <string.h>

#line 43 "CSNOBOL4.lss"

/* Adds FORTRAN IV FORMAT to CSNOBOL4 */

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <time.h>
#include <sys/select.h>
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

static int status;

static int pipefds[2];

static int createpipe(void)
{
    return pipe(pipefds);
}


/* CREATEPIPE()INTEGER */
CREATEPIPE( LA_ALIST ) LA_DCL
{
    RETINT(createpipe());
}
#line 66 "CSNOBOL4.lss"

static int getpipefd(int n)
{
    if ((n < 0) || (n > 1))
        return -1;
    return pipefds[n];
}


/* GETPIPEFD(INTEGER)INTEGER */
GETPIPEFD( LA_ALIST ) LA_DCL
{
    RETINT(getpipefd((int)LA_INT(0)));
}
#line 75 "CSNOBOL4.lss"

static int get_errno(void)
{
    return errno;
}


/* GET_ERRNO()INTEGER */
GET_ERRNO( LA_ALIST ) LA_DCL
{
    RETINT(get_errno());
}
#line 82 "CSNOBOL4.lss"

/* fd_set holds a set of file descriptors. On 64 bit Linux, this is
 * a 128 byte object. This may be as little as 4 bytes on some systems
 * (which would limit the number of fd's to 32).
 */

static int sizeof_timeval(void)
{
    return sizeof (struct timeval);
}


/* SIZEOF_TIMEVAL()INTEGER */
SIZEOF_TIMEVAL( LA_ALIST ) LA_DCL
{
    RETINT(sizeof_timeval());
}
#line 94 "CSNOBOL4.lss"

static int set_timeval(long p, int sec, int usec)
{
    struct timeval *tv = (void *)p;
    tv->tv_sec = sec;
    tv->tv_usec = usec;
}


/* SET_TIMEVAL(LONG,INTEGER,INTEGER) */
SET_TIMEVAL( LA_ALIST ) LA_DCL
{
    set_timeval((long)LA_INT(0),(int)LA_INT(1),(int)LA_INT(2));
    RETNULL;
}
#line 103 "CSNOBOL4.lss"

static int sizeof_fd_set(void)
{
    return sizeof (fd_set);
}


/* SIZEOF_FD_SET()INTEGER */
SIZEOF_FD_SET( LA_ALIST ) LA_DCL
{
    RETINT(sizeof_fd_set());
}
#line 110 "CSNOBOL4.lss"

static int fd_isset_(int fd, long p)
{
    return FD_ISSET(fd, (fd_set *)p);
}


/* FD_ISSET_(INTEGER,LONG)INTEGER */
FD_ISSET_( LA_ALIST ) LA_DCL
{
    RETINT(fd_isset_((int)LA_INT(0),(long)LA_INT(1)));
}
#line 117 "CSNOBOL4.lss"

static void fd_zero_(long p)
{
    FD_ZERO((fd_set *)p);
}


/* FD_ZERO_(LONG) */
FD_ZERO_( LA_ALIST ) LA_DCL
{
    fd_zero_((long)LA_INT(0));
    RETNULL;
}
#line 124 "CSNOBOL4.lss"

static void fd_clr(int fd, long p)
{
    FD_ClR(fd, (fd_set *)p);
}


/* FD_CLR_(INTEGER,LONG) */
FD_CLR_( LA_ALIST ) LA_DCL
{
    fd_clr_((int)LA_INT(0),(long)LA_INT(1));
    RETNULL;
}
#line 131 "CSNOBOL4.lss"

static void fd_set_(int fd, long p)
{
    FD_SET(fd, (fd_set *)p);
}


/* FD_SET_(INTEGER,LONG) */
FD_SET_( LA_ALIST ) LA_DCL
{
    fd_set_((int)LA_INT(0),(long)LA_INT(1));
    RETNULL;
}
#line 138 "CSNOBOL4.lss"

static int clear_errno(void)
{
    errno = 0;
}


/* CLEAR_ERRNO() */
CLEAR_ERRNO( LA_ALIST ) LA_DCL
{
    clear_errno();
    RETNULL;
}
#line 145 "CSNOBOL4.lss"

static int waitpid_(int pid, int options)
{
    return waitpid(pid, &status, options);
}


/* WAITPID_(INTEGER,INTEGER)INTEGER */
WAITPID_( LA_ALIST ) LA_DCL
{
    RETINT(waitpid_((int)LA_INT(0),(int)LA_INT(1)));
}
#line 152 "CSNOBOL4.lss"

static int get_status(void)
{
    return status;
}


/* GET_STATUS()INTEGER */
GET_STATUS( LA_ALIST ) LA_DCL
{
    RETINT(get_status());
}
#line 159 "CSNOBOL4.lss"

