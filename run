#!/usr/bin/bash
         exec "snobol4" "-d8m" "-b" "$0" "$@"
*
************************************************************************
*                                                                      *
*                                                                      *
*                      ######   #     #  #     #                       *
*                      #     #  #     #  ##    #                       *
*                      #     #  #     #  # #   #                       *
*                      ######   #     #  #  #  #                       *
*                      #   #    #     #  #   # #                       *
*                      #    #   #     #  #    ##                       *
*                      #     #   #####   #     #                       *
*                                                                      *
*                                                                      *
************************************************************************
*
* THIS IS THE RUN-TIME LOADER. IT READS, ASSEMBLES AND COMINES THE
* FILES ON THE COMMAND LINE. IT IS SPECIFICALLY FOR FASBOL. LOADS AND
* POPULATES THE GLOBAL SYMBOLS FROM FASBOL.SO. ADDS ASSEMBLER DIRECTIVES
* FOR STACKS, AND UUOS NEEDED FOR FASBOL.
*
* ESTABLISHES THE ASSEMBLER/LOAD ENVIRONMENT, LOADS (ASSEMBLES) EACH
* .MAC FILE NAMED, AND EXECUTES THE LOADED CODE FROM SYMBOL '.MAIN.'.
*
-TITLE RUN
-INCLUDE 'JIT.INC'
-INCLUDE 'FFI.INC'
-INCLUDE 'ASM.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'MERGET.INC'
-INCLUDE 'DDT.INC'
-STITL
*
*        DDT()
         TERMINAL = 'RUN (TUE JUN 24 19:53:25 EDT 2014)'
*
         INIT_JIT('/usr/local/bin/snobol4')
         GLOBALS = TABLE()
*
* ADD FASBOL.SO SYMBOLS
*
         H = DLOPEN('./fasbol.so', 2)
         TERMINAL = IDENT(H) DLERROR()
*
* PUSH AND POP
*
         GLOBALS<'PUSH'> = DLSYM(H, 'push')
         GLOBALS<'POP'> = DLSYM(H, 'pop')
*
* PRINT STACK, STRING, BREAK TABLE, STORAGE
*
         GLOBALS<'PRSTACK'> = DLSYM(H, 'prstack')
         GLOBALS<'PRSTRING'> = DLSYM(H, 'prstring')
         GLOBALS<'PRSTORAGE'> = DLSYM(H, 'prstorage')
         GLOBALS<'PRBREAK'> = DLSYM(H, 'prbreak')
*
* STORAGE MANAGER
*
         GLOBALS<'ALLOCATE'> = DLSYM(H, 'allocate')
         GLOBALS<'GC'> = DLSYM(H, 'gc')
         GLOBALS<'INIT_STORAGE'> = DLSYM(H, 'init_storage')
*
         GLOBALS<'STORAGE'> = DLSYM(H, 'storage')
         GLOBALS<'END_STORE'> = DLSYM(H, 'end_store')
         GLOBALS<'NDESCRIPTORS'> = DLSYM(H, 'ndescriptors')
*
         GLOBALS<'GCT_T_BYTES'> =    HI('00000000')
         GLOBALS<'GCT_T_REFS'> =     HI('40000000')
         GLOBALS<'GCT_T_FREE'> =     HI('80000000')
         GLOBALS<'GCT_T_END'> =      HI('C0000000')
         GLOBALS<'GC_MARK'> =        HI('20000000')
         GLOBALS<'GC_ROOT'> =        HI('10000000')
         GLOBALS<'GC_SIZE'> =        HI('0FFFFFFF')
*
* NOTE THAT WE CAN HAVE AS MANY "TYPES" HERE AS WE WANT. THE TYPE
* IS SPECIFIED AS A 32 BIT INTEGER. THE STORAGE ALLOCATOR ONLY
* SUPPORTS TWO TYPES - BYTES AND REFS. BYTES ARE PLAIN STORAGE, AND
* CAN BE RELOCATED (AND FREED IF NO LONGER REFERENCED). REFS ARE
* SIMPLY A VECTOR OF 32 BIT INTEGERS REFERENCING DESCRIPTORS
*
* WHICH IS THE NEXT ITEM ON THE IMPLEMENTATION LIST.
*
         GLOBALS<'TYPE_INTEGER'> = 0
         GLOBALS<'TYPE_REAL'> = 1
         GLOBALS<'TYPE_STRING'> = 2
         GLOBALS<'TYPE_BREAK'> = 3
         GLOBALS<'S_FLAGS'> = 0
         GLOBALS<'S_TYPE'> = 4
         GLOBALS<'S_DATA'> = 8
*
* FILL BREAK TABLE FROM STRING
*
         GLOBALS<'FILLBREAK'> = DLSYM(H, 'fillbreak')
*
* COMMON DATA
*
         GLOBALS<'CMN'> = 1
*
* STRINGS DEFINED IN FASBOL.SO - NUL = '', DIGITS = &DIGITS,
* UCASE = &UCASE, LCASE = &LCASE, ALPHABET = &ALPHABET
*
* WE SHOULD BUILD INIT_STORAGE CALL HERE AND DO IT -- THESE VARIABLES
* ARE PUT INTO STORAGE. NOTE THAT CMN IS A T_REFS VECTOR THAT REFERENCES
* EACH OF THESE VARIABLES, AND IS A ROOT VARIABLE.
*
         GLOBALS<'NUL'> = 0
         GLOBALS<'DIGITS'> = 1
         GLOBALS<'LCASE'> = 2
         GLOBALS<'UCASE'> = 3
         GLOBALS<'ALPHABET'> = 4
*
* STACKS DEFINED IN FASBOL.C - SS = SYSTEM STACK, ES = EXPRESSION
* STACK, PS = PATTERN STACK, AS = ASSIGNMENT STACK, CS = CONDITIONAL
* STACK.
*
         GLOBALS<'SS'> = DLSYM(H, 'SS')
         GLOBALS<'ES'> = DLSYM(H, 'ES')
         GLOBALS<'PS'> = DLSYM(H, 'PS')
         GLOBALS<'AS'> = DLSYM(H, 'AS')
         GLOBALS<'CS'> = DLSYM(H, 'CS')
*
* OFFSETS FOR STACK STRUCTURE. SINCE WE VIEW STACKS AS A PRIMITIVE
* OPERATION, WE ARE UNLIKELY TO CARE ABOUT THIS. WILL LIKELY BE
* REMOVED FROM HERE.
*
         GLOBALS<'SPT'> = 0   ;* DQ POINTER TO STACK DATA
         GLOBALS<'SIX'> = 8   ;* DW CURRENT STACK INDEX
         GLOBALS<'SFR'> = 10  ;* DW FREE ITEMS IN STACK
         GLOBALS<'SSZ'> = 12  ;* DW INITIAL/CURRENT SIZE
         GLOBALS<'SXT'> = 14  ;* DW NUMBER OF ITEMS TO GROW BY
*
* ASM DIRECTIVES - EXPANSIONS FOR PUSH STACK,REG POP STACK,REG
*
         DEFINE('PUSH__(P1,P2,P3)S')
         DEFINE('POP__(P1,P2,P3)S')
*
* READ "OBJECT" FILES, MUST BE "LORD" ORDER. EACH COMPONENT CONTRIBUTES
* TO GLOBAL SYMBOLS, WHICH ARE THEN AVAILABLE TO THE REMAINING PARTS.
*
* INDEX OF THE NEXT COMMAND LINE ARGUMENT
*
         I = 0
*
* CLEAR FLAGS (-p AND -d)
         DISASSEMBLE =
         PRINT =
*
* GET NEXT ARGUMENT. THIS WILL BE EITHER A FLAG (-p, -d) OR A FILENAME
* TO PROCESS
*
ASM_LOAD FN = HOST(HOST_ARGN, HOST(HOST_FIRSTARG) + I)       :F(ASM_RUN)
*
* OPTIONS
*
* -p "PRINTS" THE NEXT MODULE AFTER ASM COMPLETES. PRINT IS VIEW OF
*    THE CODE IN LIGHTNING FORMAT
* -d DISASSEMBLE THE NEXT MODULE AFTER ASM COMLETES. THIS IS A
*    DISASSEMBLY OF THE ACTUAL MACHINE INSTRUCTIONS.
*
         PRINT = IDENT(FN, '-p') 1                           :F(ASM_LD2)
         I = I + 1                                           :(ASM_LOAD)
ASM_LD2  DISASSEMBLE = IDENT(FN, '-d') 1                     :F(ASM_LD3)
         I = I + 1                                           :(ASM_LOAD)
*
* PROCESS A FILE. READ THE ENTIRE FILE.
*
ASM_LD3  SRC = READFILE(FN)                    J              :F(FILERR)
*
* CREATE A NEW ASM() OBJECT. ESTABLISH INITIAL SYMBOLS AS GLOBALS (UP
* TO THIS MODULE).
*
         A = ASM_CREATE(GLOBALS)
*
* ASSEMBLE (LOAD) THIS FILE. THIS RESULTS IN A NEW MACHINE CODE BLOCK
* IN MEMORY (WHICH MAY HAVE RERENCES TO ANY PREVIOUS MACHINE CODE AS
* PUBLISHED IN GLOBALS).
*
         ASM(A, SRC)                                          :F(ASMERR)
*
* "PRINT" THE RESULT, IF THE -p FLAG WAS GIVEN
*
         DIFFER(PRINT) JIT_PRINT()
         PRINT =
*
* DISASSEMBLE THE RESULT, IF THE -d FLAG WAS GIVEN
*
         DIFFER(DISASSEMBLE) JIT_DISASSEMBLE()
         DISASSEMBLE =
*
* MERGE THE GLOBALS TABLE WITH THE NEW EXPORTS FROM THIS ASM BLOCK.
* NOTE THAT NEW EXPORTS TAKE PRECEDENCE (WHICH IS THE "LEAST SURPRISING"
* BEHAVIOUR).
*
         GLOBALS = MERGET(GLOBALS, EXPORTS(A))
         I = I + 1                                           :(ASM_LOAD)
*
* ERRORS - FILE COULDN'T BE READ, ASM DIDN'T LIKE THE FILE, OR THERE
* IS NOT .MAIN. ENTRY POINT.
*
FILERR   TERMINAL = "CAN'T READ FILE " FN                         :(END)
ASMERR   TERMINAL = "ERROR ASM IN FILE " FN                       :(END)
MAINERR  TERMINAL = "NO .MAIN."                                   :(END)
*
* EXECUTE THE CODE THAT HAS BEEN LOADED.
*
* EXECUTION BEGINS AT ENTRY POINT .MAIN.
*
ASM_RUN  MAIN = GLOBALS<'.MAIN.'>
         IDENT(MAIN)                                         :S(MAINERR)
*
* CREATE A NEW FFI OBJECT. .MAIN. HAS NO PARAMETERS AND RETURNS A
* STATUS (INTEGER) TO RETURN TO THE OPERATING SYSTEM (&CODE).
*
         FFI = FFI_NEW('I', 'V')
*
* SET THE CALL POINTER FOR THE FF TO .MAIN.
*
         FFI_SET_CALLP(FFI, MAIN)
*
* CALL THE FFI (.MAIN.), RETURNING INTEGER R
*
         R = FFI_CALL_INTEGER(FFI)
*
* WE COULD, BUT DON'T BOTHER WITH FREEING ANYTHING. WE ARE NOT EVEN
* TRACKING THE ASM OBJECTS (WE COULD PUT THEM INTO A TABLE, AND FREE
* THEM). IT IS PRESUMED THAT THIS PARTICULAR KIND OF CODE GENERATION
* WILL BE DONE AT STARTUP, AND THE CODE REUSED DURING EXECUTION.
*
*        FFI_FREE(FFI)
*        FINISH_JIT()
*
* ASSIGN RESULT R INTO &CODE, AND EXIT TO THE OPERATING SYSTEM.
*
         &CODE = R                                                :(END)
*
* EXTRA OPERATIONS FOR ASM.INC. NOTE THAT THE ASM() FUNCTION IS
* EXTENSIBLE. ANY OPERATOR CAN BE ADDED BY DEFINING IT AS A FUNCTION
* 'OPERATOR' IN ASM (MAC CODE) WILL CALL FUNCTION OPERATOR__, ASSUMING
* THAT OPERATOR__ HAS BEEN DEFINED.
*
* THIS LETS US ADD OPERATORS TO THE ASM CODE, BRINGING IT TO THE
* LEVEL NEEDED FOR A PARTICULAR APPLICATION. IN THIS CASE (FASBOL
* SUPPORT), THE PDP-10 SUPPORTS 'PUSH' AND 'POP' INSTRUCTIONS. WE
* SIMULATE THESE WITH TWO OPERATORS DEFINED HERE.
*
* THE PDP-10 ALSO SUPPORTS "UUOS" WHICH ARE EXTRA INSTRUCTIONS THAT
* CAN BE USED AS COMMON CALLS. AGAIN, WE CAN REPLICATE THIS BEHAVIOUR
* BY EXTENDING ASM.
*
* AS SHOWN IN THE FUNCTIIONS 'PUSH__' AND 'POP__', ONE WAY OF HANDLING
* THESE CASES IS BY SIMPLY CREATING A CODE EXPANSION, AND SPLICING
* CODE INTO THE INPUT SOURCE (VERY LISPISH MACRO SUPPORT).
*
* PUSH STACK,REG
*
* EXPAND TO CALL. GENERALLY, WE WILL SPLICE IN REPLACEMENT CODE. IT
* WOULD BE FASTER TO JUST GENERATE THE SEQUENCES, BUT LESS CONVENIENT.
* AT A LATER TIME, DO THIS. FOR NOW, JUST EXPAND THE "VIRTUAL MACHINE"
* TO MEET OUR NEEDS. THIS IS REFLECTED IN INCREASED ASSEMBLE/LOAD TIME.
*
* THIS APPROACH ALSO LETS US CHANGE THE CODE GENERATOR MORE READILY,
* WHICH IS IMPORTANT AT THIS STAGE. RIGHT NOW WE ARE MOVING BETWEEN
* "C" PIECES IN FASBOL.C, EXPANSIONS ("MACROS" AND "PSEUDO-OPS") IN
* RUN, AND CODE GENERATED TO THE ".MAC" FILES.
*
PUSH__   S = ' PREPARE'      CHARS_NL
+            ' PUSHARGI {1}' CHARS_NL
+            ' PUSHARGR {2}' CHARS_NL
+            ' FINISHI PUSH' CHARS_NL
*
SPLICE   S = REPL(S, '{1}', P1)
         S = REPL(S, '{2}', P2)
         SRC POS(BL) LEN(0) = S                                :(RETURN)
*
* POP STACK,REG
*
POP__    S = ' PREPARE'      CHARS_NL
+            ' PUSHARGI {1}' CHARS_NL
+            ' FINISHI POP'  CHARS_NL
+            ' RETVAL {2}'   CHARS_NL                          :(SPLICE)
*
* CE: .MSNOBOL4;
*
END
