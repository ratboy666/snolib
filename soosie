#!/usr/bin/bash
         exec "snobol4" "-b" "-s" "-d 4m" "$0" "$@"

* ce: .msnobol4;

* soosie
*
* The SNOBOL4 librarian
*
* -d 512k normal (8MB RAM)
* -d 4m (64MB RAM)
*
* File data is stashed into a separate data file DAT. This avoids
* string scanning in json. We record offset and length of the data part
* of the string O:L
*
* Reading is still expensive -- we extract using data pos(o) len(l) . s
* to extract the data to the file record contents
*
* Breaking up the data this way takes 43 seconds on my i3. Writing is
* much faster -- append is fast, the pattern is much more expensive.

* we need to be able to edit the file list, examine a module, build,
* deliver. freshen
* dependency checks -- is module dirty?

-include 'JSON.INC'
-include 'READFILE.INC'
-include 'BQ.INC'
-include 'SIZEA.INC'
-include 'CRACK.INC'
-include 'TIMER.INC'
-include 'TIME.INC'
-include 'HASH.INC'
-include 'DDT.INC'
-include 'READLINE.INC'

         define('readlbr(nm)lbr,data,c,i,m,f,j,s,b,l')
         define('writelbr(lbr)c,i,m,f,j,data,n,s')
         define('createlbr(nm,lnm,dt,lc)lbr')
         define('create_file(fn)s')
         define('create_module(src,cmnt,artifacts,depends)'
+               'install,build,files,m,i')
         define('writefiles(lbr,m)f,i')

         output(.term, 20, 'T', '/dev/stdout')

top      l = readline('SOOSIE: ')
         l = trim(l)
         l fence ('ls' | 'LS' | 'new' | 'NEW' | 'read' | 'READ' |
+                 'write' | 'WRITE' | 'quit' | 'QUIT' |
+                 'extract' | 'EXTRACT' | 'help' | 'HELP') . cmd
+          rem . args                                            :f(top)

                                                                 :($cmd)
         l 'quit'                                        :s(end)f(tryls)

ls       ident(lbr)                                              :s(nol)
         c = keys_in_table(lbr<'CONTENTS'>)                    :f(empty)
         i = 1
lslup    c<i>                                                 :f(lslup2)
         s = c<i>
         term = rpad(s, 16)
         i = i + 1                                              :(lslup)
lslup2   terminal =                                               :(top)
empty    terminal = 'library empty'                               :(top)
nol      terminal = 'no library loaded'                           :(top)

* add lbr name/data name as args LBR and LBR.DAT
new      lbr = createlbr('LBR', 'SNOLIB', 'LBR.DAT', 'SNOLIB library')

* Seed in the lss files

         files = bq('ls *.lss', CHARS_NL)
         files = crack(files, CHARS_NL)

         i = 1
lup      fn = files<i>                                           :f(top)
         term = 'adding ' lpad(i, 3) ' ' rpad(fn, 16) CHARS_CR

* For initial load, we assume .INC, .html and .tst are the artifacts
* for a .lss file.
*
* note that .INC may be empty for a program. eg bundle
*
* need to deal with
* editline.c ffi.c format.c init.c jit.c p64.c p64.h
* htm -> html
* ditaa images

         base = fn
         base '.lss' =

         n = 1
         n = file(base '.html') n + 1
         n = file(base '.tst') n + 1
         a = array(n)
         a<1> = base
         a<1> = file(base '.INC') base '.INC'
         a<2> = file(base '.html') base '.html'
         a<3> = file(base '.tst') base '.tst'

* create a module with automatic dependencies

         m = create_module(fn, base ' module', a)

* add the module to the library

         lbr<'CONTENTS'><m<'NAME'>> = m
         i = i + 1                                                :(lup)

* add name of LBR on command line, default to LBR

read     terminal = 'reading library'
         t1 = time()
         lbr = readlbr('LBR')
         terminal = 'took ' time() - t1 ' milliseconds'           :(top)
  
write    ident(lbr)                                              :s(nol)

         terminal = 'writing library'
         t1 = time()
         writelbr(lbr)
         terminal = 'took ' time() - t1 ' milliseconds'           :(top)

* module name on command line

extract  ident(lbr)                                              :s(nol)
         writefiles(lbr, 'AGT')                                  :s(top)
         terminal = "can't extract"                               :(top)

help     terminal = 'SOOSIE'
         terminal =
         terminal = 'new, read, write, ls, extract, quit'
                                                                  :(top)


* Write files for module

writefiles
         ident(lbr)                                          :s(freturn)
         f = lbr<'CONTENTS'><m>
         ident(f)                                            :s(freturn)
         f = f<'FILES'>
         i = 1
co2      f<i>                                                 :f(return)
         writefile(f<i><'NAME'>, f<i><'CONTENTS'>)           :f(freturn)
         bq('chmod ' f<i><'ACCESS'> ' ' f<i><'NAME'>)
         bq('touch -d @' f<i><'TIMESTAMP'> ' ' f<i><'NAME'>)
         i = i + 1                                                :(co2)
 
* Read library

readlbr  lbr = json_decode(readfile(nm))                     :f(freturn)
         readlbr = lbr
         data = readfile(lbr<'DATAFILE'>)                    :f(freturn)
         c = keys_in_table(lbr<'CONTENTS'>)                :f(readlbr_2)
         i = 1
readlbr_3
         m = c<i>                                          :f(readlbr_2)
         f = lbr<'CONTENTS'><m><'FILES'>
         j = 1
readlbr_4
         f<j>                                              :f(readlbr_5)
         term = rpad(f<j><'NAME'>, 16) CHARS_CR
         s = f<j><'CONTENTS'>
         s break(':') . b ':' rem . l
         data pos(b) len(l) . s                                 :f(what)
         f<j><'CONTENTS'> = s
         j = j + 1                                          :(readlbr_4)
readlbr_5
         i = i + 1                                          :(readlbr_3)
readlbr_2
         readlbr = lbr                                         :(return)
what     terminal = 'bad file data'                               :(end)

* Write library

writelbr c = keys_in_table(lbr<'CONTENTS'>)               :f(writelbr_2)
         data =
         i = 1
writelbr_3
         m = c<i>                                         :f(writelbr_2)
         f = lbr<'CONTENTS'><m><'FILES'>
         j = 1
writelbr_4
         f<j>                                             :f(writelbr_5)
         n = size(data)
         s = f<j><'CONTENTS'>
         data = data s
         f<j><'CONTENTS'> = n ':' size(s)
         j = j + 1                                         :(writelbr_4)
writelbr_5
         i = i + 1                                         :(writelbr_3)
writelbr_2
         writefile(lbr<'LIBRARY'>, json_encode(lbr))             :f(end)
         writefile(lbr<'DATAFILE'>, data)               :f(end)s(return)

* Create empty library

createlbr
         lbr = table()
         lbr<'LIBRARY'> = nm
         lbr<'COMMENT'> = lc
         lbr<'TIMESTAMP'> = tv_sec(gettimeofday())
         lbr<'VERSION'> = 1
         lbr<'CONTENTS'> = table()
         lbr<'DATAFILE'> = dt
         createlbr = lbr                                       :(return)

* Create a file entry for the module
*
* use file command to determine TEXT/BINARY.

create_file
         create_file = table()
         create_file<'NAME'> = fn
         s = (?(bq('file ' fn) ? 'text') 'TEXT', 'BINARY')
         create_file<'TYPE'> = s
         create_file<'TIMESTAMP'> = bq('stat -c %Y ' fn)
         create_file<'ACCESS'> = bq('stat -c %a ' fn)
         s = readfile(fn)                                     :f(return)
         create_file<'CONTENTS'> = s                           :(return)

* Create a module for the library
*
* We begin with the source file, and fill in the rest

create_module
         m = table()

         m<'SOURCE'> = src
         m<'COMMENT'> = cmnt
         m<'ARTIFACTS'> = artifacts

* Find -MODULE or -PROGRAM directive in the source file to determine
* the module type. If a -MODULE is not seen, we assume PROGRAM to
* support older main programs.
*
* Slight problem in bq(). the command may report success/fail, which
* is returned correctly. but if the command returns success, and
* no output, it is taken to be fail. This should be documented in
* bq.

         m<'TYPE'> = (?bq('grep -- -MODULE ' src) 'MODULE', 'PROGRAM')

* Hunt down the module or program name. If we can't find it, we
* assume the src name with any extension removed.

         s = src
         src arb . s '.' arb rpos(0)
         s = bq('grep -- ^-MODULE ' src ' | sed -e "s/-MODULE //"')
         s = bq('grep -- ^-PROGRAM ' src ' | sed -e "s/-PROGRAM //"')
         m<'NAME'> = s

* Determine depends. This is determine by the first artifact, run
* through 'uses', or is supplied.

         depends = ident(depends) json_decode(bq('uses ' artifacts<1>))
+                                                                :f(end)
         m<'DEPENDS'> = depends

* From the artifacts, we create install, build and files

         n = prototype(artifacts)
         install = array(n)
         build = array(n)
         files = array(n + 1)
         m<'INSTALL'> = install
         m<'BUILD'> = build
         m<'FILES'> = files

* Add build commands to module. If the build array is empty,
* its a standard build. Otherwise the exceptional commands will
* be recorded here.

         seq(' build<i> = ?artifacts<i> table();'
+            ' build<i><"TARGET"> = artifacts<i>;'
+            ' build<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add install commands to module.

         seq(' install<i> = ?artifacts<i> table();'
+            ' install<i><"TARGET"> = artifacts<i>;'
+            ' install<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add files to module.

         files<1> = create_file(src, dat)
         seq(' files<i + 1> = create_file(artifacts<i>)', .i, 1)

* Return the new module.

         create_module = m                                     :(return)

end
