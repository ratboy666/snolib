#!/usr/bin/bash
         exec "snobol4" "-b" "-d 4m" "$0" "$@"

* ce: .msnobol4;

* soosie
*
* The SNOBOL4 librarian
*
* -d 4m : use 64MB (64 bit)
*
* Most editing (eg comments) is deferred to the GUI version

-include 'JSON.INC'
-include 'READFILE.INC'
-include 'BQ.INC'
-include 'SIZEA.INC'
-include 'CRACK.INC'
-include 'TIMER.INC'
-include 'TIME.INC'
-include 'HASH.INC'
-include 'DDT.INC'
-include 'READLINE.INC'
-include 'VDIFFER.INC'
-include 'TRIMB.INC'
-include 'LINK.INC'
-include 'REVL.INC'

         define('readlbr(nm)lbr,data,c,i,m,f,j,s,b,l')
         define('writelbr(lbr)c,i,m,f,j,data,n,s')
         define('createlbr(nm,lnm,dt,lc)lbr')
         define('create_file(fn)s')
         define('create_module(src,cmnt,artifacts,depends)'
+               'install,build,files,m,i')
         define('writefiles(lbr,m)f,i')
         define('file2module(lbr)')

         terminal = 'SOOSIE (FRI JUN  6 12:22:12 EDT 2014)'
         rlappname('SOOSIE')
         read_history('.SOOSIE')
         stifle_history(50)

         output(.term, 20, 'T', '/dev/stdout')

top      l = readline('SOOSIE: ')
         l = history_expand(l)
         l = trim(l)
         add_history(vdiffer(l))

         l fence ('ls' | 'LS' | 'new' | 'NEW' | 'read' | 'READ' |
+                 'write' | 'WRITE' | 'quit' | 'QUIT' |
+                 'extract' | 'EXTRACT' | 'help' | 'HELP' |
+                 'info' | 'INFO' | 'build' | 'BUILD' |
+                 'edit' | 'EDIT') . cmd
+          rem . args                                           :s($cmd)
         terminal = '?'                                           :(top)

quit     write_history('.SOOSIE')                        :s(end)f(tryls)

edit
 :(top)

build

 define('build_module(lbr,m)i,d') :(bm_end)

build_module

 differ(done<m<'NAME'>>) :s(return)

* recurse to process the members of d

 d = m<'DEPENDS'>
 seq(' build_module(lbr, lbr<"CONTENTS"><d<i>>)', .i)

* add this one to build list, and mark it done

 bl = link(m<'NAME'>, bl)
 done<m<'NAME'>> = 1
 :(return)

bm_end

* ddt()
 terminal = 'build -- dependency checking'
 done = table()
 bl =

 ident(lbr) :s(nol)
 args = trimb(args)
 m = lbr<'CONTENTS'><args>
 ident(m) :s(nom)

 build_module(lbr, m)

* since we consd entries to the start of bl (build list), it is in
* reverse dependency order. reverse it.

 bl = revl(bl)
 terminal = 'dependency check complete'

* now we can build up the build instructions needed for each of the
* modules. for each, we can determine if it is out of date. if it
* is, we can reach into it to collect the build instructions, and the
* install instructions

* For each of the modules, we determine if the file date of SOURCE
* is more recent than the first artifact. If not, we can discard this
* from the build list. We end up with a list of modules which are
* out of date with themselves, ordered in required build sequence.
*
* to do this, we build an filest table which is keyed on name,
* and references each of the files.


* lbr<'CONTENTS'><module><>
* 'SOURCE' 'COMMENT' 'ARTIFACTS' 'TYPE' 'NAME' 'DEPENDS'
* 'INSTALL' 'BUILD' ('TARGET' 'COMMANDS')
* 'FILES'
*   'NAME' 'TYPE' 'TIMESTAMP' 'ACCESS' 'CONTENTS'

* build file reference table, keyed on name, which references each
* file

 filest = table()
         c = keys_in_table(lbr<'CONTENTS'>)                   :f(nom)
         i = 1
ft_2    m = c<i>                                              :f(ft_3)
         f = lbr<'CONTENTS'><m><'FILES'>
         j = 1
ft_4    f<j> :f(ft_5)
         n = f<j><'NAME'>
         filest<n> = f<j>
         j = j + 1 :(ft_4)
ft_5    i = i + 1                                              :(ft_2)
ft_3

 p = bl

dlup
 ident(p) :s(top)
 terminal = value(p)
* here, check date dependency within a module. If out of date, add it
* to the next build list
 p = next(p) :(dlup)
 :(top)
nom terminal = 'MODULE ' args ' NOT FOUND' :(top)

info     ident(lbr) :s(nol)
         args = trimb(args)
         differ(args) :s(info2)
         terminal = 'lbr info'
         
         terminal = 'LIBRARY:   ' lbr<'LIBRARY'>
         terminal = 'DATAFILE:  ' lbr<'DATAFILE'>
         terminal = 'VERSION:   ' lbr<'VERSION'>
         terminal = 'COMMENT:   ' lbr<'COMMENT'>
         t = lbr<'TIMESTAMP'>
* rfc 822 (%y) 2822 (%Y)
*        t = strftime('%a, %d %b %Y %z', gmtime(t))
         t = bq('date -d @' t)
         terminal = 'TIMESTAMP: ' lbr<'TIMESTAMP'> ' (' t ')'
         terminal = 'CONTENTS:    use "ls" command to list index'
 :(top)
info2    m = args
         terminal = 'module info'
         c = lbr<'CONTENTS'><m>
         ident(c) :s(top)
* DDT()
         terminal = 'NAME:    ' c<'NAME'>
         terminal = 'TYPE:    ' c<'TYPE'>
         terminal = 'COMMENT: ' c<'COMMENT'>
         terminal = 'SOURCE:  ' c<'SOURCE'>

* lbr<'CONTENTS'><module><>
* 'SOURCE' 'COMMENT' 'ARTIFACTS' 'TYPE' 'NAME' 'DEPENDS'
* 'INSTALL' 'BUILD' ('TARGET' 'COMMANDS')
* 'FILES'
*   'NAME' 'TYPE' 'TIMESTAMP' 'ACCESS' 'CONTENTS'
 :(top)

ls       ident(lbr)                                              :s(nol)
         args = eval(args)
         c = keys_in_table(lbr<'CONTENTS'>)                    :f(empty)
         i = 1
ls2      s = c<i>                                                :f(ls3)
         s args                                                  :f(ls4)
         term = rpad(s, 16)
ls4      i = i + 1                                                :(ls2)
ls3      terminal =                                               :(top)
empty    terminal = 'library empty'                               :(top)
nol      terminal = 'no library loaded'                           :(top)

* add lbr name/data name as args LBR and LBR.DAT
new      args = trimb(args)
         args = ident(args) 'LBR'
         lbr = createlbr(args, 'SNOLIB', args '.DAT', 'SNOLIB library')

         differ(args, 'LBR') :s(top)

* Seed in the lss files

         files = bq('ls *.lss', CHARS_NL)
         files = crack(files, CHARS_NL)

         i = 1
lup      fn = files<i>                                         :f(seed2)
* gt(i, 10) :s(seed2)
         term = 'adding ' lpad(i, 3) ' ' rpad(fn, 16) CHARS_CR

* For initial load, we assume .INC, .html and .tst are the artifacts
* for a .lss file.
*
* note that .INC may be empty for a program. eg bundle
*
* need to deal with
* editline.c ffi.c format.c init.c jit.c p64.c p64.h
* htm -> html
* ditaa images

         base = fn
         base '.lss' =

         n = 1
         n = file(base '.html') n + 1
         n = file(base '.tst') n + 1
         a = array(n)
         a<1> = base
         a<1> = file(base '.INC') base '.INC'
         a<2> = file(base '.html') base '.html'
         a<3> = file(base '.tst') base '.tst'

* create a module with automatic dependencies

         m = create_module(fn, base ' module', a)

* add the module to the library

         lbr<'CONTENTS'><m<'NAME'>> = m
         i = i + 1                                                :(lup)
seed2    terminal =
         file2module(lbr)                                         :(top)

* add name of LBR on command line, default to LBR

read     args = trimb(args)
         args = ident(args) 'LBR'
         lbr = readlbr(args)                                      :(top)
  
write    ident(lbr)                                              :s(nol)
         writelbr(lbr)                                            :(top)

* module name on command line

extract  ident(lbr)                                              :s(nol)
         writefiles(lbr, 'AGT')                                  :s(top)
         terminal = "can't extract"                               :(top)

help     terminal = 'SOOSIE'
         terminal =
         terminal = 'new, read, write, ls, extract, quit'
                                                                  :(top)


* Write files for module

writefiles
         ident(lbr)                                          :s(freturn)
         f = lbr<'CONTENTS'><m>
         ident(f)                                            :s(freturn)
         f = f<'FILES'>
         i = 1
co2      f<i>                                                 :f(return)
         writefile(f<i><'NAME'>, f<i><'CONTENTS'>)           :f(freturn)
         bq('chmod ' f<i><'ACCESS'> ' ' f<i><'NAME'>)
         bq('touch -d @' f<i><'TIMESTAMP'> ' ' f<i><'NAME'>)
         i = i + 1                                                :(co2)
 
* Read library

readlbr  lbr = json_decode(readfile(nm))                     :f(freturn)
         readlbr = lbr
         data = readfile(lbr<'DATAFILE'>)                    :f(freturn)
         c = keys_in_table(lbr<'CONTENTS'>)                :f(readlbr_2)
         i = 1
readlbr_3
         m = c<i>                                          :f(readlbr_2)
         f = lbr<'CONTENTS'><m><'FILES'>
         j = 1
readlbr_4
         f<j>                                              :f(readlbr_5)
         s = f<j><'CONTENTS'>
         f<j><'LOCATION'> 'DIRECT'                         :s(readlbr_6)
         s break(':') . b ':' rem . l
         data fence tab(b) len(l) . s                           :f(what)
         f<j><'CONTENTS'> = s
         f<j><'LOCATION'> = 'DIRECT'
readlbr_6
         j = j + 1                                          :(readlbr_4)
readlbr_5
         i = i + 1                                          :(readlbr_3)
readlbr_2
         readlbr = lbr                                         :(return)
what     terminal = 'bad file data'                               :(end)


* Write library

writelbr c = keys_in_table(lbr<'CONTENTS'>)               :f(writelbr_2)
         data =
         i = 1
writelbr_3
         m = c<i>                                         :f(writelbr_2)
         f = lbr<'CONTENTS'><m><'FILES'>
         j = 1
writelbr_4
         f<j>                                             :f(writelbr_5)
         n = size(data)
         s = f<j><'CONTENTS'>
         data = data s
         f<j><'LOCATION'> = 'DATA'
         f<j><'CONTENTS'> = n ':' size(s)
         j = j + 1                                         :(writelbr_4)
writelbr_5
         i = i + 1                                         :(writelbr_3)
writelbr_2
         writefile(lbr<'LIBRARY'>, json_encode(lbr))             :f(end)
         writefile(lbr<'DATAFILE'>, data)               :f(end)s(return)

* Create empty library

createlbr
         lbr = table()
         lbr<'LIBRARY'> = nm
         lbr<'COMMENT'> = lc
         lbr<'TIMESTAMP'> = tv_sec(gettimeofday())
         lbr<'VERSION'> = 1
         lbr<'CONTENTS'> = table()
         lbr<'DATAFILE'> = dt
         createlbr = lbr                                       :(return)

* Create a file entry for the module
*
* use file command to determine TEXT/BINARY.

create_file
         create_file = table()
         create_file<'NAME'> = fn
         s = (?(bq('file ' fn) ? 'text') 'TEXT', 'BINARY')
         create_file<'TYPE'> = s
         create_file<'TIMESTAMP'> = bq('stat -c %Y ' fn)
         create_file<'ACCESS'> = bq('stat -c %a ' fn)
         create_file<'LOCATION'> = 'DIRECT'
         s = readfile(fn)                                     :f(return)
         create_file<'CONTENTS'> = s                           :(return)

* Create a module for the library
*
* We begin with the source file, and fill in the rest

create_module
         m = table()

         m<'SOURCE'> = src
         m<'COMMENT'> = cmnt
         m<'ARTIFACTS'> = artifacts

* Find -MODULE or -PROGRAM directive in the source file to determine
* the module type. If a -MODULE is not seen, we assume PROGRAM to
* support older main programs.
*
* Slight problem in bq(). the command may report success/fail, which
* is returned correctly. but if the command returns success, and
* no output, it is taken to be fail. This should be documented in
* bq.

         m<'TYPE'> = (?bq('grep -- -MODULE ' src) 'MODULE', 'PROGRAM')

* Hunt down the module or program name. If we can't find it, we
* assume the src name with any extension removed.

         s = src
         src arb . s '.' arb rpos(0)
         s = bq('grep -- ^-MODULE ' src ' | sed -e "s/-MODULE //"')
         s = bq('grep -- ^-PROGRAM ' src ' | sed -e "s/-PROGRAM //"')
         m<'NAME'> = s

* Determine depends. This is determine by the first artifact, run
* through 'uses', or is supplied.

         depends = ident(depends) json_decode(bq('uses ' artifacts<1>))
+                                                                :f(end)
         m<'DEPENDS'> = depends

* From the artifacts, we create install, build and files

         n = prototype(artifacts)
         install = array(n)
         build = array(n)
         files = array(n + 1)
         m<'INSTALL'> = install
         m<'BUILD'> = build
         m<'FILES'> = files

* Add build commands to module. If the build array is empty,
* its a standard build. Otherwise the exceptional commands will
* be recorded here.

         seq(' build<i> = ?artifacts<i> table();'
+            ' build<i><"TARGET"> = artifacts<i>;'
+            ' build<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add install commands to module.

         seq(' install<i> = ?artifacts<i> table();'
+            ' install<i><"TARGET"> = artifacts<i>;'
+            ' install<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add files to module.

         files<1> = create_file(src, dat)
         seq(' files<i + 1> = create_file(artifacts<i>)', .i, 1)

* Return the new module.

         create_module = m                                     :(return)

* We need to convert dependency references from files to modules.
* Do this after seeding - walk through each of the modules

file2module

* build a table f2mt of the file->module mappings.

         f2mt = table()
         c = keys_in_table(lbr<'CONTENTS'>)                   :f(return)
*
         i = 1
f2m_2    m = c<i>                                              :f(f2m_3)
         f = lbr<'CONTENTS'><m><'FILES'>
         j = 1
f2m_4    f<j> :f(f2m_5)
         n = f<j><'NAME'>
         f2mt<n> = m
         j = j + 1 :(f2m_4)
f2m_5    i = i + 1                                              :(f2m_2)
f2m_3

* rip through the dependencies, replacing each file reference with
* a module reference. we used 'uses' to get from function() references
* to file references, and now we go from file references to module
* references.

         i = 1
f2m_6    m = c<i>                                              :f(f2m_9)
         f = lbr<'CONTENTS'><m><'DEPENDS'>
         j = 1
f2m_8    f<j> :f(f2m_7)
         n = f<j>
         f<j> = vdiffer(f2mt<n>)
         j = j + 1 :(f2m_8)
f2m_7    i = i + 1                                              :(f2m_6)
f2m_9

* It is possible that a module can contribute multiple files to the
* dependencies. In that case we will have redundant module dependencies.
* Go through the modules, removing dependency redundancy.

         i = 1
f2m_10   m = c<i>                                             :f(f2m_11)
         f = lbr<'CONTENTS'><m><'DEPENDS'>

* dedup f by making it into a table, and then making an array from
* the keys. FIXME: this should be a library function DEDUPA(A).
* an empty array dedups to itself, and if keys_in_table fails, no
* update is made.

         ident(f, array0) :s(f2m_12)
         t = table()
         seq(' t<f<i>> = 1', .j)
         f = keys_in_table(t)

         lbr<'CONTENTS'><m><'DEPENDS'> = f
f2m_12   i = i + 1                                             :(f2m_10)
f2m_11

* Finally clean!

 :(return)


end
