#!/usr/bin/bash
         exec "snobol4" "-b" "-d 4m" "$0" "$@"

* ce: .msnobol4;

* soosie
*
* The SNOBOL4 librarian
*
* -d 4m : use 64MB (64 bit)
*
* The philosophy behind SOOSIE is similar to st-80 or dedicated lisp
* boxes. SOOSIE manages an "image" which is all the code in the
* system. Pieces can be added in, and freely used. SOOSIE manages
* the image, which includes all source code and "object" files.
*
* However, SOOSIE must be much more aware of the filesystem. The
* only thing available is "-include" which can only bring in files
* from the filesystem. Therefore, SOOSIE also manages files in the
* filesystem (only those related to SOOSIE).
*
* SOOSIE is the most complicated program in the SNOLIB suite. It
* manages the other build programs ('uses', 'bldidx, and the building
* program 'sweave', 'stangle', 'g360', 'embed', and 'ifs'). It also
* manages the external editor, and can run 'code'.
*
* Running deseq automatically. If the source file has -IN72 in it,
* a deseq pass should be executed before generating the INC file.

-include 'JSON.INC'
-include 'READFILE.INC'
-include 'BQ.INC'
-include 'SIZEA.INC'
-include 'CRACK.INC'
-include 'TIMER.INC'
-include 'TIME.INC'
-include 'HASH.INC'
-include 'READLINE.INC'
-include 'VDIFFER.INC'
-include 'TRIMB.INC'
-include 'LINK.INC'
-include 'REVL.INC'
-include 'HOST.INC'
-include 'DEDUPA.INC'
-include 'ATOL.INC'
-include 'ITERDIR.INC'
-include 'DDT.INC'
-include 'SIZEL.INC'
-include 'SIZET.INC'
-include 'STROUT.INC'
-include 'REPL.INC'


         define('iter_artifacts(lbr,m)')
         define('martifact(a)')
         define('next_artifact(a)')
         define('iter_modules(lbr)')
         define('module(m)')
         define('next_module(m)')
         define('iter_files(lbr,m)')
         define('mfile(f)')
         define('next_file(f)')
         define('writefiles(lbr,m)f,fi')
         define('wfile(f)')
         define('readlbr(nm)lbr,data,mi,m,fi,f,s,b,l')
         define('writelbr(lbr)data,mi,m,fi,f,n,s')
         define('createlbr(nm,lnm,dt,lc)')
         define('rfile(f,fn)s')
         define('create_file(fn)')
         define('create_module(src,cmnt,artifacts,depends)'
+               'install,build,files,m,s,n,i')
         define('file2module(lbr)f2mt,mi,m,d,i,n')
         define('filest(lbr)mi,m,fi,f,n')
         define('get_dependencies(lbr,m)i,d')
         define('dependencies(lbr,m)done')
         define('f2mt(lbr)mi,m,fi,f,n')
         define('extension(f)s')


         terminal = 'SOOSIE (FRI JUN  6 12:22:12 EDT 2014)'
         rlappname('SOOSIE')
         read_history('.SOOSIE')
         stifle_history(50)
         output(.term, 19, 'T', '/dev/stdout')

top      l = readline('SOOSIE: ')
         l = history_expand(l)
         l = trim(l) ' '
         add_history(vdiffer(l))

* major command, go to handler

         l fence ('ls' | 'LS' | 'new' | 'NEW' | 'load' | 'load' |
+                 'save' | 'save' | 'quit' | 'QUIT' |
+                 'extract' | 'EXTRACT' | 'help' | 'HELP' |
+                 'info' | 'INFO' | 'build' | 'BUILD' |
+                 'edit' | 'EDIT' | 'module' | 'MODULE') . cmd ' '
+          rem . args                                     :s($(cmd '.'))
         terminal = '?'                                           :(top)


* Help

help.    terminal = 'SOOSIE'
         terminal =
         terminal = 'NEW'
         terminal = 'LOAD'
         terminal = 'SAVE'
         terminal = 'LS'
         terminal = 'EXTRACT'
         terminal = 'BUILD'
         terminal = 'QUIT'
         terminal = 'MODULE'
                                                                  :(top)


* Exit

quit.     write_history('.SOOSIE')                       :s(end)f(tryls)


* module commands
* module add,rem mod

module.  ident(lbr)                                              :s(nol)
         a = trimb(args) ' '
         a fence ('add' | 'ADD' | 'rem' | 'REM' |
+                 'edit' | 'EDIT') . s ' '
+             rem . args =                            :s($('module_' s))

         terminal = 'UNKNOWN MODULE SUBCOMMAND'                   :(top)


* Adds an empty module to the library
* module edit module key remainder is value
* if its not an array, use editline() to edit it.
* need to edit the arrays. -
*
* module edit name,source,comment,type,artifacts,depends,files
*
* notes: build and install arrays should always be ordered
* in artifact order. build and install arrays have entries
* added and removed with artifact edit. files gets entries
* added when artifact is added.
* need to reorder artifacts. editline() can be exploited
* so, add artifacts and depends to 'edit' subcommand
* changing source removes old source from files, adds new
* source. files tracks source and artifacts, with possibly
* extra.
*
* ident('TYPE') means this module will never be built. It
* can however, contribute to the DEPENDS ("uber" modules)
*
* eg, a "LIST" ubermodule can be defined that will make
* all LINK sub-modules.
*
* module rename m or module copy -- copy is problematic due to
* deep copy semantics - the elements will still refer to each other

module_edit
 define('stringize(n,v)s')
 define('destring(n,v)s,i')
         args = trimb(args) ' '
         args break(' ') . mod ' ' rem . a
         mod = replace(mod, &lcase, &ucase)
         ident(lbr<'CONTENTS'><mod>)                         :s(mnexist)
         args = trimb(a) ' '
         args fence ('name' | 'NAME' | 'source' | 'SOURCE' |
+                    'comment' | 'COMMENT' | 'type' | 'TYPE' |
+                    'artifacts' | 'ARTIFACTS' | 'depends' | 'DEPENDS' |
+                    'files' | 'FILES') . var ' '
+            rem . val :f(mesyn)
* need artifacts depends files. These require conversion to string
* format and back again. type must be MODULE, PROGRAM, or empty.
         var = replace(var, &lcase, &ucase)
         val = trimb(val)
         differ(val) :s(me2)
         val = stringize(var, lbr<'CONTENTS'><mod><var>)         :f(top)
         val = editline(mod ':' var ': ', val)
me2      lbr<'CONTENTS'><mod><var> = destring(var, val)           :(top)


stringize
  stringize = v
  n 'ARTIFACTS' | 'DEPENDS' | 'FILES' :f(return)
  s =
  n 'FILES' :f(str2)
  s = table()
  seq(' s<v<i><"NAME">> = 1', .i)
  v = keys_in_table(s)
str2
  s = stringout(v, CHARS_NUL)
  s = repl(s, '\', '\\')
  s = repl(s, ' ', '\ ')
  s = replace(s, CHARS_NUL, ' ')
  stringize = s :(return)

destring
  destring = v
  n 'ARTIFACTS' | 'DEPENDS' | 'FILES' :f(return)
  s = repl(v, '\\', CHARS_NUL)
  s = repl(s, '\ ', CHARS_SOH)
  s = repl(s, CHARS_NUL, '\')
  s = crack(s, ' ')
  seq(' s<i> = repl(s<i>, CHARS_SOH, " ")', .i)
  destring = s
  n 'FILES' :f(return)
  terminal = 'destring FILES'
  f = filest(lbr)
*  seq(' output = s<i>', .i)
  seq(' s<i> = (vdiffer(filest<s<i>>), create_file(s<i>))', .i)
  destring = s :(return)

mesyn    terminal = 'MODULE M_NAME EDIT ITEM VALUE'
         terminal = 'ITEM - NAME, SOURCE, COMMENT, ARTIFACTS,'
         terminal = '       TYPE, DEPENDS, FILES'                 :(top)
 
module_add
         args = trimb(args)
         args = replace(args, &lcase, &ucase)
         ident(args)                                            :s(msyn)
         differ(lbr<'CONTENTS'><args>)                        :s(mexist)
         m = table()
         m<'NAME'> = args
         m<'SOURCE'> =
         m<'COMMENT'> =
         m<'ARTIFACTS'> = array0
         m<'TYPE'> =
         m<'DEPENDS'> = array0
         m<'INSTALL'> = array0
         m<'BUILD'> = array0
         m<'FILES'> = array0
         lbr<'CONTENTS'><args> = m                                :(top)

msyn     terminal = 'MODULE ADD|REM NAME'                         :(top)
mexist   terminal = 'MODULE ' args ' ALREADY IN LIBRARY'          :(top)
mnexist  terminal = 'MODULE ' args ' NOT IN LIBRARY'              :(top)

* we need an "undo" operation. to do this, we can copy_table() of the
* loaded lbr, and restore that back to lbr. Also, any "deep edit" needs
* to keep a copy of the deep edit entry and how to restore it.

module_rem
         args = trimb(args)
         ident(args)                                            :s(msyn)
         args = replace(args, &lcase, &ucase)
         ident(lbr<'CONTENTS'><args>)                        :s(mnexist)
         lbr<'CONTENTS'><args> =
         lbr<'CONTENTS'> = prune_table(lbr<'CONTENTS'>)           :(top)

* Edit a file in the library. We edit by file, because a module may
* have multiple source artifacts. In future, we should determine
* file collisions -- and deal with that.

edit.    fn = trimb(args)
         filest = filest(lbr)
         differ(f = filest<fn>)                                  :f(unf)
         terminal = 'EDITING ' f<'NAME'>
         wfile(f)
         host(HOST_SYSCMD, 'ED ' fn)
         ts = (file(fn) bq('stat -c %Y ' fn), 0)
         ne(ts, f<'TIMESTAMP'>)                                :s(edit2)
         terminal = 'FILE NOT CHANGED'                            :(top)
edit2    rfile(f)                                                 :(top)

unf      terminal = 'UNKNOWN FILE' :(top)


* Build a module

build.   ident(lbr)                                              :s(nol)
         args = trimb(args)
         args = replace(args, &lcase, &ucase)
         m = lbr<'CONTENTS'><args>
         ident(m)                                                :s(nom)

* dependencies of module m

         dl = dependencies(lbr, m)

* files table

         filest = filest(lbr)

* timestamp pruning. each module is checked to see if the main source
* file timestamp is more recent than any of its artifacts. if all
* artifacts are more recent, the module does not need building.

         p = dl
         bl =
ts_1     ident(p)                                               :s(ts_4)
           source = lbr<'CONTENTS'><value(p)><'SOURCE'>
           source_ts = filest<source><'TIMESTAMP'>
           ai = iter_artifacts(lbr, value(p))
           r =
ts_2         a = martifact(ai)                                  :f(ts_3)
             a_ts = filest<a><'TIMESTAMP'>
             r = gt(source_ts, a_ts) 1
           ai = next_artifact(ai)                                :(ts_2)
ts_3       bl = differ(r) link(value(p), bl)
         p = next(p)                                             :(ts_1)
ts_4     bl = revl(bl)

         terminal = ident(bl) 'MODULE IS UP TO DATE'             :s(top)

* we now have a list of modules that is needed for the build of this
* module, pruned by timestamp. We can now walk the list, constructing
* the needed build commands.

* we need to "check out" the modules in dl, then build any modules
* in bl.

* "checking out" a module is easy -- just extract all files in the
* module.
*
* we need "freshen" all files in the library. find all modules that
* need building. "clean" all external files (except, possibly,
* artifacts). "install" -- which is close to building.

         p = dl
co_1       ident(p)                                             :s(co_2)
           m = value(p)
           writefiles(lbr, m)
         p = next(p)                                             :(co_1)
co_2

* Load the default recipes

         recipes = json_decode(readfile('RECIPES'))

* The modules can now be built, in order from least to most dependent.
* This is the order that bl is in.

         p = bl
bl_1       ident(p)                                             :s(bl_2)
           m = value(p)

* To build a module, we need extract the build commands for each of the
* artifacts. m<'BUILD'> is an array of tables: TARGET/COMMANDS and
* COMMANDS is an array of commands. if COMMANDS is empty, we use
* standard commands for this type of source/artifact combination.
* Please note that the build commands are an array, to make editing
* the RECIPES file more pleasant.

           b = lbr<'CONTENTS'><m><'BUILD'>
           i = 1
bu_1         b<i>                                               :f(bu_2)
             c = b<i><'COMMANDS'>
             src = lbr<'CONTENTS'><m><'SOURCE'>
             sext = extension(src)
             tgt = b<i><'TARGET'>
             text = extension(tgt)
             terminal = 'MAKING ' tgt ' FROM ' src
             terminal = ne(sizea(c))                            :s(bu_3)
             c = recipes<sext text>

* If we don't have any commands, stub in a touch

bu_3         c = eq(sizea(c)) %'touch {{tgt}}'
             s = stringout(c, CHARS_NL)

* Replacements in the recipe

             s = repl(s, '{{src}}', src)
             s = repl(s, '{{tgt}}', tgt)

* Display the complete recipe

             terminal = s

* And cook

             host(HOST_SYSCMD, s)

* If this artifact is newer than what we have (and we hope so), replace
* the library file. If not don't update, but issue a warning message

             newf = create_file(tgt)
             oldf = filest<tgt>
             terminal = le(newf<'TIMESTAMP'>, oldf<'TIMESTAMP'>)
+                     'TARGET ' tgt ' APPEARS NOT TO HAVE BEEN UPDATED?'
+                                                               :s(bu_4)
             oldf<'TIMESTAMP'> = newf<'TIMESTAMP'>
             oldf<'ACCESS'> = newf<'ACCESS'>
             oldf<'CONTENTS'> = newf<'CONTENTS'>
bu_4       i = i + 1                                             :(bu_1)
bu_2

         p = next(p)                                             :(bl_1)
bl_2

         terminal = 'BUILD COMPLETE'                              :(top)


* Information on the library, or a module

info.    ident(lbr)                                              :s(nol)
         args = trimb(args)
         differ(args)                                          :s(info2)

cntf     n = 0
         mi = iter_modules(lbr)
cntf_2     m = module(mi)                                     :f(cntf_5)
           fi = iter_files(lbr, m)
cntf_3       f = mfile(fi)                                    :f(cntf_4)
             n = n + 1
           fi = next_file(fi)                                  :(cntf_3)
cntf_4   mi = next_module(mi)                                  :(cntf_2)
cntf_5

         terminal = 'LIBRARY:   ' lbr<'LIBRARY'>
         terminal = 'DATAFILE:  ' lbr<'DATAFILE'>
         terminal = 'VERSION:   ' lbr<'VERSION'>
         terminal = 'COMMENT:   ' lbr<'COMMENT'>
         t = (vdiffer(lbr<'TIMESTAMP'>), 0)
         t = bq('date -d @' t)
         terminal = 'TIMESTAMP: ' lbr<'TIMESTAMP'> ' (' t ')'
         terminal = 'CONTENTS:  ' sizet(lbr<'CONTENTS'>) ' modules, '
+                                 n ' files'
         terminal = '           use "ls" command to list index'

* build and install commands not shown

info2    args fence ('file ' | 'FILE ') =                      :s(info3)
         args = replace(args, &lcase, &ucase)
         m = args
         m = vdiffer(lbr<'CONTENTS'><m>)                         :f(top)
         terminal = 'NAME:      ' m<'NAME'>
         terminal = 'TYPE:      ' m<'TYPE'>
         terminal = 'SOURCE:    ' m<'SOURCE'>
         terminal = 'COMMENT:   ' m<'COMMENT'>
         term     = 'ARTIFACTS: '
         a = m<'ARTIFACTS'>
         seq(' term = rpad(a<i>, 16)', .i)
         terminal =
         term     = 'DEPENDS:   '
         a = m<'DEPENDS'>
         seq(' term = rpad(a<i>, 16)', .i)
         terminal =
         term     = 'FILES:     '
         a = m<'FILES'>
         seq(' term = ?a<i> rpad(a<i><"NAME">, 16)', .i)
         terminal =                                               :(top)

info3    filest = filest(lbr)
         args = trimb(args)
         terminal = ident(f = filest<args>) 'NO FILE'            :s(top)
         terminal = 'NAME:      ' f<'NAME'>
         terminal = 'TYPE:      ' f<'TYPE'>
         t = (vdiffer(f<'TIMESTAMP'>), 0)
         t = bq('date -d @' t)
         terminal = 'TIMESTAMP: ' f<'TIMESTAMP'> ' (' t ')'
         terminal = 'ACCESS:    ' f<'ACCESS'>
* location should always be DIRECT
*        terminal = 'LOCATION:  ' f<'LOCATION'>
         terminal = 'CONTENTS:  ' size(f<'CONTENTS'>) ' BYTES'    :(top)


* List the modules in the library

ls.      ident(lbr)                                              :s(nol)
         args = eval(args)
         m = iter_modules(lbr)
ls2        n = module(m)                                         :f(ls3)
           term = ?(n ? args) rpad(n, 16)
         m = next_module(m)                                       :(ls2)
ls3      terminal =                                               :(top)

nol      terminal = 'NO LIBRARY LOADED'                           :(top)
nom      terminal = 'MODULE ' args ' NOT FOUND'                   :(top)


* New library. Seed in '*.lss' as modules.

new.     args = trimb(args)
         args = ident(args) 'LBR'
         lbr = createlbr(args, 'SNOLIB', args '.DAT', 'SNOLIB library')

         differ(args, 'LBR')                                     :s(top)

* Seed in the lss files for LBR/LBR.DAT

         files = iter_dir('*.lss')
seed1      fn = value_dir(files)                                :f(seed2)
           term = 'adding ' rpad(fn, 16) CHARS_CR

* guess at artifacts from the .lss (or other passed in filename)

* this will become a 'add_module()' function to add a new module
* to the library. note that there is a "chicken and egg" problem
* here -- we can't determine details until the module is built,
* and we can't (yet) actually build modules.

* need to deal with editline.c ffi.c format.c init.c jit.c p64.c p64.h
* htm -> html
* ditaa images

           base = fn
           base '.lss' =

           a = table()

* the bare program, or .INC file must be the first artifact, in order
* for create_module() to correctly determine the dependencies
* automatically

           a<base>         = file(base) 1
           a<base '.INC'>  = file(base '.INC') 1

           a<base '.html'> = file(base '.html') 1
           a<base '.tst'>  = file(base '.tst') 1
           a<base '.txt'>  = file(base '.txt') 1
           a = keys_in_table(a)

           m = create_module(fn, base ' module', a)

           lbr<'CONTENTS'><m<'NAME'>> = m
         files = next_dir(files)                                :(seed1)

seed2    terminal =

* Upgrade file dependencies to module dependencies

         file2module(lbr)                                         :(top)


* Load library

load.    args = trimb(args)
         args = ident(args) 'LBR'
         lbr = readlbr(args)                                      :(top)


* Save library

save.    ident(lbr)                                              :s(nol)
         writelbr(lbr)
         lbr =                                                    :(top)


* Extract files from module

extract. ident(lbr)                                              :s(nol)
         args = trimb(args)
         ident(lbr<'CONTENTS'><args>)                            :s(nom)
         writefiles(lbr, args)                                   :s(top)
         terminal = "CAN'T EXTRACT"                               :(top)


* Functions for soosie


* Write file to filesystem. Make sure that access and timestamp
* are restored

wfile    writefile(f<'NAME'>, f<'CONTENTS'>)                 :f(freturn)
         bq('chmod ' f<'ACCESS'> ' ' f<'NAME'>)
         bq('touch -d @' f<'TIMESTAMP'> ' ' f<'NAME'>)         :(return)


* Write all files for module to filesystem

writefiles
         fi = iter_files(lbr, m)
wf2        f = mfile(fi)                                      :f(return)
           wfile(f)                                          :f(freturn)
         fi = next_file(fi)                                       :(wf2)

 
* Read library. Reads the library as a json document. Then reads the
* associated datafile. Iterates the modules in the newly read library,
* and each file, converting DATA references into DIRECT references.

readlbr  lbr = json_decode(readfile(nm))                     :f(freturn)
         readlbr = lbr
         data = readfile(lbr<'DATAFILE'>)                    :f(freturn)
         mi = iter_modules(lbr)
rdlbr_3    m = module(mi)                                    :f(rdlbr_2)
           fi = iter_files(lbr, m)
rdlbr_4      f = mfile(fi)                                   :f(rdlbr_5)
             s = f<'CONTENTS'>
             f<'LOCATION'> 'DIRECT'                          :s(rdlbr_6)
             s break(':') . b ':' rem . l
             data fence tab(b) len(l) . s                       :f(what)
             f<'CONTENTS'> = s
             f<'LOCATION'> = 'DIRECT'
rdlbr_6    fi = next_file(fi)                                 :(rdlbr_4)
rdlbr_5  mi = next_module(mi)                                 :(rdlbr_3)
rdlbr_2  readlbr = lbr                                         :(return)
what     terminal = 'BAD FILE DATA'                               :(end)


* Write library

writelbr mi = iter_modules(lbr)
wrlbr_3    m = module(mi)                                    :f(wrlbr_2)
           fi = iter_files(lbr, m)
wrlbr_4      f = mfile(fi)                                   :f(wrlbr_5)
             s = f<'CONTENTS'>
             n = size(data)
             data = data s
             f<'LOCATION'> = 'DATA'
             f<'CONTENTS'> = n ':' size(s)
           fi = next_file(fi)                                 :(wrlbr_4)
wrlbr_5  mi = next_module(mi)                                 :(wrlbr_3)
wrlbr_2  writefile(lbr<'LIBRARY'>, json_encode(lbr))             :f(end)
         writefile(lbr<'DATAFILE'>, data)               :f(end)s(return)


* Create empty library

createlbr
         createlbr = table()
         createlbr<'LIBRARY'> = nm
         createlbr<'COMMENT'> = lc
         createlbr<'TIMESTAMP'> = tv_sec(gettimeofday())
         createlbr<'VERSION'> = 1
         createlbr<'CONTENTS'> = table()
         createlbr<'DATAFILE'> = dt                            :(return)


* Create a file entry

create_file
         create_file = table()
         rfile(create_file, fn)                                :(return)


* Fill in file details (including contents) of a file entry from the
* file in the filesystem. Fill in default for non-existent file.

rfile    fn = ident(fn) f<'NAME'>
         f<'NAME'> = fn
         f<'TYPE'> = 'TEXT'
         f<'TYPE'> = (?(file(fn) bq('file ' fn) ? 'text') 'TEXT',
+                     'BINARY')
         f<'TIMESTAMP'> = (file(fn) bq('stat -c %Y ' fn), 0)
         f<'ACCESS'> = (file(fn) bq('stat -c %a ' fn), '644')
         f<'LOCATION'> = 'DIRECT'
         f<'CONTENTS'> =(file(fn) readfile(fn), '')            :(return)


* Create a module for the library
*
* We begin with the source file, comment and artifacts. If dependencies
* are not specified, use 'uses' to determine dependencies.

create_module
         m = table()

         m<'SOURCE'> = src
         m<'COMMENT'> = cmnt
         m<'ARTIFACTS'> = artifacts

* Find -MODULE or -PROGRAM directive in the source file to determine
* the module type. If a -MODULE is not seen, we assume -PROGRAM to
* support older main programs.
*
* Slight problem in bq(). the command may report success/fail, which
* is returned correctly. but if the command returns success, and
* no output, it is taken to be fail. This should be documented in
* bq.

         m<'TYPE'> = (?(file(src) bq('grep -- -MODULE ' src))
+                     'MODULE', 'PROGRAM')

* Hunt down the module or program name. If we can't find it, we
* assume the src name with any extension removed.

         s = src
         src arb . s '.' arb rpos(0)
         s = file(src)
+            bq('grep -- ^-MODULE ' src ' | sed -e "s/-MODULE //"')
         s = file(src)
+            bq('grep -- ^-PROGRAM ' src ' | sed -e "s/-PROGRAM //"')
         m<'NAME'> = s

* Determine depends. This is determine by the first artifact, run
* through 'uses', or is supplied.

         depends = ident(depends) file(artifacts<1>)
+                  json_decode(bq('uses ' artifacts<1>))
+                                                                :f(end)
         m<'DEPENDS'> = depends

* From the artifacts, we create install, build and files

         n = prototype(artifacts)
         install = array(n)
         build = array(n)
         files = array(n + 1)
         m<'INSTALL'> = install
         m<'BUILD'> = build
         m<'FILES'> = files

* Add build commands to module. If the build array is empty,
* it's a standard build. Otherwise the exceptional commands will
* be recorded here.

         seq(' build<i> = ?artifacts<i> table();'
+            ' build<i><"TARGET"> = artifacts<i>;'
+            ' build<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add install commands to module.

         seq(' install<i> = ?artifacts<i> table();'
+            ' install<i><"TARGET"> = artifacts<i>;'
+            ' install<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add files to module.

         files<1> = create_file(src, dat)
         seq(' files<i + 1> = create_file(artifacts<i>)', .i, 1)

* Return the new module.

         create_module = m                                     :(return)

* We need to convert dependency references from files to modules.
* Do this after seeding - walk through each of the modules and for
* each module, each of the dependencies.

file2module
         f2mt = f2mt(lbr)

* Rip through the dependencies, replacing each file reference with
* a module reference. We used 'uses' to get from function() references
* to file references, and now we go from file references to module
* references.
*
* If a dependency file does not have a module it belongs to, leave it
* as a file. This allows an arbitrary file to be included as a
* dependency (use './' directory path notation to ensure it is not
* part of a module)

         mi = iter_modules(lbr)                               :f(return)
f2m_6      m = module(mi)                                      :f(f2m_9)
           d = lbr<'CONTENTS'><m><'DEPENDS'>
           i = 1
f2m_8        n = d<i>                                          :f(f2m_7)
             d<i> = vdiffer(f2mt<n>)
           i = i + 1                                            :(f2m_8)
f2m_7    mi = next_module(mi)                                   :(f2m_6)
f2m_9

* It is possible that a module can contribute multiple files to the
* dependencies. In that case we will have redundant module dependencies.
* Go through the modules, removing dependency redundancy.

         mi = iter_modules(lbr)
f2m_10     m = module(mi)                                     :f(f2m_11)
           d = lbr<'CONTENTS'><m><'DEPENDS'>
           lbr<'CONTENTS'><m><'DEPENDS'> = dedupa(d)
f2m_12   mi = next_module(mi)                                  :(f2m_10)
f2m_11                                                         :(return)


* Return file reference table, keyed on name, which references each
* file in the library.

filest   filest = table()
         mi = iter_modules(lbr)
ft_2       m = module(mi)                                     :f(return)
           fi = iter_files(lbr, m)
ft_3         f = mfile(fi)                                      :f(ft_4)
             n = f<'NAME'>
             filest<n> = f
           fi = next_file(fi)                                    :(ft_3)
ft_4     mi = next_module(mi)                                    :(ft_2)


* Return a list of the dependencies of a module. This includes the
* module itself. Order is in libary build order (least to most
* dependent). get_dependencies() is a helper routine for dependencies().

dependencies
         done = table()
         get_dependencies(lbr, m)
         dependencies = revl(dependencies)                     :(return)

get_dependencies
         differ(done<m<'NAME'>>)                              :s(return)
         d = m<'DEPENDS'>
         seq(' get_dependencies(lbr, lbr<"CONTENTS"><d<i>>)', .i)
         dependencies = link(m<'NAME'>, dependencies)
         done<m<'NAME'>> = 1                                   :(return)


* Return a table of the file->module mappings. This table is keyed by
* filename, and returns the module name.

f2mt     f2mt = table()
         mi = iter_modules(lbr)
f2mt_2     m = module(mi)                                     :f(return)
           fi = iter_files(lbr, m)
f2mt_3       f = mfile(fi)                                    :f(f2mt_4)
             n = f<'NAME'>
             f2mt<n> = m
           fi = next_file(fi)                                  :(f2mt_3)
f2mt_4   mi = next_module(mi)                                  :(f2mt_2)


* Iterate modules in library

iter_modules
         iter_modules = atol(keys_in_table(lbr<'CONTENTS'>))
+                                                   :s(return)f(freturn)

module   module = differ(m) value(m)                :s(return)f(freturn)

next_module
         next_module = differ(m) next(m)            :s(return)f(freturn)


* Iterate files in module m

iter_files
         iter_files = atol(lbr<'CONTENTS'><m><'FILES'>)
+                                                   :s(return)f(freturn)

mfile    mfile = differ(f) value(f)                 :s(return)f(freturn)

next_file
         next_file = differ(f) next(f)              :s(return)f(freturn)


* Iterate artifacts in module m

iter_artifacts
         iter_artifacts = atol(lbr<'CONTENTS'><m><'ARTIFACTS'>)
+                                                   :s(return)f(freturn)

martifact
         martifact = differ(a) value(a)             :s(return)f(freturn)

next_artifact
         next_artifact = differ(a) next(a)          :s(return)f(freturn)


* Return file extension

extension
         s = reverse(f)
         s break('./') . extension '.'
         extension = reverse(extension)
         extension = '.' vdiffer(extension)                    :(return)


end
