#!/usr/bin/bash
         exec "snobol4" "-b" "-d 4m" "$0" "$@"

* ce: .msnobol4;

-INCLUDE 'ARRAY0.INC'
-INCLUDE 'ATOL.INC'
-INCLUDE 'BQ.INC'
-INCLUDE 'BRKREM.INC'
-INCLUDE 'CHARS.INC'
-INCLUDE 'COPYA.INC'
-INCLUDE 'COPYT.INC'
-INCLUDE 'CRACK.INC'
-INCLUDE 'DDT.INC'
-INCLUDE 'DEDUPA.INC'
-INCLUDE 'HOST.INC'
-INCLUDE 'ITERDIR.INC'
-INCLUDE 'JSON.INC'
-INCLUDE 'KEYST.INC'
-INCLUDE 'LINK.INC'
-INCLUDE 'MD5.INC'
-INCLUDE 'PRUNET.INC'
-INCLUDE 'READFILE.INC'
-INCLUDE 'READLINE.INC'
-INCLUDE 'EDITLINE.INC'
-INCLUDE 'REPL.INC'
-INCLUDE 'REVL.INC'
-INCLUDE 'SEQ.INC'
-INCLUDE 'SIZEA.INC'
-INCLUDE 'SIZET.INC'
-INCLUDE 'STROUT.INC'
-INCLUDE 'TIME.INC'
-INCLUDE 'TRIMB.INC'
-INCLUDE 'VDIFFER.INC'
-INCLUDE 'WRTFILE.INC'

* soosie
*
* The SNOBOL4 librarian
*
* -d 4m : use 64MB (64 bit)
*
* The philosophy behind SOOSIE is similar to ST-80 or dedicated lisp
* boxes. SOOSIE manages an "image" which is all the code in the
* system. Pieces can be added in, and freely used. SOOSIE manages
* the image, which includes all source code and "object" files.
*
* However, SOOSIE must be much more aware of the filesystem. The
* only thing available to running programs is "-INCLUDE 'APPENDA.INC'
* bring in files from the filesystem. Therefore, SOOSIE also manages
* files in the filesystem (only those related to SOOSIE).
*
* SOOSIE is the most complicated program in the SNOLIB suite. It
* manages the other build programs ('uses', 'bldidx, and the building
* program 'sweave', 'stangle', 'g360', 'embed', 'in72' and 'ifs'). It
* also manages the external editor, and can run 'code'.
*
*
* Implement library edit.
*
* Implement MODULE COPY.
*
* Implement INSTALL MODULE.
*
* "Super commands" - build modules out of date. Generate Makefile.
* Generate listing, test compile of PROGRAM.

         define('iter_artifacts(lbr,m)')
         define('martifact(a)')
         define('next_artifact(a)')
         define('iter_modules(lbr)')
         define('module(m)')
         define('next_module(m)')
         define('iter_files(lbr,m)')
         define('mfile(f)')
         define('next_file(f)')
         define('writefiles(lbr,m)f,fi')
         define('wfile(f)')
         define('readlbr(nm)lbr,data,mi,m,fi,f,s,b,l')
         define('writelbr(lbr)data,mi,m,fi,f,n,s')
         define('createlbr(nm,dt,lc)')
         define('rfile(f,fn)s,md5')
         define('create_file(fn)')
         define('create_module(src,cmnt,artifacts,depends)'
+               'install,build,files,m,s,n,i')
         define('file2module(lbr)f2mt,mi,m,d,i,n')
         define('filest(lbr)mi,m,fi,f,n')
         define('get_dependencies(lbr,m)i,d')
         define('dependencies(lbr,m)done')
         define('f2mt(lbr)mi,m,fi,f,n')
         define('extension(f)s')
         define('crepl(s,n1,v1,n2,v2,n3,v3,n4,v4)a,i,k,r')

*        ddt()

         terminal = 'SOOSIE (FRI JUN  6 12:22:12 EDT 2014)'

* Load configuration

         config = json_decode(readfile('SOOSIE.CFG'))

         rlappname('SOOSIE')
         read_history('.SOOSIE')
         stifle_history(50)
         output(.term, 19, 'T', '/dev/stdout')

* Load the default recipes

         recipes = json_decode(readfile('RECIPES'))

* Load default installation rules

         insrules = json_decode(json_rest)

top      p = (differ(lbr) lbr<'LIBRARY'>, 'NO LIBRARY')
         l = readline('SOOSIE (' p '): ')
         l = history_expand(l)
         l = trim(l) ' '
         add_history(vdiffer(l))

* major command, go to handler

         l fence ('ls' | 'LS' | 'load' | 'load' | 'seed' | 'SEED' |
+                 'save' | 'save' | 'quit' | 'QUIT' |
+                 'export' | 'EXPORT' | 'help' | 'HELP' |
+                 'file' | 'FILE' | 'import' | 'IMPORT' |
+                 'edit' | 'EDIT' | 'module' | 'MODULE' |
+                 'library' | 'LIBRARY' | 'all' | 'ALL') . cmd ' '
+          rem . args                                     :s($(cmd '.'))
         terminal = '?'                                           :(top)

file.    ident(lbr)                                              :s(nol)
         a = trimb(args) ' '
         a fence ('edit' | 'EDIT' | 'info' | 'INFO') . s ' '
+             rem . args =                              :s($('file_' s))

         terminal = 'UNKNOWN FILE SUBCOMMAND'                     :(top)


library. a = trimb(args) ' '
         a fence ('edit' | 'EDIT' | 'info' | 'INFO' |
+                 'new' | 'NEW' | 'check' | 'CHECK' |
+                 'freshen' | 'FRESHEN')                         . s ' '
+             rem . args =                           :s($('library_' s))

         terminal = 'UNKNOWN LIBRARY SUBCOMMAND'                  :(top)


all.     ident(lbr)                                              :s(nol)
         a = trimb(args) ' '
         a fence ('export' | 'EXPORT') . s ' '
+             rem . args =                               :s($('all_' s))

         terminal = 'UNKNOWN ALL SUBCOMMAND'                      :(top)


* Freshen all files in the library.

library_freshen
         mi = iter_modules(lbr)
fresh2     m = module(mi)                                     :f(fresh5)
           fi = iter_files(lbr, m)
fresh3       f = mfile(fi)                                    :f(fresh4)
             r =
             term = rpad(f<'NAME'>, 16)
             fs = file(f<'NAME'>) create_file(f<'NAME'>)
             term = lt(f<'TIMESTAMP'>, fs<'TIMESTAMP'>)
+               (r = 'FS MORE RECENT')
             f<'NAME'> = fs<'NAME'>
             f<'TIMESTAMP'> = fs<'TIMESTAMP'>
             f<'ACCESS'> = fs<'ACCESS'>
             f<'MD5'> = fs<'MD5'>
             f<'SIZE'> = fs<'SIZE'>
             f<'CONTENTS'> = fs<'CONTENTS'>
             terminal = differ(r)
             term = ident(r) CHARS_CR
           fi = next_file(fi)                                  :(fresh3)
fresh4   mi = next_module(mi)                                  :(fresh2)
fresh5                                                            :(top)


* Make sure the files in the library are sane.

library_check
         mi = iter_modules(lbr)
check2     m = module(mi)                                     :f(check5)
           fi = iter_files(lbr, m)
check3       f = mfile(fi)                                    :f(check4)
             r =
             term = rpad(f<'NAME'>, 16)
             s = md5(f<'CONTENTS'>)
             term = differ(s, f<'MD5'>) (r = 'MD5 MISMATCH  ')
             fs = file(f<'NAME'>) create_file(f<'NAME'>)
             term = lt(f<'TIMESTAMP'>, fs<'TIMESTAMP'>)
+               (r = 'FS MORE RECENT')
             term = ident(f<'CONTENTS'>) (r = 'CONTENTS EMPTY')
             terminal = differ(r)
             term = ident(r) CHARS_CR
           fi = next_file(fi)                                  :(check3)
check4   mi = next_module(mi)                                  :(check2)
check5                                                            :(top)


library_new
         args = trimb(args)
         nm =
         args brkrem(' ') . nm rem . args
         args = trimb(args)
         nm = ident(nm) 'LBR'
         args = ident(args) nm '.DAT'
         lbr = createlbr(nm, args, 'SOOSIE Library')              :(top)


library_edit
         ident(lbr)                                              :s(nol)
         args = trimb(args) ' '
         args fence ('version' | 'VERSION' | 'comment' | 'COMMENT')
+                    . var ' '
+             rem . val
         var = replace(var, &lcase, &ucase)
         val = trimb(val)
         differ(val)                                             :s(le2)
         val = editline(lbr<'LIBRARY'> ':' var ': ', lbr<var>)
le2      lbr<var> = val                                           :(top)


* Help

help.    terminal = 'SOOSIE COMMANDS'
         terminal =
         terminal = 'ALL EXPORT'
         terminal = 'SEED [FILE PATTERN]'
         terminal = 'LIBRARY INFO'
         terminal = '        EDIT VERSION|COMMENT'
         terminal = '        NEW [LBR [LBR.DAT]]'
         terminal = '        FRESHEN'
         terminal = 'FILE INFO <FILE>'
         terminal = '     EDIT <FILE>'
         terminal = 'LOAD [LIBRARY]'
         terminal = 'SAVE'
         terminal = 'LS'
         terminal = 'EXPORT <MODULE>'
         terminal = 'IMPORT <FILE PATTERN>'
         terminal = 'QUIT'
         terminal = 'MODULE BUILD <MODULE>'
         terminal = '       INFO <MODULE>'
         terminal = 'MODULE ADD <MODULE>'
         terminal = '       REM <MODULE>'
         terminal = '       EDIT <MODULE> NAME|SOURCE|COMMENT|TYPE|'
+                                                           'ARTIFACTS|'
         terminal = '                     DEPENDS|FILES [NEW VALUE]'
         terminal = 'MODULE EDIT <MODULE> BUILD|INSTALL <ARTIFACT>'
         terminal = '       FRESHEN <MODULE>'
                                                                  :(top)


* Exit

quit.     write_history('.SOOSIE')                       :s(end)f(tryls)


* Module commands

module.  ident(lbr)                                              :s(nol)
         a = trimb(args) ' '
         a fence ('add' | 'ADD' | 'rem' | 'REM' | 'build' | 'BUILD' |
+                 'edit' | 'EDIT' | 'freshen' | 'FRESHEN' |
+                 'info' | 'INFO') . s ' '
+             rem . args =                            :s($('module_' s))

         terminal = 'UNKNOWN MODULE SUBCOMMAND'                   :(top)

* files tracks source and artifacts, with possibly extra files.
*
* ident('TYPE') means this module will never be built. It can, however,
* contribute to the DEPENDS ("uber" modules)
*
* eg, a "LIST" ubermodule can be defined that will make all LINK
* (list) sub-modules.
*
* module rename m or module copy -- copy is problematic due to
* deep copy semantics - the elements will still refer to each other


module_edit_build
         val = trimb(val)
         s = lbr<'CONTENTS'><mod><'BUILD'>
         t =
         seq(' t = ident(val, s<i><"TARGET">) i', .i)
         ident(t)                                               :s(meb3)
         c = s<t><'COMMANDS'>
         ne(sizea(c))                                           :s(meb4)
         tgt = s<t><"TARGET">
         text = extension(tgt)
         src = lbr<'CONTENTS'><mod><'SOURCE'>
         sext = extension(src)
         c = recipes<sext text>
         ne(sizea(c))                                           :s(meb4)
         c = array(1)
         c<1> = crepl('{{TOUCH}}', 'file=', '{{tgt}}')
meb4     l = stringout(c, CHARS_NL) CHARS_NL
         tmpfile = '___.TMP'
         writefile(tmpfile, l)
         host(HOST_SYSCMD, crepl('{{EDIT}}', 'file=', tmpfile))
         l2 = readfile(tmpfile)
         delete(tmpfile)
         ident(l, l2)                                            :s(top)
         l2 = crack(l2, CHARS_NL)
         s<t><'COMMANDS'> = l2                                    :(top)
meb2     terminal = 'NO BUILD LIST FOR ' mod                      :(top)
meb3     terminal = val ' NOT AN ARTIFACT IN ' mod                :(top)


module_edit_install
         val = trimb(val)
         s = lbr<'CONTENTS'><mod><'INSTALL'>
         t =
         seq(' t = ident(val, s<i><"TARGET">) i', .i)
         ident(t)                                               :s(mei3)
         c = s<t><'COMMANDS'>
         ne(sizea(c))                                           :s(mei4)
         tgt = s<t><"TARGET">
         text = extension(tgt)
         c = insrules<text>
         ne(sizea(c))                                           :s(mei4)
         c = array(1)
         c<1> = crepl('# empty install list for {{tgt}}')
mei4     l = stringout(c, CHARS_NL) CHARS_NL
         tmpfile = '___.TMP'
         writefile(tmpfile, l)
         host(HOST_SYSCMD, crepl('{{EDIT}}', 'file=', tmpfile))
         l2 = readfile(tmpfile)
         delete(tmpfile)
         ident(l, l2)                                            :s(top)
         l2 = crack(l2, CHARS_NL)
         s<t><'COMMANDS'> = l2                                    :(top)
mei2     terminal = 'NO INSTALL LIST FOR ' mod                    :(top)
mei3     terminal = val ' NOT AN ARTIFACT IN ' mod                :(top)


module_edit
         define('stringize(n,v)s,i')
         define('destring(n,v)s,i,f')
         args = trimb(args) ' '
         args break(' ') . mod ' ' rem . a
         mod = replace(mod, &lcase, &ucase)
         ident(lbr<'CONTENTS'><mod>)                         :s(mnexist)
         args = trimb(a) ' '
         args fence ('build' | 'BUILD') ' ' rem . val
+                                                  :s(module_edit_build)
         args fence ('install' | 'INSTALL') ' ' rem . val
+                                                :s(module_edit_install)
         args fence ('name' | 'NAME' | 'source' | 'SOURCE' |
+                    'comment' | 'COMMENT' | 'type' | 'TYPE' |
+                    'artifacts' | 'ARTIFACTS' | 'depends' | 'DEPENDS' |
+                    'files' | 'FILES') . var ' '
+             rem . val                                        :f(mesyn)
         var = replace(var, &lcase, &ucase)
         val = trimb(val)
         differ(val)                                             :s(me2)
         val = stringize(var, lbr<'CONTENTS'><mod><var>)         :f(top)
         val = editline(mod ':' var ': ', val)
         var 'TYPE'                                              :f(me2)
         val = trimb(replace(val, &lcase, &ucase))
         val 'MODULE' | 'PROGRAM' | ''                           :s(me2)
         terminal = 'TYPE MUST BE MODULE, PROGRAM OR EMPTY'       :(top)
me2      lbr<'CONTENTS'><mod><var> = destring(var, val)       :(mfresh2)


* FIXME: what about circular dependency? blows up now in build.

* FIXME: need a freshen all

module_freshen
         mod = replace(trimb(args), &lcase, &ucase)
         ident(lbr<'CONTENTS'><mod>)                             :s(nom)

mfresh2

* Warn if module dependency doesn't exist
   
         c = lbr<'CONTENTS'>
         a = c<mod><'DEPENDS'>
         seq(' terminal = ' 
+            'ident(c<a<i>>) '
+            '"WARNING: MODULE DEPENDENCY " a<i> " NOT IN LIBRARY";'
+            ' a<i>', .i)

* Spin though SOURCE and ARTIFACTS, ensuring we have a FILES record
* for each.

* Convert lbr<'CONTENTS'><mod><'FILES'> to a table keyed by 'NAME'

         f = table()
         fl = c<mod><'FILES'>
         seq(' f<fl<i><"NAME">> = 1', .i)

* Create array a, containing SOURCE and ARTIFACTS.

         a = array0
         seq(' a = appenda(a, c<mod><"ARTIFACTS"><i>)', .i)
         a = appenda(a, vdiffer(c<mod><'SOURCE'>))

* There should be a file for each a<i>. Make a table from FILES. Check
* each element in array a, and add a new file for each not found.

         f = table()
         seq(' f<c<mod><"FILES"><i><"NAME">> = c<mod><"FILES"><i>', .i)
         seq(' terminal = ident(f<a<i>>) "CREATE FILE " a<i>', .i)
         seq(' f<a<i>> = (vdiffer(f<a<i>>), create_file(a<i>))', .i)

* Convert f table back to array

         k = keyst(f)
         a = array(sizea(k))
         seq(' a<i> = f<k<i>>', .i)

* Assign back to files

         c<mod><'FILES'> = a

* Spin through and freshen the FILES. Read each file. Compare the
* timestamp of the new file against the current timestamp. If more
* recent, replace the file record.

         seq(' f = create_file(a<i><"NAME">);'
+            ' terminal = gt(f<"TIMESTAMP">, a<i><"TIMESTAMP">) '
+            '    "FRESHENING FILE " a<i><"NAME">;'
+            ' a<i> = gt(f<"TIMESTAMP">, a<i><"TIMESTAMP">) f', .i)

* Now, adjust build and install vectors (to artifacts order). Add new
* entries to build and install as needed. Both 'INSTALL'/'BUILD' are
* array of 'TARGET'/'COMMANDS'-array.

         t = table()
         c = lbr<'CONTENTS'><mod><'BUILD'>
         seq(' t<c<i><"TARGET">> = c<i>', .i)
         ar = lbr<'CONTENTS'><mod><'ARTIFACTS'>
         a = (ne(sizea(ar)) array(sizea(ar)), array0)
         seq(' a<i> = t<ar<i>>', .i)
         seq(' bt = table();'
+            ' bt<"COMMANDS"> = array0;'
+            ' bt<"TARGET"> = ar<i>;'
+            ' a<i> = ident(a<i>) bt', .i)
         lbr<'CONTENTS'><mod><'BUILD'> = a

         t = table()
         c = lbr<'CONTENTS'><mod><'INSTALL'>
         seq(' t<c<i><"TARGET">> = c<i>', .i)
         ar = lbr<'CONTENTS'><mod><'ARTIFACTS'>
         a = (ne(sizea(ar)) array(sizea(ar)), array0)
         seq(' a<i> = t<ar<i>>', .i)
         seq(' bt = table();'
+            ' bt<"COMMANDS"> = array0;'
+            ' bt<"TARGET"> = ar<i>;'
+            ' a<i> = ident(a<i>) bt', .i)
         lbr<'CONTENTS'><mod><'CONTENTS'> = a
                                                                  :(top)

stringize
         stringize = v
         n 'LIBRARIES' | 'ARTIFACTS' | 'DEPENDS' | 'FILES'    :f(return)
         s =
         n 'FILES'                                              :f(str2)
         s = table()
         seq(' s<v<i><"NAME">> = 1', .i)
         v = keyst(s)
str2     s = stringout(v, CHARS_NUL)
         s = repl(s, '\', '\\')
         s = repl(s, ' ', '\ ')
         s = replace(s, CHARS_NUL, ' ')
         stringize = s                                         :(return)

destring v = trimb(v)
         destring = v
         v = ?(n ? 'DEPENDS') replace(v, &lcase, &ucase)
         n 'LBRARIES' | 'ARTIFACTS' | 'DEPENDS' | 'FILES'     :f(return)
         s = repl(v, '\\', CHARS_NUL)
         s = repl(s, '\ ', CHARS_SOH)
         s = repl(s, CHARS_NUL, '\')
         s = crack(s, ' ')

* Crack will try appending a terminator to ensure that the array has
* at least one element. we detect this, and replace with array0 if
* it happened. this should be in the usage notes for crack.

         s = eq(sizea(s), 1) ident(s<1>) array0

         seq(' s<i> = repl(s<i>, CHARS_SOH, " ")', .i)
         destring = s
         n 'FILES'                                            :f(return)
         f = filest(lbr)
         seq(' s<i> = (vdiffer(f<s<i>>), create_file(s<i>))', .i)
         destring = s                                          :(return)

mesyn    terminal = 'SYNTAX ERROR - TRY HELP'                     :(top)

 
module_add
         args = trimb(args)
         args = replace(args, &lcase, &ucase)
         ident(args)                                            :s(msyn)
         differ(lbr<'CONTENTS'><args>)                        :s(mexist)
         m = table()
         m<'NAME'> = args
         m<'SOURCE'> =
         m<'COMMENT'> =
         m<'ARTIFACTS'> = array0
         m<'LIBRARIES'> = array0
         m<'TYPE'> =
         m<'DEPENDS'> = array0
         m<'INSTALL'> = array0
         m<'BUILD'> = array0
         m<'FILES'> = array0
         lbr<'CONTENTS'><args> = m                                :(top)

msyn     terminal = 'MODULE ADD|REM NAME'                         :(top)
mexist   terminal = 'MODULE ' args ' ALREADY IN LIBRARY'          :(top)
mnexist  terminal = 'MODULE ' args ' NOT IN LIBRARY'              :(top)


module_rem
         args = trimb(args)
         ident(args)                                            :s(msyn)
         args = replace(args, &lcase, &ucase)
         ident(lbr<'CONTENTS'><args>)                        :s(mnexist)
         lbr<'CONTENTS'><args> =
         lbr<'CONTENTS'> = prunet(lbr<'CONTENTS'>)                :(top)


* Edit a file in the library. We edit by file, because a module may
* have multiple source artifacts. In future, we should determine
* file collisions -- and deal with that (FIXME).

file_edit
         fn = trimb(args)
         filest = filest(lbr)
         differ(f = filest<fn>)                                  :f(unf)
         terminal = 'EDITING ' f<'NAME'>
         wfile(f)
         host(HOST_SYSCMD, crepl('{{EDIT}}', 'file=', fn))
         ts = (file(fn) bq(crepl('{{TIMESTAMP}}', 'file=', fn)), 0)
         ne(ts, f<'TIMESTAMP'>)                                :s(edit2)
         terminal = 'FILE NOT CHANGED'                            :(top)
edit2    rfile(f)                                                 :(top)

unf      terminal = 'UNKNOWN FILE'                                :(top)


* Build a module

* Use convention of FAIL file created to indicate failure in build.

module_build
         ident(lbr)                                              :s(nol)
         args = trimb(args)
         args = replace(args, &lcase, &ucase)
         m = lbr<'CONTENTS'><args>
         ident(m)                                                :s(nom)

* Dependencies of module m

         dl = dependencies(lbr, m)

* Files table

         filest = filest(lbr)

* Timestamp pruning. Each module is checked to see if the main source
* file timestamp is more recent than any of its artifacts. If all
* artifacts are more recent, the module does not need building.

         p = dl
         bl =
ts_1     ident(p)                                               :s(ts_4)
           source = lbr<'CONTENTS'><value(p)><'SOURCE'>
           source_ts = filest<source><'TIMESTAMP'>
           ai = iter_artifacts(lbr, value(p))
           r =
ts_2         a = martifact(ai)                                  :f(ts_3)
             a_ts = filest<a><'TIMESTAMP'>
             r = gt(source_ts, a_ts) 1
           ai = next_artifact(ai)                                :(ts_2)
ts_3       bl = differ(r) link(value(p), bl)
         p = next(p)                                             :(ts_1)
ts_4     bl = revl(bl)

         terminal = ident(bl) 'MODULE IS UP TO DATE'             :s(top)

* We now have a list of modules that is needed for the build of this
* module, pruned by timestamp. We can now walk the list, constructing
* the needed build commands.

* We need to "check out" the modules in dl, then build any modules
* in bl.

* "Checking out" a module is easy -- just extract all files in the
* module.
*
* We need "freshen" all files in the library. Find all modules that
* need building. "Clean" all external files (except, possibly,
* artifacts). "Install" -- which is close to building.

         p = dl
co_1       ident(p)                                             :s(co_2)
           m = value(p)
           writefiles(lbr, m)
         p = next(p)                                             :(co_1)
co_2

* The modules can now be built, in order from least to most dependent.
* This is the order that bl is in.

         p = bl
bl_1       ident(p)                                             :s(bl_2)
           m = value(p)

* To build a module, we need extract the build commands for each of the
* artifacts. m<'BUILD'> is an array of tables: TARGET/COMMANDS and
* COMMANDS is an array of commands. if COMMANDS is empty, we use
* standard commands for this type of source/artifact combination.
* Please note that the build commands are an array, to make editing
* the RECIPES file more pleasant.

           b = lbr<'CONTENTS'><m><'BUILD'>
           i = 1
bu_1         b<i>                                               :f(bu_2)
             c = b<i><'COMMANDS'>
             src = lbr<'CONTENTS'><m><'SOURCE'>
             sext = extension(src)
             tgt = b<i><'TARGET'>
             text = extension(tgt)
             base = tgt
             base text rpos(0) =
             terminal = 'MAKING ' tgt ' FROM ' src ' IN MODULE ' m
             terminal = ne(sizea(c))                            :s(bu_3)
             c = recipes<sext text>

* If we don't have any commands, stub in a touch

bu_3         ne(sizea(c))                                       :s(bu_5)
             c = array(1)
             c<1> = crepl('{{TOUCH}}', 'file=', '{{tgt}}')
bu_5         s = stringout(c, CHARS_NL)

* Replacements in the recipe

             s = crepl(s, 'src=', src, 'tgt=', tgt, 'base=', base)

* Display the complete recipe

             terminal = s

* And cook

             delete('.fail')
             host(HOST_SYSCMD, s)

* If .fail exists, display it
             file('.fail')                                     :f(cook2)
             e = readfile('.fail')
             terminal = 'BUILD FAILED'
             terminal = vdiffer(e)                                :(top)

* If this artifact is newer than what we have (and we hope so), replace
* the library file. If not don't update, but issue a warning message

cook2        newf = create_file(tgt)
             oldf = filest<tgt>
             terminal = le(newf<'TIMESTAMP'>, oldf<'TIMESTAMP'>)
+                     'TARGET ' tgt ' APPEARS NOT TO HAVE BEEN UPDATED?'
+                                                               :s(bu_4)
             oldf<'TIMESTAMP'> = newf<'TIMESTAMP'>
             oldf<'ACCESS'> = newf<'ACCESS'>
             oldf<'MD5'> = newf<'MD5'>
             oldf<'SIZE'> = newf<'SIZE'>
             oldf<'CONTENTS'> = newf<'CONTENTS'>
bu_4       i = i + 1                                             :(bu_1)
bu_2

         p = next(p)                                             :(bl_1)
bl_2

         terminal = 'BUILD COMPLETE'                              :(top)


* Information on the library

library_info
         ident(lbr)                                              :s(nol)

cntf     n = 0
         mi = iter_modules(lbr)
cntf_2     m = module(mi)                                     :f(cntf_5)
           fi = iter_files(lbr, m)
cntf_3       f = mfile(fi)                                    :f(cntf_4)
             n = n + 1
           fi = next_file(fi)                                  :(cntf_3)
cntf_4   mi = next_module(mi)                                  :(cntf_2)
cntf_5

         terminal = 'LIBRARY:   ' lbr<'LIBRARY'>
         terminal = 'DATAFILE:  ' lbr<'DATAFILE'>
         terminal = 'VERSION:   ' lbr<'VERSION'>
         terminal = 'COMMENT:   ' lbr<'COMMENT'>
         t = (vdiffer(lbr<'TIMESTAMP'>), 0)
         t = bq(crepl('{{DISPLAY_TIMESTAMP}}', 'ts=', t))
         terminal = 'TIMESTAMP: ' lbr<'TIMESTAMP'> ' (' t ')'
         terminal = 'CONTENTS:  ' sizet(lbr<'CONTENTS'>) ' MODULES, '
+                                 n ' FILES'
         terminal = '           USE "LS" COMMAND TO LIST INDEX'   :(top)


* Build and install commands not shown

module_info
         args = trimb(args)
         args = replace(args, &lcase, &ucase)
         m = args
         m = lbr<'CONTENTS'><m>
         terminal = ident(m) 'NO SUCH MODULE'                    :s(top)
         terminal = 'NAME:      ' m<'NAME'>
         terminal = 'TYPE:      ' m<'TYPE'>
         terminal = 'SOURCE:    ' m<'SOURCE'>
         terminal = 'COMMENT:   ' m<'COMMENT'>
         term     = 'LIBRARIES: '
         a = m<'LIBRARIES'>
         seq(' term = rpad(a<i>, 16)', .i)
         terminal =
         term     = 'ARTIFACTS: '
         a = m<'ARTIFACTS'>
         seq(' term = rpad(a<i>, 16)', .i)
         terminal =
         term     = 'DEPENDS:   '
         a = m<'DEPENDS'>
         seq(' term = rpad(a<i>, 16)', .i)
         terminal =
         term     = 'FILES:     '
         a = m<'FILES'>
         seq(' term = ?a<i> rpad(a<i><"NAME">, 16)', .i)
         terminal =                                               :(top)

file_info
         filest = filest(lbr)
         args = trimb(args)
         terminal = ident(f = filest<args>) 'NO FILE'            :s(top)
         terminal = 'NAME:      ' f<'NAME'>
         terminal = 'TYPE:      ' f<'TYPE'>
         t = (vdiffer(f<'TIMESTAMP'>), 0)
         t = bq(crepl('{{DISPLAY_TIMESTAMP}}', 'ts=', t))
         terminal = 'TIMESTAMP: ' f<'TIMESTAMP'> ' (' t ')'
         terminal = 'ACCESS:    ' f<'ACCESS'>
         terminal = 'FS:        ' (file(f<'NAME'>) 'IN FILESYSTEM',
+                                                  'NOT IN FILESYSTEM')
         terminal = 'SIZE:      ' f<'SIZE'> ' BYTES'
         terminal = 'MD5:       ' f<'MD5'>                        :(top)


* List the modules in the library

ls.      ident(lbr)                                              :s(nol)
         args = eval(args)
         m = iter_modules(lbr)
ls2        n = module(m)                                         :f(ls3)
           term = ?(n ? args) rpad(n, 16)
         m = next_module(m)                                       :(ls2)
ls3      terminal =                                               :(top)

nol      terminal = 'NO LIBRARY LOADED'                           :(top)
nom      terminal = 'MODULE ' args ' NOT FOUND'                   :(top)


* Seed in '*.lss' (or specified pattern) as modules.

seed.    ddt()
         args = trimb(args)
         args = ident(args) "'.lss' rpos(0)"
         args = convert(args, 'PATTERN')
         files = iter_dir(len(0) args, 1)
seed1      fn = value_dir(files)                                :f(seed2)
           terminal = 'SEEDING ' rpad(fn, 16) CHARS_CR
*           term = 'SEEDING ' rpad(fn, 16) CHARS_CR

* Guess at artifacts from the .lss (or other passed in filename)

* This will become a 'add_module()' function to add a new module
* to the library. note that there is a "chicken and egg" problem
* here -- we can't determine details until the module is built,
* and we can't (yet) actually build modules.

           base = fn
           base '.lss' =

           a = table()

* The bare program, or .INC file must be the first artifact, in order
* for create_module() to correctly determine the dependencies
* automatically.

           a<base>         = file(base) 1
           a<base '.INC'>  = file(base '.INC') 1

           a<base '.html'> = file(base '.html') 1
           a<base '.tst'>  = file(base '.tst') 1
           a<base '.txt'>  = file(base '.txt') 1
           a = keyst(a)

           m = create_module(fn, base ' module', a)

           lbr<'CONTENTS'><m<'NAME'>> = m
         files = next_dir(files)                                :(seed1)

seed2    terminal =

* Upgrade file dependencies to module dependencies

         file2module(lbr)                                         :(top)


* Load library

load.    args = trimb(args)
         args = ident(args) 'LBR'
         lbr = readlbr(args)                                      :(top)


* Save library

save.    ident(lbr)                                              :s(nol)
         args = lbr<'LIBRARY'>
         writelbr(lbr)
         lbr =                                                  :(load.)


* Export all

all_export
         ident(lbr)                                              :s(nol)
         mi = iter_modules(lbr)
xall2      m = module(mi)                                      :f(xall3)
           t = lbr<'CONTENTS'><m>
           term = 'EXPORTING ' rpad(t<'NAME'>, 16) CHARS_CR
           writefiles(lbr, t<'NAME'>)
         t = copyt(t)
         t<'FILES'> = copya(t<'FILES'>)
         seq(' t<"FILES"><i> = copyt(t<"FILES"><i>)', .i)
         seq(' t<"FILES"><i><"LOCATION"> = "FILE"', .i)
         seq(' t<"FILES"><i><"CONTENTS"> = t<"FILES"><i><"NAME">', .i)
         writefile(t<'NAME'> '.MODULE', json_encode(t))
         mi = next_module(mi)                                   :(xall2)
xall3    terminal =                                               :(top)


* Export files from module

export.  ident(lbr)                                              :s(nol)
         args = trimb(args)
         args = replace(args, &lcase, &ucase)
         t = lbr<'CONTENTS'><args>
         ident(t)                                                :s(nom)
         writefiles(lbr, args)

* Copy the module, deep copy FILES, change LOCATION to FILE, remove
* contents. Should use the iter_files iterator, but doesn't because
* we are dealing with a deep copy. This means that the files iterator
* isn't general enough. It should key to a module, and not reference
* lbr at all (FIXME).

         t = copyt(t)
         t<'FILES'> = copya(t<'FILES'>)
         seq(' t<"FILES"><i> = copyt(t<"FILES"><i>)', .i)
         seq(' t<"FILES"><i><"LOCATION"> = "FILE"', .i)
         seq(' t<"FILES"><i><"CONTENTS"> = t<"FILES"><i><"NAME">', .i)

         writefile(t<'NAME'> '.MODULE', json_encode(t))
                                                                  :(top)


* Import

import.  ident(lbr)                                              :s(nol)
         args = trimb(args)
         args = ident(args) "'.MODULE' rpos(0)"
         args = convert(args, 'PATTERN')
         di = iter_dir(len(0) args, 1)
import5    mn = value_dir(di)                                :f(import3)
           terminal = 'IMPORTING ' mn
           file(mn)                                             :f(nomd)
           s = json_decode(readfile(mn))
           args = s<'NAME'>
           differ(lbr<'CONTENTS'><args>)                        :s(mdex)
           lbr<'CONTENTS'><args> = s
           fi = iter_files(lbr, args)
import2      f = mfile(fi)                                   :f(import7)
             terminal = 'ADDING FILE ' f<'NAME'>
             terminal = ~file(f<'NAME'>) 'NO FILE ' f<'NAME'>
+                                                            :f(import4)
             s =
             s = readfile(f<'NAME'>)
             f<'LOCATION'> = 'DIRECT'
             md5 = bq(crepl('{{MD5}}', 'file=',  f<'NAME'>))
             md5 break(' ') . md5
             terminal = differ(md5, f<'MD5'>) 'MD5 FAILS'
             terminal = ne(f<'SIZE'>, size(s)) 'NOT CORRECT SIZE'
             f<'CONTENTS'> = s
import4    fi = next_file(fi)                                 :(import2)
import7  di = next_dir(di)                                    :(import5)
import3                                                           :(top)

nomd     terminal = 'NO MODULE FILE ' mn                      :(import7)
mdex     terminal = 'MODULE ' mn ' ALREADY IN LIBRARY'        :(import7)

* Functions for soosie


* Write file to filesystem. Make sure that access and timestamp
* are restored

wfile    writefile(f<'NAME'>, f<'CONTENTS'>)                 :f(freturn)
         bq(crepl('{{SET_ACCESS}}',
+                 'access=', f<'ACCESS'>, 'file=', f<'NAME'>))
         bq(crepl('{{SET_TIMESTAMP}}',
+                 'ts=', f<'TIMESTAMP'>, 'file=', f<'NAME'>))  :(return)


* Write all files for module to filesystem

writefiles
         fi = iter_files(lbr, m)
wf2        f = mfile(fi)                                      :f(return)
           wfile(f)                                          :f(freturn)
         fi = next_file(fi)                                       :(wf2)

 
* Read library. Reads the library as a json document. Then reads the
* associated datafile. Iterates the modules in the newly read library,
* and each file, converting DATA references into DIRECT references.
*
* LOCATION may be:
*   DIRECT - file data is in memory
*   DATA   - file data is OFFSET:LENGTH in library data
*   FILE   - file data is external file
*
* DIRECT is internal representation. DATA is when library is at rest
* on disk. FILE is the export representation.

readlbr  lbr = json_decode(readfile(nm))                     :f(freturn)
         readlbr = lbr
         data = readfile(lbr<'DATAFILE'>)                    :f(freturn)
         mi = iter_modules(lbr)
rdlbr_3    m = module(mi)                                    :f(rdlbr_2)
           fi = iter_files(lbr, m)
rdlbr_4      f = mfile(fi)                                   :f(rdlbr_5)
             s = f<'CONTENTS'>
             f<'LOCATION'> 'DIRECT'                          :s(rdlbr_6)
             s break(':') . b ':' rem . l
             data fence tab(b) len(l) . s                       :f(what)
             f<'CONTENTS'> = s
             f<'LOCATION'> = 'DIRECT'
rdlbr_6    fi = next_file(fi)                                 :(rdlbr_4)
rdlbr_5  mi = next_module(mi)                                 :(rdlbr_3)
rdlbr_2  readlbr = lbr                                         :(return)
what     terminal = 'BAD FILE DATA'                               :(end)


* Write library

writelbr mi = iter_modules(lbr)
wrlbr_3    m = module(mi)                                    :f(wrlbr_2)
           fi = iter_files(lbr, m)
wrlbr_4      f = mfile(fi)                                   :f(wrlbr_5)
             s = f<'CONTENTS'>
             n = size(data)
             data = data s
             f<'LOCATION'> = 'DATA'
             f<'CONTENTS'> = n ':' size(s)
           fi = next_file(fi)                                 :(wrlbr_4)
wrlbr_5  mi = next_module(mi)                                 :(wrlbr_3)
wrlbr_2  writefile(lbr<'LIBRARY'>, json_encode(lbr))             :f(end)
         writefile(lbr<'DATAFILE'>, data)               :f(end)s(return)


* Create empty library

createlbr
         createlbr = table()
         createlbr<'LIBRARY'> = nm
         createlbr<'COMMENT'> = lc
         createlbr<'TIMESTAMP'> = tv_sec(gettimeofday())
         createlbr<'VERSION'> = 1
         createlbr<'CONTENTS'> = table()
         createlbr<'DATAFILE'> = dt                            :(return)


* Create a file entry

create_file
         create_file = table()
         rfile(create_file, fn)                                :(return)


* Fill in file details (including contents) of a file entry from the
* file in the filesystem. Fill in default for non-existent file.

rfile    fn = ident(fn) f<'NAME'>
         f<'NAME'> = fn
         f<'TYPE'> = 'TEXT'
         f<'TYPE'> =
+  (?(file(fn) bq(crepl('{{FILE_TYPE}}', 'file=', fn)) ? 'text') 'TEXT',
+                     'BINARY')
         f<'TIMESTAMP'> =
+           (file(fn) bq(crepl('{{TIMESTAMP}}', 'file=', fn)), 0)
         f<'ACCESS'> =
+           (file(fn) bq(crepl('{{ACCESS}}', 'file=', fn)), '644')
         f<'LOCATION'> = 'DIRECT'
         s = (file(fn) readfile(fn), '')

* The md5 for an empty file

         md5 = 'd41d8cd98f00b204e9800998ecf8427e -'
         md5 = file(fn) bq(crepl('{{MD5}}', 'file=', fn))
         md5 break(' ') . md5

         f<'MD5'> = md5
         f<'SIZE'> = size(s)
         f<'CONTENTS'> = s                                     :(return)


* Create a module for the library
*
* We begin with the source file, comment and artifacts. If dependencies
* are not specified, use 'uses' to determine dependencies.

create_module
         m = table()

         m<'SOURCE'> = src
         m<'COMMENT'> = cmnt
         m<'ARTIFACTS'> = artifacts
         m<'LIBRARIES'> = array0

* Find -MODULE or -PROGRAM directive in the source file to determine
* the module type. If a -MODULE is not seen, we assume -PROGRAM to
* support older main programs.
*
* Slight problem in bq(). the command may report success/fail, which
* is returned correctly. but if the command returns success, and
* no output, it is taken to be fail. This should be documented in
* bq.

         m<'TYPE'> =
+  (?(file(src)
+     bq(crepl('{{GREP}}', 'pattern=', '^-MODULE', 'file=', src)))
+                     'MODULE', 'PROGRAM')

* Hunt down the module or program name. If we can't find it, we
* assume the src name with any extension removed.

         s = src
         src arb . s '.' arb rpos(0)
         s = file(src)
+ bq(crepl('{{GREP}} {{SED}}', 'pattern=', '^-MODULE', 'file=', src,
+          'old=', '-MODULE ', 'new=', ''))
         s = file(src)
+ bq(crepl('{{GREP}} {{SED}}', 'pattern=', '^-PROGRAM', 'file=', src,
+          'old=', '-PROGRAM ', 'new=', ''))
         m<'NAME'> = s

* Determine depends. This is determine by the first artifact, run
* through 'uses', or is supplied.

         depends = ident(depends) file(artifacts<1>)
+              json_decode(bq(crepl('{{USES}}', 'file=', artifacts<1>)))
+                                                                :f(end)
         m<'DEPENDS'> = depends

* From the artifacts, we create install, build and files

         n = prototype(artifacts)
         install = array(n)
         build = array(n)
         files = array(n + 1)
         m<'INSTALL'> = install
         m<'BUILD'> = build
         m<'FILES'> = files

* Add build commands to module. If the build array is empty,
* it's a standard build. Otherwise the exceptional commands will
* be recorded here.

         seq(' build<i> = ?artifacts<i> table();'
+            ' build<i><"TARGET"> = artifacts<i>;'
+            ' build<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add install commands to module.

         seq(' install<i> = ?artifacts<i> table();'
+            ' install<i><"TARGET"> = artifacts<i>;'
+            ' install<i><"COMMANDS"> = ?artifacts<i> array0', .i)

* Add files to module.

         files<1> = create_file(src, dat)
         seq(' files<i + 1> = create_file(artifacts<i>)', .i, 1)
         files = dedupa(files)

* Return the new module.

         create_module = m                                     :(return)

* We need to convert dependency references from files to modules.
* Do this after seeding - walk through each of the modules and for
* each module, each of the dependencies.

file2module
         f2mt = f2mt(lbr)

* Rip through the dependencies, replacing each file reference with
* a module reference. We used 'uses' to get from function() references
* to file references, and now we go from file references to module
* references.
*
* If a dependency file does not have a module it belongs to, leave it
* as a file. This allows an arbitrary file to be included as a
* dependency (use './' directory path notation to ensure it is not
* part of a module)

         mi = iter_modules(lbr)                               :f(return)
f2m_6      m = module(mi)                                      :f(f2m_9)
           d = lbr<'CONTENTS'><m><'DEPENDS'>
           i = 1
f2m_8        n = d<i>                                          :f(f2m_7)
             d<i> = vdiffer(f2mt<n>)
           i = i + 1                                            :(f2m_8)
f2m_7    mi = next_module(mi)                                   :(f2m_6)
f2m_9

* It is possible that a module can contribute multiple files to the
* dependencies. In that case we will have redundant module dependencies.
* Go through the modules, removing dependency redundancy.

         mi = iter_modules(lbr)
f2m_10     m = module(mi)                                     :f(f2m_11)
           d = lbr<'CONTENTS'><m><'DEPENDS'>
           lbr<'CONTENTS'><m><'DEPENDS'> = dedupa(d)
f2m_12   mi = next_module(mi)                                  :(f2m_10)
f2m_11                                                         :(return)


* Return file reference table, keyed on name, which references each
* file in the library.

filest   filest = table()
         mi = iter_modules(lbr)
ft_2       m = module(mi)                                     :f(return)
           fi = iter_files(lbr, m)
ft_3         f = mfile(fi)                                      :f(ft_4)
             n = f<'NAME'>
             filest<n> = f
           fi = next_file(fi)                                    :(ft_3)
ft_4     mi = next_module(mi)                                    :(ft_2)


* Return a list of the dependencies of a module. This includes the
* module itself. Order is in libary build order (least to most
* dependent). get_dependencies() is a helper routine for dependencies().

dependencies
         done = table()
         get_dependencies(lbr, m)
         dependencies = revl(dependencies)                     :(return)

get_dependencies
         differ(done<m<'NAME'>>)                              :s(return)
         d = m<'DEPENDS'>
         seq(' get_dependencies(lbr, lbr<"CONTENTS"><d<i>>)', .i)
         dependencies = link(m<'NAME'>, dependencies)
         done<m<'NAME'>> = 1                                   :(return)


* Return a table of the file->module mappings. This table is keyed by
* filename, and returns the module name.

f2mt     f2mt = table()
         mi = iter_modules(lbr)
f2mt_2     m = module(mi)                                     :f(return)
           fi = iter_files(lbr, m)
f2mt_3       f = mfile(fi)                                    :f(f2mt_4)
             n = f<'NAME'>
             f2mt<n> = m
           fi = next_file(fi)                                  :(f2mt_3)
f2mt_4   mi = next_module(mi)                                  :(f2mt_2)


* Iterate modules in library

iter_modules
         iter_modules = atol(keyst(lbr<'CONTENTS'>))
+                                                   :s(return)f(freturn)

module   module = differ(m) value(m)                :s(return)f(freturn)

next_module
         next_module = differ(m) next(m)            :s(return)f(freturn)


* Iterate files in module m

iter_files
         iter_files = atol(lbr<'CONTENTS'><m><'FILES'>)
+                                                   :s(return)f(freturn)

mfile    mfile = differ(f) value(f)                 :s(return)f(freturn)

next_file
         next_file = differ(f) next(f)              :s(return)f(freturn)


* Iterate artifacts in module m

iter_artifacts
         iter_artifacts = atol(lbr<'CONTENTS'><m><'ARTIFACTS'>)
+                                                   :s(return)f(freturn)

martifact
         martifact = differ(a) value(a)             :s(return)f(freturn)

next_artifact
         next_artifact = differ(a) next(a)          :s(return)f(freturn)


* Return file extension

extension
         s = reverse(f)
         s break('./') . extension '.'
         extension = reverse(extension)
         extension = '.' vdiffer(extension)                    :(return)


* config<'REPLACE'> is a table of replacement strings to be applied
* to command strings and build recipes. For example, {{INCDIR}}
* will be replaced with INCDIR as defined. There is an entry
* for each directory needed in build and install recipes, and
* for each command that is used by SOOSIE.

crepl    a = keyst(config<'REPLACE'>)
         seq(' k = ?a<i> "{{" a<i> "}}";'
+            ' r = ?a<i> config<"REPLACE"><a<i>>;'
+            ' s = ?a<i> repl(s, k, r)', .i)
         ident(n1)                                            :s(crepl2)
         n1 '=' =
         s = repl(s, '{{' n1 '}}', v1)
         ident(n2)                                            :s(crepl2)
         n2 '=' =
         s = repl(s, '{{' n2 '}}', v2)
         ident(n3)                                            :s(crepl2)
         n3 '=' =
         s = repl(s, '{{' n3 '}}', v3)
         ident(n4)                                            :s(crepl2)
         n4 '=' =
         s = repl(s, '{{' n4 '}}', v4)
crepl2   seq(' k = ?a<i> "{{" a<i> "}}";'
+            ' r = ?a<i> config<"REPLACE"><a<i>>;'
+            ' s = ?a<i> repl(s, k, r)', .i)
         crepl = s                                             :(return)


end
